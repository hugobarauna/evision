searchNodes=[{"doc":"","ref":"Evision.html","title":"Evision","type":"module"},{"doc":"return a list of enabled modules in this build","ref":"Evision.html#__enabled_modules__/0","title":"Evision.__enabled_modules__/0","type":"function"},{"doc":"Raising version of absdiff/2 .","ref":"Evision.html#absdiff!/2","title":"Evision.absdiff!/2","type":"function"},{"doc":"Raising version of absdiff/3 .","ref":"Evision.html#absdiff!/3","title":"Evision.absdiff!/3","type":"function"},{"doc":"Calculates the per-element absolute difference between two arrays or between an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array or a scalar. src2 : Evision.Mat . second input array or a scalar. Return dst : Evision.Mat . output array that has the same size and type as input arrays. The function cv::absdiff calculates: Absolute difference between two arrays when they have the same size and type: \\f[\\texttt{dst}(I) = \\texttt{saturate} (| \\texttt{src1}(I) - \\texttt{src2}(I)|)\\f] Absolute difference between an array and a scalar when the second array is constructed from Scalar or has as many elements as the number of channels in src1 : \\f[\\texttt{dst}(I) = \\texttt{saturate} (| \\texttt{src1}(I) - \\texttt{src2} |)\\f] Absolute difference between a scalar and an array when the first array is constructed from Scalar or has as many elements as the number of channels in src2 : \\f[\\texttt{dst}(I) = \\texttt{saturate} (| \\texttt{src1} - \\texttt{src2}(I) |)\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. Note : Saturation is not applied when the arrays have the depth CV_32S. You may even get a negative value in the case of overflow. @sa cv::abs(const Mat&amp;) Python prototype (for reference): absdiff(src1, src2[, dst]) -&gt; dst","ref":"Evision.html#absdiff/2","title":"Evision.absdiff/2","type":"function"},{"doc":"Calculates the per-element absolute difference between two arrays or between an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array or a scalar. src2 : Evision.Mat . second input array or a scalar. Return dst : Evision.Mat . output array that has the same size and type as input arrays. The function cv::absdiff calculates: Absolute difference between two arrays when they have the same size and type: \\f[\\texttt{dst}(I) = \\texttt{saturate} (| \\texttt{src1}(I) - \\texttt{src2}(I)|)\\f] Absolute difference between an array and a scalar when the second array is constructed from Scalar or has as many elements as the number of channels in src1 : \\f[\\texttt{dst}(I) = \\texttt{saturate} (| \\texttt{src1}(I) - \\texttt{src2} |)\\f] Absolute difference between a scalar and an array when the first array is constructed from Scalar or has as many elements as the number of channels in src2 : \\f[\\texttt{dst}(I) = \\texttt{saturate} (| \\texttt{src1} - \\texttt{src2}(I) |)\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. Note : Saturation is not applied when the arrays have the depth CV_32S. You may even get a negative value in the case of overflow. @sa cv::abs(const Mat&amp;) Python prototype (for reference): absdiff(src1, src2[, dst]) -&gt; dst","ref":"Evision.html#absdiff/3","title":"Evision.absdiff/3","type":"function"},{"doc":"Raising version of accumulate/2 .","ref":"Evision.html#accumulate!/2","title":"Evision.accumulate!/2","type":"function"},{"doc":"Raising version of accumulate/3 .","ref":"Evision.html#accumulate!/3","title":"Evision.accumulate!/3","type":"function"},{"doc":"Adds an image to the accumulator image. Positional Arguments src : Evision.Mat . Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer. Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F. The function adds src or some of its elements to dst : \\f[\\texttt{dst} (x,y) \\leftarrow \\texttt{dst} (x,y) + \\texttt{src} (x,y) \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] The function supports multi-channel images. Each channel is processed independently. The function cv::accumulate can be used, for example, to collect statistics of a scene background viewed by a still camera and for the further foreground-background segmentation. @sa accumulateSquare, accumulateProduct, accumulateWeighted Python prototype (for reference): accumulate(src, dst[, mask]) -&gt; dst","ref":"Evision.html#accumulate/2","title":"Evision.accumulate/2","type":"function"},{"doc":"Adds an image to the accumulator image. Positional Arguments src : Evision.Mat . Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer. Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F. The function adds src or some of its elements to dst : \\f[\\texttt{dst} (x,y) \\leftarrow \\texttt{dst} (x,y) + \\texttt{src} (x,y) \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] The function supports multi-channel images. Each channel is processed independently. The function cv::accumulate can be used, for example, to collect statistics of a scene background viewed by a still camera and for the further foreground-background segmentation. @sa accumulateSquare, accumulateProduct, accumulateWeighted Python prototype (for reference): accumulate(src, dst[, mask]) -&gt; dst","ref":"Evision.html#accumulate/3","title":"Evision.accumulate/3","type":"function"},{"doc":"Raising version of accumulateProduct/3 .","ref":"Evision.html#accumulateProduct!/3","title":"Evision.accumulateProduct!/3","type":"function"},{"doc":"Raising version of accumulateProduct/4 .","ref":"Evision.html#accumulateProduct!/4","title":"Evision.accumulateProduct!/4","type":"function"},{"doc":"Adds the per-element product of two input images to the accumulator image. Positional Arguments src1 : Evision.Mat . First input image, 1- or 3-channel, 8-bit or 32-bit floating point. src2 : Evision.Mat . Second input image of the same type and the same size as src1 . Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input images, 32-bit or 64-bit floating-point. The function adds the product of two images or their selected regions to the accumulator dst : \\f[\\texttt{dst} (x,y) \\leftarrow \\texttt{dst} (x,y) + \\texttt{src1} (x,y) \\cdot \\texttt{src2} (x,y) \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] The function supports multi-channel images. Each channel is processed independently. @sa accumulate, accumulateSquare, accumulateWeighted Python prototype (for reference): accumulateProduct(src1, src2, dst[, mask]) -&gt; dst","ref":"Evision.html#accumulateProduct/3","title":"Evision.accumulateProduct/3","type":"function"},{"doc":"Adds the per-element product of two input images to the accumulator image. Positional Arguments src1 : Evision.Mat . First input image, 1- or 3-channel, 8-bit or 32-bit floating point. src2 : Evision.Mat . Second input image of the same type and the same size as src1 . Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input images, 32-bit or 64-bit floating-point. The function adds the product of two images or their selected regions to the accumulator dst : \\f[\\texttt{dst} (x,y) \\leftarrow \\texttt{dst} (x,y) + \\texttt{src1} (x,y) \\cdot \\texttt{src2} (x,y) \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] The function supports multi-channel images. Each channel is processed independently. @sa accumulate, accumulateSquare, accumulateWeighted Python prototype (for reference): accumulateProduct(src1, src2, dst[, mask]) -&gt; dst","ref":"Evision.html#accumulateProduct/4","title":"Evision.accumulateProduct/4","type":"function"},{"doc":"Raising version of accumulateSquare/2 .","ref":"Evision.html#accumulateSquare!/2","title":"Evision.accumulateSquare!/2","type":"function"},{"doc":"Raising version of accumulateSquare/3 .","ref":"Evision.html#accumulateSquare!/3","title":"Evision.accumulateSquare!/3","type":"function"},{"doc":"Adds the square of a source image to the accumulator image. Positional Arguments src : Evision.Mat . Input image as 1- or 3-channel, 8-bit or 32-bit floating point. Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point. The function adds the input image src or its selected region, raised to a power of 2, to the accumulator dst : \\f[\\texttt{dst} (x,y) \\leftarrow \\texttt{dst} (x,y) + \\texttt{src} (x,y)^2 \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] The function supports multi-channel images. Each channel is processed independently. @sa accumulateSquare, accumulateProduct, accumulateWeighted Python prototype (for reference): accumulateSquare(src, dst[, mask]) -&gt; dst","ref":"Evision.html#accumulateSquare/2","title":"Evision.accumulateSquare/2","type":"function"},{"doc":"Adds the square of a source image to the accumulator image. Positional Arguments src : Evision.Mat . Input image as 1- or 3-channel, 8-bit or 32-bit floating point. Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point. The function adds the input image src or its selected region, raised to a power of 2, to the accumulator dst : \\f[\\texttt{dst} (x,y) \\leftarrow \\texttt{dst} (x,y) + \\texttt{src} (x,y)^2 \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] The function supports multi-channel images. Each channel is processed independently. @sa accumulateSquare, accumulateProduct, accumulateWeighted Python prototype (for reference): accumulateSquare(src, dst[, mask]) -&gt; dst","ref":"Evision.html#accumulateSquare/3","title":"Evision.accumulateSquare/3","type":"function"},{"doc":"Raising version of accumulateWeighted/3 .","ref":"Evision.html#accumulateWeighted!/3","title":"Evision.accumulateWeighted!/3","type":"function"},{"doc":"Raising version of accumulateWeighted/4 .","ref":"Evision.html#accumulateWeighted!/4","title":"Evision.accumulateWeighted!/4","type":"function"},{"doc":"Updates a running average. Positional Arguments src : Evision.Mat . Input image as 1- or 3-channel, 8-bit or 32-bit floating point. alpha : double . Weight of the input image. Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point. The function calculates the weighted sum of the input image src and the accumulator dst so that dst becomes a running average of a frame sequence: \\f[\\texttt{dst} (x,y) \\leftarrow (1- \\texttt{alpha} ) \\cdot \\texttt{dst} (x,y) + \\texttt{alpha} \\cdot \\texttt{src} (x,y) \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] That is, alpha regulates the update speed (how fast the accumulator &quot;forgets&quot; about earlier images). The function supports multi-channel images. Each channel is processed independently. @sa accumulate, accumulateSquare, accumulateProduct Python prototype (for reference): accumulateWeighted(src, dst, alpha[, mask]) -&gt; dst","ref":"Evision.html#accumulateWeighted/3","title":"Evision.accumulateWeighted/3","type":"function"},{"doc":"Updates a running average. Positional Arguments src : Evision.Mat . Input image as 1- or 3-channel, 8-bit or 32-bit floating point. alpha : double . Weight of the input image. Keyword Arguments mask : Evision.Mat . Optional operation mask. Return dst : Evision.Mat . %Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point. The function calculates the weighted sum of the input image src and the accumulator dst so that dst becomes a running average of a frame sequence: \\f[\\texttt{dst} (x,y) \\leftarrow (1- \\texttt{alpha} ) \\cdot \\texttt{dst} (x,y) + \\texttt{alpha} \\cdot \\texttt{src} (x,y) \\quad \\text{if} \\quad \\texttt{mask} (x,y) \\ne 0\\f] That is, alpha regulates the update speed (how fast the accumulator &quot;forgets&quot; about earlier images). The function supports multi-channel images. Each channel is processed independently. @sa accumulate, accumulateSquare, accumulateProduct Python prototype (for reference): accumulateWeighted(src, dst, alpha[, mask]) -&gt; dst","ref":"Evision.html#accumulateWeighted/4","title":"Evision.accumulateWeighted/4","type":"function"},{"doc":"Raising version of adaptiveThreshold/6 .","ref":"Evision.html#adaptiveThreshold!/6","title":"Evision.adaptiveThreshold!/6","type":"function"},{"doc":"Raising version of adaptiveThreshold/7 .","ref":"Evision.html#adaptiveThreshold!/7","title":"Evision.adaptiveThreshold!/7","type":"function"},{"doc":"Applies an adaptive threshold to an array. Positional Arguments src : Evision.Mat . Source 8-bit single-channel image. maxValue : double . Non-zero value assigned to the pixels for which the condition is satisfied adaptiveMethod : int . Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes. The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries. thresholdType : int . Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV, see #ThresholdTypes. blockSize : int . Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on. c : double . Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well. Return dst : Evision.Mat . Destination image of the same size and the same type as src. The function transforms a grayscale image to a binary image according to the formulae: THRESH_BINARY \\f[dst(x,y) = \\fork{\\texttt{maxValue}}{if (src(x,y) &gt; T(x,y))}{0}{otherwise}\\f] THRESH_BINARY_INV \\f[dst(x,y) = \\fork{0}{if (src(x,y) &gt; T(x,y))}{\\texttt{maxValue}}{otherwise}\\f] where \\f$T(x,y)\\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter). The function can process the image in-place. @sa threshold, blur, GaussianBlur Python prototype (for reference): adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) -&gt; dst","ref":"Evision.html#adaptiveThreshold/6","title":"Evision.adaptiveThreshold/6","type":"function"},{"doc":"Applies an adaptive threshold to an array. Positional Arguments src : Evision.Mat . Source 8-bit single-channel image. maxValue : double . Non-zero value assigned to the pixels for which the condition is satisfied adaptiveMethod : int . Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes. The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries. thresholdType : int . Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV, see #ThresholdTypes. blockSize : int . Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on. c : double . Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well. Return dst : Evision.Mat . Destination image of the same size and the same type as src. The function transforms a grayscale image to a binary image according to the formulae: THRESH_BINARY \\f[dst(x,y) = \\fork{\\texttt{maxValue}}{if (src(x,y) &gt; T(x,y))}{0}{otherwise}\\f] THRESH_BINARY_INV \\f[dst(x,y) = \\fork{0}{if (src(x,y) &gt; T(x,y))}{\\texttt{maxValue}}{otherwise}\\f] where \\f$T(x,y)\\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter). The function can process the image in-place. @sa threshold, blur, GaussianBlur Python prototype (for reference): adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) -&gt; dst","ref":"Evision.html#adaptiveThreshold/7","title":"Evision.adaptiveThreshold/7","type":"function"},{"doc":"Raising version of add/2 .","ref":"Evision.html#add!/2","title":"Evision.add!/2","type":"function"},{"doc":"Raising version of add/3 .","ref":"Evision.html#add!/3","title":"Evision.add!/3","type":"function"},{"doc":"Calculates the per-element sum of two arrays or an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array or a scalar. src2 : Evision.Mat . second input array or a scalar. Keyword Arguments mask : Evision.Mat . optional operation mask - 8-bit single channel array, that specifies elements of the output array to be changed. dtype : int . optional depth of the output array (see the discussion below). Return dst : Evision.Mat . output array that has the same size and number of channels as the input array(s); the depth is defined by dtype or src1/src2. The function add calculates: Sum of two arrays when both input arrays have the same size and the same number of channels: \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) + \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f] Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of elements as src1.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) + \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f] Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of elements as src2.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1} + \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions: dst = src1 + src2; dst += src1; // equivalent to add(dst, src1, dst); The input arrays and the output array can all have the same or different depths. For example, you can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit floating-point array. Depth of the output array is determined by the dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case, the output array will have the same depth as the input array, be it src1, src2 or both. Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa subtract, addWeighted, scaleAdd, Mat::convertTo Python prototype (for reference): add(src1, src2[, dst[, mask[, dtype]]]) -&gt; dst","ref":"Evision.html#add/2","title":"Evision.add/2","type":"function"},{"doc":"Calculates the per-element sum of two arrays or an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array or a scalar. src2 : Evision.Mat . second input array or a scalar. Keyword Arguments mask : Evision.Mat . optional operation mask - 8-bit single channel array, that specifies elements of the output array to be changed. dtype : int . optional depth of the output array (see the discussion below). Return dst : Evision.Mat . output array that has the same size and number of channels as the input array(s); the depth is defined by dtype or src1/src2. The function add calculates: Sum of two arrays when both input arrays have the same size and the same number of channels: \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) + \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f] Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of elements as src1.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) + \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f] Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of elements as src2.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1} + \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions: dst = src1 + src2; dst += src1; // equivalent to add(dst, src1, dst); The input arrays and the output array can all have the same or different depths. For example, you can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit floating-point array. Depth of the output array is determined by the dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case, the output array will have the same depth as the input array, be it src1, src2 or both. Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa subtract, addWeighted, scaleAdd, Mat::convertTo Python prototype (for reference): add(src1, src2[, dst[, mask[, dtype]]]) -&gt; dst","ref":"Evision.html#add/3","title":"Evision.add/3","type":"function"},{"doc":"Raising version of addText/4 .","ref":"Evision.html#addText!/4","title":"Evision.addText!/4","type":"function"},{"doc":"Raising version of addText/5 .","ref":"Evision.html#addText!/5","title":"Evision.addText!/5","type":"function"},{"doc":"Draws a text on the image. Positional Arguments img : Evision.Mat . 8-bit 3-channel image where the text should be drawn. text : String . Text to write on an image. org : Point . Point(x,y) where the text should start on an image. nameFont : String . Name of the font. The name should match the name of a system font (such as Times*). If the font is not found, a default one is used. Keyword Arguments pointSize : int . Size of the font. If not specified, equal zero or negative, the point size of the font is set to a system-dependent default value. Generally, this is 12 points. color : Scalar . Color of the font in BGRA where A = 255 is fully transparent. weight : int . Font weight. Available operation flags are : cv::QtFontWeights You can also specify a positive integer for better control. style : int . Font style. Available operation flags are : cv::QtFontStyles spacing : int . Spacing between characters. It can be negative or positive. Python prototype (for reference): addText(img, text, org, nameFont[, pointSize[, color[, weight[, style[, spacing]]]]]) -&gt; None","ref":"Evision.html#addText/4","title":"Evision.addText/4","type":"function"},{"doc":"Draws a text on the image. Positional Arguments img : Evision.Mat . 8-bit 3-channel image where the text should be drawn. text : String . Text to write on an image. org : Point . Point(x,y) where the text should start on an image. nameFont : String . Name of the font. The name should match the name of a system font (such as Times*). If the font is not found, a default one is used. Keyword Arguments pointSize : int . Size of the font. If not specified, equal zero or negative, the point size of the font is set to a system-dependent default value. Generally, this is 12 points. color : Scalar . Color of the font in BGRA where A = 255 is fully transparent. weight : int . Font weight. Available operation flags are : cv::QtFontWeights You can also specify a positive integer for better control. style : int . Font style. Available operation flags are : cv::QtFontStyles spacing : int . Spacing between characters. It can be negative or positive. Python prototype (for reference): addText(img, text, org, nameFont[, pointSize[, color[, weight[, style[, spacing]]]]]) -&gt; None","ref":"Evision.html#addText/5","title":"Evision.addText/5","type":"function"},{"doc":"Raising version of addWeighted/5 .","ref":"Evision.html#addWeighted!/5","title":"Evision.addWeighted!/5","type":"function"},{"doc":"Raising version of addWeighted/6 .","ref":"Evision.html#addWeighted!/6","title":"Evision.addWeighted!/6","type":"function"},{"doc":"Calculates the weighted sum of two arrays. Positional Arguments src1 : Evision.Mat . first input array. alpha : double . weight of the first array elements. src2 : Evision.Mat . second input array of the same size and channel number as src1. beta : double . weight of the second array elements. gamma : double . scalar added to each sum. Keyword Arguments dtype : int . optional depth of the output array; when both input arrays have the same depth, dtype can be set to -1, which will be equivalent to src1.depth(). Return dst : Evision.Mat . output array that has the same size and number of channels as the input arrays. The function addWeighted calculates the weighted sum of two arrays as follows: \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{src1} (I)* \\texttt{alpha} + \\texttt{src2} (I)* \\texttt{beta} + \\texttt{gamma} )\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The function can be replaced with a matrix expression: dst = src1*alpha + src2*beta + gamma; Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa add, subtract, scaleAdd, Mat::convertTo Python prototype (for reference): addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]]) -&gt; dst","ref":"Evision.html#addWeighted/5","title":"Evision.addWeighted/5","type":"function"},{"doc":"Calculates the weighted sum of two arrays. Positional Arguments src1 : Evision.Mat . first input array. alpha : double . weight of the first array elements. src2 : Evision.Mat . second input array of the same size and channel number as src1. beta : double . weight of the second array elements. gamma : double . scalar added to each sum. Keyword Arguments dtype : int . optional depth of the output array; when both input arrays have the same depth, dtype can be set to -1, which will be equivalent to src1.depth(). Return dst : Evision.Mat . output array that has the same size and number of channels as the input arrays. The function addWeighted calculates the weighted sum of two arrays as follows: \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{src1} (I)* \\texttt{alpha} + \\texttt{src2} (I)* \\texttt{beta} + \\texttt{gamma} )\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The function can be replaced with a matrix expression: dst = src1*alpha + src2*beta + gamma; Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa add, subtract, scaleAdd, Mat::convertTo Python prototype (for reference): addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]]) -&gt; dst","ref":"Evision.html#addWeighted/6","title":"Evision.addWeighted/6","type":"function"},{"doc":"Raising version of applyColorMap/2 .","ref":"Evision.html#applyColorMap!/2","title":"Evision.applyColorMap!/2","type":"function"},{"doc":"Raising version of applyColorMap/3 .","ref":"Evision.html#applyColorMap!/3","title":"Evision.applyColorMap!/3","type":"function"},{"doc":"Variant 1: Applies a user colormap on a given image. Positional Arguments src : Evision.Mat . The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. userColor : Evision.Mat . The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256 Return dst : Evision.Mat . The result is the colormapped source image. Note: Mat::create is called on dst. Python prototype (for reference): applyColorMap(src, userColor[, dst]) -&gt; dst Variant 2: Applies a GNU Octave/MATLAB equivalent colormap on a given image. Positional Arguments src : Evision.Mat . The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. colormap : int . The colormap to apply, see #ColormapTypes Return dst : Evision.Mat . The result is the colormapped source image. Note: Mat::create is called on dst. Python prototype (for reference): applyColorMap(src, colormap[, dst]) -&gt; dst","ref":"Evision.html#applyColorMap/2","title":"Evision.applyColorMap/2","type":"function"},{"doc":"Variant 1: Applies a user colormap on a given image. Positional Arguments src : Evision.Mat . The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. userColor : Evision.Mat . The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256 Return dst : Evision.Mat . The result is the colormapped source image. Note: Mat::create is called on dst. Python prototype (for reference): applyColorMap(src, userColor[, dst]) -&gt; dst Variant 2: Applies a GNU Octave/MATLAB equivalent colormap on a given image. Positional Arguments src : Evision.Mat . The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. colormap : int . The colormap to apply, see #ColormapTypes Return dst : Evision.Mat . The result is the colormapped source image. Note: Mat::create is called on dst. Python prototype (for reference): applyColorMap(src, colormap[, dst]) -&gt; dst","ref":"Evision.html#applyColorMap/3","title":"Evision.applyColorMap/3","type":"function"},{"doc":"Raising version of approxPolyDP/3 .","ref":"Evision.html#approxPolyDP!/3","title":"Evision.approxPolyDP!/3","type":"function"},{"doc":"Raising version of approxPolyDP/4 .","ref":"Evision.html#approxPolyDP!/4","title":"Evision.approxPolyDP!/4","type":"function"},{"doc":"Approximates a polygonal curve(s) with the specified precision. Positional Arguments curve : Evision.Mat . Input vector of a 2D point stored in std::vector or Mat epsilon : double . Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation. closed : bool . If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed. Return approxCurve : Evision.Mat . Result of the approximation. The type should match the type of the input curve. The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less vertices so that the distance between them is less or equal to the specified precision. It uses the Douglas-Peucker algorithm http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm Python prototype (for reference): approxPolyDP(curve, epsilon, closed[, approxCurve]) -&gt; approxCurve","ref":"Evision.html#approxPolyDP/3","title":"Evision.approxPolyDP/3","type":"function"},{"doc":"Approximates a polygonal curve(s) with the specified precision. Positional Arguments curve : Evision.Mat . Input vector of a 2D point stored in std::vector or Mat epsilon : double . Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation. closed : bool . If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed. Return approxCurve : Evision.Mat . Result of the approximation. The type should match the type of the input curve. The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less vertices so that the distance between them is less or equal to the specified precision. It uses the Douglas-Peucker algorithm http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm Python prototype (for reference): approxPolyDP(curve, epsilon, closed[, approxCurve]) -&gt; approxCurve","ref":"Evision.html#approxPolyDP/4","title":"Evision.approxPolyDP/4","type":"function"},{"doc":"Raising version of arcLength/2 .","ref":"Evision.html#arcLength!/2","title":"Evision.arcLength!/2","type":"function"},{"doc":"Calculates a contour perimeter or a curve length. Positional Arguments curve : Evision.Mat . Input vector of 2D points, stored in std::vector or Mat. closed : bool . Flag indicating whether the curve is closed or not. The function computes a curve length or a closed contour perimeter. Python prototype (for reference): arcLength(curve, closed) -&gt; retval","ref":"Evision.html#arcLength/2","title":"Evision.arcLength/2","type":"function"},{"doc":"Raising version of arrowedLine/4 .","ref":"Evision.html#arrowedLine!/4","title":"Evision.arrowedLine!/4","type":"function"},{"doc":"Raising version of arrowedLine/5 .","ref":"Evision.html#arrowedLine!/5","title":"Evision.arrowedLine!/5","type":"function"},{"doc":"Draws an arrow segment pointing from the first point to the second one. Positional Arguments pt1 : Point . The point the arrow starts from. pt2 : Point . The point the arrow points to. color : Scalar . Line color. Keyword Arguments thickness : int . Line thickness. line_type : int . Type of the line. See #LineTypes shift : int . Number of fractional bits in the point coordinates. tipLength : double . The length of the arrow tip in relation to the arrow length Return img : Evision.Mat . Image. The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line. Python prototype (for reference): arrowedLine(img, pt1, pt2, color[, thickness[, line_type[, shift[, tipLength]]]]) -&gt; img","ref":"Evision.html#arrowedLine/4","title":"Evision.arrowedLine/4","type":"function"},{"doc":"Draws an arrow segment pointing from the first point to the second one. Positional Arguments pt1 : Point . The point the arrow starts from. pt2 : Point . The point the arrow points to. color : Scalar . Line color. Keyword Arguments thickness : int . Line thickness. line_type : int . Type of the line. See #LineTypes shift : int . Number of fractional bits in the point coordinates. tipLength : double . The length of the arrow tip in relation to the arrow length Return img : Evision.Mat . Image. The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line. Python prototype (for reference): arrowedLine(img, pt1, pt2, color[, thickness[, line_type[, shift[, tipLength]]]]) -&gt; img","ref":"Evision.html#arrowedLine/5","title":"Evision.arrowedLine/5","type":"function"},{"doc":"Raising version of batchDistance/3 .","ref":"Evision.html#batchDistance!/3","title":"Evision.batchDistance!/3","type":"function"},{"doc":"Raising version of batchDistance/4 .","ref":"Evision.html#batchDistance!/4","title":"Evision.batchDistance!/4","type":"function"},{"doc":"naive nearest neighbor finder Positional Arguments src1 : Evision.Mat src2 : Evision.Mat dtype : int Keyword Arguments normType : int . k : int . mask : Evision.Mat . update : int . crosscheck : bool . Return dist : Evision.Mat . nidx : Evision.Mat . see http://en.wikipedia.org/wiki/Nearest_neighbor_search @todo document Python prototype (for reference): batchDistance(src1, src2, dtype[, dist[, nidx[, normType[, K[, mask[, update[, crosscheck]]]]]]]) -&gt; dist, nidx","ref":"Evision.html#batchDistance/3","title":"Evision.batchDistance/3","type":"function"},{"doc":"naive nearest neighbor finder Positional Arguments src1 : Evision.Mat src2 : Evision.Mat dtype : int Keyword Arguments normType : int . k : int . mask : Evision.Mat . update : int . crosscheck : bool . Return dist : Evision.Mat . nidx : Evision.Mat . see http://en.wikipedia.org/wiki/Nearest_neighbor_search @todo document Python prototype (for reference): batchDistance(src1, src2, dtype[, dist[, nidx[, normType[, K[, mask[, update[, crosscheck]]]]]]]) -&gt; dist, nidx","ref":"Evision.html#batchDistance/4","title":"Evision.batchDistance/4","type":"function"},{"doc":"Raising version of bilateralFilter/4 .","ref":"Evision.html#bilateralFilter!/4","title":"Evision.bilateralFilter!/4","type":"function"},{"doc":"Raising version of bilateralFilter/5 .","ref":"Evision.html#bilateralFilter!/5","title":"Evision.bilateralFilter!/5","type":"function"},{"doc":"Applies the bilateral filter to an image. Positional Arguments src : Evision.Mat . Source 8-bit or floating-point, 1-channel or 3-channel image. d : int . Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace. sigmaColor : double . Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color. sigmaSpace : double . Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace. Keyword Arguments borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes Return dst : Evision.Mat . Destination image of the same size and type as src . The function applies bilateral filtering to the input image, as described in http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters. Sigma values : For simplicity, you can set the 2 sigma values to be the same. If they are small (\\&lt; 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very strong effect, making the image look &quot;cartoonish&quot;. Filter size : Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering. This filter does not work inplace. Python prototype (for reference): bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#bilateralFilter/4","title":"Evision.bilateralFilter/4","type":"function"},{"doc":"Applies the bilateral filter to an image. Positional Arguments src : Evision.Mat . Source 8-bit or floating-point, 1-channel or 3-channel image. d : int . Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace. sigmaColor : double . Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color. sigmaSpace : double . Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace. Keyword Arguments borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes Return dst : Evision.Mat . Destination image of the same size and type as src . The function applies bilateral filtering to the input image, as described in http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters. Sigma values : For simplicity, you can set the 2 sigma values to be the same. If they are small (\\&lt; 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very strong effect, making the image look &quot;cartoonish&quot;. Filter size : Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering. This filter does not work inplace. Python prototype (for reference): bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#bilateralFilter/5","title":"Evision.bilateralFilter/5","type":"function"},{"doc":"Raising version of blendLinear/4 .","ref":"Evision.html#blendLinear!/4","title":"Evision.blendLinear!/4","type":"function"},{"doc":"Raising version of blendLinear/5 .","ref":"Evision.html#blendLinear!/5","title":"Evision.blendLinear!/5","type":"function"},{"doc":"Positional Arguments src1 : Evision.Mat src2 : Evision.Mat weights1 : Evision.Mat weights2 : Evision.Mat Return dst : Evision.Mat . Has overloading in C++ variant without mask parameter Python prototype (for reference): blendLinear(src1, src2, weights1, weights2[, dst]) -&gt; dst","ref":"Evision.html#blendLinear/4","title":"Evision.blendLinear/4","type":"function"},{"doc":"Positional Arguments src1 : Evision.Mat src2 : Evision.Mat weights1 : Evision.Mat weights2 : Evision.Mat Return dst : Evision.Mat . Has overloading in C++ variant without mask parameter Python prototype (for reference): blendLinear(src1, src2, weights1, weights2[, dst]) -&gt; dst","ref":"Evision.html#blendLinear/5","title":"Evision.blendLinear/5","type":"function"},{"doc":"Raising version of blur/2 .","ref":"Evision.html#blur!/2","title":"Evision.blur!/2","type":"function"},{"doc":"Raising version of blur/3 .","ref":"Evision.html#blur!/3","title":"Evision.blur!/3","type":"function"},{"doc":"Blurs an image using the normalized box filter. Positional Arguments src : Evision.Mat . input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. ksize : Size . blurring kernel size. Keyword Arguments anchor : Point . anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src. The function smooths an image using the kernel: \\f[\\texttt{K} = \\frac{1}{\\texttt{ksize.width*ksize.height}} \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\hdotsfor{6} \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\end{bmatrix}\\f] The call blur(src, dst, ksize, anchor, borderType) is equivalent to boxFilter(src, dst, src.type(), ksize, anchor, true, borderType) . @sa boxFilter, bilateralFilter, GaussianBlur, medianBlur Python prototype (for reference): blur(src, ksize[, dst[, anchor[, borderType]]]) -&gt; dst","ref":"Evision.html#blur/2","title":"Evision.blur/2","type":"function"},{"doc":"Blurs an image using the normalized box filter. Positional Arguments src : Evision.Mat . input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. ksize : Size . blurring kernel size. Keyword Arguments anchor : Point . anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src. The function smooths an image using the kernel: \\f[\\texttt{K} = \\frac{1}{\\texttt{ksize.width*ksize.height}} \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\hdotsfor{6} \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\end{bmatrix}\\f] The call blur(src, dst, ksize, anchor, borderType) is equivalent to boxFilter(src, dst, src.type(), ksize, anchor, true, borderType) . @sa boxFilter, bilateralFilter, GaussianBlur, medianBlur Python prototype (for reference): blur(src, ksize[, dst[, anchor[, borderType]]]) -&gt; dst","ref":"Evision.html#blur/3","title":"Evision.blur/3","type":"function"},{"doc":"Raising version of borderInterpolate/3 .","ref":"Evision.html#borderInterpolate!/3","title":"Evision.borderInterpolate!/3","type":"function"},{"doc":"Computes the source location of an extrapolated pixel. Positional Arguments p : int . 0-based coordinate of the extrapolated pixel along one of the axes, likely \\&lt;0 or &gt;= len len : int . Length of the array along the corresponding axis. borderType : int . Border type, one of the #BorderTypes, except for #BORDER_TRANSPARENT and #BORDER_ISOLATED . When borderType==#BORDER_CONSTANT , the function always returns -1, regardless of p and len. The function computes and returns the coordinate of a donor pixel corresponding to the specified extrapolated pixel when using the specified extrapolation border mode. For example, if you use cv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and want to compute value of the &quot;virtual&quot; pixel Point(-5, 100) in a floating-point image img , it looks like: float val = img.at&lt;float&gt;(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101), borderInterpolate(-5, img.cols, cv::BORDER_WRAP)); Normally, the function is not called directly. It is used inside filtering functions and also in copyMakeBorder. @sa copyMakeBorder Python prototype (for reference): borderInterpolate(p, len, borderType) -&gt; retval","ref":"Evision.html#borderInterpolate/3","title":"Evision.borderInterpolate/3","type":"function"},{"doc":"Raising version of boundingRect/1 .","ref":"Evision.html#boundingRect!/1","title":"Evision.boundingRect!/1","type":"function"},{"doc":"Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image. Positional Arguments array : Evision.Mat . Input gray-scale image or 2D point set, stored in std::vector or Mat. The function calculates and returns the minimal up-right bounding rectangle for the specified point set or non-zero pixels of gray-scale image. Python prototype (for reference): boundingRect(array) -&gt; retval","ref":"Evision.html#boundingRect/1","title":"Evision.boundingRect/1","type":"function"},{"doc":"Raising version of boxFilter/3 .","ref":"Evision.html#boxFilter!/3","title":"Evision.boxFilter!/3","type":"function"},{"doc":"Raising version of boxFilter/4 .","ref":"Evision.html#boxFilter!/4","title":"Evision.boxFilter!/4","type":"function"},{"doc":"Blurs an image using the box filter. Positional Arguments src : Evision.Mat . input image. ddepth : int . the output image depth (-1 to use src.depth()). ksize : Size . blurring kernel size. Keyword Arguments anchor : Point . anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. normalize : bool . flag, specifying whether the kernel is normalized by its area or not. borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src. The function smooths an image using the kernel: \\f[\\texttt{K} = \\alpha \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\hdotsfor{6} \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\end{bmatrix}\\f] where \\f[\\alpha = \\begin{cases} \\frac{1}{\\texttt{ksize.width*ksize.height}} &amp; \\texttt{when } \\texttt{normalize=true} \\\\1 &amp; \\texttt{otherwise}\\end{cases}\\f] Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral. @sa blur, bilateralFilter, GaussianBlur, medianBlur, integral Python prototype (for reference): boxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -&gt; dst","ref":"Evision.html#boxFilter/3","title":"Evision.boxFilter/3","type":"function"},{"doc":"Blurs an image using the box filter. Positional Arguments src : Evision.Mat . input image. ddepth : int . the output image depth (-1 to use src.depth()). ksize : Size . blurring kernel size. Keyword Arguments anchor : Point . anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. normalize : bool . flag, specifying whether the kernel is normalized by its area or not. borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src. The function smooths an image using the kernel: \\f[\\texttt{K} = \\alpha \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\hdotsfor{6} \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\end{bmatrix}\\f] where \\f[\\alpha = \\begin{cases} \\frac{1}{\\texttt{ksize.width*ksize.height}} &amp; \\texttt{when } \\texttt{normalize=true} \\\\1 &amp; \\texttt{otherwise}\\end{cases}\\f] Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral. @sa blur, bilateralFilter, GaussianBlur, medianBlur, integral Python prototype (for reference): boxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -&gt; dst","ref":"Evision.html#boxFilter/4","title":"Evision.boxFilter/4","type":"function"},{"doc":"Raising version of boxPoints/1 .","ref":"Evision.html#boxPoints!/1","title":"Evision.boxPoints!/1","type":"function"},{"doc":"Raising version of boxPoints/2 .","ref":"Evision.html#boxPoints!/2","title":"Evision.boxPoints!/2","type":"function"},{"doc":"Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle. Positional Arguments box : {centre={x, y}, size={s1, s2}, angle} . The input rotated rectangle. It may be the output of Return points : Evision.Mat . The output array of four vertices of rectangles. The function finds the four vertices of a rotated rectangle. This function is useful to draw the rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please visit the @ref tutorial_bounding_rotated_ellipses &quot;tutorial on Creating Bounding rotated boxes and ellipses for contours&quot; for more information. Python prototype (for reference): boxPoints(box[, points]) -&gt; points","ref":"Evision.html#boxPoints/1","title":"Evision.boxPoints/1","type":"function"},{"doc":"Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle. Positional Arguments box : {centre={x, y}, size={s1, s2}, angle} . The input rotated rectangle. It may be the output of Return points : Evision.Mat . The output array of four vertices of rectangles. The function finds the four vertices of a rotated rectangle. This function is useful to draw the rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please visit the @ref tutorial_bounding_rotated_ellipses &quot;tutorial on Creating Bounding rotated boxes and ellipses for contours&quot; for more information. Python prototype (for reference): boxPoints(box[, points]) -&gt; points","ref":"Evision.html#boxPoints/2","title":"Evision.boxPoints/2","type":"function"},{"doc":"Raising version of buildOpticalFlowPyramid/3 .","ref":"Evision.html#buildOpticalFlowPyramid!/3","title":"Evision.buildOpticalFlowPyramid!/3","type":"function"},{"doc":"Raising version of buildOpticalFlowPyramid/4 .","ref":"Evision.html#buildOpticalFlowPyramid!/4","title":"Evision.buildOpticalFlowPyramid!/4","type":"function"},{"doc":"Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. Positional Arguments img : Evision.Mat . 8-bit input image. winSize : Size . window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. maxLevel : int . 0-based maximal pyramid level number. Keyword Arguments withDerivatives : bool . set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. pyrBorder : int . the border mode for pyramid layers. derivBorder : int . the border mode for gradients. tryReuseInputImage : bool . put ROI of input image into the pyramid if possible. You can pass false to force data copying. Return pyramid : [Evision.Mat] . output pyramid. @return number of levels in constructed pyramid. Can be less than maxLevel. Python prototype (for reference): buildOpticalFlowPyramid(img, winSize, maxLevel[, pyramid[, withDerivatives[, pyrBorder[, derivBorder[, tryReuseInputImage]]]]]) -&gt; retval, pyramid","ref":"Evision.html#buildOpticalFlowPyramid/3","title":"Evision.buildOpticalFlowPyramid/3","type":"function"},{"doc":"Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. Positional Arguments img : Evision.Mat . 8-bit input image. winSize : Size . window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. maxLevel : int . 0-based maximal pyramid level number. Keyword Arguments withDerivatives : bool . set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. pyrBorder : int . the border mode for pyramid layers. derivBorder : int . the border mode for gradients. tryReuseInputImage : bool . put ROI of input image into the pyramid if possible. You can pass false to force data copying. Return pyramid : [Evision.Mat] . output pyramid. @return number of levels in constructed pyramid. Can be less than maxLevel. Python prototype (for reference): buildOpticalFlowPyramid(img, winSize, maxLevel[, pyramid[, withDerivatives[, pyrBorder[, derivBorder[, tryReuseInputImage]]]]]) -&gt; retval, pyramid","ref":"Evision.html#buildOpticalFlowPyramid/4","title":"Evision.buildOpticalFlowPyramid/4","type":"function"},{"doc":"Raising version of calcBackProject/5 .","ref":"Evision.html#calcBackProject!/5","title":"Evision.calcBackProject!/5","type":"function"},{"doc":"Raising version of calcBackProject/6 .","ref":"Evision.html#calcBackProject!/6","title":"Evision.calcBackProject!/6","type":"function"},{"doc":"Positional Arguments images : [Evision.Mat] channels : [int] hist : Evision.Mat ranges : [float] scale : double Return dst : Evision.Mat . Has overloading in C++ Python prototype (for reference): calcBackProject(images, channels, hist, ranges, scale[, dst]) -&gt; dst","ref":"Evision.html#calcBackProject/5","title":"Evision.calcBackProject/5","type":"function"},{"doc":"Positional Arguments images : [Evision.Mat] channels : [int] hist : Evision.Mat ranges : [float] scale : double Return dst : Evision.Mat . Has overloading in C++ Python prototype (for reference): calcBackProject(images, channels, hist, ranges, scale[, dst]) -&gt; dst","ref":"Evision.html#calcBackProject/6","title":"Evision.calcBackProject/6","type":"function"},{"doc":"Raising version of calcCovarMatrix/3 .","ref":"Evision.html#calcCovarMatrix!/3","title":"Evision.calcCovarMatrix!/3","type":"function"},{"doc":"Raising version of calcCovarMatrix/4 .","ref":"Evision.html#calcCovarMatrix!/4","title":"Evision.calcCovarMatrix!/4","type":"function"},{"doc":"Positional Arguments samples : Evision.Mat . samples stored as rows/columns of a single matrix. flags : int . operation flags as a combination of #CovarFlags Keyword Arguments ctype : int . type of the matrixl; it equals 'CV_64F' by default. Return covar : Evision.Mat . output covariance matrix of the type ctype and square size. mean : Evision.Mat . input or output (depending on the flags) array as the average value of the input vectors. Has overloading in C++ Note : use #COVAR_ROWS or #COVAR_COLS flag Python prototype (for reference): calcCovarMatrix(samples, mean, flags[, covar[, ctype]]) -&gt; covar, mean","ref":"Evision.html#calcCovarMatrix/3","title":"Evision.calcCovarMatrix/3","type":"function"},{"doc":"Positional Arguments samples : Evision.Mat . samples stored as rows/columns of a single matrix. flags : int . operation flags as a combination of #CovarFlags Keyword Arguments ctype : int . type of the matrixl; it equals 'CV_64F' by default. Return covar : Evision.Mat . output covariance matrix of the type ctype and square size. mean : Evision.Mat . input or output (depending on the flags) array as the average value of the input vectors. Has overloading in C++ Note : use #COVAR_ROWS or #COVAR_COLS flag Python prototype (for reference): calcCovarMatrix(samples, mean, flags[, covar[, ctype]]) -&gt; covar, mean","ref":"Evision.html#calcCovarMatrix/4","title":"Evision.calcCovarMatrix/4","type":"function"},{"doc":"Raising version of calcHist/5 .","ref":"Evision.html#calcHist!/5","title":"Evision.calcHist!/5","type":"function"},{"doc":"Raising version of calcHist/6 .","ref":"Evision.html#calcHist!/6","title":"Evision.calcHist!/6","type":"function"},{"doc":"Positional Arguments images : [Evision.Mat] channels : [int] mask : Evision.Mat histSize : [int] ranges : [float] Keyword Arguments accumulate : bool . Return hist : Evision.Mat . Has overloading in C++ Python prototype (for reference): calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) -&gt; hist","ref":"Evision.html#calcHist/5","title":"Evision.calcHist/5","type":"function"},{"doc":"Positional Arguments images : [Evision.Mat] channels : [int] mask : Evision.Mat histSize : [int] ranges : [float] Keyword Arguments accumulate : bool . Return hist : Evision.Mat . Has overloading in C++ Python prototype (for reference): calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) -&gt; hist","ref":"Evision.html#calcHist/6","title":"Evision.calcHist/6","type":"function"},{"doc":"Raising version of calcOpticalFlowFarneback/10 .","ref":"Evision.html#calcOpticalFlowFarneback!/10","title":"Evision.calcOpticalFlowFarneback!/10","type":"function"},{"doc":"Computes a dense optical flow using the Gunnar Farneback's algorithm. Positional Arguments prev : Evision.Mat . first 8-bit single-channel input image. next : Evision.Mat . second input image of the same size and the same type as prev. pyr_scale : double . parameter, specifying the image scale (\\&lt;1) to build pyramids for each image; pyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one. levels : int . number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used. winsize : int . averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field. iterations : int . number of iterations the algorithm does at each pyramid level. poly_n : int . size of the pixel neighborhood used to find polynomial expansion in each pixel; larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field, typically poly_n =5 or 7. poly_sigma : double . standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a good value would be poly_sigma=1.5. flags : int . operation flags that can be a combination of the following: OPTFLOW_USE_INITIAL_FLOW uses the input flow as an initial flow approximation. OPTFLOW_FARNEBACK_GAUSSIAN uses the Gaussian \\f$\\texttt{winsize}\\times\\texttt{winsize}\\f$ filter instead of a box filter of the same size for optical flow estimation; usually, this option gives z more accurate flow than with a box filter, at the cost of lower speed; normally, winsize for a Gaussian window should be set to a larger value to achieve the same level of robustness. Return flow : Evision.Mat . computed flow image that has the same size as prev and type CV_32FC2. The function finds an optical flow for each prev pixel using the @cite Farneback2003 algorithm so that \\f[\\texttt{prev} (y,x) \\sim \\texttt{next} ( y + \\texttt{flow} (y,x)[1], x + \\texttt{flow} (y,x)[0])\\f] Note : An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/cpp/fback.cpp (Python) An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/python/opt_flow.py Python prototype (for reference): calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags) -&gt; flow","ref":"Evision.html#calcOpticalFlowFarneback/10","title":"Evision.calcOpticalFlowFarneback/10","type":"function"},{"doc":"Raising version of calcOpticalFlowPyrLK/4 .","ref":"Evision.html#calcOpticalFlowPyrLK!/4","title":"Evision.calcOpticalFlowPyrLK!/4","type":"function"},{"doc":"Raising version of calcOpticalFlowPyrLK/5 .","ref":"Evision.html#calcOpticalFlowPyrLK!/5","title":"Evision.calcOpticalFlowPyrLK!/5","type":"function"},{"doc":"Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. Positional Arguments prevImg : Evision.Mat . first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. nextImg : Evision.Mat . second input image or pyramid of the same size and the same type as prevImg. prevPts : Evision.Mat . vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. Keyword Arguments winSize : Size . size of the search window at each pyramid level. maxLevel : int . 0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. criteria : TermCriteria . parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. flags : int . operation flags: OPTFLOW_USE_INITIAL_FLOW uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate. OPTFLOW_LK_GET_MIN_EIGENVALS use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. minEigThreshold : double . the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. Return nextPts : Evision.Mat . output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. status : Evision.Mat . output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. err : Evision.Mat . output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See @cite Bouguet00 . The function is parallelized with the TBB library. Note : An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp (Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py (Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py Python prototype (for reference): calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts[, status[, err[, winSize[, maxLevel[, criteria[, flags[, minEigThreshold]]]]]]]) -&gt; nextPts, status, err","ref":"Evision.html#calcOpticalFlowPyrLK/4","title":"Evision.calcOpticalFlowPyrLK/4","type":"function"},{"doc":"Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. Positional Arguments prevImg : Evision.Mat . first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. nextImg : Evision.Mat . second input image or pyramid of the same size and the same type as prevImg. prevPts : Evision.Mat . vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. Keyword Arguments winSize : Size . size of the search window at each pyramid level. maxLevel : int . 0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. criteria : TermCriteria . parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. flags : int . operation flags: OPTFLOW_USE_INITIAL_FLOW uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate. OPTFLOW_LK_GET_MIN_EIGENVALS use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. minEigThreshold : double . the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. Return nextPts : Evision.Mat . output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. status : Evision.Mat . output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. err : Evision.Mat . output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See @cite Bouguet00 . The function is parallelized with the TBB library. Note : An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp (Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py (Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py Python prototype (for reference): calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts[, status[, err[, winSize[, maxLevel[, criteria[, flags[, minEigThreshold]]]]]]]) -&gt; nextPts, status, err","ref":"Evision.html#calcOpticalFlowPyrLK/5","title":"Evision.calcOpticalFlowPyrLK/5","type":"function"},{"doc":"Raising version of calibrateCamera/5 .","ref":"Evision.html#calibrateCamera!/5","title":"Evision.calibrateCamera!/5","type":"function"},{"doc":"Raising version of calibrateCamera/6 .","ref":"Evision.html#calibrateCamera!/6","title":"Evision.calibrateCamera!/6","type":"function"},{"doc":"Positional Arguments objectPoints : [Evision.Mat] imagePoints : [Evision.Mat] imageSize : Size Keyword Arguments flags : int . criteria : TermCriteria . Return cameraMatrix : Evision.Mat distCoeffs : Evision.Mat rvecs : [Evision.Mat] . tvecs : [Evision.Mat] . Has overloading in C++ Python prototype (for reference): calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs","ref":"Evision.html#calibrateCamera/5","title":"Evision.calibrateCamera/5","type":"function"},{"doc":"Positional Arguments objectPoints : [Evision.Mat] imagePoints : [Evision.Mat] imageSize : Size Keyword Arguments flags : int . criteria : TermCriteria . Return cameraMatrix : Evision.Mat distCoeffs : Evision.Mat rvecs : [Evision.Mat] . tvecs : [Evision.Mat] . Has overloading in C++ Python prototype (for reference): calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs","ref":"Evision.html#calibrateCamera/6","title":"Evision.calibrateCamera/6","type":"function"},{"doc":"Raising version of calibrateCameraExtended/5 .","ref":"Evision.html#calibrateCameraExtended!/5","title":"Evision.calibrateCameraExtended!/5","type":"function"},{"doc":"Raising version of calibrateCameraExtended/6 .","ref":"Evision.html#calibrateCameraExtended!/6","title":"Evision.calibrateCameraExtended!/6","type":"function"},{"doc":"Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern. Positional Arguments objectPoints : [Evision.Mat] . In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space (e.g. std::vector&lt;std::vector&lt;cv::Vec3f&gt;&gt;). The outer vector contains as many elements as the number of pattern views. If the same calibration pattern is shown in each view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns or even different patterns in different views. Then, the vectors will be different. Although the points are 3D, they all lie in the calibration pattern's XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a planar rig. In the old interface all the vectors of object points from different views are concatenated together. imagePoints : [Evision.Mat] . In the new interface it is a vector of vectors of the projections of calibration pattern points (e.g. std::vector&lt;std::vector&lt;cv::Vec2f&gt;&gt;). imagePoints.size() and objectPoints.size(), and imagePoints[i].size() and objectPoints[i].size() for each i, must be equal, respectively. In the old interface all the vectors of object points from different views are concatenated together. imageSize : Size . Size of the image used only to initialize the camera intrinsic matrix. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center ( imageSize is used), and focal distances are computed in a least-squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function just to estimate extrinsic parameters. Use @ref solvePnP instead. @ref CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global optimization. It stays at the center or at a different location specified when criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return cameraMatrix : Evision.Mat . Input/output 3x3 floating-point camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . If @ref CALIB_USE_INTRINSIC_GUESS and/or @ref CALIB_FIX_ASPECT_RATIO, @ref CALIB_FIX_PRINCIPAL_POINT or @ref CALIB_FIX_FOCAL_LENGTH are specified, some or all of fx, fy, cx, cy must be initialized before calling the function. distCoeffs : Evision.Mat . Input/output vector of distortion coefficients \\f$\\distcoeffs\\f$. rvecs : [Evision.Mat] . Output vector of rotation vectors (@ref Rodrigues ) estimated for each pattern view (e.g. std::vector&lt;cv::Mat&gt;&gt;). That is, each i-th rotation vector together with the corresponding i-th translation vector (see the next output parameter description) brings the calibration pattern from the object coordinate space (in which object points are specified) to the camera coordinate space. In more technical terms, the tuple of the i-th rotation and translation vector performs a change of basis from object coordinate space to camera coordinate space. Due to its duality, this tuple is equivalent to the position of the calibration pattern with respect to the camera coordinate space. tvecs : [Evision.Mat] . Output vector of translation vectors estimated for each pattern view, see parameter describtion above. stdDeviationsIntrinsics : Evision.Mat . Output vector of standard deviations estimated for intrinsic parameters. Order of deviations values: \\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3, s_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's deviation is equals to zero. stdDeviationsExtrinsics : Evision.Mat . Output vector of standard deviations estimated for extrinsic parameters. Order of deviations values: \\f$(R 0, T_0, \\dotsc , R {M - 1}, T_{M - 1})\\f$ where M is the number of pattern views. \\f$R_i, T_i\\f$ are concatenated 1x3 vectors. perViewErrors : Evision.Mat . Output vector of the RMS re-projection error estimated for each pattern view. @ref CALIB_USE_INTRINSIC_GUESS is set too. @ref CALIB_FIX_ASPECT_RATIO The functions consider only fy as a free parameter. The ratio fx/fy stays the same as in the input cameraMatrix . When @ref CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are ignored, only their ratio is computed and used further. @ref CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients \\f$(p_1, p_2)\\f$ are set to zeros and stay zero. @ref CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global optimization if @ref CALIB_USE_INTRINSIC_GUESS is set. @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 The corresponding radial distortion coefficient is not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients or more. @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the thin prism model and return 12 coefficients or more. @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the tilted sensor model and return 14 coefficients. @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @return the overall RMS re-projection error. The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The algorithm is based on @cite Zhang2000 and @cite BouguetMCT . The coordinates of 3D object points and their corresponding 2D projections in each view must be specified. That may be achieved by using an object with known geometry and easily detectable feature points. Such an object is called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as a calibration rig (see @ref findChessboardCorners). Currently, initialization of intrinsic parameters (when @ref CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration patterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also be used as long as initial cameraMatrix is provided. The algorithm performs the following steps: Compute the initial intrinsic parameters (the option only available for planar calibration patterns) or read them from the input parameters. The distortion coefficients are all set to zeros initially unless some of CALIB_FIX_K? are specified. Estimate the initial camera pose as if the intrinsic parameters have been already known. This is done using @ref solvePnP . Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error, that is, the total sum of squared distances between the observed feature points imagePoints and the projected (using the current estimates for camera parameters and the poses) object points objectPoints. See @ref projectPoints for details. Note : If you use a non-square (i.e. non-N-by-N) grid and @ref findChessboardCorners for calibration, and @ref calibrateCamera returns bad values (zero distortion coefficients, \\f$c_x\\f$ and \\f$c_y\\f$ very far from the image center, and/or large differences between \\f$f_x\\f$ and \\f$f_y\\f$ (ratios of 10:1 or more)), then you are probably using patternSize=cvSize(rows,cols) instead of using patternSize=cvSize(cols,rows) in @ref findChessboardCorners. @sa calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort Python prototype (for reference): calibrateCameraExtended(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors","ref":"Evision.html#calibrateCameraExtended/5","title":"Evision.calibrateCameraExtended/5","type":"function"},{"doc":"Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern. Positional Arguments objectPoints : [Evision.Mat] . In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space (e.g. std::vector&lt;std::vector&lt;cv::Vec3f&gt;&gt;). The outer vector contains as many elements as the number of pattern views. If the same calibration pattern is shown in each view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns or even different patterns in different views. Then, the vectors will be different. Although the points are 3D, they all lie in the calibration pattern's XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a planar rig. In the old interface all the vectors of object points from different views are concatenated together. imagePoints : [Evision.Mat] . In the new interface it is a vector of vectors of the projections of calibration pattern points (e.g. std::vector&lt;std::vector&lt;cv::Vec2f&gt;&gt;). imagePoints.size() and objectPoints.size(), and imagePoints[i].size() and objectPoints[i].size() for each i, must be equal, respectively. In the old interface all the vectors of object points from different views are concatenated together. imageSize : Size . Size of the image used only to initialize the camera intrinsic matrix. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center ( imageSize is used), and focal distances are computed in a least-squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function just to estimate extrinsic parameters. Use @ref solvePnP instead. @ref CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global optimization. It stays at the center or at a different location specified when criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return cameraMatrix : Evision.Mat . Input/output 3x3 floating-point camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . If @ref CALIB_USE_INTRINSIC_GUESS and/or @ref CALIB_FIX_ASPECT_RATIO, @ref CALIB_FIX_PRINCIPAL_POINT or @ref CALIB_FIX_FOCAL_LENGTH are specified, some or all of fx, fy, cx, cy must be initialized before calling the function. distCoeffs : Evision.Mat . Input/output vector of distortion coefficients \\f$\\distcoeffs\\f$. rvecs : [Evision.Mat] . Output vector of rotation vectors (@ref Rodrigues ) estimated for each pattern view (e.g. std::vector&lt;cv::Mat&gt;&gt;). That is, each i-th rotation vector together with the corresponding i-th translation vector (see the next output parameter description) brings the calibration pattern from the object coordinate space (in which object points are specified) to the camera coordinate space. In more technical terms, the tuple of the i-th rotation and translation vector performs a change of basis from object coordinate space to camera coordinate space. Due to its duality, this tuple is equivalent to the position of the calibration pattern with respect to the camera coordinate space. tvecs : [Evision.Mat] . Output vector of translation vectors estimated for each pattern view, see parameter describtion above. stdDeviationsIntrinsics : Evision.Mat . Output vector of standard deviations estimated for intrinsic parameters. Order of deviations values: \\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3, s_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's deviation is equals to zero. stdDeviationsExtrinsics : Evision.Mat . Output vector of standard deviations estimated for extrinsic parameters. Order of deviations values: \\f$(R 0, T_0, \\dotsc , R {M - 1}, T_{M - 1})\\f$ where M is the number of pattern views. \\f$R_i, T_i\\f$ are concatenated 1x3 vectors. perViewErrors : Evision.Mat . Output vector of the RMS re-projection error estimated for each pattern view. @ref CALIB_USE_INTRINSIC_GUESS is set too. @ref CALIB_FIX_ASPECT_RATIO The functions consider only fy as a free parameter. The ratio fx/fy stays the same as in the input cameraMatrix . When @ref CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are ignored, only their ratio is computed and used further. @ref CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients \\f$(p_1, p_2)\\f$ are set to zeros and stay zero. @ref CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global optimization if @ref CALIB_USE_INTRINSIC_GUESS is set. @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 The corresponding radial distortion coefficient is not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients or more. @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the thin prism model and return 12 coefficients or more. @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the tilted sensor model and return 14 coefficients. @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @return the overall RMS re-projection error. The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The algorithm is based on @cite Zhang2000 and @cite BouguetMCT . The coordinates of 3D object points and their corresponding 2D projections in each view must be specified. That may be achieved by using an object with known geometry and easily detectable feature points. Such an object is called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as a calibration rig (see @ref findChessboardCorners). Currently, initialization of intrinsic parameters (when @ref CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration patterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also be used as long as initial cameraMatrix is provided. The algorithm performs the following steps: Compute the initial intrinsic parameters (the option only available for planar calibration patterns) or read them from the input parameters. The distortion coefficients are all set to zeros initially unless some of CALIB_FIX_K? are specified. Estimate the initial camera pose as if the intrinsic parameters have been already known. This is done using @ref solvePnP . Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error, that is, the total sum of squared distances between the observed feature points imagePoints and the projected (using the current estimates for camera parameters and the poses) object points objectPoints. See @ref projectPoints for details. Note : If you use a non-square (i.e. non-N-by-N) grid and @ref findChessboardCorners for calibration, and @ref calibrateCamera returns bad values (zero distortion coefficients, \\f$c_x\\f$ and \\f$c_y\\f$ very far from the image center, and/or large differences between \\f$f_x\\f$ and \\f$f_y\\f$ (ratios of 10:1 or more)), then you are probably using patternSize=cvSize(rows,cols) instead of using patternSize=cvSize(cols,rows) in @ref findChessboardCorners. @sa calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort Python prototype (for reference): calibrateCameraExtended(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors","ref":"Evision.html#calibrateCameraExtended/6","title":"Evision.calibrateCameraExtended/6","type":"function"},{"doc":"Raising version of calibrateCameraRO/6 .","ref":"Evision.html#calibrateCameraRO!/6","title":"Evision.calibrateCameraRO!/6","type":"function"},{"doc":"Raising version of calibrateCameraRO/7 .","ref":"Evision.html#calibrateCameraRO!/7","title":"Evision.calibrateCameraRO!/7","type":"function"},{"doc":"Positional Arguments objectPoints : [Evision.Mat] imagePoints : [Evision.Mat] imageSize : Size iFixedPoint : int Keyword Arguments flags : int . criteria : TermCriteria . Return cameraMatrix : Evision.Mat distCoeffs : Evision.Mat rvecs : [Evision.Mat] . tvecs : [Evision.Mat] . newObjPoints : Evision.Mat . Has overloading in C++ Python prototype (for reference): calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, flags[, criteria]]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints","ref":"Evision.html#calibrateCameraRO/6","title":"Evision.calibrateCameraRO/6","type":"function"},{"doc":"Positional Arguments objectPoints : [Evision.Mat] imagePoints : [Evision.Mat] imageSize : Size iFixedPoint : int Keyword Arguments flags : int . criteria : TermCriteria . Return cameraMatrix : Evision.Mat distCoeffs : Evision.Mat rvecs : [Evision.Mat] . tvecs : [Evision.Mat] . newObjPoints : Evision.Mat . Has overloading in C++ Python prototype (for reference): calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, flags[, criteria]]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints","ref":"Evision.html#calibrateCameraRO/7","title":"Evision.calibrateCameraRO/7","type":"function"},{"doc":"Raising version of calibrateCameraROExtended/6 .","ref":"Evision.html#calibrateCameraROExtended!/6","title":"Evision.calibrateCameraROExtended!/6","type":"function"},{"doc":"Raising version of calibrateCameraROExtended/7 .","ref":"Evision.html#calibrateCameraROExtended!/7","title":"Evision.calibrateCameraROExtended!/7","type":"function"},{"doc":"Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern. Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of calibration pattern points in the calibration pattern coordinate space. See #calibrateCamera for details. If the method of releasing object to be used, the identical calibration board must be used in each view and it must be fully visible, and all objectPoints[i] must be the same and all points should be roughly close to a plane. The calibration target has to be rigid, or at least static if the camera (rather than the calibration target) is shifted for grabbing images. imagePoints : [Evision.Mat] . Vector of vectors of the projections of calibration pattern points. See #calibrateCamera for details. imageSize : Size . Size of the image used only to initialize the intrinsic camera matrix. iFixedPoint : int . The index of the 3D object point in objectPoints[0] to be fixed. It also acts as a switch for calibration method selection. If object-releasing method to be used, pass in the parameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will make standard calibration method selected. Usually the top-right corner point of the calibration board grid is recommended to be fixed when object-releasing method being utilized. According to \\cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front and objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and newObjPoints are only possible if coordinates of these three fixed points are accurate enough. Keyword Arguments flags : int . Different flags that may be zero or a combination of some predefined values. See #calibrateCamera for details. If the method of releasing object is used, the calibration time may be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially less precise and less stable in some rare cases. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return cameraMatrix : Evision.Mat . Output 3x3 floating-point camera matrix. See #calibrateCamera for details. distCoeffs : Evision.Mat . Output vector of distortion coefficients. See #calibrateCamera for details. rvecs : [Evision.Mat] . Output vector of rotation vectors estimated for each pattern view. See #calibrateCamera for details. tvecs : [Evision.Mat] . Output vector of translation vectors estimated for each pattern view. newObjPoints : Evision.Mat . The updated output vector of calibration pattern points. The coordinates might be scaled based on three fixed points. The returned coordinates are accurate only if the above mentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter is ignored with standard calibration method. stdDeviationsIntrinsics : Evision.Mat . Output vector of standard deviations estimated for intrinsic parameters. See #calibrateCamera for details. stdDeviationsExtrinsics : Evision.Mat . Output vector of standard deviations estimated for extrinsic parameters. See #calibrateCamera for details. stdDeviationsObjPoints : Evision.Mat . Output vector of standard deviations estimated for refined coordinates of calibration pattern points. It has the same size and order as objectPoints[0] vector. This parameter is ignored with standard calibration method. perViewErrors : Evision.Mat . Output vector of the RMS re-projection error estimated for each pattern view. This function is an extension of #calibrateCamera with the method of releasing object which was proposed in @cite strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar targets (calibration plates), this method can dramatically improve the precision of the estimated camera parameters. Both the object-releasing method and standard method are supported by this function. Use the parameter iFixedPoint for method selection. In the internal implementation, #calibrateCamera is a wrapper for this function. @return the overall RMS re-projection error. The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The algorithm is based on @cite Zhang2000, @cite BouguetMCT and @cite strobl2011iccv. See #calibrateCamera for other detailed explanations. @sa calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort Python prototype (for reference): calibrateCameraROExtended(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, stdDeviationsObjPoints[, perViewErrors[, flags[, criteria]]]]]]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors","ref":"Evision.html#calibrateCameraROExtended/6","title":"Evision.calibrateCameraROExtended/6","type":"function"},{"doc":"Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern. Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of calibration pattern points in the calibration pattern coordinate space. See #calibrateCamera for details. If the method of releasing object to be used, the identical calibration board must be used in each view and it must be fully visible, and all objectPoints[i] must be the same and all points should be roughly close to a plane. The calibration target has to be rigid, or at least static if the camera (rather than the calibration target) is shifted for grabbing images. imagePoints : [Evision.Mat] . Vector of vectors of the projections of calibration pattern points. See #calibrateCamera for details. imageSize : Size . Size of the image used only to initialize the intrinsic camera matrix. iFixedPoint : int . The index of the 3D object point in objectPoints[0] to be fixed. It also acts as a switch for calibration method selection. If object-releasing method to be used, pass in the parameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will make standard calibration method selected. Usually the top-right corner point of the calibration board grid is recommended to be fixed when object-releasing method being utilized. According to \\cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front and objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and newObjPoints are only possible if coordinates of these three fixed points are accurate enough. Keyword Arguments flags : int . Different flags that may be zero or a combination of some predefined values. See #calibrateCamera for details. If the method of releasing object is used, the calibration time may be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially less precise and less stable in some rare cases. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return cameraMatrix : Evision.Mat . Output 3x3 floating-point camera matrix. See #calibrateCamera for details. distCoeffs : Evision.Mat . Output vector of distortion coefficients. See #calibrateCamera for details. rvecs : [Evision.Mat] . Output vector of rotation vectors estimated for each pattern view. See #calibrateCamera for details. tvecs : [Evision.Mat] . Output vector of translation vectors estimated for each pattern view. newObjPoints : Evision.Mat . The updated output vector of calibration pattern points. The coordinates might be scaled based on three fixed points. The returned coordinates are accurate only if the above mentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter is ignored with standard calibration method. stdDeviationsIntrinsics : Evision.Mat . Output vector of standard deviations estimated for intrinsic parameters. See #calibrateCamera for details. stdDeviationsExtrinsics : Evision.Mat . Output vector of standard deviations estimated for extrinsic parameters. See #calibrateCamera for details. stdDeviationsObjPoints : Evision.Mat . Output vector of standard deviations estimated for refined coordinates of calibration pattern points. It has the same size and order as objectPoints[0] vector. This parameter is ignored with standard calibration method. perViewErrors : Evision.Mat . Output vector of the RMS re-projection error estimated for each pattern view. This function is an extension of #calibrateCamera with the method of releasing object which was proposed in @cite strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar targets (calibration plates), this method can dramatically improve the precision of the estimated camera parameters. Both the object-releasing method and standard method are supported by this function. Use the parameter iFixedPoint for method selection. In the internal implementation, #calibrateCamera is a wrapper for this function. @return the overall RMS re-projection error. The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The algorithm is based on @cite Zhang2000, @cite BouguetMCT and @cite strobl2011iccv. See #calibrateCamera for other detailed explanations. @sa calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort Python prototype (for reference): calibrateCameraROExtended(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, stdDeviationsObjPoints[, perViewErrors[, flags[, criteria]]]]]]]]]) -&gt; retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors","ref":"Evision.html#calibrateCameraROExtended/7","title":"Evision.calibrateCameraROExtended/7","type":"function"},{"doc":"Raising version of calibrateHandEye/4 .","ref":"Evision.html#calibrateHandEye!/4","title":"Evision.calibrateHandEye!/4","type":"function"},{"doc":"Raising version of calibrateHandEye/5 .","ref":"Evision.html#calibrateHandEye!/5","title":"Evision.calibrateHandEye!/5","type":"function"},{"doc":"Computes Hand-Eye calibration: \\f$_{}^{g}\\textrm{T}_c\\f$ Positional Arguments r_gripper2base : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from gripper frame to robot base frame. t_gripper2base : [Evision.Mat] . Translation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from gripper frame to robot base frame. r_target2cam : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from calibration target frame to camera frame. t_target2cam : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from calibration target frame to camera frame. Keyword Arguments method : HandEyeCalibrationMethod . One of the implemented Hand-Eye calibration method, see cv::HandEyeCalibrationMethod Return r_cam2gripper : Evision.Mat . Estimated (3x3) rotation part extracted from the homogeneous matrix that transforms a point expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$). t_cam2gripper : Evision.Mat . Estimated (3x1) translation part extracted from the homogeneous matrix that transforms a point expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$). The function performs the Hand-Eye calibration using various methods. One approach consists in estimating the rotation then the translation (separable solutions) and the following methods are implemented: R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \\cite Tsai89 F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \\cite Park94 R. Horaud, F. Dornaika Hand-Eye Calibration \\cite Horaud95 Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions), with the following implemented methods: N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \\cite Andreff99 K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \\cite Daniilidis98 The following picture describes the Hand-Eye calibration problem where the transformation between a camera (&quot;eye&quot;) mounted on a robot gripper (&quot;hand&quot;) has to be estimated. This configuration is called eye-in-hand. The eye-to-hand configuration consists in a static camera observing a calibration pattern mounted on the robot end-effector. The transformation from the camera to the robot base frame can then be estimated by inputting the suitable transformations to the function, see below. The calibration procedure is the following: a static calibration pattern is used to estimate the transformation between the target frame and the camera frame the robot gripper is moved in order to acquire several poses for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for instance the robot kinematics \\f[ \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{b}\\textrm{R}_g &amp; _{}^{b}\\textrm{t}_g \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} \\f] for each pose, the homogeneous transformation between the calibration target frame and the camera frame is recorded using for instance a pose estimation method (PnP) from 2D-3D point correspondences \\f[ \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{c}\\textrm{R}_t &amp; _{}^{c}\\textrm{t}_t \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_t\\\\ Y_t\\\\ Z_t\\\\ 1 \\end{bmatrix} \\f] The Hand-Eye calibration procedure returns the following homogeneous transformation \\f[ \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} \\begin{bmatrix} _{}^{g}\\textrm{R}_c &amp; _{}^{g}\\textrm{t}_c \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} \\f] This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{X}\\mathbf{B}\\f$ equation: for an eye-in-hand configuration \\f[ \\begin{align*} ^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(1)} &amp;= \\hspace{0.1em} ^{b}{\\textrm{T}_g}^{(2)} \\hspace{0.2em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} \\\\ (^{b}{\\textrm{T}_g}^{(2)})^{-1} \\hspace{0.2em} ^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c &amp;= \\hspace{0.1em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} (^{c}{\\textrm{T}_t}^{(1)})^{-1} \\\\ \\textrm{A}_i \\textrm{X} &amp;= \\textrm{X} \\textrm{B}_i \\\\ \\end{align*} \\f] for an eye-to-hand configuration \\f[ \\begin{align*} ^{g}{\\textrm{T}_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(1)} &amp;= \\hspace{0.1em} ^{g}{\\textrm{T}_b}^{(2)} \\hspace{0.2em} ^{b}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} \\\\ (^{g}{\\textrm{T}_b}^{(2)})^{-1} \\hspace{0.2em} ^{g}{\\textrm{T}_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}_c &amp;= \\hspace{0.1em} ^{b}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} (^{c}{\\textrm{T}_t}^{(1)})^{-1} \\\\ \\textrm{A}_i \\textrm{X} &amp;= \\textrm{X} \\textrm{B}_i \\\\ \\end{align*} \\f] \\note Additional information can be found on this website . \\note A minimum of 2 motions with non parallel rotation axes are necessary to determine the hand-eye transformation. So at least 3 different poses are required, but it is strongly recommended to use many more poses. Python prototype (for reference): calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam[, R_cam2gripper[, t_cam2gripper[, method]]]) -&gt; R_cam2gripper, t_cam2gripper","ref":"Evision.html#calibrateHandEye/4","title":"Evision.calibrateHandEye/4","type":"function"},{"doc":"Computes Hand-Eye calibration: \\f$_{}^{g}\\textrm{T}_c\\f$ Positional Arguments r_gripper2base : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from gripper frame to robot base frame. t_gripper2base : [Evision.Mat] . Translation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from gripper frame to robot base frame. r_target2cam : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from calibration target frame to camera frame. t_target2cam : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from calibration target frame to camera frame. Keyword Arguments method : HandEyeCalibrationMethod . One of the implemented Hand-Eye calibration method, see cv::HandEyeCalibrationMethod Return r_cam2gripper : Evision.Mat . Estimated (3x3) rotation part extracted from the homogeneous matrix that transforms a point expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$). t_cam2gripper : Evision.Mat . Estimated (3x1) translation part extracted from the homogeneous matrix that transforms a point expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$). The function performs the Hand-Eye calibration using various methods. One approach consists in estimating the rotation then the translation (separable solutions) and the following methods are implemented: R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \\cite Tsai89 F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \\cite Park94 R. Horaud, F. Dornaika Hand-Eye Calibration \\cite Horaud95 Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions), with the following implemented methods: N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \\cite Andreff99 K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \\cite Daniilidis98 The following picture describes the Hand-Eye calibration problem where the transformation between a camera (&quot;eye&quot;) mounted on a robot gripper (&quot;hand&quot;) has to be estimated. This configuration is called eye-in-hand. The eye-to-hand configuration consists in a static camera observing a calibration pattern mounted on the robot end-effector. The transformation from the camera to the robot base frame can then be estimated by inputting the suitable transformations to the function, see below. The calibration procedure is the following: a static calibration pattern is used to estimate the transformation between the target frame and the camera frame the robot gripper is moved in order to acquire several poses for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for instance the robot kinematics \\f[ \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{b}\\textrm{R}_g &amp; _{}^{b}\\textrm{t}_g \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} \\f] for each pose, the homogeneous transformation between the calibration target frame and the camera frame is recorded using for instance a pose estimation method (PnP) from 2D-3D point correspondences \\f[ \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{c}\\textrm{R}_t &amp; _{}^{c}\\textrm{t}_t \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_t\\\\ Y_t\\\\ Z_t\\\\ 1 \\end{bmatrix} \\f] The Hand-Eye calibration procedure returns the following homogeneous transformation \\f[ \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} \\begin{bmatrix} _{}^{g}\\textrm{R}_c &amp; _{}^{g}\\textrm{t}_c \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} \\f] This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{X}\\mathbf{B}\\f$ equation: for an eye-in-hand configuration \\f[ \\begin{align*} ^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(1)} &amp;= \\hspace{0.1em} ^{b}{\\textrm{T}_g}^{(2)} \\hspace{0.2em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} \\\\ (^{b}{\\textrm{T}_g}^{(2)})^{-1} \\hspace{0.2em} ^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c &amp;= \\hspace{0.1em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} (^{c}{\\textrm{T}_t}^{(1)})^{-1} \\\\ \\textrm{A}_i \\textrm{X} &amp;= \\textrm{X} \\textrm{B}_i \\\\ \\end{align*} \\f] for an eye-to-hand configuration \\f[ \\begin{align*} ^{g}{\\textrm{T}_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(1)} &amp;= \\hspace{0.1em} ^{g}{\\textrm{T}_b}^{(2)} \\hspace{0.2em} ^{b}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} \\\\ (^{g}{\\textrm{T}_b}^{(2)})^{-1} \\hspace{0.2em} ^{g}{\\textrm{T}_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}_c &amp;= \\hspace{0.1em} ^{b}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} (^{c}{\\textrm{T}_t}^{(1)})^{-1} \\\\ \\textrm{A}_i \\textrm{X} &amp;= \\textrm{X} \\textrm{B}_i \\\\ \\end{align*} \\f] \\note Additional information can be found on this website . \\note A minimum of 2 motions with non parallel rotation axes are necessary to determine the hand-eye transformation. So at least 3 different poses are required, but it is strongly recommended to use many more poses. Python prototype (for reference): calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam[, R_cam2gripper[, t_cam2gripper[, method]]]) -&gt; R_cam2gripper, t_cam2gripper","ref":"Evision.html#calibrateHandEye/5","title":"Evision.calibrateHandEye/5","type":"function"},{"doc":"Raising version of calibrateRobotWorldHandEye/4 .","ref":"Evision.html#calibrateRobotWorldHandEye!/4","title":"Evision.calibrateRobotWorldHandEye!/4","type":"function"},{"doc":"Raising version of calibrateRobotWorldHandEye/5 .","ref":"Evision.html#calibrateRobotWorldHandEye!/5","title":"Evision.calibrateRobotWorldHandEye!/5","type":"function"},{"doc":"Computes Robot-World/Hand-Eye calibration: \\f$_{}^{w}\\textrm{T}_b\\f$ and \\f$_{}^{c}\\textrm{T}_g\\f$ Positional Arguments r_world2cam : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from world frame to the camera frame. t_world2cam : [Evision.Mat] . Translation part extracted from the homogeneous matrix that transforms a point expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from world frame to the camera frame. r_base2gripper : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from robot base frame to the gripper frame. t_base2gripper : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from robot base frame to the gripper frame. Keyword Arguments method : RobotWorldHandEyeCalibrationMethod . One of the implemented Robot-World/Hand-Eye calibration method, see cv::RobotWorldHandEyeCalibrationMethod Return r_base2world : Evision.Mat . Estimated (3x3) rotation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$). t_base2world : Evision.Mat . Estimated (3x1) translation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$). r_gripper2cam : Evision.Mat . Estimated (3x3) rotation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$). t_gripper2cam : Evision.Mat . Estimated (3x1) translation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$). The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the rotation then the translation (separable solutions): M. Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \\cite Shah2013SolvingTR Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions), with the following implemented method: A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product \\cite Li2010SimultaneousRA The following picture describes the Robot-World/Hand-Eye calibration problem where the transformations between a robot and a world frame and between a robot gripper (&quot;hand&quot;) and a camera (&quot;eye&quot;) mounted at the robot end-effector have to be estimated. The calibration procedure is the following: a static calibration pattern is used to estimate the transformation between the target frame and the camera frame the robot gripper is moved in order to acquire several poses for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for instance the robot kinematics \\f[ \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{g}\\textrm{R}_b &amp; _{}^{g}\\textrm{t}_b \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} \\f] for each pose, the homogeneous transformation between the calibration target frame (the world frame) and the camera frame is recorded using for instance a pose estimation method (PnP) from 2D-3D point correspondences \\f[ \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{c}\\textrm{R}_w &amp; _{}^{c}\\textrm{t}_w \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix} \\f] The Robot-World/Hand-Eye calibration procedure returns the following homogeneous transformations \\f[ \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix} \\begin{bmatrix} _{}^{w}\\textrm{R}_b &amp; _{}^{w}\\textrm{t}_b \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} \\f] \\f[ \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} \\begin{bmatrix} _{}^{c}\\textrm{R}_g &amp; _{}^{c}\\textrm{t}_g \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} \\f] This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{Z}\\mathbf{B}\\f$ equation, with: \\f$\\mathbf{A} \\Leftrightarrow \\hspace{0.1em} _{}^{c}\\textrm{T}_w\\f$ \\f$\\mathbf{X} \\Leftrightarrow \\hspace{0.1em} _{}^{w}\\textrm{T}_b\\f$ \\f$\\mathbf{Z} \\Leftrightarrow \\hspace{0.1em} _{}^{c}\\textrm{T}_g\\f$ \\f$\\mathbf{B} \\Leftrightarrow \\hspace{0.1em} _{}^{g}\\textrm{T}_b\\f$ \\note At least 3 measurements are required (input vectors size must be greater or equal to 3). Python prototype (for reference): calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper[, R_base2world[, t_base2world[, R_gripper2cam[, t_gripper2cam[, method]]]]]) -&gt; R_base2world, t_base2world, R_gripper2cam, t_gripper2cam","ref":"Evision.html#calibrateRobotWorldHandEye/4","title":"Evision.calibrateRobotWorldHandEye/4","type":"function"},{"doc":"Computes Robot-World/Hand-Eye calibration: \\f$_{}^{w}\\textrm{T}_b\\f$ and \\f$_{}^{c}\\textrm{T}_g\\f$ Positional Arguments r_world2cam : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from world frame to the camera frame. t_world2cam : [Evision.Mat] . Translation part extracted from the homogeneous matrix that transforms a point expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from world frame to the camera frame. r_base2gripper : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the rotation, (3x3) rotation matrices or (3x1) rotation vectors, for all the transformations from robot base frame to the gripper frame. t_base2gripper : [Evision.Mat] . Rotation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$). This is a vector ( vector&lt;Mat&gt; ) that contains the (3x1) translation vectors for all the transformations from robot base frame to the gripper frame. Keyword Arguments method : RobotWorldHandEyeCalibrationMethod . One of the implemented Robot-World/Hand-Eye calibration method, see cv::RobotWorldHandEyeCalibrationMethod Return r_base2world : Evision.Mat . Estimated (3x3) rotation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$). t_base2world : Evision.Mat . Estimated (3x1) translation part extracted from the homogeneous matrix that transforms a point expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$). r_gripper2cam : Evision.Mat . Estimated (3x3) rotation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$). t_gripper2cam : Evision.Mat . Estimated (3x1) translation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$). The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the rotation then the translation (separable solutions): M. Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \\cite Shah2013SolvingTR Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions), with the following implemented method: A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product \\cite Li2010SimultaneousRA The following picture describes the Robot-World/Hand-Eye calibration problem where the transformations between a robot and a world frame and between a robot gripper (&quot;hand&quot;) and a camera (&quot;eye&quot;) mounted at the robot end-effector have to be estimated. The calibration procedure is the following: a static calibration pattern is used to estimate the transformation between the target frame and the camera frame the robot gripper is moved in order to acquire several poses for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for instance the robot kinematics \\f[ \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{g}\\textrm{R}_b &amp; _{}^{g}\\textrm{t}_b \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} \\f] for each pose, the homogeneous transformation between the calibration target frame (the world frame) and the camera frame is recorded using for instance a pose estimation method (PnP) from 2D-3D point correspondences \\f[ \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} _{}^{c}\\textrm{R}_w &amp; _{}^{c}\\textrm{t}_w \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix} \\f] The Robot-World/Hand-Eye calibration procedure returns the following homogeneous transformations \\f[ \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix} \\begin{bmatrix} _{}^{w}\\textrm{R}_b &amp; _{}^{w}\\textrm{t}_b \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} \\f] \\f[ \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} \\begin{bmatrix} _{}^{c}\\textrm{R}_g &amp; _{}^{c}\\textrm{t}_g \\\\ 0_{1 \\times 3} &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} \\f] This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{Z}\\mathbf{B}\\f$ equation, with: \\f$\\mathbf{A} \\Leftrightarrow \\hspace{0.1em} _{}^{c}\\textrm{T}_w\\f$ \\f$\\mathbf{X} \\Leftrightarrow \\hspace{0.1em} _{}^{w}\\textrm{T}_b\\f$ \\f$\\mathbf{Z} \\Leftrightarrow \\hspace{0.1em} _{}^{c}\\textrm{T}_g\\f$ \\f$\\mathbf{B} \\Leftrightarrow \\hspace{0.1em} _{}^{g}\\textrm{T}_b\\f$ \\note At least 3 measurements are required (input vectors size must be greater or equal to 3). Python prototype (for reference): calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper[, R_base2world[, t_base2world[, R_gripper2cam[, t_gripper2cam[, method]]]]]) -&gt; R_base2world, t_base2world, R_gripper2cam, t_gripper2cam","ref":"Evision.html#calibrateRobotWorldHandEye/5","title":"Evision.calibrateRobotWorldHandEye/5","type":"function"},{"doc":"Raising version of calibrationMatrixValues/4 .","ref":"Evision.html#calibrationMatrixValues!/4","title":"Evision.calibrationMatrixValues!/4","type":"function"},{"doc":"Computes useful camera characteristics from the camera intrinsic matrix. Positional Arguments cameraMatrix : Evision.Mat . Input camera intrinsic matrix that can be estimated by #calibrateCamera or #stereoCalibrate . imageSize : Size . Input image size in pixels. apertureWidth : double . Physical width in mm of the sensor. apertureHeight : double . Physical height in mm of the sensor. Return fovx : double . Output field of view in degrees along the horizontal sensor axis. fovy : double . Output field of view in degrees along the vertical sensor axis. focalLength : double . Focal length of the lens in mm. principalPoint : Point2d . Principal point in mm. aspectRatio : double . \\f$f_y/f_x\\f$ The function computes various useful camera characteristics from the previously estimated camera matrix. Note : Do keep in mind that the unity measure 'mm' stands for whatever unit of measure one chooses for the chessboard pitch (it can thus be any value). Python prototype (for reference): calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight) -&gt; fovx, fovy, focalLength, principalPoint, aspectRatio","ref":"Evision.html#calibrationMatrixValues/4","title":"Evision.calibrationMatrixValues/4","type":"function"},{"doc":"Raising version of camShift/3 .","ref":"Evision.html#camShift!/3","title":"Evision.camShift!/3","type":"function"},{"doc":"Finds an object center, size, and orientation. Positional Arguments probImage : Evision.Mat . Back projection of the object histogram. See calcBackProject. criteria : TermCriteria . Stop criteria for the underlying meanShift. returns (in old interfaces) Number of iterations CAMSHIFT took to converge The function implements the CAMSHIFT object tracking algorithm @cite Bradski98 . First, it finds an object center using meanShift and then adjusts the window size and finds the optimal rotation. The function returns the rotated rectangle structure that includes the object position, size, and orientation. The next position of the search window can be obtained with RotatedRect::boundingRect() Return window : Rect . Initial search window. See the OpenCV sample camshiftdemo.c that tracks colored objects. Note : (Python) A sample explaining the camshift tracking algorithm can be found at opencv_source_code/samples/python/camshift.py Python prototype (for reference): CamShift(probImage, window, criteria) -&gt; retval, window","ref":"Evision.html#camShift/3","title":"Evision.camShift/3","type":"function"},{"doc":"Raising version of canny/3 .","ref":"Evision.html#canny!/3","title":"Evision.canny!/3","type":"function"},{"doc":"Raising version of canny/4 .","ref":"Evision.html#canny!/4","title":"Evision.canny!/4","type":"function"},{"doc":"Raising version of canny/5 .","ref":"Evision.html#canny!/5","title":"Evision.canny!/5","type":"function"},{"doc":"Finds edges in an image using the Canny algorithm @cite Canny86 . Positional Arguments image : Evision.Mat . 8-bit input image. threshold1 : double . first threshold for the hysteresis procedure. threshold2 : double . second threshold for the hysteresis procedure. Keyword Arguments apertureSize : int . aperture size for the Sobel operator. l2gradient : bool . a flag, indicating whether a more accurate \\f$L_2\\f$ norm \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough ( L2gradient=false ). Return edges : Evision.Mat . output edge map; single channels 8-bit image, which has the same size as image . The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See http://en.wikipedia.org/wiki/Canny_edge_detector Python prototype (for reference): Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]]) -&gt; edges","ref":"Evision.html#canny/3","title":"Evision.canny/3","type":"function"},{"doc":"Variant 1: Positional Arguments dx : Evision.Mat . 16-bit x derivative of input image (CV_16SC1 or CV_16SC3). dy : Evision.Mat . 16-bit y derivative of input image (same type as dx). threshold1 : double . first threshold for the hysteresis procedure. threshold2 : double . second threshold for the hysteresis procedure. Keyword Arguments l2gradient : bool . a flag, indicating whether a more accurate \\f$L_2\\f$ norm \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough ( L2gradient=false ). Return edges : Evision.Mat . output edge map; single channels 8-bit image, which has the same size as image . Finds edges in an image using the Canny algorithm with custom image gradient. Python prototype (for reference): Canny(dx, dy, threshold1, threshold2[, edges[, L2gradient]]) -&gt; edges Variant 2: Finds edges in an image using the Canny algorithm @cite Canny86 . Positional Arguments image : Evision.Mat . 8-bit input image. threshold1 : double . first threshold for the hysteresis procedure. threshold2 : double . second threshold for the hysteresis procedure. Keyword Arguments apertureSize : int . aperture size for the Sobel operator. l2gradient : bool . a flag, indicating whether a more accurate \\f$L_2\\f$ norm \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough ( L2gradient=false ). Return edges : Evision.Mat . output edge map; single channels 8-bit image, which has the same size as image . The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See http://en.wikipedia.org/wiki/Canny_edge_detector Python prototype (for reference): Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]]) -&gt; edges","ref":"Evision.html#canny/4","title":"Evision.canny/4","type":"function"},{"doc":"Positional Arguments dx : Evision.Mat . 16-bit x derivative of input image (CV_16SC1 or CV_16SC3). dy : Evision.Mat . 16-bit y derivative of input image (same type as dx). threshold1 : double . first threshold for the hysteresis procedure. threshold2 : double . second threshold for the hysteresis procedure. Keyword Arguments l2gradient : bool . a flag, indicating whether a more accurate \\f$L_2\\f$ norm \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough ( L2gradient=false ). Return edges : Evision.Mat . output edge map; single channels 8-bit image, which has the same size as image . Finds edges in an image using the Canny algorithm with custom image gradient. Python prototype (for reference): Canny(dx, dy, threshold1, threshold2[, edges[, L2gradient]]) -&gt; edges","ref":"Evision.html#canny/5","title":"Evision.canny/5","type":"function"},{"doc":"Raising version of cartToPolar/2 .","ref":"Evision.html#cartToPolar!/2","title":"Evision.cartToPolar!/2","type":"function"},{"doc":"Raising version of cartToPolar/3 .","ref":"Evision.html#cartToPolar!/3","title":"Evision.cartToPolar!/3","type":"function"},{"doc":"Calculates the magnitude and angle of 2D vectors. Positional Arguments x : Evision.Mat . array of x-coordinates; this must be a single-precision or double-precision floating-point array. y : Evision.Mat . array of y-coordinates, that must have the same size and same type as x. Keyword Arguments angleInDegrees : bool . a flag, indicating whether the angles are measured in radians (which is by default), or in degrees. Return magnitude : Evision.Mat . output array of magnitudes of the same size and type as x. angle : Evision.Mat . output array of angles that has the same size and type as x; the angles are measured in radians (from 0 to 2*Pi) or in degrees (0 to 360 degrees). The function cv::cartToPolar calculates either the magnitude, angle, or both for every 2D vector (x(I),y(I)): \\f[\\begin{array}{l} \\texttt{magnitude} (I)= \\sqrt{\\texttt{x}(I)^2+\\texttt{y}(I)^2} , \\\\ \\texttt{angle} (I)= \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))[ \\cdot180 / \\pi ] \\end{array}\\f] The angles are calculated with accuracy about 0.3 degrees. For the point (0,0), the angle is set to 0. @sa Sobel, Scharr Python prototype (for reference): cartToPolar(x, y[, magnitude[, angle[, angleInDegrees]]]) -&gt; magnitude, angle","ref":"Evision.html#cartToPolar/2","title":"Evision.cartToPolar/2","type":"function"},{"doc":"Calculates the magnitude and angle of 2D vectors. Positional Arguments x : Evision.Mat . array of x-coordinates; this must be a single-precision or double-precision floating-point array. y : Evision.Mat . array of y-coordinates, that must have the same size and same type as x. Keyword Arguments angleInDegrees : bool . a flag, indicating whether the angles are measured in radians (which is by default), or in degrees. Return magnitude : Evision.Mat . output array of magnitudes of the same size and type as x. angle : Evision.Mat . output array of angles that has the same size and type as x; the angles are measured in radians (from 0 to 2*Pi) or in degrees (0 to 360 degrees). The function cv::cartToPolar calculates either the magnitude, angle, or both for every 2D vector (x(I),y(I)): \\f[\\begin{array}{l} \\texttt{magnitude} (I)= \\sqrt{\\texttt{x}(I)^2+\\texttt{y}(I)^2} , \\\\ \\texttt{angle} (I)= \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))[ \\cdot180 / \\pi ] \\end{array}\\f] The angles are calculated with accuracy about 0.3 degrees. For the point (0,0), the angle is set to 0. @sa Sobel, Scharr Python prototype (for reference): cartToPolar(x, y[, magnitude[, angle[, angleInDegrees]]]) -&gt; magnitude, angle","ref":"Evision.html#cartToPolar/3","title":"Evision.cartToPolar/3","type":"function"},{"doc":"Raising version of checkChessboard/2 .","ref":"Evision.html#checkChessboard!/2","title":"Evision.checkChessboard!/2","type":"function"},{"doc":"Positional Arguments img : Evision.Mat size : Size Python prototype (for reference): checkChessboard(img, size) -&gt; retval","ref":"Evision.html#checkChessboard/2","title":"Evision.checkChessboard/2","type":"function"},{"doc":"Raising version of checkHardwareSupport/1 .","ref":"Evision.html#checkHardwareSupport!/1","title":"Evision.checkHardwareSupport!/1","type":"function"},{"doc":"Returns true if the specified feature is supported by the host hardware. Positional Arguments feature : int . The feature of interest, one of cv::CpuFeatures The function returns true if the host hardware supports the specified feature. When user calls setUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until setUseOptimized(true) is called. This way user can dynamically switch on and off the optimized code in OpenCV. Python prototype (for reference): checkHardwareSupport(feature) -&gt; retval","ref":"Evision.html#checkHardwareSupport/1","title":"Evision.checkHardwareSupport/1","type":"function"},{"doc":"Raising version of checkRange/1 .","ref":"Evision.html#checkRange!/1","title":"Evision.checkRange!/1","type":"function"},{"doc":"Raising version of checkRange/2 .","ref":"Evision.html#checkRange!/2","title":"Evision.checkRange!/2","type":"function"},{"doc":"Checks every element of an input array for invalid values. Positional Arguments a : Evision.Mat . input array. Keyword Arguments quiet : bool . a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception. minVal : double . inclusive lower boundary of valid values range. maxVal : double . exclusive upper boundary of valid values range. Return pos : Point* . optional output parameter, when not NULL, must be a pointer to array of src.dims elements. The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt; DBL_MAX and maxVal \\&lt; DBL_MAX, the function also checks that each value is between minVal and maxVal. In case of multi-channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the function either returns false (when quiet=true) or throws an exception. Python prototype (for reference): checkRange(a[, quiet[, minVal[, maxVal]]]) -&gt; retval, pos","ref":"Evision.html#checkRange/1","title":"Evision.checkRange/1","type":"function"},{"doc":"Checks every element of an input array for invalid values. Positional Arguments a : Evision.Mat . input array. Keyword Arguments quiet : bool . a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception. minVal : double . inclusive lower boundary of valid values range. maxVal : double . exclusive upper boundary of valid values range. Return pos : Point* . optional output parameter, when not NULL, must be a pointer to array of src.dims elements. The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt; DBL_MAX and maxVal \\&lt; DBL_MAX, the function also checks that each value is between minVal and maxVal. In case of multi-channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the function either returns false (when quiet=true) or throws an exception. Python prototype (for reference): checkRange(a[, quiet[, minVal[, maxVal]]]) -&gt; retval, pos","ref":"Evision.html#checkRange/2","title":"Evision.checkRange/2","type":"function"},{"doc":"Raising version of circle/4 .","ref":"Evision.html#circle!/4","title":"Evision.circle!/4","type":"function"},{"doc":"Raising version of circle/5 .","ref":"Evision.html#circle!/5","title":"Evision.circle!/5","type":"function"},{"doc":"Draws a circle. Positional Arguments center : Point . Center of the circle. radius : int . Radius of the circle. color : Scalar . Circle color. Keyword Arguments thickness : int . Thickness of the circle outline, if positive. Negative values, like #FILLED, mean that a filled circle is to be drawn. lineType : int . Type of the circle boundary. See #LineTypes shift : int . Number of fractional bits in the coordinates of the center and in the radius value. Return img : Evision.Mat . Image where the circle is drawn. The function cv::circle draws a simple or filled circle with a given center and radius. Python prototype (for reference): circle(img, center, radius, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#circle/4","title":"Evision.circle/4","type":"function"},{"doc":"Draws a circle. Positional Arguments center : Point . Center of the circle. radius : int . Radius of the circle. color : Scalar . Circle color. Keyword Arguments thickness : int . Thickness of the circle outline, if positive. Negative values, like #FILLED, mean that a filled circle is to be drawn. lineType : int . Type of the circle boundary. See #LineTypes shift : int . Number of fractional bits in the coordinates of the center and in the radius value. Return img : Evision.Mat . Image where the circle is drawn. The function cv::circle draws a simple or filled circle with a given center and radius. Python prototype (for reference): circle(img, center, radius, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#circle/5","title":"Evision.circle/5","type":"function"},{"doc":"Raising version of clipLine/3 .","ref":"Evision.html#clipLine!/3","title":"Evision.clipLine!/3","type":"function"},{"doc":"Positional Arguments imgRect : Rect . Image rectangle. Return pt1 : Point . First line point. pt2 : Point . Second line point. Has overloading in C++ Python prototype (for reference): clipLine(imgRect, pt1, pt2) -&gt; retval, pt1, pt2","ref":"Evision.html#clipLine/3","title":"Evision.clipLine/3","type":"function"},{"doc":"Raising version of colorChange/2 .","ref":"Evision.html#colorChange!/2","title":"Evision.colorChange!/2","type":"function"},{"doc":"Raising version of colorChange/3 .","ref":"Evision.html#colorChange!/3","title":"Evision.colorChange!/3","type":"function"},{"doc":"Given an original color image, two differently colored versions of this image can be mixed seamlessly. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. Keyword Arguments red_mul : float . R-channel multiply factor. green_mul : float . G-channel multiply factor. blue_mul : float . B-channel multiply factor. Return dst : Evision.Mat . Output image with the same size and type as src . Multiplication factor is between .5 to 2.5. Python prototype (for reference): colorChange(src, mask[, dst[, red_mul[, green_mul[, blue_mul]]]]) -&gt; dst","ref":"Evision.html#colorChange/2","title":"Evision.colorChange/2","type":"function"},{"doc":"Given an original color image, two differently colored versions of this image can be mixed seamlessly. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. Keyword Arguments red_mul : float . R-channel multiply factor. green_mul : float . G-channel multiply factor. blue_mul : float . B-channel multiply factor. Return dst : Evision.Mat . Output image with the same size and type as src . Multiplication factor is between .5 to 2.5. Python prototype (for reference): colorChange(src, mask[, dst[, red_mul[, green_mul[, blue_mul]]]]) -&gt; dst","ref":"Evision.html#colorChange/3","title":"Evision.colorChange/3","type":"function"},{"doc":"Raising version of compare/3 .","ref":"Evision.html#compare!/3","title":"Evision.compare!/3","type":"function"},{"doc":"Raising version of compare/4 .","ref":"Evision.html#compare!/4","title":"Evision.compare!/4","type":"function"},{"doc":"Performs the per-element comparison of two arrays or an array and scalar value. Positional Arguments src1 : Evision.Mat . first input array or a scalar; when it is an array, it must have a single channel. src2 : Evision.Mat . second input array or a scalar; when it is an array, it must have a single channel. cmpop : int . a flag, that specifies correspondence between the arrays (cv::CmpTypes) Return dst : Evision.Mat . output array of type ref CV_8U that has the same size and the same number of channels as the input arrays. The function compares: Elements of two arrays when src1 and src2 have the same size: \\f[\\texttt{dst} (I) = \\texttt{src1} (I) \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f] Elements of src1 with a scalar src2 when src2 is constructed from Scalar or has a single element: \\f[\\texttt{dst} (I) = \\texttt{src1}(I) \\,\\texttt{cmpop}\\, \\texttt{src2}\\f] src1 with elements of src2 when src1 is constructed from Scalar or has a single element: \\f[\\texttt{dst} (I) = \\texttt{src1} \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f] When the comparison result is true, the corresponding element of output array is set to 255. The comparison operations can be replaced with the equivalent matrix expressions: Mat dst1 = src1 &gt;= src2; Mat dst2 = src1 &lt; 8; ... @sa checkRange, min, max, threshold Python prototype (for reference): compare(src1, src2, cmpop[, dst]) -&gt; dst","ref":"Evision.html#compare/3","title":"Evision.compare/3","type":"function"},{"doc":"Performs the per-element comparison of two arrays or an array and scalar value. Positional Arguments src1 : Evision.Mat . first input array or a scalar; when it is an array, it must have a single channel. src2 : Evision.Mat . second input array or a scalar; when it is an array, it must have a single channel. cmpop : int . a flag, that specifies correspondence between the arrays (cv::CmpTypes) Return dst : Evision.Mat . output array of type ref CV_8U that has the same size and the same number of channels as the input arrays. The function compares: Elements of two arrays when src1 and src2 have the same size: \\f[\\texttt{dst} (I) = \\texttt{src1} (I) \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f] Elements of src1 with a scalar src2 when src2 is constructed from Scalar or has a single element: \\f[\\texttt{dst} (I) = \\texttt{src1}(I) \\,\\texttt{cmpop}\\, \\texttt{src2}\\f] src1 with elements of src2 when src1 is constructed from Scalar or has a single element: \\f[\\texttt{dst} (I) = \\texttt{src1} \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f] When the comparison result is true, the corresponding element of output array is set to 255. The comparison operations can be replaced with the equivalent matrix expressions: Mat dst1 = src1 &gt;= src2; Mat dst2 = src1 &lt; 8; ... @sa checkRange, min, max, threshold Python prototype (for reference): compare(src1, src2, cmpop[, dst]) -&gt; dst","ref":"Evision.html#compare/4","title":"Evision.compare/4","type":"function"},{"doc":"Raising version of compareHist/3 .","ref":"Evision.html#compareHist!/3","title":"Evision.compareHist!/3","type":"function"},{"doc":"Compares two histograms. Positional Arguments h1 : Evision.Mat . First compared histogram. h2 : Evision.Mat . Second compared histogram of the same size as H1 . method : int . Comparison method, see #HistCompMethods The function cv::compareHist compares two dense or two sparse histograms using the specified method. The function returns \\f$d(H_1, H_2)\\f$ . While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms or more general sparse configurations of weighted points, consider using the #EMD function. Python prototype (for reference): compareHist(H1, H2, method) -&gt; retval","ref":"Evision.html#compareHist/3","title":"Evision.compareHist/3","type":"function"},{"doc":"Raising version of completeSymm/1 .","ref":"Evision.html#completeSymm!/1","title":"Evision.completeSymm!/1","type":"function"},{"doc":"Raising version of completeSymm/2 .","ref":"Evision.html#completeSymm!/2","title":"Evision.completeSymm!/2","type":"function"},{"doc":"Copies the lower or the upper half of a square matrix to its another half. Keyword Arguments lowerToUpper : bool . operation flag; if true, the lower half is copied to the upper half. Otherwise, the upper half is copied to the lower half. Return m : Evision.Mat . input-output floating-point square matrix. The function cv::completeSymm copies the lower or the upper half of a square matrix to its another half. The matrix diagonal remains unchanged: \\f$\\texttt{m}_{ij}=\\texttt{m}_{ji}\\f$ for \\f$i &gt; j\\f$ if lowerToUpper=false \\f$\\texttt{m}_{ij}=\\texttt{m}_{ji}\\f$ for \\f$i &lt; j\\f$ if lowerToUpper=true @sa flip, transpose Python prototype (for reference): completeSymm(m[, lowerToUpper]) -&gt; m","ref":"Evision.html#completeSymm/1","title":"Evision.completeSymm/1","type":"function"},{"doc":"Copies the lower or the upper half of a square matrix to its another half. Keyword Arguments lowerToUpper : bool . operation flag; if true, the lower half is copied to the upper half. Otherwise, the upper half is copied to the lower half. Return m : Evision.Mat . input-output floating-point square matrix. The function cv::completeSymm copies the lower or the upper half of a square matrix to its another half. The matrix diagonal remains unchanged: \\f$\\texttt{m}_{ij}=\\texttt{m}_{ji}\\f$ for \\f$i &gt; j\\f$ if lowerToUpper=false \\f$\\texttt{m}_{ij}=\\texttt{m}_{ji}\\f$ for \\f$i &lt; j\\f$ if lowerToUpper=true @sa flip, transpose Python prototype (for reference): completeSymm(m[, lowerToUpper]) -&gt; m","ref":"Evision.html#completeSymm/2","title":"Evision.completeSymm/2","type":"function"},{"doc":"Raising version of composeRT/4 .","ref":"Evision.html#composeRT!/4","title":"Evision.composeRT!/4","type":"function"},{"doc":"Raising version of composeRT/5 .","ref":"Evision.html#composeRT!/5","title":"Evision.composeRT!/5","type":"function"},{"doc":"Combines two rotation-and-shift transformations. Positional Arguments rvec1 : Evision.Mat . First rotation vector. tvec1 : Evision.Mat . First translation vector. rvec2 : Evision.Mat . Second rotation vector. tvec2 : Evision.Mat . Second translation vector. Return rvec3 : Evision.Mat . Output rotation vector of the superposition. tvec3 : Evision.Mat . Output translation vector of the superposition. dr3dr1 : Evision.Mat . Optional output derivative of rvec3 with regard to rvec1 dr3dt1 : Evision.Mat . Optional output derivative of rvec3 with regard to tvec1 dr3dr2 : Evision.Mat . Optional output derivative of rvec3 with regard to rvec2 dr3dt2 : Evision.Mat . Optional output derivative of rvec3 with regard to tvec2 dt3dr1 : Evision.Mat . Optional output derivative of tvec3 with regard to rvec1 dt3dt1 : Evision.Mat . Optional output derivative of tvec3 with regard to tvec1 dt3dr2 : Evision.Mat . Optional output derivative of tvec3 with regard to rvec2 dt3dt2 : Evision.Mat . Optional output derivative of tvec3 with regard to tvec2 The functions compute: \\f[\\begin{array}{l} \\texttt{rvec3} = \\mathrm{rodrigues} ^{-1} \\left ( \\mathrm{rodrigues} ( \\texttt{rvec2} ) \\cdot \\mathrm{rodrigues} ( \\texttt{rvec1} ) \\right ) \\\\ \\texttt{tvec3} = \\mathrm{rodrigues} ( \\texttt{rvec2} ) \\cdot \\texttt{tvec1} + \\texttt{tvec2} \\end{array} ,\\f] where \\f$\\mathrm{rodrigues}\\f$ denotes a rotation vector to a rotation matrix transformation, and \\f$\\mathrm{rodrigues}^{-1}\\f$ denotes the inverse transformation. See Rodrigues for details. Also, the functions can compute the derivatives of the output vectors with regards to the input vectors (see matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a function that contains a matrix multiplication. Python prototype (for reference): composeRT(rvec1, tvec1, rvec2, tvec2[, rvec3[, tvec3[, dr3dr1[, dr3dt1[, dr3dr2[, dr3dt2[, dt3dr1[, dt3dt1[, dt3dr2[, dt3dt2]]]]]]]]]]) -&gt; rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2","ref":"Evision.html#composeRT/4","title":"Evision.composeRT/4","type":"function"},{"doc":"Combines two rotation-and-shift transformations. Positional Arguments rvec1 : Evision.Mat . First rotation vector. tvec1 : Evision.Mat . First translation vector. rvec2 : Evision.Mat . Second rotation vector. tvec2 : Evision.Mat . Second translation vector. Return rvec3 : Evision.Mat . Output rotation vector of the superposition. tvec3 : Evision.Mat . Output translation vector of the superposition. dr3dr1 : Evision.Mat . Optional output derivative of rvec3 with regard to rvec1 dr3dt1 : Evision.Mat . Optional output derivative of rvec3 with regard to tvec1 dr3dr2 : Evision.Mat . Optional output derivative of rvec3 with regard to rvec2 dr3dt2 : Evision.Mat . Optional output derivative of rvec3 with regard to tvec2 dt3dr1 : Evision.Mat . Optional output derivative of tvec3 with regard to rvec1 dt3dt1 : Evision.Mat . Optional output derivative of tvec3 with regard to tvec1 dt3dr2 : Evision.Mat . Optional output derivative of tvec3 with regard to rvec2 dt3dt2 : Evision.Mat . Optional output derivative of tvec3 with regard to tvec2 The functions compute: \\f[\\begin{array}{l} \\texttt{rvec3} = \\mathrm{rodrigues} ^{-1} \\left ( \\mathrm{rodrigues} ( \\texttt{rvec2} ) \\cdot \\mathrm{rodrigues} ( \\texttt{rvec1} ) \\right ) \\\\ \\texttt{tvec3} = \\mathrm{rodrigues} ( \\texttt{rvec2} ) \\cdot \\texttt{tvec1} + \\texttt{tvec2} \\end{array} ,\\f] where \\f$\\mathrm{rodrigues}\\f$ denotes a rotation vector to a rotation matrix transformation, and \\f$\\mathrm{rodrigues}^{-1}\\f$ denotes the inverse transformation. See Rodrigues for details. Also, the functions can compute the derivatives of the output vectors with regards to the input vectors (see matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a function that contains a matrix multiplication. Python prototype (for reference): composeRT(rvec1, tvec1, rvec2, tvec2[, rvec3[, tvec3[, dr3dr1[, dr3dt1[, dr3dr2[, dr3dt2[, dt3dr1[, dt3dt1[, dt3dr2[, dt3dt2]]]]]]]]]]) -&gt; rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2","ref":"Evision.html#composeRT/5","title":"Evision.composeRT/5","type":"function"},{"doc":"Raising version of computeCorrespondEpilines/3 .","ref":"Evision.html#computeCorrespondEpilines!/3","title":"Evision.computeCorrespondEpilines!/3","type":"function"},{"doc":"Raising version of computeCorrespondEpilines/4 .","ref":"Evision.html#computeCorrespondEpilines!/4","title":"Evision.computeCorrespondEpilines!/4","type":"function"},{"doc":"For points in an image of a stereo pair, computes the corresponding epilines in the other image. Positional Arguments points : Evision.Mat . Input points. \\f$N \\times 1\\f$ or \\f$1 \\times N\\f$ matrix of type CV_32FC2 or vector\\&lt;Point2f&gt; . whichImage : int . Index of the image (1 or 2) that contains the points . f : Evision.Mat . Fundamental matrix that can be estimated using #findFundamentalMat or #stereoRectify . Return lines : Evision.Mat . Output vector of the epipolar lines corresponding to the points in the other image. Each line \\f$ax + by + c=0\\f$ is encoded by 3 numbers \\f$(a, b, c)\\f$ . For every point in one of the two images of a stereo pair, the function finds the equation of the corresponding epipolar line in the other image. From the fundamental matrix definition (see #findFundamentalMat ), line \\f$l^{(2)}_i\\f$ in the second image for the point \\f$p^{(1)}_i\\f$ in the first image (when whichImage=1 ) is computed as: \\f[l^{(2)}_i = F p^{(1)}_i\\f] And vice versa, when whichImage=2, \\f$l^{(1)}_i\\f$ is computed from \\f$p^{(2)}_i\\f$ as: \\f[l^{(1)}_i = F^T p^{(2)}_i\\f] Line coefficients are defined up to a scale. They are normalized so that \\f$a_i^2+b_i^2=1\\f$ . Python prototype (for reference): computeCorrespondEpilines(points, whichImage, F[, lines]) -&gt; lines","ref":"Evision.html#computeCorrespondEpilines/3","title":"Evision.computeCorrespondEpilines/3","type":"function"},{"doc":"For points in an image of a stereo pair, computes the corresponding epilines in the other image. Positional Arguments points : Evision.Mat . Input points. \\f$N \\times 1\\f$ or \\f$1 \\times N\\f$ matrix of type CV_32FC2 or vector\\&lt;Point2f&gt; . whichImage : int . Index of the image (1 or 2) that contains the points . f : Evision.Mat . Fundamental matrix that can be estimated using #findFundamentalMat or #stereoRectify . Return lines : Evision.Mat . Output vector of the epipolar lines corresponding to the points in the other image. Each line \\f$ax + by + c=0\\f$ is encoded by 3 numbers \\f$(a, b, c)\\f$ . For every point in one of the two images of a stereo pair, the function finds the equation of the corresponding epipolar line in the other image. From the fundamental matrix definition (see #findFundamentalMat ), line \\f$l^{(2)}_i\\f$ in the second image for the point \\f$p^{(1)}_i\\f$ in the first image (when whichImage=1 ) is computed as: \\f[l^{(2)}_i = F p^{(1)}_i\\f] And vice versa, when whichImage=2, \\f$l^{(1)}_i\\f$ is computed from \\f$p^{(2)}_i\\f$ as: \\f[l^{(1)}_i = F^T p^{(2)}_i\\f] Line coefficients are defined up to a scale. They are normalized so that \\f$a_i^2+b_i^2=1\\f$ . Python prototype (for reference): computeCorrespondEpilines(points, whichImage, F[, lines]) -&gt; lines","ref":"Evision.html#computeCorrespondEpilines/4","title":"Evision.computeCorrespondEpilines/4","type":"function"},{"doc":"Raising version of computeECC/2 .","ref":"Evision.html#computeECC!/2","title":"Evision.computeECC!/2","type":"function"},{"doc":"Raising version of computeECC/3 .","ref":"Evision.html#computeECC!/3","title":"Evision.computeECC!/3","type":"function"},{"doc":"Computes the Enhanced Correlation Coefficient value between two images @cite EP08 . Positional Arguments templateImage : Evision.Mat . single-channel template image; CV_8U or CV_32F array. inputImage : Evision.Mat . single-channel input image to be warped to provide an image similar to templateImage, same type as templateImage. Keyword Arguments inputMask : Evision.Mat . An optional mask to indicate valid values of inputImage. @sa findTransformECC Python prototype (for reference): computeECC(templateImage, inputImage[, inputMask]) -&gt; retval","ref":"Evision.html#computeECC/2","title":"Evision.computeECC/2","type":"function"},{"doc":"Computes the Enhanced Correlation Coefficient value between two images @cite EP08 . Positional Arguments templateImage : Evision.Mat . single-channel template image; CV_8U or CV_32F array. inputImage : Evision.Mat . single-channel input image to be warped to provide an image similar to templateImage, same type as templateImage. Keyword Arguments inputMask : Evision.Mat . An optional mask to indicate valid values of inputImage. @sa findTransformECC Python prototype (for reference): computeECC(templateImage, inputImage[, inputMask]) -&gt; retval","ref":"Evision.html#computeECC/3","title":"Evision.computeECC/3","type":"function"},{"doc":"Raising version of connectedComponents/1 .","ref":"Evision.html#connectedComponents!/1","title":"Evision.connectedComponents!/1","type":"function"},{"doc":"Raising version of connectedComponents/2 .","ref":"Evision.html#connectedComponents!/2","title":"Evision.connectedComponents!/2","type":"function"},{"doc":"Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled Keyword Arguments connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. Return labels : Evision.Mat . destination labeled image Has overloading in C++ Python prototype (for reference): connectedComponents(image[, labels[, connectivity[, ltype]]]) -&gt; retval, labels","ref":"Evision.html#connectedComponents/1","title":"Evision.connectedComponents/1","type":"function"},{"doc":"Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled Keyword Arguments connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. Return labels : Evision.Mat . destination labeled image Has overloading in C++ Python prototype (for reference): connectedComponents(image[, labels[, connectivity[, ltype]]]) -&gt; retval, labels","ref":"Evision.html#connectedComponents/2","title":"Evision.connectedComponents/2","type":"function"},{"doc":"Raising version of connectedComponentsWithAlgorithm/4 .","ref":"Evision.html#connectedComponentsWithAlgorithm!/4","title":"Evision.connectedComponentsWithAlgorithm!/4","type":"function"},{"doc":"Raising version of connectedComponentsWithAlgorithm/5 .","ref":"Evision.html#connectedComponentsWithAlgorithm!/5","title":"Evision.connectedComponentsWithAlgorithm!/5","type":"function"},{"doc":"computes the connected components labeled image of boolean image Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. ccltype : int . connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes). Return labels : Evision.Mat . destination labeled image image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while Spaghetti and BBDT do not. This function uses parallel version of the algorithms if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs. Python prototype (for reference): connectedComponentsWithAlgorithm(image, connectivity, ltype, ccltype[, labels]) -&gt; retval, labels","ref":"Evision.html#connectedComponentsWithAlgorithm/4","title":"Evision.connectedComponentsWithAlgorithm/4","type":"function"},{"doc":"computes the connected components labeled image of boolean image Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. ccltype : int . connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes). Return labels : Evision.Mat . destination labeled image image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while Spaghetti and BBDT do not. This function uses parallel version of the algorithms if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs. Python prototype (for reference): connectedComponentsWithAlgorithm(image, connectivity, ltype, ccltype[, labels]) -&gt; retval, labels","ref":"Evision.html#connectedComponentsWithAlgorithm/5","title":"Evision.connectedComponentsWithAlgorithm/5","type":"function"},{"doc":"Raising version of connectedComponentsWithStats/1 .","ref":"Evision.html#connectedComponentsWithStats!/1","title":"Evision.connectedComponentsWithStats!/1","type":"function"},{"doc":"Raising version of connectedComponentsWithStats/2 .","ref":"Evision.html#connectedComponentsWithStats!/2","title":"Evision.connectedComponentsWithStats!/2","type":"function"},{"doc":"Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled Keyword Arguments connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. Return labels : Evision.Mat . destination labeled image stats : Evision.Mat . statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. centroids : Evision.Mat . centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. Has overloading in C++ Python prototype (for reference): connectedComponentsWithStats(image[, labels[, stats[, centroids[, connectivity[, ltype]]]]]) -&gt; retval, labels, stats, centroids","ref":"Evision.html#connectedComponentsWithStats/1","title":"Evision.connectedComponentsWithStats/1","type":"function"},{"doc":"Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled Keyword Arguments connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. Return labels : Evision.Mat . destination labeled image stats : Evision.Mat . statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. centroids : Evision.Mat . centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. Has overloading in C++ Python prototype (for reference): connectedComponentsWithStats(image[, labels[, stats[, centroids[, connectivity[, ltype]]]]]) -&gt; retval, labels, stats, centroids","ref":"Evision.html#connectedComponentsWithStats/2","title":"Evision.connectedComponentsWithStats/2","type":"function"},{"doc":"Raising version of connectedComponentsWithStatsWithAlgorithm/4 .","ref":"Evision.html#connectedComponentsWithStatsWithAlgorithm!/4","title":"Evision.connectedComponentsWithStatsWithAlgorithm!/4","type":"function"},{"doc":"Raising version of connectedComponentsWithStatsWithAlgorithm/5 .","ref":"Evision.html#connectedComponentsWithStatsWithAlgorithm!/5","title":"Evision.connectedComponentsWithStatsWithAlgorithm!/5","type":"function"},{"doc":"computes the connected components labeled image of boolean image and also produces a statistics output for each label Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. ccltype : int . connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes). Return labels : Evision.Mat . destination labeled image stats : Evision.Mat . statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. centroids : Evision.Mat . centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while Spaghetti and BBDT do not. This function uses parallel version of the algorithms (statistics included) if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs. Python prototype (for reference): connectedComponentsWithStatsWithAlgorithm(image, connectivity, ltype, ccltype[, labels[, stats[, centroids]]]) -&gt; retval, labels, stats, centroids","ref":"Evision.html#connectedComponentsWithStatsWithAlgorithm/4","title":"Evision.connectedComponentsWithStatsWithAlgorithm/4","type":"function"},{"doc":"computes the connected components labeled image of boolean image and also produces a statistics output for each label Positional Arguments image : Evision.Mat . the 8-bit single-channel image to be labeled connectivity : int . 8 or 4 for 8-way or 4-way connectivity respectively ltype : int . output image label type. Currently CV_32S and CV_16U are supported. ccltype : int . connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes). Return labels : Evision.Mat . destination labeled image stats : Evision.Mat . statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. centroids : Evision.Mat . centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while Spaghetti and BBDT do not. This function uses parallel version of the algorithms (statistics included) if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs. Python prototype (for reference): connectedComponentsWithStatsWithAlgorithm(image, connectivity, ltype, ccltype[, labels[, stats[, centroids]]]) -&gt; retval, labels, stats, centroids","ref":"Evision.html#connectedComponentsWithStatsWithAlgorithm/5","title":"Evision.connectedComponentsWithStatsWithAlgorithm/5","type":"function"},{"doc":"Raising version of contourArea/1 .","ref":"Evision.html#contourArea!/1","title":"Evision.contourArea!/1","type":"function"},{"doc":"Raising version of contourArea/2 .","ref":"Evision.html#contourArea!/2","title":"Evision.contourArea!/2","type":"function"},{"doc":"Calculates a contour area. Positional Arguments contour : Evision.Mat . Input vector of 2D points (contour vertices), stored in std::vector or Mat. Keyword Arguments oriented : bool . Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is false, which means that the absolute value is returned. The function computes a contour area. Similarly to moments , the area is computed using the Green formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong results for contours with self-intersections. Example: vector &lt; Point &gt; contour ; contour . push_back ( Point2f ( 0 , 0 ) ) ; contour . push_back ( Point2f ( 10 , 0 ) ) ; contour . push_back ( Point2f ( 10 , 10 ) ) ; contour . push_back ( Point2f ( 5 , 4 ) ) ; double area0 = contourArea ( contour ) ; vector &lt; Point &gt; approx ; approxPolyDP ( contour , approx , 5 , true ) ; double area1 = contourArea ( approx ) ; cout &lt;&lt; &quot;area0 =&quot; &lt;&lt; area0 &lt;&lt; endl &lt;&lt; &quot;area1 =&quot; &lt;&lt; area1 &lt;&lt; endl &lt;&lt; &quot;approx poly vertices&quot; &lt;&lt; approx . size ( ) &lt;&lt; endl ; Python prototype (for reference): contourArea(contour[, oriented]) -&gt; retval","ref":"Evision.html#contourArea/1","title":"Evision.contourArea/1","type":"function"},{"doc":"Calculates a contour area. Positional Arguments contour : Evision.Mat . Input vector of 2D points (contour vertices), stored in std::vector or Mat. Keyword Arguments oriented : bool . Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is false, which means that the absolute value is returned. The function computes a contour area. Similarly to moments , the area is computed using the Green formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong results for contours with self-intersections. Example: vector &lt; Point &gt; contour ; contour . push_back ( Point2f ( 0 , 0 ) ) ; contour . push_back ( Point2f ( 10 , 0 ) ) ; contour . push_back ( Point2f ( 10 , 10 ) ) ; contour . push_back ( Point2f ( 5 , 4 ) ) ; double area0 = contourArea ( contour ) ; vector &lt; Point &gt; approx ; approxPolyDP ( contour , approx , 5 , true ) ; double area1 = contourArea ( approx ) ; cout &lt;&lt; &quot;area0 =&quot; &lt;&lt; area0 &lt;&lt; endl &lt;&lt; &quot;area1 =&quot; &lt;&lt; area1 &lt;&lt; endl &lt;&lt; &quot;approx poly vertices&quot; &lt;&lt; approx . size ( ) &lt;&lt; endl ; Python prototype (for reference): contourArea(contour[, oriented]) -&gt; retval","ref":"Evision.html#contourArea/2","title":"Evision.contourArea/2","type":"function"},{"doc":"Raising version of convertFp16/1 .","ref":"Evision.html#convertFp16!/1","title":"Evision.convertFp16!/1","type":"function"},{"doc":"Raising version of convertFp16/2 .","ref":"Evision.html#convertFp16!/2","title":"Evision.convertFp16!/2","type":"function"},{"doc":"Converts an array to half precision floating number. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array. This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data. There are two use modes (src -&gt; dst): CV_32F -&gt; CV_16S and CV_16S -&gt; CV_32F. The input array has to have type of CV_32F or CV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error. The format of half precision floating point is defined in IEEE 754-2008. Python prototype (for reference): convertFp16(src[, dst]) -&gt; dst","ref":"Evision.html#convertFp16/1","title":"Evision.convertFp16/1","type":"function"},{"doc":"Converts an array to half precision floating number. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array. This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data. There are two use modes (src -&gt; dst): CV_32F -&gt; CV_16S and CV_16S -&gt; CV_32F. The input array has to have type of CV_32F or CV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error. The format of half precision floating point is defined in IEEE 754-2008. Python prototype (for reference): convertFp16(src[, dst]) -&gt; dst","ref":"Evision.html#convertFp16/2","title":"Evision.convertFp16/2","type":"function"},{"doc":"Raising version of convertMaps/3 .","ref":"Evision.html#convertMaps!/3","title":"Evision.convertMaps!/3","type":"function"},{"doc":"Raising version of convertMaps/4 .","ref":"Evision.html#convertMaps!/4","title":"Evision.convertMaps!/4","type":"function"},{"doc":"Converts image transformation maps from one representation to another. Positional Arguments map1 : Evision.Mat . The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 . map2 : Evision.Mat . The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix), respectively. dstmap1type : int . Type of the first output map that should be CV_16SC2, CV_32FC1, or CV_32FC2 . Keyword Arguments nninterpolation : bool . Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation. Return dstmap1 : Evision.Mat . The first output map that has the type dstmap1type and the same size as src . dstmap2 : Evision.Mat . The second output map. The function converts a pair of maps for remap from one representation to another. The following options ( (map1.type(), map2.type()) \\f$\\rightarrow\\f$ (dstmap1.type(), dstmap2.type()) ) are supported: \\f$\\texttt{(CV_32FC1, CV_32FC1)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. This is the most frequently used conversion operation, in which the original floating-point maps (see #remap) are converted to a more compact and much faster fixed-point representation. The first output array contains the rounded coordinates and the second array (created only when nninterpolation=false ) contains indices in the interpolation tables. \\f$\\texttt{(CV_32FC2)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. The same as above but the original maps are stored in one 2-channel matrix. Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same as the originals. @sa remap, undistort, initUndistortRectifyMap Python prototype (for reference): convertMaps(map1, map2, dstmap1type[, dstmap1[, dstmap2[, nninterpolation]]]) -&gt; dstmap1, dstmap2","ref":"Evision.html#convertMaps/3","title":"Evision.convertMaps/3","type":"function"},{"doc":"Converts image transformation maps from one representation to another. Positional Arguments map1 : Evision.Mat . The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 . map2 : Evision.Mat . The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix), respectively. dstmap1type : int . Type of the first output map that should be CV_16SC2, CV_32FC1, or CV_32FC2 . Keyword Arguments nninterpolation : bool . Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation. Return dstmap1 : Evision.Mat . The first output map that has the type dstmap1type and the same size as src . dstmap2 : Evision.Mat . The second output map. The function converts a pair of maps for remap from one representation to another. The following options ( (map1.type(), map2.type()) \\f$\\rightarrow\\f$ (dstmap1.type(), dstmap2.type()) ) are supported: \\f$\\texttt{(CV_32FC1, CV_32FC1)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. This is the most frequently used conversion operation, in which the original floating-point maps (see #remap) are converted to a more compact and much faster fixed-point representation. The first output array contains the rounded coordinates and the second array (created only when nninterpolation=false ) contains indices in the interpolation tables. \\f$\\texttt{(CV_32FC2)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. The same as above but the original maps are stored in one 2-channel matrix. Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same as the originals. @sa remap, undistort, initUndistortRectifyMap Python prototype (for reference): convertMaps(map1, map2, dstmap1type[, dstmap1[, dstmap2[, nninterpolation]]]) -&gt; dstmap1, dstmap2","ref":"Evision.html#convertMaps/4","title":"Evision.convertMaps/4","type":"function"},{"doc":"Raising version of convertPointsFromHomogeneous/1 .","ref":"Evision.html#convertPointsFromHomogeneous!/1","title":"Evision.convertPointsFromHomogeneous!/1","type":"function"},{"doc":"Raising version of convertPointsFromHomogeneous/2 .","ref":"Evision.html#convertPointsFromHomogeneous!/2","title":"Evision.convertPointsFromHomogeneous!/2","type":"function"},{"doc":"Converts points from homogeneous to Euclidean space. Positional Arguments src : Evision.Mat . Input vector of N-dimensional points. Return dst : Evision.Mat . Output vector of N-1-dimensional points. The function converts points homogeneous to Euclidean space using perspective projection. That is, each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the output point coordinates will be (0,0,0,...). Python prototype (for reference): convertPointsFromHomogeneous(src[, dst]) -&gt; dst","ref":"Evision.html#convertPointsFromHomogeneous/1","title":"Evision.convertPointsFromHomogeneous/1","type":"function"},{"doc":"Converts points from homogeneous to Euclidean space. Positional Arguments src : Evision.Mat . Input vector of N-dimensional points. Return dst : Evision.Mat . Output vector of N-1-dimensional points. The function converts points homogeneous to Euclidean space using perspective projection. That is, each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the output point coordinates will be (0,0,0,...). Python prototype (for reference): convertPointsFromHomogeneous(src[, dst]) -&gt; dst","ref":"Evision.html#convertPointsFromHomogeneous/2","title":"Evision.convertPointsFromHomogeneous/2","type":"function"},{"doc":"Raising version of convertPointsToHomogeneous/1 .","ref":"Evision.html#convertPointsToHomogeneous!/1","title":"Evision.convertPointsToHomogeneous!/1","type":"function"},{"doc":"Raising version of convertPointsToHomogeneous/2 .","ref":"Evision.html#convertPointsToHomogeneous!/2","title":"Evision.convertPointsToHomogeneous!/2","type":"function"},{"doc":"Converts points from Euclidean to homogeneous space. Positional Arguments src : Evision.Mat . Input vector of N-dimensional points. Return dst : Evision.Mat . Output vector of N+1-dimensional points. The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1). Python prototype (for reference): convertPointsToHomogeneous(src[, dst]) -&gt; dst","ref":"Evision.html#convertPointsToHomogeneous/1","title":"Evision.convertPointsToHomogeneous/1","type":"function"},{"doc":"Converts points from Euclidean to homogeneous space. Positional Arguments src : Evision.Mat . Input vector of N-dimensional points. Return dst : Evision.Mat . Output vector of N+1-dimensional points. The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1). Python prototype (for reference): convertPointsToHomogeneous(src[, dst]) -&gt; dst","ref":"Evision.html#convertPointsToHomogeneous/2","title":"Evision.convertPointsToHomogeneous/2","type":"function"},{"doc":"Raising version of convertScaleAbs/1 .","ref":"Evision.html#convertScaleAbs!/1","title":"Evision.convertScaleAbs!/1","type":"function"},{"doc":"Raising version of convertScaleAbs/2 .","ref":"Evision.html#convertScaleAbs!/2","title":"Evision.convertScaleAbs!/2","type":"function"},{"doc":"Scales, calculates absolute values, and converts the result to 8-bit. Positional Arguments src : Evision.Mat . input array. Keyword Arguments alpha : double . optional scale factor. beta : double . optional delta added to the scaled values. Return dst : Evision.Mat . output array. On each element of the input array, the function convertScaleAbs performs three operations sequentially: scaling, taking an absolute value, conversion to an unsigned 8-bit type: \\f[\\texttt{dst} (I)= \\texttt{saturate\\_cast&lt;uchar&gt;} (| \\texttt{src} (I)* \\texttt{alpha} + \\texttt{beta} |)\\f] In case of multi-channel arrays, the function processes each channel independently. When the output is not 8-bit, the operation can be emulated by calling the Mat::convertTo method (or by using matrix expressions) and then by calculating an absolute value of the result. For example: Mat_&lt;float&gt; A(30,30); randu(A, Scalar(-100), Scalar(100)); Mat_&lt;float&gt; B = A*5 + 3; B = abs(B); // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job, // but it will allocate a temporary matrix @sa Mat::convertTo, cv::abs(const Mat&amp;) Python prototype (for reference): convertScaleAbs(src[, dst[, alpha[, beta]]]) -&gt; dst","ref":"Evision.html#convertScaleAbs/1","title":"Evision.convertScaleAbs/1","type":"function"},{"doc":"Scales, calculates absolute values, and converts the result to 8-bit. Positional Arguments src : Evision.Mat . input array. Keyword Arguments alpha : double . optional scale factor. beta : double . optional delta added to the scaled values. Return dst : Evision.Mat . output array. On each element of the input array, the function convertScaleAbs performs three operations sequentially: scaling, taking an absolute value, conversion to an unsigned 8-bit type: \\f[\\texttt{dst} (I)= \\texttt{saturate\\_cast&lt;uchar&gt;} (| \\texttt{src} (I)* \\texttt{alpha} + \\texttt{beta} |)\\f] In case of multi-channel arrays, the function processes each channel independently. When the output is not 8-bit, the operation can be emulated by calling the Mat::convertTo method (or by using matrix expressions) and then by calculating an absolute value of the result. For example: Mat_&lt;float&gt; A(30,30); randu(A, Scalar(-100), Scalar(100)); Mat_&lt;float&gt; B = A*5 + 3; B = abs(B); // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job, // but it will allocate a temporary matrix @sa Mat::convertTo, cv::abs(const Mat&amp;) Python prototype (for reference): convertScaleAbs(src[, dst[, alpha[, beta]]]) -&gt; dst","ref":"Evision.html#convertScaleAbs/2","title":"Evision.convertScaleAbs/2","type":"function"},{"doc":"Raising version of convexHull/1 .","ref":"Evision.html#convexHull!/1","title":"Evision.convexHull!/1","type":"function"},{"doc":"Raising version of convexHull/2 .","ref":"Evision.html#convexHull!/2","title":"Evision.convexHull!/2","type":"function"},{"doc":"Finds the convex hull of a point set. Positional Arguments points : Evision.Mat . Input 2D point set, stored in std::vector or Mat. Keyword Arguments clockwise : bool . Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards. returnPoints : bool . Operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector: std::vector\\&lt;int&gt; implies returnPoints=false, std::vector\\&lt;Point&gt; implies returnPoints=true. Return hull : Evision.Mat . Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves. The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82 that has O(N logN) complexity in the current implementation. Note : points and hull should be different arrays, inplace processing isn't supported. Check @ref tutorial_hull &quot;the corresponding tutorial&quot; for more details. useful links: https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/ Python prototype (for reference): convexHull(points[, hull[, clockwise[, returnPoints]]]) -&gt; hull","ref":"Evision.html#convexHull/1","title":"Evision.convexHull/1","type":"function"},{"doc":"Finds the convex hull of a point set. Positional Arguments points : Evision.Mat . Input 2D point set, stored in std::vector or Mat. Keyword Arguments clockwise : bool . Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards. returnPoints : bool . Operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector: std::vector\\&lt;int&gt; implies returnPoints=false, std::vector\\&lt;Point&gt; implies returnPoints=true. Return hull : Evision.Mat . Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves. The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82 that has O(N logN) complexity in the current implementation. Note : points and hull should be different arrays, inplace processing isn't supported. Check @ref tutorial_hull &quot;the corresponding tutorial&quot; for more details. useful links: https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/ Python prototype (for reference): convexHull(points[, hull[, clockwise[, returnPoints]]]) -&gt; hull","ref":"Evision.html#convexHull/2","title":"Evision.convexHull/2","type":"function"},{"doc":"Raising version of convexityDefects/2 .","ref":"Evision.html#convexityDefects!/2","title":"Evision.convexityDefects!/2","type":"function"},{"doc":"Raising version of convexityDefects/3 .","ref":"Evision.html#convexityDefects!/3","title":"Evision.convexityDefects!/3","type":"function"},{"doc":"Finds the convexity defects of a contour. Positional Arguments contour : Evision.Mat . Input contour. convexhull : Evision.Mat . Convex hull obtained using convexHull that should contain indices of the contour points that make the hull. Return convexityDefects : Evision.Mat . The output vector of convexity defects. In C++ and the new Python/Java interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices in the original contour of the convexity defect beginning, end and the farthest point, and fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-point value of the depth will be fixpt_depth/256.0. The figure below displays convexity defects of a hand contour: Python prototype (for reference): convexityDefects(contour, convexhull[, convexityDefects]) -&gt; convexityDefects","ref":"Evision.html#convexityDefects/2","title":"Evision.convexityDefects/2","type":"function"},{"doc":"Finds the convexity defects of a contour. Positional Arguments contour : Evision.Mat . Input contour. convexhull : Evision.Mat . Convex hull obtained using convexHull that should contain indices of the contour points that make the hull. Return convexityDefects : Evision.Mat . The output vector of convexity defects. In C++ and the new Python/Java interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices in the original contour of the convexity defect beginning, end and the farthest point, and fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-point value of the depth will be fixpt_depth/256.0. The figure below displays convexity defects of a hand contour: Python prototype (for reference): convexityDefects(contour, convexhull[, convexityDefects]) -&gt; convexityDefects","ref":"Evision.html#convexityDefects/3","title":"Evision.convexityDefects/3","type":"function"},{"doc":"Raising version of copyMakeBorder/6 .","ref":"Evision.html#copyMakeBorder!/6","title":"Evision.copyMakeBorder!/6","type":"function"},{"doc":"Raising version of copyMakeBorder/7 .","ref":"Evision.html#copyMakeBorder!/7","title":"Evision.copyMakeBorder!/7","type":"function"},{"doc":"Forms a border around an image. Positional Arguments src : Evision.Mat . Source image. top : int . the top pixels bottom : int . the bottom pixels left : int . the left pixels right : int . Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs to be built. borderType : int . Border type. See borderInterpolate for details. Keyword Arguments value : Scalar . Border value if borderType==BORDER_CONSTANT . Return dst : Evision.Mat . Destination image of the same type as src and the size Size(src.cols+left+right, src.rows+top+bottom) . The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but what other more complex functions, including your own, may do to simplify image boundary handling. The function supports the mode when src is already in the middle of dst . In this case, the function does not copy src itself but simply constructs the border, for example: // let border be the same in all directions int border=2; // constructs a larger image to fit both the image and the border Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth()); // select the middle part of it w/o copying data Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows)); // convert image from RGB to grayscale cvtColor(rgb, gray, COLOR_RGB2GRAY); // form a border in-place copyMakeBorder(gray, gray_buf, border, border, border, border, BORDER_REPLICATE); // now do some custom filtering ... ... Note : When the source image is a part (ROI) of a bigger image, the function will try to use the pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as if src was not a ROI, use borderType | #BORDER_ISOLATED. @sa borderInterpolate Python prototype (for reference): copyMakeBorder(src, top, bottom, left, right, borderType[, dst[, value]]) -&gt; dst","ref":"Evision.html#copyMakeBorder/6","title":"Evision.copyMakeBorder/6","type":"function"},{"doc":"Forms a border around an image. Positional Arguments src : Evision.Mat . Source image. top : int . the top pixels bottom : int . the bottom pixels left : int . the left pixels right : int . Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs to be built. borderType : int . Border type. See borderInterpolate for details. Keyword Arguments value : Scalar . Border value if borderType==BORDER_CONSTANT . Return dst : Evision.Mat . Destination image of the same type as src and the size Size(src.cols+left+right, src.rows+top+bottom) . The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but what other more complex functions, including your own, may do to simplify image boundary handling. The function supports the mode when src is already in the middle of dst . In this case, the function does not copy src itself but simply constructs the border, for example: // let border be the same in all directions int border=2; // constructs a larger image to fit both the image and the border Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth()); // select the middle part of it w/o copying data Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows)); // convert image from RGB to grayscale cvtColor(rgb, gray, COLOR_RGB2GRAY); // form a border in-place copyMakeBorder(gray, gray_buf, border, border, border, border, BORDER_REPLICATE); // now do some custom filtering ... ... Note : When the source image is a part (ROI) of a bigger image, the function will try to use the pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as if src was not a ROI, use borderType | #BORDER_ISOLATED. @sa borderInterpolate Python prototype (for reference): copyMakeBorder(src, top, bottom, left, right, borderType[, dst[, value]]) -&gt; dst","ref":"Evision.html#copyMakeBorder/7","title":"Evision.copyMakeBorder/7","type":"function"},{"doc":"Raising version of copyTo/2 .","ref":"Evision.html#copyTo!/2","title":"Evision.copyTo!/2","type":"function"},{"doc":"Raising version of copyTo/3 .","ref":"Evision.html#copyTo!/3","title":"Evision.copyTo!/3","type":"function"},{"doc":"This is an overloaded member function, provided for convenience (python) Copies the matrix to another one. When the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data. Positional Arguments src : Evision.Mat . source matrix. mask : Evision.Mat . Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. Return dst : Evision.Mat . Destination matrix. If it does not have a proper size or type before the operation, it is reallocated. Python prototype (for reference): copyTo(src, mask[, dst]) -&gt; dst","ref":"Evision.html#copyTo/2","title":"Evision.copyTo/2","type":"function"},{"doc":"This is an overloaded member function, provided for convenience (python) Copies the matrix to another one. When the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data. Positional Arguments src : Evision.Mat . source matrix. mask : Evision.Mat . Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. Return dst : Evision.Mat . Destination matrix. If it does not have a proper size or type before the operation, it is reallocated. Python prototype (for reference): copyTo(src, mask[, dst]) -&gt; dst","ref":"Evision.html#copyTo/3","title":"Evision.copyTo/3","type":"function"},{"doc":"Raising version of cornerEigenValsAndVecs/3 .","ref":"Evision.html#cornerEigenValsAndVecs!/3","title":"Evision.cornerEigenValsAndVecs!/3","type":"function"},{"doc":"Raising version of cornerEigenValsAndVecs/4 .","ref":"Evision.html#cornerEigenValsAndVecs!/4","title":"Evision.cornerEigenValsAndVecs!/4","type":"function"},{"doc":"Calculates eigenvalues and eigenvectors of image blocks for corner detection. Positional Arguments src : Evision.Mat . Input single-channel 8-bit or floating-point image. blockSize : int . Neighborhood size (see details below). ksize : int . Aperture parameter for the Sobel operator. Keyword Arguments borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Image to store the results. It has the same size as src and the type CV_32FC(6) . For every pixel \\f$p\\f$ , the function cornerEigenValsAndVecs considers a blockSize \\f$\\times\\f$ blockSize neighborhood \\f$S(p)\\f$ . It calculates the covariation matrix of derivatives over the neighborhood as: \\f[M = \\begin{bmatrix} \\sum _{S(p)}(dI/dx)^2 &amp; \\sum _{S(p)}dI/dx dI/dy \\\\ \\sum _{S(p)}dI/dx dI/dy &amp; \\sum _{S(p)}(dI/dy)^2 \\end{bmatrix}\\f] where the derivatives are computed using the Sobel operator. After that, it finds eigenvectors and eigenvalues of \\f$M\\f$ and stores them in the destination image as \\f$(\\lambda_1, \\lambda_2, x_1, y_1, x_2, y_2)\\f$ where \\f$\\lambda_1, \\lambda_2\\f$ are the non-sorted eigenvalues of \\f$M\\f$ \\f$x_1, y_1\\f$ are the eigenvectors corresponding to \\f$\\lambda_1\\f$ \\f$x_2, y_2\\f$ are the eigenvectors corresponding to \\f$\\lambda_2\\f$ The output of the function can be used for robust edge or corner detection. @sa cornerMinEigenVal, cornerHarris, preCornerDetect Python prototype (for reference): cornerEigenValsAndVecs(src, blockSize, ksize[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#cornerEigenValsAndVecs/3","title":"Evision.cornerEigenValsAndVecs/3","type":"function"},{"doc":"Calculates eigenvalues and eigenvectors of image blocks for corner detection. Positional Arguments src : Evision.Mat . Input single-channel 8-bit or floating-point image. blockSize : int . Neighborhood size (see details below). ksize : int . Aperture parameter for the Sobel operator. Keyword Arguments borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Image to store the results. It has the same size as src and the type CV_32FC(6) . For every pixel \\f$p\\f$ , the function cornerEigenValsAndVecs considers a blockSize \\f$\\times\\f$ blockSize neighborhood \\f$S(p)\\f$ . It calculates the covariation matrix of derivatives over the neighborhood as: \\f[M = \\begin{bmatrix} \\sum _{S(p)}(dI/dx)^2 &amp; \\sum _{S(p)}dI/dx dI/dy \\\\ \\sum _{S(p)}dI/dx dI/dy &amp; \\sum _{S(p)}(dI/dy)^2 \\end{bmatrix}\\f] where the derivatives are computed using the Sobel operator. After that, it finds eigenvectors and eigenvalues of \\f$M\\f$ and stores them in the destination image as \\f$(\\lambda_1, \\lambda_2, x_1, y_1, x_2, y_2)\\f$ where \\f$\\lambda_1, \\lambda_2\\f$ are the non-sorted eigenvalues of \\f$M\\f$ \\f$x_1, y_1\\f$ are the eigenvectors corresponding to \\f$\\lambda_1\\f$ \\f$x_2, y_2\\f$ are the eigenvectors corresponding to \\f$\\lambda_2\\f$ The output of the function can be used for robust edge or corner detection. @sa cornerMinEigenVal, cornerHarris, preCornerDetect Python prototype (for reference): cornerEigenValsAndVecs(src, blockSize, ksize[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#cornerEigenValsAndVecs/4","title":"Evision.cornerEigenValsAndVecs/4","type":"function"},{"doc":"Raising version of cornerHarris/4 .","ref":"Evision.html#cornerHarris!/4","title":"Evision.cornerHarris!/4","type":"function"},{"doc":"Raising version of cornerHarris/5 .","ref":"Evision.html#cornerHarris!/5","title":"Evision.cornerHarris!/5","type":"function"},{"doc":"Harris corner detector. Positional Arguments src : Evision.Mat . Input single-channel 8-bit or floating-point image. blockSize : int . Neighborhood size (see the details on #cornerEigenValsAndVecs ). ksize : int . Aperture parameter for the Sobel operator. k : double . Harris detector free parameter. See the formula above. Keyword Arguments borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Image to store the Harris detector responses. It has the type CV_32FC1 and the same size as src . The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and cornerEigenValsAndVecs , for each pixel \\f$(x, y)\\f$ it calculates a \\f$2\\times2\\f$ gradient covariance matrix \\f$M^{(x,y)}\\f$ over a \\f$\\texttt{blockSize} \\times \\texttt{blockSize}\\f$ neighborhood. Then, it computes the following characteristic: \\f[\\texttt{dst} (x,y) = \\mathrm{det} M^{(x,y)} - k \\cdot \\left ( \\mathrm{tr} M^{(x,y)} \\right )^2\\f] Corners in the image can be found as the local maxima of this response map. Python prototype (for reference): cornerHarris(src, blockSize, ksize, k[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#cornerHarris/4","title":"Evision.cornerHarris/4","type":"function"},{"doc":"Harris corner detector. Positional Arguments src : Evision.Mat . Input single-channel 8-bit or floating-point image. blockSize : int . Neighborhood size (see the details on #cornerEigenValsAndVecs ). ksize : int . Aperture parameter for the Sobel operator. k : double . Harris detector free parameter. See the formula above. Keyword Arguments borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Image to store the Harris detector responses. It has the type CV_32FC1 and the same size as src . The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and cornerEigenValsAndVecs , for each pixel \\f$(x, y)\\f$ it calculates a \\f$2\\times2\\f$ gradient covariance matrix \\f$M^{(x,y)}\\f$ over a \\f$\\texttt{blockSize} \\times \\texttt{blockSize}\\f$ neighborhood. Then, it computes the following characteristic: \\f[\\texttt{dst} (x,y) = \\mathrm{det} M^{(x,y)} - k \\cdot \\left ( \\mathrm{tr} M^{(x,y)} \\right )^2\\f] Corners in the image can be found as the local maxima of this response map. Python prototype (for reference): cornerHarris(src, blockSize, ksize, k[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#cornerHarris/5","title":"Evision.cornerHarris/5","type":"function"},{"doc":"Raising version of cornerMinEigenVal/2 .","ref":"Evision.html#cornerMinEigenVal!/2","title":"Evision.cornerMinEigenVal!/2","type":"function"},{"doc":"Raising version of cornerMinEigenVal/3 .","ref":"Evision.html#cornerMinEigenVal!/3","title":"Evision.cornerMinEigenVal!/3","type":"function"},{"doc":"Calculates the minimal eigenvalue of gradient matrices for corner detection. Positional Arguments src : Evision.Mat . Input single-channel 8-bit or floating-point image. blockSize : int . Neighborhood size (see the details on #cornerEigenValsAndVecs ). Keyword Arguments ksize : int . Aperture parameter for the Sobel operator. borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src . The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, \\f$\\min(\\lambda_1, \\lambda_2)\\f$ in terms of the formulae in the cornerEigenValsAndVecs description. Python prototype (for reference): cornerMinEigenVal(src, blockSize[, dst[, ksize[, borderType]]]) -&gt; dst","ref":"Evision.html#cornerMinEigenVal/2","title":"Evision.cornerMinEigenVal/2","type":"function"},{"doc":"Calculates the minimal eigenvalue of gradient matrices for corner detection. Positional Arguments src : Evision.Mat . Input single-channel 8-bit or floating-point image. blockSize : int . Neighborhood size (see the details on #cornerEigenValsAndVecs ). Keyword Arguments ksize : int . Aperture parameter for the Sobel operator. borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src . The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, \\f$\\min(\\lambda_1, \\lambda_2)\\f$ in terms of the formulae in the cornerEigenValsAndVecs description. Python prototype (for reference): cornerMinEigenVal(src, blockSize[, dst[, ksize[, borderType]]]) -&gt; dst","ref":"Evision.html#cornerMinEigenVal/3","title":"Evision.cornerMinEigenVal/3","type":"function"},{"doc":"Raising version of cornerSubPix/5 .","ref":"Evision.html#cornerSubPix!/5","title":"Evision.cornerSubPix!/5","type":"function"},{"doc":"Refines the corner locations. Positional Arguments image : Evision.Mat . Input single-channel, 8-bit or float image. winSize : Size . Half of the side length of the search window. For example, if winSize=Size(5,5) , then a \\f$(5 2+1) \\times (5 2+1) = 11 \\times 11\\f$ search window is used. zeroZone : Size . Half of the size of the dead region in the middle of the search zone over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size. criteria : TermCriteria . Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after criteria.maxCount iterations or when the corner position moves by less than criteria.epsilon on some iteration. Return corners : Evision.Mat . Initial coordinates of the input corners and refined coordinates provided for output. The function iterates to find the sub-pixel accurate location of corners or radial saddle points as described in @cite forstner1987fast, and as shown on the figure below. Sub-pixel accurate corner locator is based on the observation that every vector from the center \\f$q\\f$ to a point \\f$p\\f$ located within a neighborhood of \\f$q\\f$ is orthogonal to the image gradient at \\f$p\\f$ subject to image and measurement noise. Consider the expression: \\f[\\epsilon _i = {DI_{p_i}}^T \\cdot (q - p_i)\\f] where \\f${DI_{p_i}}\\f$ is an image gradient at one of the points \\f$p_i\\f$ in a neighborhood of \\f$q\\f$ . The value of \\f$q\\f$ is to be found so that \\f$\\epsilon_i\\f$ is minimized. A system of equations may be set up with \\f$\\epsilon_i\\f$ set to zero: \\f[\\sum _i(DI_{p_i} \\cdot {DI_{p_i}}^T) \\cdot q - \\sum _i(DI_{p_i} \\cdot {DI_{p_i}}^T \\cdot p_i)\\f] where the gradients are summed within a neighborhood (&quot;search window&quot;) of \\f$q\\f$ . Calling the first gradient term \\f$G\\f$ and the second gradient term \\f$b\\f$ gives: \\f[q = G^{-1} \\cdot b\\f] The algorithm sets the center of the neighborhood window at this new center \\f$q\\f$ and then iterates until the center stays within a set threshold. Python prototype (for reference): cornerSubPix(image, corners, winSize, zeroZone, criteria) -&gt; corners","ref":"Evision.html#cornerSubPix/5","title":"Evision.cornerSubPix/5","type":"function"},{"doc":"Raising version of correctMatches/3 .","ref":"Evision.html#correctMatches!/3","title":"Evision.correctMatches!/3","type":"function"},{"doc":"Raising version of correctMatches/4 .","ref":"Evision.html#correctMatches!/4","title":"Evision.correctMatches!/4","type":"function"},{"doc":"Refines coordinates of corresponding points. Positional Arguments f : Evision.Mat . 3x3 fundamental matrix. points1 : Evision.Mat . 1xN array containing the first set of points. points2 : Evision.Mat . 1xN array containing the second set of points. Return newPoints1 : Evision.Mat . The optimized points1. newPoints2 : Evision.Mat . The optimized points2. The function implements the Optimal Triangulation Method (see Multiple View Geometry for details). For each given point correspondence points1[i] \\&lt;-&gt; points2[i], and a fundamental matrix F, it computes the corrected correspondences newPoints1[i] \\&lt;-&gt; newPoints2[i] that minimize the geometric error \\f$d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2\\f$ (where \\f$d(a,b)\\f$ is the geometric distance between points \\f$a\\f$ and \\f$b\\f$ ) subject to the epipolar constraint \\f$newPoints2^T * F * newPoints1 = 0\\f$ . Python prototype (for reference): correctMatches(F, points1, points2[, newPoints1[, newPoints2]]) -&gt; newPoints1, newPoints2","ref":"Evision.html#correctMatches/3","title":"Evision.correctMatches/3","type":"function"},{"doc":"Refines coordinates of corresponding points. Positional Arguments f : Evision.Mat . 3x3 fundamental matrix. points1 : Evision.Mat . 1xN array containing the first set of points. points2 : Evision.Mat . 1xN array containing the second set of points. Return newPoints1 : Evision.Mat . The optimized points1. newPoints2 : Evision.Mat . The optimized points2. The function implements the Optimal Triangulation Method (see Multiple View Geometry for details). For each given point correspondence points1[i] \\&lt;-&gt; points2[i], and a fundamental matrix F, it computes the corrected correspondences newPoints1[i] \\&lt;-&gt; newPoints2[i] that minimize the geometric error \\f$d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2\\f$ (where \\f$d(a,b)\\f$ is the geometric distance between points \\f$a\\f$ and \\f$b\\f$ ) subject to the epipolar constraint \\f$newPoints2^T * F * newPoints1 = 0\\f$ . Python prototype (for reference): correctMatches(F, points1, points2[, newPoints1[, newPoints2]]) -&gt; newPoints1, newPoints2","ref":"Evision.html#correctMatches/4","title":"Evision.correctMatches/4","type":"function"},{"doc":"Raising version of countNonZero/1 .","ref":"Evision.html#countNonZero!/1","title":"Evision.countNonZero!/1","type":"function"},{"doc":"Counts non-zero array elements. Positional Arguments src : Evision.Mat . single-channel array. The function returns the number of non-zero elements in src : \\f[\\sum _{I: \\; \\texttt{src} (I) \\ne0 } 1\\f] @sa mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix Python prototype (for reference): countNonZero(src) -&gt; retval","ref":"Evision.html#countNonZero/1","title":"Evision.countNonZero/1","type":"function"},{"doc":"Raising version of createAlignMTB/0 .","ref":"Evision.html#createAlignMTB!/0","title":"Evision.createAlignMTB!/0","type":"function"},{"doc":"Raising version of createAlignMTB/1 .","ref":"Evision.html#createAlignMTB!/1","title":"Evision.createAlignMTB!/1","type":"function"},{"doc":"Creates AlignMTB object Keyword Arguments max_bits : int . logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are usually good enough (31 and 63 pixels shift respectively). exclude_range : int . range for exclusion bitmap that is constructed to suppress noise around the median value. cut : bool . if true cuts images, otherwise fills the new regions with zeros. Python prototype (for reference): createAlignMTB([, max_bits[, exclude_range[, cut]]]) -&gt; retval","ref":"Evision.html#createAlignMTB/0","title":"Evision.createAlignMTB/0","type":"function"},{"doc":"Creates AlignMTB object Keyword Arguments max_bits : int . logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are usually good enough (31 and 63 pixels shift respectively). exclude_range : int . range for exclusion bitmap that is constructed to suppress noise around the median value. cut : bool . if true cuts images, otherwise fills the new regions with zeros. Python prototype (for reference): createAlignMTB([, max_bits[, exclude_range[, cut]]]) -&gt; retval","ref":"Evision.html#createAlignMTB/1","title":"Evision.createAlignMTB/1","type":"function"},{"doc":"Raising version of createBackgroundSubtractorKNN/0 .","ref":"Evision.html#createBackgroundSubtractorKNN!/0","title":"Evision.createBackgroundSubtractorKNN!/0","type":"function"},{"doc":"Raising version of createBackgroundSubtractorKNN/1 .","ref":"Evision.html#createBackgroundSubtractorKNN!/1","title":"Evision.createBackgroundSubtractorKNN!/1","type":"function"},{"doc":"Creates KNN Background Subtractor Keyword Arguments history : int . Length of the history. dist2Threshold : double . Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update. detectShadows : bool . If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. Python prototype (for reference): createBackgroundSubtractorKNN([, history[, dist2Threshold[, detectShadows]]]) -&gt; retval","ref":"Evision.html#createBackgroundSubtractorKNN/0","title":"Evision.createBackgroundSubtractorKNN/0","type":"function"},{"doc":"Creates KNN Background Subtractor Keyword Arguments history : int . Length of the history. dist2Threshold : double . Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update. detectShadows : bool . If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. Python prototype (for reference): createBackgroundSubtractorKNN([, history[, dist2Threshold[, detectShadows]]]) -&gt; retval","ref":"Evision.html#createBackgroundSubtractorKNN/1","title":"Evision.createBackgroundSubtractorKNN/1","type":"function"},{"doc":"Raising version of createBackgroundSubtractorMOG2/0 .","ref":"Evision.html#createBackgroundSubtractorMOG2!/0","title":"Evision.createBackgroundSubtractorMOG2!/0","type":"function"},{"doc":"Raising version of createBackgroundSubtractorMOG2/1 .","ref":"Evision.html#createBackgroundSubtractorMOG2!/1","title":"Evision.createBackgroundSubtractorMOG2!/1","type":"function"},{"doc":"Creates MOG2 Background Subtractor Keyword Arguments history : int . Length of the history. varThreshold : double . Threshold on the squared Mahalanobis distance between the pixel and the model to decide whether a pixel is well described by the background model. This parameter does not affect the background update. detectShadows : bool . If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. Python prototype (for reference): createBackgroundSubtractorMOG2([, history[, varThreshold[, detectShadows]]]) -&gt; retval","ref":"Evision.html#createBackgroundSubtractorMOG2/0","title":"Evision.createBackgroundSubtractorMOG2/0","type":"function"},{"doc":"Creates MOG2 Background Subtractor Keyword Arguments history : int . Length of the history. varThreshold : double . Threshold on the squared Mahalanobis distance between the pixel and the model to decide whether a pixel is well described by the background model. This parameter does not affect the background update. detectShadows : bool . If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. Python prototype (for reference): createBackgroundSubtractorMOG2([, history[, varThreshold[, detectShadows]]]) -&gt; retval","ref":"Evision.html#createBackgroundSubtractorMOG2/1","title":"Evision.createBackgroundSubtractorMOG2/1","type":"function"},{"doc":"Raising version of createCalibrateDebevec/0 .","ref":"Evision.html#createCalibrateDebevec!/0","title":"Evision.createCalibrateDebevec!/0","type":"function"},{"doc":"Raising version of createCalibrateDebevec/1 .","ref":"Evision.html#createCalibrateDebevec!/1","title":"Evision.createCalibrateDebevec!/1","type":"function"},{"doc":"Creates CalibrateDebevec object Keyword Arguments samples : int . number of pixel locations to use lambda : float . smoothness term weight. Greater values produce smoother results, but can alter the response. random : bool . if true sample pixel locations are chosen at random, otherwise they form a rectangular grid. Python prototype (for reference): createCalibrateDebevec([, samples[, lambda[, random]]]) -&gt; retval","ref":"Evision.html#createCalibrateDebevec/0","title":"Evision.createCalibrateDebevec/0","type":"function"},{"doc":"Creates CalibrateDebevec object Keyword Arguments samples : int . number of pixel locations to use lambda : float . smoothness term weight. Greater values produce smoother results, but can alter the response. random : bool . if true sample pixel locations are chosen at random, otherwise they form a rectangular grid. Python prototype (for reference): createCalibrateDebevec([, samples[, lambda[, random]]]) -&gt; retval","ref":"Evision.html#createCalibrateDebevec/1","title":"Evision.createCalibrateDebevec/1","type":"function"},{"doc":"Raising version of createCalibrateRobertson/0 .","ref":"Evision.html#createCalibrateRobertson!/0","title":"Evision.createCalibrateRobertson!/0","type":"function"},{"doc":"Raising version of createCalibrateRobertson/1 .","ref":"Evision.html#createCalibrateRobertson!/1","title":"Evision.createCalibrateRobertson!/1","type":"function"},{"doc":"Creates CalibrateRobertson object Keyword Arguments max_iter : int . maximal number of Gauss-Seidel solver iterations. threshold : float . target difference between results of two successive steps of the minimization. Python prototype (for reference): createCalibrateRobertson([, max_iter[, threshold]]) -&gt; retval","ref":"Evision.html#createCalibrateRobertson/0","title":"Evision.createCalibrateRobertson/0","type":"function"},{"doc":"Creates CalibrateRobertson object Keyword Arguments max_iter : int . maximal number of Gauss-Seidel solver iterations. threshold : float . target difference between results of two successive steps of the minimization. Python prototype (for reference): createCalibrateRobertson([, max_iter[, threshold]]) -&gt; retval","ref":"Evision.html#createCalibrateRobertson/1","title":"Evision.createCalibrateRobertson/1","type":"function"},{"doc":"Raising version of createCLAHE/0 .","ref":"Evision.html#createCLAHE!/0","title":"Evision.createCLAHE!/0","type":"function"},{"doc":"Raising version of createCLAHE/1 .","ref":"Evision.html#createCLAHE!/1","title":"Evision.createCLAHE!/1","type":"function"},{"doc":"Creates a smart pointer to a cv::CLAHE class and initializes it. Keyword Arguments clipLimit : double . Threshold for contrast limiting. tileGridSize : Size . Size of grid for histogram equalization. Input image will be divided into equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column. Python prototype (for reference): createCLAHE([, clipLimit[, tileGridSize]]) -&gt; retval","ref":"Evision.html#createCLAHE/0","title":"Evision.createCLAHE/0","type":"function"},{"doc":"Creates a smart pointer to a cv::CLAHE class and initializes it. Keyword Arguments clipLimit : double . Threshold for contrast limiting. tileGridSize : Size . Size of grid for histogram equalization. Input image will be divided into equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column. Python prototype (for reference): createCLAHE([, clipLimit[, tileGridSize]]) -&gt; retval","ref":"Evision.html#createCLAHE/1","title":"Evision.createCLAHE/1","type":"function"},{"doc":"Raising version of createGeneralizedHoughBallard/0 .","ref":"Evision.html#createGeneralizedHoughBallard!/0","title":"Evision.createGeneralizedHoughBallard!/0","type":"function"},{"doc":"Creates a smart pointer to a cv::GeneralizedHoughBallard class and initializes it. Python prototype (for reference): createGeneralizedHoughBallard() -&gt; retval","ref":"Evision.html#createGeneralizedHoughBallard/0","title":"Evision.createGeneralizedHoughBallard/0","type":"function"},{"doc":"Raising version of createGeneralizedHoughGuil/0 .","ref":"Evision.html#createGeneralizedHoughGuil!/0","title":"Evision.createGeneralizedHoughGuil!/0","type":"function"},{"doc":"Creates a smart pointer to a cv::GeneralizedHoughGuil class and initializes it. Python prototype (for reference): createGeneralizedHoughGuil() -&gt; retval","ref":"Evision.html#createGeneralizedHoughGuil/0","title":"Evision.createGeneralizedHoughGuil/0","type":"function"},{"doc":"Raising version of createHanningWindow/2 .","ref":"Evision.html#createHanningWindow!/2","title":"Evision.createHanningWindow!/2","type":"function"},{"doc":"Raising version of createHanningWindow/3 .","ref":"Evision.html#createHanningWindow!/3","title":"Evision.createHanningWindow!/3","type":"function"},{"doc":"This function computes a Hanning window coefficients in two dimensions. Positional Arguments winSize : Size . The window size specifications (both width and height must be &gt; 1) type : int . Created array type Return dst : Evision.Mat . Destination array to place Hann coefficients in See ( http://en.wikipedia.org/wiki/Hann_function ) and ( http://en.wikipedia.org/wiki/Window_function ) for more information. An example is shown below: // create hanning window of size 100 x100 and type CV_32F Mat hann ; createHanningWindow ( hann , Size ( 100 , 100 ) , CV_32F ) ; Python prototype (for reference): createHanningWindow(winSize, type[, dst]) -&gt; dst","ref":"Evision.html#createHanningWindow/2","title":"Evision.createHanningWindow/2","type":"function"},{"doc":"This function computes a Hanning window coefficients in two dimensions. Positional Arguments winSize : Size . The window size specifications (both width and height must be &gt; 1) type : int . Created array type Return dst : Evision.Mat . Destination array to place Hann coefficients in See ( http://en.wikipedia.org/wiki/Hann_function ) and ( http://en.wikipedia.org/wiki/Window_function ) for more information. An example is shown below: // create hanning window of size 100 x100 and type CV_32F Mat hann ; createHanningWindow ( hann , Size ( 100 , 100 ) , CV_32F ) ; Python prototype (for reference): createHanningWindow(winSize, type[, dst]) -&gt; dst","ref":"Evision.html#createHanningWindow/3","title":"Evision.createHanningWindow/3","type":"function"},{"doc":"Raising version of createLineSegmentDetector/0 .","ref":"Evision.html#createLineSegmentDetector!/0","title":"Evision.createLineSegmentDetector!/0","type":"function"},{"doc":"Raising version of createLineSegmentDetector/1 .","ref":"Evision.html#createLineSegmentDetector!/1","title":"Evision.createLineSegmentDetector!/1","type":"function"},{"doc":"Creates a smart pointer to a LineSegmentDetector object and initializes it. Keyword Arguments refine : int . The way found lines will be refined, see #LineSegmentDetectorModes scale : double . The scale of the image that will be used to find the lines. Range (0..1]. sigma_scale : double . Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale. quant : double . Bound to the quantization error on the gradient norm. ang_th : double . Gradient angle tolerance in degrees. log_eps : double . Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen. density_th : double . Minimal density of aligned region points in the enclosing rectangle. n_bins : int . Number of bins in pseudo-ordering of gradient modulus. The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application. Python prototype (for reference): createLineSegmentDetector([, refine[, scale[, sigma_scale[, quant[, ang_th[, log_eps[, density_th[, n_bins]]]]]]]]) -&gt; retval","ref":"Evision.html#createLineSegmentDetector/0","title":"Evision.createLineSegmentDetector/0","type":"function"},{"doc":"Creates a smart pointer to a LineSegmentDetector object and initializes it. Keyword Arguments refine : int . The way found lines will be refined, see #LineSegmentDetectorModes scale : double . The scale of the image that will be used to find the lines. Range (0..1]. sigma_scale : double . Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale. quant : double . Bound to the quantization error on the gradient norm. ang_th : double . Gradient angle tolerance in degrees. log_eps : double . Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen. density_th : double . Minimal density of aligned region points in the enclosing rectangle. n_bins : int . Number of bins in pseudo-ordering of gradient modulus. The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application. Python prototype (for reference): createLineSegmentDetector([, refine[, scale[, sigma_scale[, quant[, ang_th[, log_eps[, density_th[, n_bins]]]]]]]]) -&gt; retval","ref":"Evision.html#createLineSegmentDetector/1","title":"Evision.createLineSegmentDetector/1","type":"function"},{"doc":"Raising version of createMergeDebevec/0 .","ref":"Evision.html#createMergeDebevec!/0","title":"Evision.createMergeDebevec!/0","type":"function"},{"doc":"Creates MergeDebevec object Python prototype (for reference): createMergeDebevec() -&gt; retval","ref":"Evision.html#createMergeDebevec/0","title":"Evision.createMergeDebevec/0","type":"function"},{"doc":"Raising version of createMergeMertens/0 .","ref":"Evision.html#createMergeMertens!/0","title":"Evision.createMergeMertens!/0","type":"function"},{"doc":"Raising version of createMergeMertens/1 .","ref":"Evision.html#createMergeMertens!/1","title":"Evision.createMergeMertens!/1","type":"function"},{"doc":"Creates MergeMertens object Keyword Arguments contrast_weight : float . contrast measure weight. See MergeMertens. saturation_weight : float . saturation measure weight exposure_weight : float . well-exposedness measure weight Python prototype (for reference): createMergeMertens([, contrast_weight[, saturation_weight[, exposure_weight]]]) -&gt; retval","ref":"Evision.html#createMergeMertens/0","title":"Evision.createMergeMertens/0","type":"function"},{"doc":"Creates MergeMertens object Keyword Arguments contrast_weight : float . contrast measure weight. See MergeMertens. saturation_weight : float . saturation measure weight exposure_weight : float . well-exposedness measure weight Python prototype (for reference): createMergeMertens([, contrast_weight[, saturation_weight[, exposure_weight]]]) -&gt; retval","ref":"Evision.html#createMergeMertens/1","title":"Evision.createMergeMertens/1","type":"function"},{"doc":"Raising version of createMergeRobertson/0 .","ref":"Evision.html#createMergeRobertson!/0","title":"Evision.createMergeRobertson!/0","type":"function"},{"doc":"Creates MergeRobertson object Python prototype (for reference): createMergeRobertson() -&gt; retval","ref":"Evision.html#createMergeRobertson/0","title":"Evision.createMergeRobertson/0","type":"function"},{"doc":"Raising version of createTonemap/0 .","ref":"Evision.html#createTonemap!/0","title":"Evision.createTonemap!/0","type":"function"},{"doc":"Raising version of createTonemap/1 .","ref":"Evision.html#createTonemap!/1","title":"Evision.createTonemap!/1","type":"function"},{"doc":"Creates simple linear mapper with gamma correction Keyword Arguments gamma : float . positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma equal to 2.2f is suitable for most displays. Generally gamma &gt; 1 brightens the image and gamma \\&lt; 1 darkens it. Python prototype (for reference): createTonemap([, gamma]) -&gt; retval","ref":"Evision.html#createTonemap/0","title":"Evision.createTonemap/0","type":"function"},{"doc":"Creates simple linear mapper with gamma correction Keyword Arguments gamma : float . positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma equal to 2.2f is suitable for most displays. Generally gamma &gt; 1 brightens the image and gamma \\&lt; 1 darkens it. Python prototype (for reference): createTonemap([, gamma]) -&gt; retval","ref":"Evision.html#createTonemap/1","title":"Evision.createTonemap/1","type":"function"},{"doc":"Raising version of createTonemapDrago/0 .","ref":"Evision.html#createTonemapDrago!/0","title":"Evision.createTonemapDrago!/0","type":"function"},{"doc":"Raising version of createTonemapDrago/1 .","ref":"Evision.html#createTonemapDrago!/1","title":"Evision.createTonemapDrago!/1","type":"function"},{"doc":"Creates TonemapDrago object Keyword Arguments gamma : float . gamma value for gamma correction. See createTonemap saturation : float . positive saturation enhancement value. 1.0 preserves saturation, values greater than 1 increase saturation and values less than 1 decrease it. bias : float . value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best results, default value is 0.85. Python prototype (for reference): createTonemapDrago([, gamma[, saturation[, bias]]]) -&gt; retval","ref":"Evision.html#createTonemapDrago/0","title":"Evision.createTonemapDrago/0","type":"function"},{"doc":"Creates TonemapDrago object Keyword Arguments gamma : float . gamma value for gamma correction. See createTonemap saturation : float . positive saturation enhancement value. 1.0 preserves saturation, values greater than 1 increase saturation and values less than 1 decrease it. bias : float . value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best results, default value is 0.85. Python prototype (for reference): createTonemapDrago([, gamma[, saturation[, bias]]]) -&gt; retval","ref":"Evision.html#createTonemapDrago/1","title":"Evision.createTonemapDrago/1","type":"function"},{"doc":"Raising version of createTonemapMantiuk/0 .","ref":"Evision.html#createTonemapMantiuk!/0","title":"Evision.createTonemapMantiuk!/0","type":"function"},{"doc":"Raising version of createTonemapMantiuk/1 .","ref":"Evision.html#createTonemapMantiuk!/1","title":"Evision.createTonemapMantiuk!/1","type":"function"},{"doc":"Creates TonemapMantiuk object Keyword Arguments gamma : float . gamma value for gamma correction. See createTonemap scale : float . contrast scale factor. HVS response is multiplied by this parameter, thus compressing dynamic range. Values from 0.6 to 0.9 produce best results. saturation : float . saturation enhancement value. See createTonemapDrago Python prototype (for reference): createTonemapMantiuk([, gamma[, scale[, saturation]]]) -&gt; retval","ref":"Evision.html#createTonemapMantiuk/0","title":"Evision.createTonemapMantiuk/0","type":"function"},{"doc":"Creates TonemapMantiuk object Keyword Arguments gamma : float . gamma value for gamma correction. See createTonemap scale : float . contrast scale factor. HVS response is multiplied by this parameter, thus compressing dynamic range. Values from 0.6 to 0.9 produce best results. saturation : float . saturation enhancement value. See createTonemapDrago Python prototype (for reference): createTonemapMantiuk([, gamma[, scale[, saturation]]]) -&gt; retval","ref":"Evision.html#createTonemapMantiuk/1","title":"Evision.createTonemapMantiuk/1","type":"function"},{"doc":"Raising version of createTonemapReinhard/0 .","ref":"Evision.html#createTonemapReinhard!/0","title":"Evision.createTonemapReinhard!/0","type":"function"},{"doc":"Raising version of createTonemapReinhard/1 .","ref":"Evision.html#createTonemapReinhard!/1","title":"Evision.createTonemapReinhard!/1","type":"function"},{"doc":"Creates TonemapReinhard object Keyword Arguments gamma : float . gamma value for gamma correction. See createTonemap intensity : float . result intensity in [-8, 8] range. Greater intensity produces brighter results. light_adapt : float . light adaptation in [0, 1] range. If 1 adaptation is based only on pixel value, if 0 it's global, otherwise it's a weighted mean of this two cases. color_adapt : float . chromatic adaptation in [0, 1] range. If 1 channels are treated independently, if 0 adaptation level is the same for each channel. Python prototype (for reference): createTonemapReinhard([, gamma[, intensity[, light_adapt[, color_adapt]]]]) -&gt; retval","ref":"Evision.html#createTonemapReinhard/0","title":"Evision.createTonemapReinhard/0","type":"function"},{"doc":"Creates TonemapReinhard object Keyword Arguments gamma : float . gamma value for gamma correction. See createTonemap intensity : float . result intensity in [-8, 8] range. Greater intensity produces brighter results. light_adapt : float . light adaptation in [0, 1] range. If 1 adaptation is based only on pixel value, if 0 it's global, otherwise it's a weighted mean of this two cases. color_adapt : float . chromatic adaptation in [0, 1] range. If 1 channels are treated independently, if 0 adaptation level is the same for each channel. Python prototype (for reference): createTonemapReinhard([, gamma[, intensity[, light_adapt[, color_adapt]]]]) -&gt; retval","ref":"Evision.html#createTonemapReinhard/1","title":"Evision.createTonemapReinhard/1","type":"function"},{"doc":"Raising version of cubeRoot/1 .","ref":"Evision.html#cubeRoot!/1","title":"Evision.cubeRoot!/1","type":"function"},{"doc":"Computes the cube root of an argument. Positional Arguments val : float . A function argument. The function cubeRoot computes \\f$\\sqrt[3]{\\texttt{val}}\\f$. Negative arguments are handled correctly. NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for single-precision data. Python prototype (for reference): cubeRoot(val) -&gt; retval","ref":"Evision.html#cubeRoot/1","title":"Evision.cubeRoot/1","type":"function"},{"doc":"","ref":"Evision.html#cv_8S/0","title":"Evision.cv_8S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8SC1/0","title":"Evision.cv_8SC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8SC2/0","title":"Evision.cv_8SC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8SC3/0","title":"Evision.cv_8SC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8SC4/0","title":"Evision.cv_8SC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8SC/1","title":"Evision.cv_8SC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_8U/0","title":"Evision.cv_8U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8UC1/0","title":"Evision.cv_8UC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8UC2/0","title":"Evision.cv_8UC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8UC3/0","title":"Evision.cv_8UC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8UC4/0","title":"Evision.cv_8UC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_8UC/1","title":"Evision.cv_8UC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_16F/0","title":"Evision.cv_16F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16FC1/0","title":"Evision.cv_16FC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16FC2/0","title":"Evision.cv_16FC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16FC3/0","title":"Evision.cv_16FC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16FC4/0","title":"Evision.cv_16FC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16FC/1","title":"Evision.cv_16FC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_16S/0","title":"Evision.cv_16S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16SC1/0","title":"Evision.cv_16SC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16SC2/0","title":"Evision.cv_16SC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16SC3/0","title":"Evision.cv_16SC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16SC4/0","title":"Evision.cv_16SC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16SC/1","title":"Evision.cv_16SC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_16U/0","title":"Evision.cv_16U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16UC1/0","title":"Evision.cv_16UC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16UC2/0","title":"Evision.cv_16UC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16UC3/0","title":"Evision.cv_16UC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16UC4/0","title":"Evision.cv_16UC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_16UC/1","title":"Evision.cv_16UC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_32F/0","title":"Evision.cv_32F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32FC1/0","title":"Evision.cv_32FC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32FC2/0","title":"Evision.cv_32FC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32FC3/0","title":"Evision.cv_32FC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32FC4/0","title":"Evision.cv_32FC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32FC/1","title":"Evision.cv_32FC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_32S/0","title":"Evision.cv_32S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32SC1/0","title":"Evision.cv_32SC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32SC2/0","title":"Evision.cv_32SC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32SC3/0","title":"Evision.cv_32SC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32SC4/0","title":"Evision.cv_32SC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_32SC/1","title":"Evision.cv_32SC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_64F/0","title":"Evision.cv_64F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_64FC1/0","title":"Evision.cv_64FC1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_64FC2/0","title":"Evision.cv_64FC2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_64FC3/0","title":"Evision.cv_64FC3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_64FC4/0","title":"Evision.cv_64FC4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_64FC/1","title":"Evision.cv_64FC/1","type":"function"},{"doc":"","ref":"Evision.html#cv_ACCESS_FAST/0","title":"Evision.cv_ACCESS_FAST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ACCESS_MASK/0","title":"Evision.cv_ACCESS_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ACCESS_READ/0","title":"Evision.cv_ACCESS_READ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ACCESS_RW/0","title":"Evision.cv_ACCESS_RW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ACCESS_WRITE/0","title":"Evision.cv_ACCESS_WRITE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ADAPTIVE_THRESH_GAUSSIAN_C/0","title":"Evision.cv_ADAPTIVE_THRESH_GAUSSIAN_C/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ADAPTIVE_THRESH_MEAN_C/0","title":"Evision.cv_ADAPTIVE_THRESH_MEAN_C/0","type":"function"},{"doc":"","ref":"Evision.html#cv_AGAST_5_8/0","title":"Evision.cv_AGAST_5_8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_AGAST_7_12d/0","title":"Evision.cv_AGAST_7_12d/0","type":"function"},{"doc":"","ref":"Evision.html#cv_AGAST_7_12s/0","title":"Evision.cv_AGAST_7_12s/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ALGORITHM/0","title":"Evision.cv_ALGORITHM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ANNEAL/0","title":"Evision.cv_ANNEAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_APPEND/0","title":"Evision.cv_APPEND/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ARRAY_BUFFER/0","title":"Evision.cv_ARRAY_BUFFER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_AS_IS/0","title":"Evision.cv_AS_IS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ASGD/0","title":"Evision.cv_ASGD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ASYMMETRIC_GRID/0","title":"Evision.cv_ASYMMETRIC_GRID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ASYNC_CLEANUP/0","title":"Evision.cv_ASYNC_CLEANUP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_AUTO_STEP/0","title":"Evision.cv_AUTO_STEP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BACKPROP/0","title":"Evision.cv_BACKPROP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BASE64/0","title":"Evision.cv_BASE64/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BATCH/0","title":"Evision.cv_BATCH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadAlign/0","title":"Evision.cv_BadAlign/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadAlphaChannel/0","title":"Evision.cv_BadAlphaChannel/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadCallBack/0","title":"Evision.cv_BadCallBack/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadCOI/0","title":"Evision.cv_BadCOI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadDataPtr/0","title":"Evision.cv_BadDataPtr/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadDepth/0","title":"Evision.cv_BadDepth/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadImageSize/0","title":"Evision.cv_BadImageSize/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadModelOrChSeq/0","title":"Evision.cv_BadModelOrChSeq/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadNumChannel1U/0","title":"Evision.cv_BadNumChannel1U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadNumChannels/0","title":"Evision.cv_BadNumChannels/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadOffset/0","title":"Evision.cv_BadOffset/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadOrder/0","title":"Evision.cv_BadOrder/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadOrigin/0","title":"Evision.cv_BadOrigin/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadROISize/0","title":"Evision.cv_BadROISize/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadStep/0","title":"Evision.cv_BadStep/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BadTileSize/0","title":"Evision.cv_BadTileSize/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BLOCKING_SYNC/0","title":"Evision.cv_BLOCKING_SYNC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BOOLEAN/0","title":"Evision.cv_BOOLEAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_CONSTANT/0","title":"Evision.cv_BORDER_CONSTANT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_DEFAULT/0","title":"Evision.cv_BORDER_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_ISOLATED/0","title":"Evision.cv_BORDER_ISOLATED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_REFLECT101/0","title":"Evision.cv_BORDER_REFLECT101/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_REFLECT/0","title":"Evision.cv_BORDER_REFLECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_REFLECT_101/0","title":"Evision.cv_BORDER_REFLECT_101/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_REPLICATE/0","title":"Evision.cv_BORDER_REPLICATE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_TRANSPARENT/0","title":"Evision.cv_BORDER_TRANSPARENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BORDER_WRAP/0","title":"Evision.cv_BORDER_WRAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_Boost_REAL/0","title":"Evision.cv_Boost_REAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BRUTE_FORCE/0","title":"Evision.cv_BRUTE_FORCE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BRUTEFORCE/0","title":"Evision.cv_BRUTEFORCE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BRUTEFORCE_HAMMING/0","title":"Evision.cv_BRUTEFORCE_HAMMING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BRUTEFORCE_HAMMINGLUT/0","title":"Evision.cv_BRUTEFORCE_HAMMINGLUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BRUTEFORCE_L1/0","title":"Evision.cv_BRUTEFORCE_L1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_BRUTEFORCE_SL2/0","title":"Evision.cv_BRUTEFORCE_SL2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_Buffer_READ_ONLY/0","title":"Evision.cv_Buffer_READ_ONLY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_Buffer_READ_WRITE/0","title":"Evision.cv_Buffer_READ_WRITE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_Buffer_WRITE_ONLY/0","title":"Evision.cv_Buffer_WRITE_ONLY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_C/0","title":"Evision.cv_C/0","type":"function"},{"doc":"","ref":"Evision.html#cv_C_SVC/0","title":"Evision.cv_C_SVC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_ACCURACY/0","title":"Evision.cv_CALIB_CB_ACCURACY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_ADAPTIVE_THRESH/0","title":"Evision.cv_CALIB_CB_ADAPTIVE_THRESH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_ASYMMETRIC_GRID/0","title":"Evision.cv_CALIB_CB_ASYMMETRIC_GRID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_CLUSTERING/0","title":"Evision.cv_CALIB_CB_CLUSTERING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_EXHAUSTIVE/0","title":"Evision.cv_CALIB_CB_EXHAUSTIVE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_FAST_CHECK/0","title":"Evision.cv_CALIB_CB_FAST_CHECK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_FILTER_QUADS/0","title":"Evision.cv_CALIB_CB_FILTER_QUADS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_LARGER/0","title":"Evision.cv_CALIB_CB_LARGER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_MARKER/0","title":"Evision.cv_CALIB_CB_MARKER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_NORMALIZE_IMAGE/0","title":"Evision.cv_CALIB_CB_NORMALIZE_IMAGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CB_SYMMETRIC_GRID/0","title":"Evision.cv_CALIB_CB_SYMMETRIC_GRID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_CHECK_COND/0","title":"Evision.cv_CALIB_CHECK_COND/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_ASPECT_RATIO/0","title":"Evision.cv_CALIB_FIX_ASPECT_RATIO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_FOCAL_LENGTH/0","title":"Evision.cv_CALIB_FIX_FOCAL_LENGTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_INTRINSIC/0","title":"Evision.cv_CALIB_FIX_INTRINSIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_K1/0","title":"Evision.cv_CALIB_FIX_K1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_K2/0","title":"Evision.cv_CALIB_FIX_K2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_K3/0","title":"Evision.cv_CALIB_FIX_K3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_K4/0","title":"Evision.cv_CALIB_FIX_K4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_K5/0","title":"Evision.cv_CALIB_FIX_K5/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_K6/0","title":"Evision.cv_CALIB_FIX_K6/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_PRINCIPAL_POINT/0","title":"Evision.cv_CALIB_FIX_PRINCIPAL_POINT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_S1_S2_S3_S4/0","title":"Evision.cv_CALIB_FIX_S1_S2_S3_S4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_SKEW/0","title":"Evision.cv_CALIB_FIX_SKEW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_TANGENT_DIST/0","title":"Evision.cv_CALIB_FIX_TANGENT_DIST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_FIX_TAUX_TAUY/0","title":"Evision.cv_CALIB_FIX_TAUX_TAUY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_HAND_EYE_ANDREFF/0","title":"Evision.cv_CALIB_HAND_EYE_ANDREFF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_HAND_EYE_DANIILIDIS/0","title":"Evision.cv_CALIB_HAND_EYE_DANIILIDIS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_HAND_EYE_HORAUD/0","title":"Evision.cv_CALIB_HAND_EYE_HORAUD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_HAND_EYE_PARK/0","title":"Evision.cv_CALIB_HAND_EYE_PARK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_HAND_EYE_TSAI/0","title":"Evision.cv_CALIB_HAND_EYE_TSAI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_NINTRINSIC/0","title":"Evision.cv_CALIB_NINTRINSIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_RATIONAL_MODEL/0","title":"Evision.cv_CALIB_RATIONAL_MODEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_RECOMPUTE_EXTRINSIC/0","title":"Evision.cv_CALIB_RECOMPUTE_EXTRINSIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_ROBOT_WORLD_HAND_EYE_LI/0","title":"Evision.cv_CALIB_ROBOT_WORLD_HAND_EYE_LI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_ROBOT_WORLD_HAND_EYE_SHAH/0","title":"Evision.cv_CALIB_ROBOT_WORLD_HAND_EYE_SHAH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_SAME_FOCAL_LENGTH/0","title":"Evision.cv_CALIB_SAME_FOCAL_LENGTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_THIN_PRISM_MODEL/0","title":"Evision.cv_CALIB_THIN_PRISM_MODEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_TILTED_MODEL/0","title":"Evision.cv_CALIB_TILTED_MODEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_USE_EXTRINSIC_GUESS/0","title":"Evision.cv_CALIB_USE_EXTRINSIC_GUESS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_USE_INTRINSIC_GUESS/0","title":"Evision.cv_CALIB_USE_INTRINSIC_GUESS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_USE_LU/0","title":"Evision.cv_CALIB_USE_LU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_USE_QR/0","title":"Evision.cv_CALIB_USE_QR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_ZERO_DISPARITY/0","title":"Evision.cv_CALIB_ZERO_DISPARITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CALIB_ZERO_TANGENT_DIST/0","title":"Evision.cv_CALIB_ZERO_TANGENT_DIST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_ANDROID/0","title":"Evision.cv_CAP_ANDROID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_ANY/0","title":"Evision.cv_CAP_ANY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_ARAVIS/0","title":"Evision.cv_CAP_ARAVIS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_AVFOUNDATION/0","title":"Evision.cv_CAP_AVFOUNDATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_CMU1394/0","title":"Evision.cv_CAP_CMU1394/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_DC1394/0","title":"Evision.cv_CAP_DC1394/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_DSHOW/0","title":"Evision.cv_CAP_DSHOW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_FFMPEG/0","title":"Evision.cv_CAP_FFMPEG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_FIREWARE/0","title":"Evision.cv_CAP_FIREWARE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_FIREWIRE/0","title":"Evision.cv_CAP_FIREWIRE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_GIGANETIX/0","title":"Evision.cv_CAP_GIGANETIX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_GPHOTO2/0","title":"Evision.cv_CAP_GPHOTO2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_GSTREAMER/0","title":"Evision.cv_CAP_GSTREAMER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_IEEE1394/0","title":"Evision.cv_CAP_IEEE1394/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_IMAGES/0","title":"Evision.cv_CAP_IMAGES/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTEL_MFX/0","title":"Evision.cv_CAP_INTEL_MFX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC/0","title":"Evision.cv_CAP_INTELPERC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_DEPTH_GENERATOR/0","title":"Evision.cv_CAP_INTELPERC_DEPTH_GENERATOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_DEPTH_MAP/0","title":"Evision.cv_CAP_INTELPERC_DEPTH_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_GENERATORS_MASK/0","title":"Evision.cv_CAP_INTELPERC_GENERATORS_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_IMAGE/0","title":"Evision.cv_CAP_INTELPERC_IMAGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_IMAGE_GENERATOR/0","title":"Evision.cv_CAP_INTELPERC_IMAGE_GENERATOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_IR_GENERATOR/0","title":"Evision.cv_CAP_INTELPERC_IR_GENERATOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_IR_MAP/0","title":"Evision.cv_CAP_INTELPERC_IR_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_INTELPERC_UVDEPTH_MAP/0","title":"Evision.cv_CAP_INTELPERC_UVDEPTH_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_MSMF/0","title":"Evision.cv_CAP_MSMF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENCV_MJPEG/0","title":"Evision.cv_CAP_OPENCV_MJPEG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI2/0","title":"Evision.cv_CAP_OPENNI2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI2_ASTRA/0","title":"Evision.cv_CAP_OPENNI2_ASTRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI2_ASUS/0","title":"Evision.cv_CAP_OPENNI2_ASUS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI/0","title":"Evision.cv_CAP_OPENNI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_ASUS/0","title":"Evision.cv_CAP_OPENNI_ASUS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_BGR_IMAGE/0","title":"Evision.cv_CAP_OPENNI_BGR_IMAGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DEPTH_GENERATOR/0","title":"Evision.cv_CAP_OPENNI_DEPTH_GENERATOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DEPTH_GENERATOR_BASELINE/0","title":"Evision.cv_CAP_OPENNI_DEPTH_GENERATOR_BASELINE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH/0","title":"Evision.cv_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DEPTH_GENERATOR_PRESENT/0","title":"Evision.cv_CAP_OPENNI_DEPTH_GENERATOR_PRESENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION/0","title":"Evision.cv_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON/0","title":"Evision.cv_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DEPTH_MAP/0","title":"Evision.cv_CAP_OPENNI_DEPTH_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DISPARITY_MAP/0","title":"Evision.cv_CAP_OPENNI_DISPARITY_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_DISPARITY_MAP_32F/0","title":"Evision.cv_CAP_OPENNI_DISPARITY_MAP_32F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_GENERATORS_MASK/0","title":"Evision.cv_CAP_OPENNI_GENERATORS_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_GRAY_IMAGE/0","title":"Evision.cv_CAP_OPENNI_GRAY_IMAGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_IMAGE_GENERATOR/0","title":"Evision.cv_CAP_OPENNI_IMAGE_GENERATOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE/0","title":"Evision.cv_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_IMAGE_GENERATOR_PRESENT/0","title":"Evision.cv_CAP_OPENNI_IMAGE_GENERATOR_PRESENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_IR_GENERATOR/0","title":"Evision.cv_CAP_OPENNI_IR_GENERATOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_IR_GENERATOR_PRESENT/0","title":"Evision.cv_CAP_OPENNI_IR_GENERATOR_PRESENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_IR_IMAGE/0","title":"Evision.cv_CAP_OPENNI_IR_IMAGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_POINT_CLOUD_MAP/0","title":"Evision.cv_CAP_OPENNI_POINT_CLOUD_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_QVGA_30HZ/0","title":"Evision.cv_CAP_OPENNI_QVGA_30HZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_QVGA_60HZ/0","title":"Evision.cv_CAP_OPENNI_QVGA_60HZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_SXGA_15HZ/0","title":"Evision.cv_CAP_OPENNI_SXGA_15HZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_SXGA_30HZ/0","title":"Evision.cv_CAP_OPENNI_SXGA_30HZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_VALID_DEPTH_MASK/0","title":"Evision.cv_CAP_OPENNI_VALID_DEPTH_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_OPENNI_VGA_30HZ/0","title":"Evision.cv_CAP_OPENNI_VGA_30HZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_APERTURE/0","title":"Evision.cv_CAP_PROP_APERTURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_ARAVIS_AUTOTRIGGER/0","title":"Evision.cv_CAP_PROP_ARAVIS_AUTOTRIGGER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_BASE_INDEX/0","title":"Evision.cv_CAP_PROP_AUDIO_BASE_INDEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_DATA_DEPTH/0","title":"Evision.cv_CAP_PROP_AUDIO_DATA_DEPTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_POS/0","title":"Evision.cv_CAP_PROP_AUDIO_POS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_SAMPLES_PER_SECOND/0","title":"Evision.cv_CAP_PROP_AUDIO_SAMPLES_PER_SECOND/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_SHIFT_NSEC/0","title":"Evision.cv_CAP_PROP_AUDIO_SHIFT_NSEC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_STREAM/0","title":"Evision.cv_CAP_PROP_AUDIO_STREAM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_SYNCHRONIZE/0","title":"Evision.cv_CAP_PROP_AUDIO_SYNCHRONIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_TOTAL_CHANNELS/0","title":"Evision.cv_CAP_PROP_AUDIO_TOTAL_CHANNELS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUDIO_TOTAL_STREAMS/0","title":"Evision.cv_CAP_PROP_AUDIO_TOTAL_STREAMS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUTO_EXPOSURE/0","title":"Evision.cv_CAP_PROP_AUTO_EXPOSURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUTO_WB/0","title":"Evision.cv_CAP_PROP_AUTO_WB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_AUTOFOCUS/0","title":"Evision.cv_CAP_PROP_AUTOFOCUS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_BACKEND/0","title":"Evision.cv_CAP_PROP_BACKEND/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_BACKLIGHT/0","title":"Evision.cv_CAP_PROP_BACKLIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_BITRATE/0","title":"Evision.cv_CAP_PROP_BITRATE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_BRIGHTNESS/0","title":"Evision.cv_CAP_PROP_BRIGHTNESS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_BUFFERSIZE/0","title":"Evision.cv_CAP_PROP_BUFFERSIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_CHANNEL/0","title":"Evision.cv_CAP_PROP_CHANNEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_CODEC_EXTRADATA_INDEX/0","title":"Evision.cv_CAP_PROP_CODEC_EXTRADATA_INDEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_CODEC_PIXEL_FORMAT/0","title":"Evision.cv_CAP_PROP_CODEC_PIXEL_FORMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_CONTRAST/0","title":"Evision.cv_CAP_PROP_CONTRAST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_CONVERT_RGB/0","title":"Evision.cv_CAP_PROP_CONVERT_RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_DC1394_MAX/0","title":"Evision.cv_CAP_PROP_DC1394_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_DC1394_MODE_AUTO/0","title":"Evision.cv_CAP_PROP_DC1394_MODE_AUTO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_DC1394_MODE_MANUAL/0","title":"Evision.cv_CAP_PROP_DC1394_MODE_MANUAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO/0","title":"Evision.cv_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_DC1394_OFF/0","title":"Evision.cv_CAP_PROP_DC1394_OFF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_EXPOSURE/0","title":"Evision.cv_CAP_PROP_EXPOSURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_EXPOSUREPROGRAM/0","title":"Evision.cv_CAP_PROP_EXPOSUREPROGRAM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_FOCUS/0","title":"Evision.cv_CAP_PROP_FOCUS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_FORMAT/0","title":"Evision.cv_CAP_PROP_FORMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_FOURCC/0","title":"Evision.cv_CAP_PROP_FOURCC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_FPS/0","title":"Evision.cv_CAP_PROP_FPS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_FRAME_COUNT/0","title":"Evision.cv_CAP_PROP_FRAME_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_FRAME_HEIGHT/0","title":"Evision.cv_CAP_PROP_FRAME_HEIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_FRAME_WIDTH/0","title":"Evision.cv_CAP_PROP_FRAME_WIDTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GAIN/0","title":"Evision.cv_CAP_PROP_GAIN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GAMMA/0","title":"Evision.cv_CAP_PROP_GAMMA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GIGA_FRAME_HEIGH_MAX/0","title":"Evision.cv_CAP_PROP_GIGA_FRAME_HEIGH_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GIGA_FRAME_OFFSET_X/0","title":"Evision.cv_CAP_PROP_GIGA_FRAME_OFFSET_X/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GIGA_FRAME_OFFSET_Y/0","title":"Evision.cv_CAP_PROP_GIGA_FRAME_OFFSET_Y/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GIGA_FRAME_SENS_HEIGH/0","title":"Evision.cv_CAP_PROP_GIGA_FRAME_SENS_HEIGH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GIGA_FRAME_SENS_WIDTH/0","title":"Evision.cv_CAP_PROP_GIGA_FRAME_SENS_WIDTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GIGA_FRAME_WIDTH_MAX/0","title":"Evision.cv_CAP_PROP_GIGA_FRAME_WIDTH_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GPHOTO2_COLLECT_MSGS/0","title":"Evision.cv_CAP_PROP_GPHOTO2_COLLECT_MSGS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GPHOTO2_FLUSH_MSGS/0","title":"Evision.cv_CAP_PROP_GPHOTO2_FLUSH_MSGS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GPHOTO2_PREVIEW/0","title":"Evision.cv_CAP_PROP_GPHOTO2_PREVIEW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GPHOTO2_RELOAD_CONFIG/0","title":"Evision.cv_CAP_PROP_GPHOTO2_RELOAD_CONFIG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE/0","title":"Evision.cv_CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GPHOTO2_WIDGET_ENUMERATE/0","title":"Evision.cv_CAP_PROP_GPHOTO2_WIDGET_ENUMERATE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GSTREAMER_QUEUE_LENGTH/0","title":"Evision.cv_CAP_PROP_GSTREAMER_QUEUE_LENGTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_GUID/0","title":"Evision.cv_CAP_PROP_GUID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_HUE/0","title":"Evision.cv_CAP_PROP_HUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_HW_ACCELERATION/0","title":"Evision.cv_CAP_PROP_HW_ACCELERATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_HW_ACCELERATION_USE_OPENCL/0","title":"Evision.cv_CAP_PROP_HW_ACCELERATION_USE_OPENCL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_HW_DEVICE/0","title":"Evision.cv_CAP_PROP_HW_DEVICE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IMAGES_BASE/0","title":"Evision.cv_CAP_PROP_IMAGES_BASE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IMAGES_LAST/0","title":"Evision.cv_CAP_PROP_IMAGES_LAST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD/0","title":"Evision.cv_CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ/0","title":"Evision.cv_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT/0","title":"Evision.cv_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE/0","title":"Evision.cv_CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE/0","title":"Evision.cv_CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_INTELPERC_PROFILE_COUNT/0","title":"Evision.cv_CAP_PROP_INTELPERC_PROFILE_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_INTELPERC_PROFILE_IDX/0","title":"Evision.cv_CAP_PROP_INTELPERC_PROFILE_IDX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IOS_DEVICE_EXPOSURE/0","title":"Evision.cv_CAP_PROP_IOS_DEVICE_EXPOSURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IOS_DEVICE_FLASH/0","title":"Evision.cv_CAP_PROP_IOS_DEVICE_FLASH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IOS_DEVICE_FOCUS/0","title":"Evision.cv_CAP_PROP_IOS_DEVICE_FOCUS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IOS_DEVICE_TORCH/0","title":"Evision.cv_CAP_PROP_IOS_DEVICE_TORCH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IOS_DEVICE_WHITEBALANCE/0","title":"Evision.cv_CAP_PROP_IOS_DEVICE_WHITEBALANCE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_IRIS/0","title":"Evision.cv_CAP_PROP_IRIS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_ISO_SPEED/0","title":"Evision.cv_CAP_PROP_ISO_SPEED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_LRF_HAS_KEY_FRAME/0","title":"Evision.cv_CAP_PROP_LRF_HAS_KEY_FRAME/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_MODE/0","title":"Evision.cv_CAP_PROP_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_MONOCHROME/0","title":"Evision.cv_CAP_PROP_MONOCHROME/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPEN_TIMEOUT_MSEC/0","title":"Evision.cv_CAP_PROP_OPEN_TIMEOUT_MSEC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI2_MIRROR/0","title":"Evision.cv_CAP_PROP_OPENNI2_MIRROR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI2_SYNC/0","title":"Evision.cv_CAP_PROP_OPENNI2_SYNC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_APPROX_FRAME_SYNC/0","title":"Evision.cv_CAP_PROP_OPENNI_APPROX_FRAME_SYNC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_BASELINE/0","title":"Evision.cv_CAP_PROP_OPENNI_BASELINE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_CIRCLE_BUFFER/0","title":"Evision.cv_CAP_PROP_OPENNI_CIRCLE_BUFFER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_FOCAL_LENGTH/0","title":"Evision.cv_CAP_PROP_OPENNI_FOCAL_LENGTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_FRAME_MAX_DEPTH/0","title":"Evision.cv_CAP_PROP_OPENNI_FRAME_MAX_DEPTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_GENERATOR_PRESENT/0","title":"Evision.cv_CAP_PROP_OPENNI_GENERATOR_PRESENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_MAX_BUFFER_SIZE/0","title":"Evision.cv_CAP_PROP_OPENNI_MAX_BUFFER_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_MAX_TIME_DURATION/0","title":"Evision.cv_CAP_PROP_OPENNI_MAX_TIME_DURATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_OUTPUT_MODE/0","title":"Evision.cv_CAP_PROP_OPENNI_OUTPUT_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_REGISTRATION/0","title":"Evision.cv_CAP_PROP_OPENNI_REGISTRATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_OPENNI_REGISTRATION_ON/0","title":"Evision.cv_CAP_PROP_OPENNI_REGISTRATION_ON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_ORIENTATION_AUTO/0","title":"Evision.cv_CAP_PROP_ORIENTATION_AUTO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_ORIENTATION_META/0","title":"Evision.cv_CAP_PROP_ORIENTATION_META/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PAN/0","title":"Evision.cv_CAP_PROP_PAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_POS_AVI_RATIO/0","title":"Evision.cv_CAP_PROP_POS_AVI_RATIO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_POS_FRAMES/0","title":"Evision.cv_CAP_PROP_POS_FRAMES/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_POS_MSEC/0","title":"Evision.cv_CAP_PROP_POS_MSEC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PVAPI_BINNINGX/0","title":"Evision.cv_CAP_PROP_PVAPI_BINNINGX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PVAPI_BINNINGY/0","title":"Evision.cv_CAP_PROP_PVAPI_BINNINGY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PVAPI_DECIMATIONHORIZONTAL/0","title":"Evision.cv_CAP_PROP_PVAPI_DECIMATIONHORIZONTAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PVAPI_DECIMATIONVERTICAL/0","title":"Evision.cv_CAP_PROP_PVAPI_DECIMATIONVERTICAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE/0","title":"Evision.cv_CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PVAPI_MULTICASTIP/0","title":"Evision.cv_CAP_PROP_PVAPI_MULTICASTIP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_PVAPI_PIXELFORMAT/0","title":"Evision.cv_CAP_PROP_PVAPI_PIXELFORMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_READ_TIMEOUT_MSEC/0","title":"Evision.cv_CAP_PROP_READ_TIMEOUT_MSEC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_RECTIFICATION/0","title":"Evision.cv_CAP_PROP_RECTIFICATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_ROLL/0","title":"Evision.cv_CAP_PROP_ROLL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_SAR_DEN/0","title":"Evision.cv_CAP_PROP_SAR_DEN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_SAR_NUM/0","title":"Evision.cv_CAP_PROP_SAR_NUM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_SATURATION/0","title":"Evision.cv_CAP_PROP_SATURATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_SETTINGS/0","title":"Evision.cv_CAP_PROP_SETTINGS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_SHARPNESS/0","title":"Evision.cv_CAP_PROP_SHARPNESS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_SPEED/0","title":"Evision.cv_CAP_PROP_SPEED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_STREAM_OPEN_TIME_USEC/0","title":"Evision.cv_CAP_PROP_STREAM_OPEN_TIME_USEC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_TEMPERATURE/0","title":"Evision.cv_CAP_PROP_TEMPERATURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_TILT/0","title":"Evision.cv_CAP_PROP_TILT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_TRIGGER/0","title":"Evision.cv_CAP_PROP_TRIGGER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_TRIGGER_DELAY/0","title":"Evision.cv_CAP_PROP_TRIGGER_DELAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_VIDEO_STREAM/0","title":"Evision.cv_CAP_PROP_VIDEO_STREAM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_VIDEO_TOTAL_CHANNELS/0","title":"Evision.cv_CAP_PROP_VIDEO_TOTAL_CHANNELS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_VIEWFINDER/0","title":"Evision.cv_CAP_PROP_VIEWFINDER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_WB_TEMPERATURE/0","title":"Evision.cv_CAP_PROP_WB_TEMPERATURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_WHITE_BALANCE_BLUE_U/0","title":"Evision.cv_CAP_PROP_WHITE_BALANCE_BLUE_U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_WHITE_BALANCE_RED_V/0","title":"Evision.cv_CAP_PROP_WHITE_BALANCE_RED_V/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_ACQ_BUFFER_SIZE/0","title":"Evision.cv_CAP_PROP_XI_ACQ_BUFFER_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT/0","title":"Evision.cv_CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_ACQ_FRAME_BURST_COUNT/0","title":"Evision.cv_CAP_PROP_XI_ACQ_FRAME_BURST_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_ACQ_TIMING_MODE/0","title":"Evision.cv_CAP_PROP_XI_ACQ_TIMING_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT/0","title":"Evision.cv_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE/0","title":"Evision.cv_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AE_MAX_LIMIT/0","title":"Evision.cv_CAP_PROP_XI_AE_MAX_LIMIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AEAG/0","title":"Evision.cv_CAP_PROP_XI_AEAG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AEAG_LEVEL/0","title":"Evision.cv_CAP_PROP_XI_AEAG_LEVEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AEAG_ROI_HEIGHT/0","title":"Evision.cv_CAP_PROP_XI_AEAG_ROI_HEIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AEAG_ROI_OFFSET_X/0","title":"Evision.cv_CAP_PROP_XI_AEAG_ROI_OFFSET_X/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AEAG_ROI_OFFSET_Y/0","title":"Evision.cv_CAP_PROP_XI_AEAG_ROI_OFFSET_Y/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AEAG_ROI_WIDTH/0","title":"Evision.cv_CAP_PROP_XI_AEAG_ROI_WIDTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AG_MAX_LIMIT/0","title":"Evision.cv_CAP_PROP_XI_AG_MAX_LIMIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_APPLY_CMS/0","title":"Evision.cv_CAP_PROP_XI_APPLY_CMS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION/0","title":"Evision.cv_CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AUTO_WB/0","title":"Evision.cv_CAP_PROP_XI_AUTO_WB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_AVAILABLE_BANDWIDTH/0","title":"Evision.cv_CAP_PROP_XI_AVAILABLE_BANDWIDTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_BINNING_HORIZONTAL/0","title":"Evision.cv_CAP_PROP_XI_BINNING_HORIZONTAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_BINNING_PATTERN/0","title":"Evision.cv_CAP_PROP_XI_BINNING_PATTERN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_BINNING_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_BINNING_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_BINNING_VERTICAL/0","title":"Evision.cv_CAP_PROP_XI_BINNING_VERTICAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_BPC/0","title":"Evision.cv_CAP_PROP_XI_BPC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_BUFFER_POLICY/0","title":"Evision.cv_CAP_PROP_XI_BUFFER_POLICY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_BUFFERS_QUEUE_SIZE/0","title":"Evision.cv_CAP_PROP_XI_BUFFERS_QUEUE_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_00/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_00/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_01/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_01/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_02/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_02/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_03/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_03/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_10/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_10/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_11/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_11/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_12/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_13/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_13/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_20/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_20/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_21/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_21/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_22/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_22/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_23/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_23/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_30/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_30/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_31/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_31/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_32/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_32/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CC_MATRIX_33/0","title":"Evision.cv_CAP_PROP_XI_CC_MATRIX_33/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CHIP_TEMP/0","title":"Evision.cv_CAP_PROP_XI_CHIP_TEMP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_CMS/0","title":"Evision.cv_CAP_PROP_XI_CMS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_COLOR_FILTER_ARRAY/0","title":"Evision.cv_CAP_PROP_XI_COLOR_FILTER_ARRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_COLUMN_FPN_CORRECTION/0","title":"Evision.cv_CAP_PROP_XI_COLUMN_FPN_CORRECTION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_COOLING/0","title":"Evision.cv_CAP_PROP_XI_COOLING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_COUNTER_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_COUNTER_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_COUNTER_VALUE/0","title":"Evision.cv_CAP_PROP_XI_COUNTER_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DATA_FORMAT/0","title":"Evision.cv_CAP_PROP_XI_DATA_FORMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEBOUNCE_EN/0","title":"Evision.cv_CAP_PROP_XI_DEBOUNCE_EN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEBOUNCE_POL/0","title":"Evision.cv_CAP_PROP_XI_DEBOUNCE_POL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEBOUNCE_T0/0","title":"Evision.cv_CAP_PROP_XI_DEBOUNCE_T0/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEBOUNCE_T1/0","title":"Evision.cv_CAP_PROP_XI_DEBOUNCE_T1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEBUG_LEVEL/0","title":"Evision.cv_CAP_PROP_XI_DEBUG_LEVEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DECIMATION_HORIZONTAL/0","title":"Evision.cv_CAP_PROP_XI_DECIMATION_HORIZONTAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DECIMATION_PATTERN/0","title":"Evision.cv_CAP_PROP_XI_DECIMATION_PATTERN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DECIMATION_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_DECIMATION_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DECIMATION_VERTICAL/0","title":"Evision.cv_CAP_PROP_XI_DECIMATION_VERTICAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEFAULT_CC_MATRIX/0","title":"Evision.cv_CAP_PROP_XI_DEFAULT_CC_MATRIX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEVICE_MODEL_ID/0","title":"Evision.cv_CAP_PROP_XI_DEVICE_MODEL_ID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEVICE_RESET/0","title":"Evision.cv_CAP_PROP_XI_DEVICE_RESET/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DEVICE_SN/0","title":"Evision.cv_CAP_PROP_XI_DEVICE_SN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DOWNSAMPLING/0","title":"Evision.cv_CAP_PROP_XI_DOWNSAMPLING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_DOWNSAMPLING_TYPE/0","title":"Evision.cv_CAP_PROP_XI_DOWNSAMPLING_TYPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_EXP_PRIORITY/0","title":"Evision.cv_CAP_PROP_XI_EXP_PRIORITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_EXPOSURE/0","title":"Evision.cv_CAP_PROP_XI_EXPOSURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_EXPOSURE_BURST_COUNT/0","title":"Evision.cv_CAP_PROP_XI_EXPOSURE_BURST_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_FFS_ACCESS_KEY/0","title":"Evision.cv_CAP_PROP_XI_FFS_ACCESS_KEY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_FFS_FILE_ID/0","title":"Evision.cv_CAP_PROP_XI_FFS_FILE_ID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_FFS_FILE_SIZE/0","title":"Evision.cv_CAP_PROP_XI_FFS_FILE_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_FRAMERATE/0","title":"Evision.cv_CAP_PROP_XI_FRAMERATE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_FREE_FFS_SIZE/0","title":"Evision.cv_CAP_PROP_XI_FREE_FFS_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GAIN/0","title":"Evision.cv_CAP_PROP_XI_GAIN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GAIN_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_GAIN_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GAMMAC/0","title":"Evision.cv_CAP_PROP_XI_GAMMAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GAMMAY/0","title":"Evision.cv_CAP_PROP_XI_GAMMAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GPI_LEVEL/0","title":"Evision.cv_CAP_PROP_XI_GPI_LEVEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GPI_MODE/0","title":"Evision.cv_CAP_PROP_XI_GPI_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GPI_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_GPI_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GPO_MODE/0","title":"Evision.cv_CAP_PROP_XI_GPO_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_GPO_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_GPO_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HDR/0","title":"Evision.cv_CAP_PROP_XI_HDR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HDR_KNEEPOINT_COUNT/0","title":"Evision.cv_CAP_PROP_XI_HDR_KNEEPOINT_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HDR_T1/0","title":"Evision.cv_CAP_PROP_XI_HDR_T1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HDR_T2/0","title":"Evision.cv_CAP_PROP_XI_HDR_T2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HEIGHT/0","title":"Evision.cv_CAP_PROP_XI_HEIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HOUS_BACK_SIDE_TEMP/0","title":"Evision.cv_CAP_PROP_XI_HOUS_BACK_SIDE_TEMP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HOUS_TEMP/0","title":"Evision.cv_CAP_PROP_XI_HOUS_TEMP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_HW_REVISION/0","title":"Evision.cv_CAP_PROP_XI_HW_REVISION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IMAGE_BLACK_LEVEL/0","title":"Evision.cv_CAP_PROP_XI_IMAGE_BLACK_LEVEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH/0","title":"Evision.cv_CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IMAGE_DATA_FORMAT/0","title":"Evision.cv_CAP_PROP_XI_IMAGE_DATA_FORMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA/0","title":"Evision.cv_CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IMAGE_IS_COLOR/0","title":"Evision.cv_CAP_PROP_XI_IMAGE_IS_COLOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IMAGE_PAYLOAD_SIZE/0","title":"Evision.cv_CAP_PROP_XI_IMAGE_PAYLOAD_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IS_COOLED/0","title":"Evision.cv_CAP_PROP_XI_IS_COOLED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_IS_DEVICE_EXIST/0","title":"Evision.cv_CAP_PROP_XI_IS_DEVICE_EXIST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_KNEEPOINT1/0","title":"Evision.cv_CAP_PROP_XI_KNEEPOINT1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_KNEEPOINT2/0","title":"Evision.cv_CAP_PROP_XI_KNEEPOINT2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LED_MODE/0","title":"Evision.cv_CAP_PROP_XI_LED_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LED_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_LED_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_APERTURE_VALUE/0","title":"Evision.cv_CAP_PROP_XI_LENS_APERTURE_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_FEATURE/0","title":"Evision.cv_CAP_PROP_XI_LENS_FEATURE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_FEATURE_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_LENS_FEATURE_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_FOCAL_LENGTH/0","title":"Evision.cv_CAP_PROP_XI_LENS_FOCAL_LENGTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_FOCUS_DISTANCE/0","title":"Evision.cv_CAP_PROP_XI_LENS_FOCUS_DISTANCE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_FOCUS_MOVE/0","title":"Evision.cv_CAP_PROP_XI_LENS_FOCUS_MOVE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE/0","title":"Evision.cv_CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LENS_MODE/0","title":"Evision.cv_CAP_PROP_XI_LENS_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LIMIT_BANDWIDTH/0","title":"Evision.cv_CAP_PROP_XI_LIMIT_BANDWIDTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LUT_EN/0","title":"Evision.cv_CAP_PROP_XI_LUT_EN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LUT_INDEX/0","title":"Evision.cv_CAP_PROP_XI_LUT_INDEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_LUT_VALUE/0","title":"Evision.cv_CAP_PROP_XI_LUT_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_MANUAL_WB/0","title":"Evision.cv_CAP_PROP_XI_MANUAL_WB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_OFFSET_X/0","title":"Evision.cv_CAP_PROP_XI_OFFSET_X/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_OFFSET_Y/0","title":"Evision.cv_CAP_PROP_XI_OFFSET_Y/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH/0","title":"Evision.cv_CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_OUTPUT_DATA_PACKING/0","title":"Evision.cv_CAP_PROP_XI_OUTPUT_DATA_PACKING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE/0","title":"Evision.cv_CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_RECENT_FRAME/0","title":"Evision.cv_CAP_PROP_XI_RECENT_FRAME/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_REGION_MODE/0","title":"Evision.cv_CAP_PROP_XI_REGION_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_REGION_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_REGION_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_ROW_FPN_CORRECTION/0","title":"Evision.cv_CAP_PROP_XI_ROW_FPN_CORRECTION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_BOARD_TEMP/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_BOARD_TEMP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_FEATURE_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_FEATURE_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_FEATURE_VALUE/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_FEATURE_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_MODE/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SENSOR_TAPS/0","title":"Evision.cv_CAP_PROP_XI_SENSOR_TAPS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SHARPNESS/0","title":"Evision.cv_CAP_PROP_XI_SHARPNESS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_SHUTTER_TYPE/0","title":"Evision.cv_CAP_PROP_XI_SHUTTER_TYPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TARGET_TEMP/0","title":"Evision.cv_CAP_PROP_XI_TARGET_TEMP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TEST_PATTERN/0","title":"Evision.cv_CAP_PROP_XI_TEST_PATTERN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TIMEOUT/0","title":"Evision.cv_CAP_PROP_XI_TIMEOUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT/0","title":"Evision.cv_CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TRG_DELAY/0","title":"Evision.cv_CAP_PROP_XI_TRG_DELAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TRG_SELECTOR/0","title":"Evision.cv_CAP_PROP_XI_TRG_SELECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TRG_SOFTWARE/0","title":"Evision.cv_CAP_PROP_XI_TRG_SOFTWARE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TRG_SOURCE/0","title":"Evision.cv_CAP_PROP_XI_TRG_SOURCE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TS_RST_MODE/0","title":"Evision.cv_CAP_PROP_XI_TS_RST_MODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_TS_RST_SOURCE/0","title":"Evision.cv_CAP_PROP_XI_TS_RST_SOURCE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_USED_FFS_SIZE/0","title":"Evision.cv_CAP_PROP_XI_USED_FFS_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_WB_KB/0","title":"Evision.cv_CAP_PROP_XI_WB_KB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_WB_KG/0","title":"Evision.cv_CAP_PROP_XI_WB_KG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_WB_KR/0","title":"Evision.cv_CAP_PROP_XI_WB_KR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_XI_WIDTH/0","title":"Evision.cv_CAP_PROP_XI_WIDTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PROP_ZOOM/0","title":"Evision.cv_CAP_PROP_ZOOM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI/0","title":"Evision.cv_CAP_PVAPI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_DECIMATION_2OUTOF4/0","title":"Evision.cv_CAP_PVAPI_DECIMATION_2OUTOF4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_DECIMATION_2OUTOF8/0","title":"Evision.cv_CAP_PVAPI_DECIMATION_2OUTOF8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_DECIMATION_2OUTOF16/0","title":"Evision.cv_CAP_PVAPI_DECIMATION_2OUTOF16/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_DECIMATION_OFF/0","title":"Evision.cv_CAP_PVAPI_DECIMATION_OFF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_FSTRIGMODE_FIXEDRATE/0","title":"Evision.cv_CAP_PVAPI_FSTRIGMODE_FIXEDRATE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_FSTRIGMODE_FREERUN/0","title":"Evision.cv_CAP_PVAPI_FSTRIGMODE_FREERUN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_FSTRIGMODE_SOFTWARE/0","title":"Evision.cv_CAP_PVAPI_FSTRIGMODE_SOFTWARE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_FSTRIGMODE_SYNCIN1/0","title":"Evision.cv_CAP_PVAPI_FSTRIGMODE_SYNCIN1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_FSTRIGMODE_SYNCIN2/0","title":"Evision.cv_CAP_PVAPI_FSTRIGMODE_SYNCIN2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_BAYER8/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_BAYER8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_BAYER16/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_BAYER16/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_BGR24/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_BGR24/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_BGRA32/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_BGRA32/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_MONO8/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_MONO8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_MONO16/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_MONO16/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_RGB24/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_RGB24/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_PVAPI_PIXELFORMAT_RGBA32/0","title":"Evision.cv_CAP_PVAPI_PIXELFORMAT_RGBA32/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_QT/0","title":"Evision.cv_CAP_QT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_REALSENSE/0","title":"Evision.cv_CAP_REALSENSE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_UEYE/0","title":"Evision.cv_CAP_UEYE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_UNICAP/0","title":"Evision.cv_CAP_UNICAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_V4L2/0","title":"Evision.cv_CAP_V4L2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_V4L/0","title":"Evision.cv_CAP_V4L/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_VFW/0","title":"Evision.cv_CAP_VFW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_WINRT/0","title":"Evision.cv_CAP_WINRT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_XIAPI/0","title":"Evision.cv_CAP_XIAPI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CAP_XINE/0","title":"Evision.cv_CAP_XINE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CASCADE_DO_CANNY_PRUNING/0","title":"Evision.cv_CASCADE_DO_CANNY_PRUNING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CASCADE_DO_ROUGH_SEARCH/0","title":"Evision.cv_CASCADE_DO_ROUGH_SEARCH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CASCADE_FIND_BIGGEST_OBJECT/0","title":"Evision.cv_CASCADE_FIND_BIGGEST_OBJECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CASCADE_SCALE_IMAGE/0","title":"Evision.cv_CASCADE_SCALE_IMAGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CC_STAT_AREA/0","title":"Evision.cv_CC_STAT_AREA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CC_STAT_HEIGHT/0","title":"Evision.cv_CC_STAT_HEIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CC_STAT_LEFT/0","title":"Evision.cv_CC_STAT_LEFT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CC_STAT_MAX/0","title":"Evision.cv_CC_STAT_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CC_STAT_TOP/0","title":"Evision.cv_CC_STAT_TOP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CC_STAT_WIDTH/0","title":"Evision.cv_CC_STAT_WIDTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CCL_BBDT/0","title":"Evision.cv_CCL_BBDT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CCL_BOLELLI/0","title":"Evision.cv_CCL_BOLELLI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CCL_DEFAULT/0","title":"Evision.cv_CCL_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CCL_GRANA/0","title":"Evision.cv_CCL_GRANA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CCL_SAUF/0","title":"Evision.cv_CCL_SAUF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CCL_SPAGHETTI/0","title":"Evision.cv_CCL_SPAGHETTI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CCL_WU/0","title":"Evision.cv_CCL_WU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CHAIN_APPROX_NONE/0","title":"Evision.cv_CHAIN_APPROX_NONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CHAIN_APPROX_SIMPLE/0","title":"Evision.cv_CHAIN_APPROX_SIMPLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CHAIN_APPROX_TC89_KCOS/0","title":"Evision.cv_CHAIN_APPROX_TC89_KCOS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CHAIN_APPROX_TC89_L1/0","title":"Evision.cv_CHAIN_APPROX_TC89_L1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CHANNELS/0","title":"Evision.cv_CHANNELS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CHANNELS_BLOCKS/0","title":"Evision.cv_CHANNELS_BLOCKS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CHI2/0","title":"Evision.cv_CHI2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CMP_EQ/0","title":"Evision.cv_CMP_EQ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CMP_GE/0","title":"Evision.cv_CMP_GE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CMP_GT/0","title":"Evision.cv_CMP_GT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CMP_LE/0","title":"Evision.cv_CMP_LE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CMP_LT/0","title":"Evision.cv_CMP_LT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CMP_NE/0","title":"Evision.cv_CMP_NE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COEF/0","title":"Evision.cv_COEF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COL_SAMPLE/0","title":"Evision.cv_COL_SAMPLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR/0","title":"Evision.cv_COLOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2BGR/0","title":"Evision.cv_COLOR_BayerBG2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2BGR_EA/0","title":"Evision.cv_COLOR_BayerBG2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2BGR_VNG/0","title":"Evision.cv_COLOR_BayerBG2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2BGRA/0","title":"Evision.cv_COLOR_BayerBG2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2GRAY/0","title":"Evision.cv_COLOR_BayerBG2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2RGB/0","title":"Evision.cv_COLOR_BayerBG2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2RGB_EA/0","title":"Evision.cv_COLOR_BayerBG2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2RGB_VNG/0","title":"Evision.cv_COLOR_BayerBG2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBG2RGBA/0","title":"Evision.cv_COLOR_BayerBG2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2BGR/0","title":"Evision.cv_COLOR_BayerBGGR2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2BGR_EA/0","title":"Evision.cv_COLOR_BayerBGGR2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2BGR_VNG/0","title":"Evision.cv_COLOR_BayerBGGR2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2BGRA/0","title":"Evision.cv_COLOR_BayerBGGR2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2GRAY/0","title":"Evision.cv_COLOR_BayerBGGR2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2RGB/0","title":"Evision.cv_COLOR_BayerBGGR2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2RGB_EA/0","title":"Evision.cv_COLOR_BayerBGGR2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2RGB_VNG/0","title":"Evision.cv_COLOR_BayerBGGR2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerBGGR2RGBA/0","title":"Evision.cv_COLOR_BayerBGGR2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2BGR/0","title":"Evision.cv_COLOR_BayerGB2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2BGR_EA/0","title":"Evision.cv_COLOR_BayerGB2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2BGR_VNG/0","title":"Evision.cv_COLOR_BayerGB2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2BGRA/0","title":"Evision.cv_COLOR_BayerGB2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2GRAY/0","title":"Evision.cv_COLOR_BayerGB2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2RGB/0","title":"Evision.cv_COLOR_BayerGB2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2RGB_EA/0","title":"Evision.cv_COLOR_BayerGB2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2RGB_VNG/0","title":"Evision.cv_COLOR_BayerGB2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGB2RGBA/0","title":"Evision.cv_COLOR_BayerGB2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2BGR/0","title":"Evision.cv_COLOR_BayerGBRG2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2BGR_EA/0","title":"Evision.cv_COLOR_BayerGBRG2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2BGR_VNG/0","title":"Evision.cv_COLOR_BayerGBRG2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2BGRA/0","title":"Evision.cv_COLOR_BayerGBRG2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2GRAY/0","title":"Evision.cv_COLOR_BayerGBRG2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2RGB/0","title":"Evision.cv_COLOR_BayerGBRG2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2RGB_EA/0","title":"Evision.cv_COLOR_BayerGBRG2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2RGB_VNG/0","title":"Evision.cv_COLOR_BayerGBRG2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGBRG2RGBA/0","title":"Evision.cv_COLOR_BayerGBRG2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2BGR/0","title":"Evision.cv_COLOR_BayerGR2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2BGR_EA/0","title":"Evision.cv_COLOR_BayerGR2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2BGR_VNG/0","title":"Evision.cv_COLOR_BayerGR2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2BGRA/0","title":"Evision.cv_COLOR_BayerGR2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2GRAY/0","title":"Evision.cv_COLOR_BayerGR2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2RGB/0","title":"Evision.cv_COLOR_BayerGR2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2RGB_EA/0","title":"Evision.cv_COLOR_BayerGR2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2RGB_VNG/0","title":"Evision.cv_COLOR_BayerGR2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGR2RGBA/0","title":"Evision.cv_COLOR_BayerGR2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2BGR/0","title":"Evision.cv_COLOR_BayerGRBG2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2BGR_EA/0","title":"Evision.cv_COLOR_BayerGRBG2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2BGR_VNG/0","title":"Evision.cv_COLOR_BayerGRBG2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2BGRA/0","title":"Evision.cv_COLOR_BayerGRBG2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2GRAY/0","title":"Evision.cv_COLOR_BayerGRBG2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2RGB/0","title":"Evision.cv_COLOR_BayerGRBG2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2RGB_EA/0","title":"Evision.cv_COLOR_BayerGRBG2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2RGB_VNG/0","title":"Evision.cv_COLOR_BayerGRBG2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerGRBG2RGBA/0","title":"Evision.cv_COLOR_BayerGRBG2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2BGR/0","title":"Evision.cv_COLOR_BayerRG2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2BGR_EA/0","title":"Evision.cv_COLOR_BayerRG2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2BGR_VNG/0","title":"Evision.cv_COLOR_BayerRG2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2BGRA/0","title":"Evision.cv_COLOR_BayerRG2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2GRAY/0","title":"Evision.cv_COLOR_BayerRG2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2RGB/0","title":"Evision.cv_COLOR_BayerRG2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2RGB_EA/0","title":"Evision.cv_COLOR_BayerRG2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2RGB_VNG/0","title":"Evision.cv_COLOR_BayerRG2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRG2RGBA/0","title":"Evision.cv_COLOR_BayerRG2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2BGR/0","title":"Evision.cv_COLOR_BayerRGGB2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2BGR_EA/0","title":"Evision.cv_COLOR_BayerRGGB2BGR_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2BGR_VNG/0","title":"Evision.cv_COLOR_BayerRGGB2BGR_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2BGRA/0","title":"Evision.cv_COLOR_BayerRGGB2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2GRAY/0","title":"Evision.cv_COLOR_BayerRGGB2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2RGB/0","title":"Evision.cv_COLOR_BayerRGGB2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2RGB_EA/0","title":"Evision.cv_COLOR_BayerRGGB2RGB_EA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2RGB_VNG/0","title":"Evision.cv_COLOR_BayerRGGB2RGB_VNG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BayerRGGB2RGBA/0","title":"Evision.cv_COLOR_BayerRGGB2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2BGR555/0","title":"Evision.cv_COLOR_BGR2BGR555/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2BGR565/0","title":"Evision.cv_COLOR_BGR2BGR565/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2BGRA/0","title":"Evision.cv_COLOR_BGR2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2GRAY/0","title":"Evision.cv_COLOR_BGR2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2HLS/0","title":"Evision.cv_COLOR_BGR2HLS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2HLS_FULL/0","title":"Evision.cv_COLOR_BGR2HLS_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2HSV/0","title":"Evision.cv_COLOR_BGR2HSV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2HSV_FULL/0","title":"Evision.cv_COLOR_BGR2HSV_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2Lab/0","title":"Evision.cv_COLOR_BGR2Lab/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2Luv/0","title":"Evision.cv_COLOR_BGR2Luv/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2RGB/0","title":"Evision.cv_COLOR_BGR2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2RGBA/0","title":"Evision.cv_COLOR_BGR2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2XYZ/0","title":"Evision.cv_COLOR_BGR2XYZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2YCrCb/0","title":"Evision.cv_COLOR_BGR2YCrCb/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2YUV/0","title":"Evision.cv_COLOR_BGR2YUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2YUV_I420/0","title":"Evision.cv_COLOR_BGR2YUV_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2YUV_IYUV/0","title":"Evision.cv_COLOR_BGR2YUV_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR2YUV_YV12/0","title":"Evision.cv_COLOR_BGR2YUV_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5552BGR/0","title":"Evision.cv_COLOR_BGR5552BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5552BGRA/0","title":"Evision.cv_COLOR_BGR5552BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5552GRAY/0","title":"Evision.cv_COLOR_BGR5552GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5552RGB/0","title":"Evision.cv_COLOR_BGR5552RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5552RGBA/0","title":"Evision.cv_COLOR_BGR5552RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5652BGR/0","title":"Evision.cv_COLOR_BGR5652BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5652BGRA/0","title":"Evision.cv_COLOR_BGR5652BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5652GRAY/0","title":"Evision.cv_COLOR_BGR5652GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5652RGB/0","title":"Evision.cv_COLOR_BGR5652RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGR5652RGBA/0","title":"Evision.cv_COLOR_BGR5652RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2BGR555/0","title":"Evision.cv_COLOR_BGRA2BGR555/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2BGR565/0","title":"Evision.cv_COLOR_BGRA2BGR565/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2BGR/0","title":"Evision.cv_COLOR_BGRA2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2GRAY/0","title":"Evision.cv_COLOR_BGRA2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2RGB/0","title":"Evision.cv_COLOR_BGRA2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2RGBA/0","title":"Evision.cv_COLOR_BGRA2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2YUV_I420/0","title":"Evision.cv_COLOR_BGRA2YUV_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2YUV_IYUV/0","title":"Evision.cv_COLOR_BGRA2YUV_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_BGRA2YUV_YV12/0","title":"Evision.cv_COLOR_BGRA2YUV_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_COLORCVT_MAX/0","title":"Evision.cv_COLOR_COLORCVT_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_GRAD/0","title":"Evision.cv_COLOR_GRAD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_GRAY2BGR555/0","title":"Evision.cv_COLOR_GRAY2BGR555/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_GRAY2BGR565/0","title":"Evision.cv_COLOR_GRAY2BGR565/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_GRAY2BGR/0","title":"Evision.cv_COLOR_GRAY2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_GRAY2BGRA/0","title":"Evision.cv_COLOR_GRAY2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_GRAY2RGB/0","title":"Evision.cv_COLOR_GRAY2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_GRAY2RGBA/0","title":"Evision.cv_COLOR_GRAY2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HLS2BGR/0","title":"Evision.cv_COLOR_HLS2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HLS2BGR_FULL/0","title":"Evision.cv_COLOR_HLS2BGR_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HLS2RGB/0","title":"Evision.cv_COLOR_HLS2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HLS2RGB_FULL/0","title":"Evision.cv_COLOR_HLS2RGB_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HSV2BGR/0","title":"Evision.cv_COLOR_HSV2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HSV2BGR_FULL/0","title":"Evision.cv_COLOR_HSV2BGR_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HSV2RGB/0","title":"Evision.cv_COLOR_HSV2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_HSV2RGB_FULL/0","title":"Evision.cv_COLOR_HSV2RGB_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Lab2BGR/0","title":"Evision.cv_COLOR_Lab2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Lab2LBGR/0","title":"Evision.cv_COLOR_Lab2LBGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Lab2LRGB/0","title":"Evision.cv_COLOR_Lab2LRGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Lab2RGB/0","title":"Evision.cv_COLOR_Lab2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_LBGR2Lab/0","title":"Evision.cv_COLOR_LBGR2Lab/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_LBGR2Luv/0","title":"Evision.cv_COLOR_LBGR2Luv/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_LRGB2Lab/0","title":"Evision.cv_COLOR_LRGB2Lab/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_LRGB2Luv/0","title":"Evision.cv_COLOR_LRGB2Luv/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Luv2BGR/0","title":"Evision.cv_COLOR_Luv2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Luv2LBGR/0","title":"Evision.cv_COLOR_Luv2LBGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Luv2LRGB/0","title":"Evision.cv_COLOR_Luv2LRGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_Luv2RGB/0","title":"Evision.cv_COLOR_Luv2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_mRGBA2RGBA/0","title":"Evision.cv_COLOR_mRGBA2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2BGR555/0","title":"Evision.cv_COLOR_RGB2BGR555/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2BGR565/0","title":"Evision.cv_COLOR_RGB2BGR565/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2BGR/0","title":"Evision.cv_COLOR_RGB2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2BGRA/0","title":"Evision.cv_COLOR_RGB2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2GRAY/0","title":"Evision.cv_COLOR_RGB2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2HLS/0","title":"Evision.cv_COLOR_RGB2HLS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2HLS_FULL/0","title":"Evision.cv_COLOR_RGB2HLS_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2HSV/0","title":"Evision.cv_COLOR_RGB2HSV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2HSV_FULL/0","title":"Evision.cv_COLOR_RGB2HSV_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2Lab/0","title":"Evision.cv_COLOR_RGB2Lab/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2Luv/0","title":"Evision.cv_COLOR_RGB2Luv/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2RGBA/0","title":"Evision.cv_COLOR_RGB2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2XYZ/0","title":"Evision.cv_COLOR_RGB2XYZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2YCrCb/0","title":"Evision.cv_COLOR_RGB2YCrCb/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2YUV/0","title":"Evision.cv_COLOR_RGB2YUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2YUV_I420/0","title":"Evision.cv_COLOR_RGB2YUV_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2YUV_IYUV/0","title":"Evision.cv_COLOR_RGB2YUV_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGB2YUV_YV12/0","title":"Evision.cv_COLOR_RGB2YUV_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2BGR555/0","title":"Evision.cv_COLOR_RGBA2BGR555/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2BGR565/0","title":"Evision.cv_COLOR_RGBA2BGR565/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2BGR/0","title":"Evision.cv_COLOR_RGBA2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2BGRA/0","title":"Evision.cv_COLOR_RGBA2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2GRAY/0","title":"Evision.cv_COLOR_RGBA2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2mRGBA/0","title":"Evision.cv_COLOR_RGBA2mRGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2RGB/0","title":"Evision.cv_COLOR_RGBA2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2YUV_I420/0","title":"Evision.cv_COLOR_RGBA2YUV_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2YUV_IYUV/0","title":"Evision.cv_COLOR_RGBA2YUV_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_RGBA2YUV_YV12/0","title":"Evision.cv_COLOR_RGBA2YUV_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_XYZ2BGR/0","title":"Evision.cv_COLOR_XYZ2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_XYZ2RGB/0","title":"Evision.cv_COLOR_XYZ2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YCrCb2BGR/0","title":"Evision.cv_COLOR_YCrCb2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YCrCb2RGB/0","title":"Evision.cv_COLOR_YCrCb2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR/0","title":"Evision.cv_COLOR_YUV2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_I420/0","title":"Evision.cv_COLOR_YUV2BGR_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_IYUV/0","title":"Evision.cv_COLOR_YUV2BGR_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_NV12/0","title":"Evision.cv_COLOR_YUV2BGR_NV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_NV21/0","title":"Evision.cv_COLOR_YUV2BGR_NV21/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_UYNV/0","title":"Evision.cv_COLOR_YUV2BGR_UYNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_UYVY/0","title":"Evision.cv_COLOR_YUV2BGR_UYVY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_Y422/0","title":"Evision.cv_COLOR_YUV2BGR_Y422/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_YUNV/0","title":"Evision.cv_COLOR_YUV2BGR_YUNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_YUY2/0","title":"Evision.cv_COLOR_YUV2BGR_YUY2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_YUYV/0","title":"Evision.cv_COLOR_YUV2BGR_YUYV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_YV12/0","title":"Evision.cv_COLOR_YUV2BGR_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGR_YVYU/0","title":"Evision.cv_COLOR_YUV2BGR_YVYU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_I420/0","title":"Evision.cv_COLOR_YUV2BGRA_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_IYUV/0","title":"Evision.cv_COLOR_YUV2BGRA_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_NV12/0","title":"Evision.cv_COLOR_YUV2BGRA_NV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_NV21/0","title":"Evision.cv_COLOR_YUV2BGRA_NV21/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_UYNV/0","title":"Evision.cv_COLOR_YUV2BGRA_UYNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_UYVY/0","title":"Evision.cv_COLOR_YUV2BGRA_UYVY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_Y422/0","title":"Evision.cv_COLOR_YUV2BGRA_Y422/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_YUNV/0","title":"Evision.cv_COLOR_YUV2BGRA_YUNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_YUY2/0","title":"Evision.cv_COLOR_YUV2BGRA_YUY2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_YUYV/0","title":"Evision.cv_COLOR_YUV2BGRA_YUYV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_YV12/0","title":"Evision.cv_COLOR_YUV2BGRA_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2BGRA_YVYU/0","title":"Evision.cv_COLOR_YUV2BGRA_YVYU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_420/0","title":"Evision.cv_COLOR_YUV2GRAY_420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_I420/0","title":"Evision.cv_COLOR_YUV2GRAY_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_IYUV/0","title":"Evision.cv_COLOR_YUV2GRAY_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_NV12/0","title":"Evision.cv_COLOR_YUV2GRAY_NV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_NV21/0","title":"Evision.cv_COLOR_YUV2GRAY_NV21/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_UYNV/0","title":"Evision.cv_COLOR_YUV2GRAY_UYNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_UYVY/0","title":"Evision.cv_COLOR_YUV2GRAY_UYVY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_Y422/0","title":"Evision.cv_COLOR_YUV2GRAY_Y422/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_YUNV/0","title":"Evision.cv_COLOR_YUV2GRAY_YUNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_YUY2/0","title":"Evision.cv_COLOR_YUV2GRAY_YUY2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_YUYV/0","title":"Evision.cv_COLOR_YUV2GRAY_YUYV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_YV12/0","title":"Evision.cv_COLOR_YUV2GRAY_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2GRAY_YVYU/0","title":"Evision.cv_COLOR_YUV2GRAY_YVYU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB/0","title":"Evision.cv_COLOR_YUV2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_I420/0","title":"Evision.cv_COLOR_YUV2RGB_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_IYUV/0","title":"Evision.cv_COLOR_YUV2RGB_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_NV12/0","title":"Evision.cv_COLOR_YUV2RGB_NV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_NV21/0","title":"Evision.cv_COLOR_YUV2RGB_NV21/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_UYNV/0","title":"Evision.cv_COLOR_YUV2RGB_UYNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_UYVY/0","title":"Evision.cv_COLOR_YUV2RGB_UYVY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_Y422/0","title":"Evision.cv_COLOR_YUV2RGB_Y422/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_YUNV/0","title":"Evision.cv_COLOR_YUV2RGB_YUNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_YUY2/0","title":"Evision.cv_COLOR_YUV2RGB_YUY2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_YUYV/0","title":"Evision.cv_COLOR_YUV2RGB_YUYV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_YV12/0","title":"Evision.cv_COLOR_YUV2RGB_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGB_YVYU/0","title":"Evision.cv_COLOR_YUV2RGB_YVYU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_I420/0","title":"Evision.cv_COLOR_YUV2RGBA_I420/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_IYUV/0","title":"Evision.cv_COLOR_YUV2RGBA_IYUV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_NV12/0","title":"Evision.cv_COLOR_YUV2RGBA_NV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_NV21/0","title":"Evision.cv_COLOR_YUV2RGBA_NV21/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_UYNV/0","title":"Evision.cv_COLOR_YUV2RGBA_UYNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_UYVY/0","title":"Evision.cv_COLOR_YUV2RGBA_UYVY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_Y422/0","title":"Evision.cv_COLOR_YUV2RGBA_Y422/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_YUNV/0","title":"Evision.cv_COLOR_YUV2RGBA_YUNV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_YUY2/0","title":"Evision.cv_COLOR_YUV2RGBA_YUY2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_YUYV/0","title":"Evision.cv_COLOR_YUV2RGBA_YUYV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_YV12/0","title":"Evision.cv_COLOR_YUV2RGBA_YV12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV2RGBA_YVYU/0","title":"Evision.cv_COLOR_YUV2RGBA_YVYU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420p2BGR/0","title":"Evision.cv_COLOR_YUV420p2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420p2BGRA/0","title":"Evision.cv_COLOR_YUV420p2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420p2GRAY/0","title":"Evision.cv_COLOR_YUV420p2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420p2RGB/0","title":"Evision.cv_COLOR_YUV420p2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420p2RGBA/0","title":"Evision.cv_COLOR_YUV420p2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420sp2BGR/0","title":"Evision.cv_COLOR_YUV420sp2BGR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420sp2BGRA/0","title":"Evision.cv_COLOR_YUV420sp2BGRA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420sp2GRAY/0","title":"Evision.cv_COLOR_YUV420sp2GRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420sp2RGB/0","title":"Evision.cv_COLOR_YUV420sp2RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLOR_YUV420sp2RGBA/0","title":"Evision.cv_COLOR_YUV420sp2RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_AUTUMN/0","title":"Evision.cv_COLORMAP_AUTUMN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_BONE/0","title":"Evision.cv_COLORMAP_BONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_CIVIDIS/0","title":"Evision.cv_COLORMAP_CIVIDIS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_COOL/0","title":"Evision.cv_COLORMAP_COOL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_DEEPGREEN/0","title":"Evision.cv_COLORMAP_DEEPGREEN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_HOT/0","title":"Evision.cv_COLORMAP_HOT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_HSV/0","title":"Evision.cv_COLORMAP_HSV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_INFERNO/0","title":"Evision.cv_COLORMAP_INFERNO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_JET/0","title":"Evision.cv_COLORMAP_JET/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_MAGMA/0","title":"Evision.cv_COLORMAP_MAGMA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_OCEAN/0","title":"Evision.cv_COLORMAP_OCEAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_PARULA/0","title":"Evision.cv_COLORMAP_PARULA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_PINK/0","title":"Evision.cv_COLORMAP_PINK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_PLASMA/0","title":"Evision.cv_COLORMAP_PLASMA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_RAINBOW/0","title":"Evision.cv_COLORMAP_RAINBOW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_SPRING/0","title":"Evision.cv_COLORMAP_SPRING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_SUMMER/0","title":"Evision.cv_COLORMAP_SUMMER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_TURBO/0","title":"Evision.cv_COLORMAP_TURBO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_TWILIGHT/0","title":"Evision.cv_COLORMAP_TWILIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_TWILIGHT_SHIFTED/0","title":"Evision.cv_COLORMAP_TWILIGHT_SHIFTED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_VIRIDIS/0","title":"Evision.cv_COLORMAP_VIRIDIS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COLORMAP_WINTER/0","title":"Evision.cv_COLORMAP_WINTER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COMPRESSED_INPUT/0","title":"Evision.cv_COMPRESSED_INPUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CONSTANT/0","title":"Evision.cv_CONSTANT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CONTOURS_MATCH_I1/0","title":"Evision.cv_CONTOURS_MATCH_I1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CONTOURS_MATCH_I2/0","title":"Evision.cv_CONTOURS_MATCH_I2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CONTOURS_MATCH_I3/0","title":"Evision.cv_CONTOURS_MATCH_I3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COPY_ON_MAP/0","title":"Evision.cv_COPY_ON_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CORRECT_LEVEL_H/0","title":"Evision.cv_CORRECT_LEVEL_H/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CORRECT_LEVEL_L/0","title":"Evision.cv_CORRECT_LEVEL_L/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CORRECT_LEVEL_M/0","title":"Evision.cv_CORRECT_LEVEL_M/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CORRECT_LEVEL_Q/0","title":"Evision.cv_CORRECT_LEVEL_Q/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COST_COLOR/0","title":"Evision.cv_COST_COLOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COST_COLOR_GRAD/0","title":"Evision.cv_COST_COLOR_GRAD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COUNT/0","title":"Evision.cv_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COV_MAT_DEFAULT/0","title":"Evision.cv_COV_MAT_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COV_MAT_DIAGONAL/0","title":"Evision.cv_COV_MAT_DIAGONAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COV_MAT_GENERIC/0","title":"Evision.cv_COV_MAT_GENERIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COV_MAT_SPHERICAL/0","title":"Evision.cv_COV_MAT_SPHERICAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COVAR_COLS/0","title":"Evision.cv_COVAR_COLS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COVAR_NORMAL/0","title":"Evision.cv_COVAR_NORMAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COVAR_ROWS/0","title":"Evision.cv_COVAR_ROWS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COVAR_SCALE/0","title":"Evision.cv_COVAR_SCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COVAR_SCRAMBLED/0","title":"Evision.cv_COVAR_SCRAMBLED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_COVAR_USE_AVG/0","title":"Evision.cv_COVAR_USE_AVG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ComputeModeDefault/0","title":"Evision.cv_ComputeModeDefault/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ComputeModeExclusive/0","title":"Evision.cv_ComputeModeExclusive/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ComputeModeExclusiveProcess/0","title":"Evision.cv_ComputeModeExclusiveProcess/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ComputeModeProhibited/0","title":"Evision.cv_ComputeModeProhibited/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CROP/0","title":"Evision.cv_CROP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CUDA_GPU_MAT/0","title":"Evision.cv_CUDA_GPU_MAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CUDA_HOST_MEM/0","title":"Evision.cv_CUDA_HOST_MEM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_CUSTOM/0","title":"Evision.cv_CUSTOM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_cn_shift/0","title":"Evision.cv_cn_shift/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DATA_AS_COL/0","title":"Evision.cv_DATA_AS_COL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DATA_AS_ROW/0","title":"Evision.cv_DATA_AS_ROW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DCT_INVERSE/0","title":"Evision.cv_DCT_INVERSE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DCT_ROWS/0","title":"Evision.cv_DCT_ROWS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DECOMP_CHOLESKY/0","title":"Evision.cv_DECOMP_CHOLESKY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DECOMP_EIG/0","title":"Evision.cv_DECOMP_EIG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DECOMP_LU/0","title":"Evision.cv_DECOMP_LU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DECOMP_NORMAL/0","title":"Evision.cv_DECOMP_NORMAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DECOMP_QR/0","title":"Evision.cv_DECOMP_QR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DECOMP_SVD/0","title":"Evision.cv_DECOMP_SVD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEFAULT/0","title":"Evision.cv_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEFAULT_MAX_ITERS/0","title":"Evision.cv_DEFAULT_MAX_ITERS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEFAULT_NCLUSTERS/0","title":"Evision.cv_DEFAULT_NCLUSTERS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEFAULT_NLEVELS/0","title":"Evision.cv_DEFAULT_NLEVELS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEGREE/0","title":"Evision.cv_DEGREE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_COMPONENT/0","title":"Evision.cv_DEPTH_COMPONENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK/0","title":"Evision.cv_DEPTH_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_8S/0","title":"Evision.cv_DEPTH_MASK_8S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_8U/0","title":"Evision.cv_DEPTH_MASK_8U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_16F/0","title":"Evision.cv_DEPTH_MASK_16F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_16S/0","title":"Evision.cv_DEPTH_MASK_16S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_16U/0","title":"Evision.cv_DEPTH_MASK_16U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_32F/0","title":"Evision.cv_DEPTH_MASK_32F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_32S/0","title":"Evision.cv_DEPTH_MASK_32S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_64F/0","title":"Evision.cv_DEPTH_MASK_64F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_ALL/0","title":"Evision.cv_DEPTH_MASK_ALL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_ALL_16F/0","title":"Evision.cv_DEPTH_MASK_ALL_16F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_ALL_BUT_8S/0","title":"Evision.cv_DEPTH_MASK_ALL_BUT_8S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEPTH_MASK_FLT/0","title":"Evision.cv_DEPTH_MASK_FLT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DESCR_FORMAT_COL_BY_COL/0","title":"Evision.cv_DESCR_FORMAT_COL_BY_COL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DESCR_FORMAT_ROW_BY_ROW/0","title":"Evision.cv_DESCR_FORMAT_ROW_BY_ROW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DESCRIPTOR_KAZE/0","title":"Evision.cv_DESCRIPTOR_KAZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DESCRIPTOR_KAZE_UPRIGHT/0","title":"Evision.cv_DESCRIPTOR_KAZE_UPRIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DESCRIPTOR_MLDB/0","title":"Evision.cv_DESCRIPTOR_MLDB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DESCRIPTOR_MLDB_UPRIGHT/0","title":"Evision.cv_DESCRIPTOR_MLDB_UPRIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEVICE_COPY_OBSOLETE/0","title":"Evision.cv_DEVICE_COPY_OBSOLETE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DEVICE_MEM_MAPPED/0","title":"Evision.cv_DEVICE_MEM_MAPPED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DFT_COMPLEX_INPUT/0","title":"Evision.cv_DFT_COMPLEX_INPUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DFT_COMPLEX_OUTPUT/0","title":"Evision.cv_DFT_COMPLEX_OUTPUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DFT_INVERSE/0","title":"Evision.cv_DFT_INVERSE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DFT_REAL_OUTPUT/0","title":"Evision.cv_DFT_REAL_OUTPUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DFT_ROWS/0","title":"Evision.cv_DFT_ROWS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DFT_SCALE/0","title":"Evision.cv_DFT_SCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIFF_CHARBONNIER/0","title":"Evision.cv_DIFF_CHARBONNIER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIFF_PM_G1/0","title":"Evision.cv_DIFF_PM_G1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIFF_PM_G2/0","title":"Evision.cv_DIFF_PM_G2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIFF_WEICKERT/0","title":"Evision.cv_DIFF_WEICKERT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DISABLE_TIMING/0","title":"Evision.cv_DISABLE_TIMING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DISCRETE/0","title":"Evision.cv_DISCRETE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DISP_SCALE/0","title":"Evision.cv_DISP_SCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DISP_SHIFT/0","title":"Evision.cv_DISP_SHIFT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_C/0","title":"Evision.cv_DIST_C/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_FAIR/0","title":"Evision.cv_DIST_FAIR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_HUBER/0","title":"Evision.cv_DIST_HUBER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_L1/0","title":"Evision.cv_DIST_L1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_L2/0","title":"Evision.cv_DIST_L2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_L12/0","title":"Evision.cv_DIST_L12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_LABEL_CCOMP/0","title":"Evision.cv_DIST_LABEL_CCOMP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_LABEL_PIXEL/0","title":"Evision.cv_DIST_LABEL_PIXEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_MASK_3/0","title":"Evision.cv_DIST_MASK_3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_MASK_5/0","title":"Evision.cv_DIST_MASK_5/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_MASK_PRECISE/0","title":"Evision.cv_DIST_MASK_PRECISE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_USER/0","title":"Evision.cv_DIST_USER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DIST_WELSCH/0","title":"Evision.cv_DIST_WELSCH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_CUDA/0","title":"Evision.cv_DNN_BACKEND_CUDA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_DEFAULT/0","title":"Evision.cv_DNN_BACKEND_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_HALIDE/0","title":"Evision.cv_DNN_BACKEND_HALIDE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_INFERENCE_ENGINE/0","title":"Evision.cv_DNN_BACKEND_INFERENCE_ENGINE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_OPENCV/0","title":"Evision.cv_DNN_BACKEND_OPENCV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_TIMVX/0","title":"Evision.cv_DNN_BACKEND_TIMVX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_VKCOM/0","title":"Evision.cv_DNN_BACKEND_VKCOM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_BACKEND_WEBNN/0","title":"Evision.cv_DNN_BACKEND_WEBNN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_CPU/0","title":"Evision.cv_DNN_TARGET_CPU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_CUDA/0","title":"Evision.cv_DNN_TARGET_CUDA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_CUDA_FP16/0","title":"Evision.cv_DNN_TARGET_CUDA_FP16/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_FPGA/0","title":"Evision.cv_DNN_TARGET_FPGA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_HDDL/0","title":"Evision.cv_DNN_TARGET_HDDL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_MYRIAD/0","title":"Evision.cv_DNN_TARGET_MYRIAD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_NPU/0","title":"Evision.cv_DNN_TARGET_NPU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_OPENCL/0","title":"Evision.cv_DNN_TARGET_OPENCL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_OPENCL_FP16/0","title":"Evision.cv_DNN_TARGET_OPENCL_FP16/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DNN_TARGET_VULKAN/0","title":"Evision.cv_DNN_TARGET_VULKAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DP_SEAM/0","title":"Evision.cv_DP_SEAM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DRAW_OVER_OUTIMG/0","title":"Evision.cv_DRAW_OVER_OUTIMG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DRAW_RICH_KEYPOINTS/0","title":"Evision.cv_DRAW_RICH_KEYPOINTS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_DYNAMIC_PARALLELISM/0","title":"Evision.cv_DYNAMIC_PARALLELISM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_depth_max/0","title":"Evision.cv_depth_max/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ECI_UTF8/0","title":"Evision.cv_ECI_UTF8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ELEMENT_ARRAY_BUFFER/0","title":"Evision.cv_ELEMENT_ARRAY_BUFFER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EMPTY/0","title":"Evision.cv_EMPTY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EPS/0","title":"Evision.cv_EPS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EPS_SVR/0","title":"Evision.cv_EPS_SVR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ERR_CAMERA_PARAMS_ADJUST_FAIL/0","title":"Evision.cv_ERR_CAMERA_PARAMS_ADJUST_FAIL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ERR_HOMOGRAPHY_EST_FAIL/0","title":"Evision.cv_ERR_HOMOGRAPHY_EST_FAIL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ERR_NEED_MORE_IMGS/0","title":"Evision.cv_ERR_NEED_MORE_IMGS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EULER_ANGLES_MAX_VALUE/0","title":"Evision.cv_EULER_ANGLES_MAX_VALUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_FLAG_ALTKEY/0","title":"Evision.cv_EVENT_FLAG_ALTKEY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_FLAG_CTRLKEY/0","title":"Evision.cv_EVENT_FLAG_CTRLKEY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_FLAG_LBUTTON/0","title":"Evision.cv_EVENT_FLAG_LBUTTON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_FLAG_MBUTTON/0","title":"Evision.cv_EVENT_FLAG_MBUTTON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_FLAG_RBUTTON/0","title":"Evision.cv_EVENT_FLAG_RBUTTON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_FLAG_SHIFTKEY/0","title":"Evision.cv_EVENT_FLAG_SHIFTKEY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_LBUTTONDBLCLK/0","title":"Evision.cv_EVENT_LBUTTONDBLCLK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_LBUTTONDOWN/0","title":"Evision.cv_EVENT_LBUTTONDOWN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_LBUTTONUP/0","title":"Evision.cv_EVENT_LBUTTONUP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_MBUTTONDBLCLK/0","title":"Evision.cv_EVENT_MBUTTONDBLCLK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_MBUTTONDOWN/0","title":"Evision.cv_EVENT_MBUTTONDOWN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_MBUTTONUP/0","title":"Evision.cv_EVENT_MBUTTONUP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_MOUSEHWHEEL/0","title":"Evision.cv_EVENT_MOUSEHWHEEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_MOUSEMOVE/0","title":"Evision.cv_EVENT_MOUSEMOVE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_MOUSEWHEEL/0","title":"Evision.cv_EVENT_MOUSEWHEEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_RBUTTONDBLCLK/0","title":"Evision.cv_EVENT_RBUTTONDBLCLK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_RBUTTONDOWN/0","title":"Evision.cv_EVENT_RBUTTONDOWN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EVENT_RBUTTONUP/0","title":"Evision.cv_EVENT_RBUTTONUP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXEC_KERNEL/0","title":"Evision.cv_EXEC_KERNEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXEC_NATIVE_KERNEL/0","title":"Evision.cv_EXEC_NATIVE_KERNEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXPR/0","title":"Evision.cv_EXPR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_XYX/0","title":"Evision.cv_EXT_XYX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_XYZ/0","title":"Evision.cv_EXT_XYZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_XZX/0","title":"Evision.cv_EXT_XZX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_XZY/0","title":"Evision.cv_EXT_XZY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_YXY/0","title":"Evision.cv_EXT_YXY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_YXZ/0","title":"Evision.cv_EXT_YXZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_YZX/0","title":"Evision.cv_EXT_YZX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_YZY/0","title":"Evision.cv_EXT_YZY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_ZXY/0","title":"Evision.cv_EXT_ZXY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_ZXZ/0","title":"Evision.cv_EXT_ZXZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_ZYX/0","title":"Evision.cv_EXT_ZYX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_EXT_ZYZ/0","title":"Evision.cv_EXT_ZYZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FAST_N/0","title":"Evision.cv_FAST_N/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FAST_SCORE/0","title":"Evision.cv_FAST_SCORE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATHER/0","title":"Evision.cv_FEATHER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_10/0","title":"Evision.cv_FEATURE_SET_COMPUTE_10/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_11/0","title":"Evision.cv_FEATURE_SET_COMPUTE_11/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_12/0","title":"Evision.cv_FEATURE_SET_COMPUTE_12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_13/0","title":"Evision.cv_FEATURE_SET_COMPUTE_13/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_20/0","title":"Evision.cv_FEATURE_SET_COMPUTE_20/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_21/0","title":"Evision.cv_FEATURE_SET_COMPUTE_21/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_30/0","title":"Evision.cv_FEATURE_SET_COMPUTE_30/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_32/0","title":"Evision.cv_FEATURE_SET_COMPUTE_32/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_35/0","title":"Evision.cv_FEATURE_SET_COMPUTE_35/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FEATURE_SET_COMPUTE_50/0","title":"Evision.cv_FEATURE_SET_COMPUTE_50/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FILLED/0","title":"Evision.cv_FILLED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FILTER_SCHARR/0","title":"Evision.cv_FILTER_SCHARR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FIXED_SIZE/0","title":"Evision.cv_FIXED_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FIXED_TYPE/0","title":"Evision.cv_FIXED_TYPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FileNode_FLOAT/0","title":"Evision.cv_FileNode_FLOAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FileNode_INT/0","title":"Evision.cv_FileNode_INT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FileNode_NONE/0","title":"Evision.cv_FileNode_NONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FileNode_STRING/0","title":"Evision.cv_FileNode_STRING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FileNode_TYPE_MASK/0","title":"Evision.cv_FileNode_TYPE_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FileNode_UNIFORM/0","title":"Evision.cv_FileNode_UNIFORM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_8S/0","title":"Evision.cv_FLANN_INDEX_TYPE_8S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_8U/0","title":"Evision.cv_FLANN_INDEX_TYPE_8U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_16S/0","title":"Evision.cv_FLANN_INDEX_TYPE_16S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_16U/0","title":"Evision.cv_FLANN_INDEX_TYPE_16U/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_32F/0","title":"Evision.cv_FLANN_INDEX_TYPE_32F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_32S/0","title":"Evision.cv_FLANN_INDEX_TYPE_32S/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_64F/0","title":"Evision.cv_FLANN_INDEX_TYPE_64F/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_ALGORITHM/0","title":"Evision.cv_FLANN_INDEX_TYPE_ALGORITHM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_BOOL/0","title":"Evision.cv_FLANN_INDEX_TYPE_BOOL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANN_INDEX_TYPE_STRING/0","title":"Evision.cv_FLANN_INDEX_TYPE_STRING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLANNBASED/0","title":"Evision.cv_FLANNBASED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLOAT/0","title":"Evision.cv_FLOAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLOODFILL_FIXED_RANGE/0","title":"Evision.cv_FLOODFILL_FIXED_RANGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLOODFILL_MASK_ONLY/0","title":"Evision.cv_FLOODFILL_MASK_ONLY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FLOW/0","title":"Evision.cv_FLOW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FM_7POINT/0","title":"Evision.cv_FM_7POINT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FM_8POINT/0","title":"Evision.cv_FM_8POINT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FM_LMEDS/0","title":"Evision.cv_FM_LMEDS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FM_RANSAC/0","title":"Evision.cv_FM_RANSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FMT_C/0","title":"Evision.cv_FMT_C/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FMT_CSV/0","title":"Evision.cv_FMT_CSV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FMT_DEFAULT/0","title":"Evision.cv_FMT_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FMT_MATLAB/0","title":"Evision.cv_FMT_MATLAB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FMT_NUMPY/0","title":"Evision.cv_FMT_NUMPY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FMT_PYTHON/0","title":"Evision.cv_FMT_PYTHON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_COMPLEX/0","title":"Evision.cv_FONT_HERSHEY_COMPLEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_COMPLEX_SMALL/0","title":"Evision.cv_FONT_HERSHEY_COMPLEX_SMALL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_DUPLEX/0","title":"Evision.cv_FONT_HERSHEY_DUPLEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_PLAIN/0","title":"Evision.cv_FONT_HERSHEY_PLAIN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_SCRIPT_COMPLEX/0","title":"Evision.cv_FONT_HERSHEY_SCRIPT_COMPLEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_SCRIPT_SIMPLEX/0","title":"Evision.cv_FONT_HERSHEY_SCRIPT_SIMPLEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_SIMPLEX/0","title":"Evision.cv_FONT_HERSHEY_SIMPLEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_HERSHEY_TRIPLEX/0","title":"Evision.cv_FONT_HERSHEY_TRIPLEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FONT_ITALIC/0","title":"Evision.cv_FONT_ITALIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FORMAT_AUTO/0","title":"Evision.cv_FORMAT_AUTO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FORMAT_JSON/0","title":"Evision.cv_FORMAT_JSON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FORMAT_MASK/0","title":"Evision.cv_FORMAT_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FORMAT_XML/0","title":"Evision.cv_FORMAT_XML/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FORMAT_YAML/0","title":"Evision.cv_FORMAT_YAML/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT/0","title":"Evision.cv_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_DENORM/0","title":"Evision.cv_FP_DENORM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_FMA/0","title":"Evision.cv_FP_FMA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_INF_NAN/0","title":"Evision.cv_FP_INF_NAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_ROUND_TO_INF/0","title":"Evision.cv_FP_ROUND_TO_INF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_ROUND_TO_NEAREST/0","title":"Evision.cv_FP_ROUND_TO_NEAREST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_ROUND_TO_ZERO/0","title":"Evision.cv_FP_ROUND_TO_ZERO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FP_SOFT_FLOAT/0","title":"Evision.cv_FP_SOFT_FLOAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FR_COSINE/0","title":"Evision.cv_FR_COSINE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FR_NORM_L2/0","title":"Evision.cv_FR_NORM_L2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_FULL_UV/0","title":"Evision.cv_FULL_UV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_FIX_FOCAL_LENGTH/0","title":"Evision.cv_fisheye_CALIB_FIX_FOCAL_LENGTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_FIX_INTRINSIC/0","title":"Evision.cv_fisheye_CALIB_FIX_INTRINSIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_FIX_K1/0","title":"Evision.cv_fisheye_CALIB_FIX_K1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_FIX_K2/0","title":"Evision.cv_fisheye_CALIB_FIX_K2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_FIX_K3/0","title":"Evision.cv_fisheye_CALIB_FIX_K3/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_FIX_K4/0","title":"Evision.cv_fisheye_CALIB_FIX_K4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_FIX_PRINCIPAL_POINT/0","title":"Evision.cv_fisheye_CALIB_FIX_PRINCIPAL_POINT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_USE_INTRINSIC_GUESS/0","title":"Evision.cv_fisheye_CALIB_USE_INTRINSIC_GUESS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_fisheye_CALIB_ZERO_DISPARITY/0","title":"Evision.cv_fisheye_CALIB_ZERO_DISPARITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GAIN/0","title":"Evision.cv_GAIN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GAIN_BLOCKS/0","title":"Evision.cv_GAIN_BLOCKS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GAMMA/0","title":"Evision.cv_GAMMA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GAUSSIAN/0","title":"Evision.cv_GAUSSIAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_BGD/0","title":"Evision.cv_GC_BGD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_EVAL/0","title":"Evision.cv_GC_EVAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_EVAL_FREEZE_MODEL/0","title":"Evision.cv_GC_EVAL_FREEZE_MODEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_FGD/0","title":"Evision.cv_GC_FGD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_INIT_WITH_MASK/0","title":"Evision.cv_GC_INIT_WITH_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_INIT_WITH_RECT/0","title":"Evision.cv_GC_INIT_WITH_RECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_PR_BGD/0","title":"Evision.cv_GC_PR_BGD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GC_PR_FGD/0","title":"Evision.cv_GC_PR_FGD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GEMM_1_T/0","title":"Evision.cv_GEMM_1_T/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GEMM_2_T/0","title":"Evision.cv_GEMM_2_T/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GEMM_3_T/0","title":"Evision.cv_GEMM_3_T/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GENTLE/0","title":"Evision.cv_GENTLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GLOBAL_ATOMICS/0","title":"Evision.cv_GLOBAL_ATOMICS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GpuApiCallError/0","title":"Evision.cv_GpuApiCallError/0","type":"function"},{"doc":"","ref":"Evision.html#cv_GpuNotSupported/0","title":"Evision.cv_GpuNotSupported/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HARD_MARGIN/0","title":"Evision.cv_HARD_MARGIN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HARRIS_SCORE/0","title":"Evision.cv_HARRIS_SCORE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HASH_BIT/0","title":"Evision.cv_HASH_BIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HASH_SCALE/0","title":"Evision.cv_HASH_SCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HeaderIsNull/0","title":"Evision.cv_HeaderIsNull/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HISTCMP_BHATTACHARYYA/0","title":"Evision.cv_HISTCMP_BHATTACHARYYA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HISTCMP_CHISQR/0","title":"Evision.cv_HISTCMP_CHISQR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HISTCMP_CHISQR_ALT/0","title":"Evision.cv_HISTCMP_CHISQR_ALT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HISTCMP_CORREL/0","title":"Evision.cv_HISTCMP_CORREL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HISTCMP_HELLINGER/0","title":"Evision.cv_HISTCMP_HELLINGER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HISTCMP_INTERSECT/0","title":"Evision.cv_HISTCMP_INTERSECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HISTCMP_KL_DIV/0","title":"Evision.cv_HISTCMP_KL_DIV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HOST_COPY_OBSOLETE/0","title":"Evision.cv_HOST_COPY_OBSOLETE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HOUGH_GRADIENT/0","title":"Evision.cv_HOUGH_GRADIENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HOUGH_GRADIENT_ALT/0","title":"Evision.cv_HOUGH_GRADIENT_ALT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HOUGH_MULTI_SCALE/0","title":"Evision.cv_HOUGH_MULTI_SCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HOUGH_PROBABILISTIC/0","title":"Evision.cv_HOUGH_PROBABILISTIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_HOUGH_STANDARD/0","title":"Evision.cv_HOUGH_STANDARD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IDENTITY/0","title":"Evision.cv_IDENTITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_ANYCOLOR/0","title":"Evision.cv_IMREAD_ANYCOLOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_ANYDEPTH/0","title":"Evision.cv_IMREAD_ANYDEPTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_COLOR/0","title":"Evision.cv_IMREAD_COLOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_GRAYSCALE/0","title":"Evision.cv_IMREAD_GRAYSCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_IGNORE_ORIENTATION/0","title":"Evision.cv_IMREAD_IGNORE_ORIENTATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_LOAD_GDAL/0","title":"Evision.cv_IMREAD_LOAD_GDAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_REDUCED_COLOR_2/0","title":"Evision.cv_IMREAD_REDUCED_COLOR_2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_REDUCED_COLOR_4/0","title":"Evision.cv_IMREAD_REDUCED_COLOR_4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_REDUCED_COLOR_8/0","title":"Evision.cv_IMREAD_REDUCED_COLOR_8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_REDUCED_GRAYSCALE_2/0","title":"Evision.cv_IMREAD_REDUCED_GRAYSCALE_2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_REDUCED_GRAYSCALE_4/0","title":"Evision.cv_IMREAD_REDUCED_GRAYSCALE_4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_REDUCED_GRAYSCALE_8/0","title":"Evision.cv_IMREAD_REDUCED_GRAYSCALE_8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMREAD_UNCHANGED/0","title":"Evision.cv_IMREAD_UNCHANGED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_B44/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_B44/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_B44A/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_B44A/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_DWAA/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_DWAA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_DWAB/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_DWAB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_NO/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_NO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_PIZ/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_PIZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_PXR24/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_PXR24/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_RLE/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_RLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_ZIP/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_ZIP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_COMPRESSION_ZIPS/0","title":"Evision.cv_IMWRITE_EXR_COMPRESSION_ZIPS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_TYPE/0","title":"Evision.cv_IMWRITE_EXR_TYPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_TYPE_FLOAT/0","title":"Evision.cv_IMWRITE_EXR_TYPE_FLOAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_EXR_TYPE_HALF/0","title":"Evision.cv_IMWRITE_EXR_TYPE_HALF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_JPEG2000_COMPRESSION_X1000/0","title":"Evision.cv_IMWRITE_JPEG2000_COMPRESSION_X1000/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_JPEG_CHROMA_QUALITY/0","title":"Evision.cv_IMWRITE_JPEG_CHROMA_QUALITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_JPEG_LUMA_QUALITY/0","title":"Evision.cv_IMWRITE_JPEG_LUMA_QUALITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_JPEG_OPTIMIZE/0","title":"Evision.cv_IMWRITE_JPEG_OPTIMIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_JPEG_PROGRESSIVE/0","title":"Evision.cv_IMWRITE_JPEG_PROGRESSIVE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_JPEG_QUALITY/0","title":"Evision.cv_IMWRITE_JPEG_QUALITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_JPEG_RST_INTERVAL/0","title":"Evision.cv_IMWRITE_JPEG_RST_INTERVAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PAM_FORMAT_BLACKANDWHITE/0","title":"Evision.cv_IMWRITE_PAM_FORMAT_BLACKANDWHITE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PAM_FORMAT_GRAYSCALE/0","title":"Evision.cv_IMWRITE_PAM_FORMAT_GRAYSCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA/0","title":"Evision.cv_IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PAM_FORMAT_NULL/0","title":"Evision.cv_IMWRITE_PAM_FORMAT_NULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PAM_FORMAT_RGB/0","title":"Evision.cv_IMWRITE_PAM_FORMAT_RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PAM_FORMAT_RGB_ALPHA/0","title":"Evision.cv_IMWRITE_PAM_FORMAT_RGB_ALPHA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PAM_TUPLETYPE/0","title":"Evision.cv_IMWRITE_PAM_TUPLETYPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_BILEVEL/0","title":"Evision.cv_IMWRITE_PNG_BILEVEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_COMPRESSION/0","title":"Evision.cv_IMWRITE_PNG_COMPRESSION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_STRATEGY/0","title":"Evision.cv_IMWRITE_PNG_STRATEGY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_STRATEGY_DEFAULT/0","title":"Evision.cv_IMWRITE_PNG_STRATEGY_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_STRATEGY_FILTERED/0","title":"Evision.cv_IMWRITE_PNG_STRATEGY_FILTERED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_STRATEGY_FIXED/0","title":"Evision.cv_IMWRITE_PNG_STRATEGY_FIXED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY/0","title":"Evision.cv_IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PNG_STRATEGY_RLE/0","title":"Evision.cv_IMWRITE_PNG_STRATEGY_RLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_PXM_BINARY/0","title":"Evision.cv_IMWRITE_PXM_BINARY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_TIFF_COMPRESSION/0","title":"Evision.cv_IMWRITE_TIFF_COMPRESSION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_TIFF_RESUNIT/0","title":"Evision.cv_IMWRITE_TIFF_RESUNIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_TIFF_XDPI/0","title":"Evision.cv_IMWRITE_TIFF_XDPI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_TIFF_YDPI/0","title":"Evision.cv_IMWRITE_TIFF_YDPI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_IMWRITE_WEBP_QUALITY/0","title":"Evision.cv_IMWRITE_WEBP_QUALITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INPAINT_NS/0","title":"Evision.cv_INPAINT_NS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INPAINT_TELEA/0","title":"Evision.cv_INPAINT_TELEA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INSIDE_MAP/0","title":"Evision.cv_INSIDE_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT/0","title":"Evision.cv_INT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_XYX/0","title":"Evision.cv_INT_XYX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_XYZ/0","title":"Evision.cv_INT_XYZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_XZX/0","title":"Evision.cv_INT_XZX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_XZY/0","title":"Evision.cv_INT_XZY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_YXY/0","title":"Evision.cv_INT_YXY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_YXZ/0","title":"Evision.cv_INT_YXZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_YZX/0","title":"Evision.cv_INT_YZX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_YZY/0","title":"Evision.cv_INT_YZY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_ZXY/0","title":"Evision.cv_INT_ZXY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_ZXZ/0","title":"Evision.cv_INT_ZXZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_ZYX/0","title":"Evision.cv_INT_ZYX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INT_ZYZ/0","title":"Evision.cv_INT_ZYZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER/0","title":"Evision.cv_INTER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_AREA/0","title":"Evision.cv_INTER_AREA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_BITS2/0","title":"Evision.cv_INTER_BITS2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_BITS/0","title":"Evision.cv_INTER_BITS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_CUBIC/0","title":"Evision.cv_INTER_CUBIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_LANCZOS4/0","title":"Evision.cv_INTER_LANCZOS4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_LINEAR/0","title":"Evision.cv_INTER_LINEAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_LINEAR_EXACT/0","title":"Evision.cv_INTER_LINEAR_EXACT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_MAX/0","title":"Evision.cv_INTER_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_NEAREST/0","title":"Evision.cv_INTER_NEAREST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_NEAREST_EXACT/0","title":"Evision.cv_INTER_NEAREST_EXACT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_TAB_SIZE2/0","title":"Evision.cv_INTER_TAB_SIZE2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTER_TAB_SIZE/0","title":"Evision.cv_INTER_TAB_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTERPROCESS/0","title":"Evision.cv_INTERPROCESS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTERSECT_FULL/0","title":"Evision.cv_INTERSECT_FULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTERSECT_NONE/0","title":"Evision.cv_INTERSECT_NONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_INTERSECT_PARTIAL/0","title":"Evision.cv_INTERSECT_PARTIAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_InputArray_MAT/0","title":"Evision.cv_InputArray_MAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_KDTREE/0","title":"Evision.cv_KDTREE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_KIND_MASK/0","title":"Evision.cv_KIND_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_KIND_SHIFT/0","title":"Evision.cv_KIND_SHIFT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_KMEANS_PP_CENTERS/0","title":"Evision.cv_KMEANS_PP_CENTERS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_KMEANS_RANDOM_CENTERS/0","title":"Evision.cv_KMEANS_RANDOM_CENTERS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_KMEANS_USE_INITIAL_LABELS/0","title":"Evision.cv_KMEANS_USE_INITIAL_LABELS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_L2Hys/0","title":"Evision.cv_L2Hys/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LAST_VALUE_FLANN_INDEX_TYPE/0","title":"Evision.cv_LAST_VALUE_FLANN_INDEX_TYPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LDR_SIZE/0","title":"Evision.cv_LDR_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LEAKYRELU/0","title":"Evision.cv_LEAKYRELU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LINE_4/0","title":"Evision.cv_LINE_4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LINE_8/0","title":"Evision.cv_LINE_8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LINE_AA/0","title":"Evision.cv_LINE_AA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LINE_LOOP/0","title":"Evision.cv_LINE_LOOP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LINE_STRIP/0","title":"Evision.cv_LINE_STRIP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LINEAR/0","title":"Evision.cv_LINEAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LINES/0","title":"Evision.cv_LINES/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LMEDS/0","title":"Evision.cv_LMEDS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL/0","title":"Evision.cv_LOCAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL_IS_GLOBAL/0","title":"Evision.cv_LOCAL_IS_GLOBAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL_IS_LOCAL/0","title":"Evision.cv_LOCAL_IS_LOCAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL_OPTIM_GC/0","title":"Evision.cv_LOCAL_OPTIM_GC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL_OPTIM_INNER_AND_ITER_LO/0","title":"Evision.cv_LOCAL_OPTIM_INNER_AND_ITER_LO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL_OPTIM_INNER_LO/0","title":"Evision.cv_LOCAL_OPTIM_INNER_LO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL_OPTIM_NULL/0","title":"Evision.cv_LOCAL_OPTIM_NULL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOCAL_OPTIM_SIGMA/0","title":"Evision.cv_LOCAL_OPTIM_SIGMA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LOGIT/0","title":"Evision.cv_LOGIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LSD_REFINE_ADV/0","title":"Evision.cv_LSD_REFINE_ADV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LSD_REFINE_NONE/0","title":"Evision.cv_LSD_REFINE_NONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_LSD_REFINE_STD/0","title":"Evision.cv_LSD_REFINE_STD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MAGIC_MASK/0","title":"Evision.cv_MAGIC_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MAGIC_VAL/0","title":"Evision.cv_MAGIC_VAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MAP/0","title":"Evision.cv_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MARKER_CROSS/0","title":"Evision.cv_MARKER_CROSS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MARKER_DIAMOND/0","title":"Evision.cv_MARKER_DIAMOND/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MARKER_SQUARE/0","title":"Evision.cv_MARKER_SQUARE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MARKER_STAR/0","title":"Evision.cv_MARKER_STAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MARKER_TILTED_CROSS/0","title":"Evision.cv_MARKER_TILTED_CROSS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MARKER_TRIANGLE_DOWN/0","title":"Evision.cv_MARKER_TRIANGLE_DOWN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MARKER_TRIANGLE_UP/0","title":"Evision.cv_MARKER_TRIANGLE_UP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MAT/0","title":"Evision.cv_MAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MAT_VECTOR/0","title":"Evision.cv_MAT_VECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MATX/0","title":"Evision.cv_MATX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MAX_DIM/0","title":"Evision.cv_MAX_DIM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MAX_ITER/0","title":"Evision.cv_MAX_ITER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MaskIsTiled/0","title":"Evision.cv_MaskIsTiled/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MEMORY/0","title":"Evision.cv_MEMORY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MINI_BATCH/0","title":"Evision.cv_MINI_BATCH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MIXED_CLONE/0","title":"Evision.cv_MIXED_CLONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_ALPHANUMERIC/0","title":"Evision.cv_MODE_ALPHANUMERIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_AUTO/0","title":"Evision.cv_MODE_AUTO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_BYTE/0","title":"Evision.cv_MODE_BYTE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_DETECT/0","title":"Evision.cv_MODE_DETECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_ECI/0","title":"Evision.cv_MODE_ECI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_HH4/0","title":"Evision.cv_MODE_HH4/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_HH/0","title":"Evision.cv_MODE_HH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_INIT_NEG/0","title":"Evision.cv_MODE_INIT_NEG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_INIT_POS/0","title":"Evision.cv_MODE_INIT_POS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_KANJI/0","title":"Evision.cv_MODE_KANJI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_NUMERIC/0","title":"Evision.cv_MODE_NUMERIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_SGBM/0","title":"Evision.cv_MODE_SGBM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_SGBM_3WAY/0","title":"Evision.cv_MODE_SGBM_3WAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_STRUCTURED_APPEND/0","title":"Evision.cv_MODE_STRUCTURED_APPEND/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_TRACK_NEG/0","title":"Evision.cv_MODE_TRACK_NEG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODE_TRACK_POS/0","title":"Evision.cv_MODE_TRACK_POS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MODIFY_A/0","title":"Evision.cv_MODIFY_A/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MONOCHROME_TRANSFER/0","title":"Evision.cv_MONOCHROME_TRANSFER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_BLACKHAT/0","title":"Evision.cv_MORPH_BLACKHAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_CLOSE/0","title":"Evision.cv_MORPH_CLOSE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_CROSS/0","title":"Evision.cv_MORPH_CROSS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_DILATE/0","title":"Evision.cv_MORPH_DILATE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_ELLIPSE/0","title":"Evision.cv_MORPH_ELLIPSE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_ERODE/0","title":"Evision.cv_MORPH_ERODE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_GRADIENT/0","title":"Evision.cv_MORPH_GRADIENT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_HITMISS/0","title":"Evision.cv_MORPH_HITMISS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_OPEN/0","title":"Evision.cv_MORPH_OPEN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_RECT/0","title":"Evision.cv_MORPH_RECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MORPH_TOPHAT/0","title":"Evision.cv_MORPH_TOPHAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MOTION_AFFINE/0","title":"Evision.cv_MOTION_AFFINE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MOTION_EUCLIDEAN/0","title":"Evision.cv_MOTION_EUCLIDEAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MOTION_HOMOGRAPHY/0","title":"Evision.cv_MOTION_HOMOGRAPHY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MOTION_TRANSLATION/0","title":"Evision.cv_MOTION_TRANSLATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_MULTI_BAND/0","title":"Evision.cv_MULTI_BAND/0","type":"function"},{"doc":"","ref":"Evision.html#cv_maketype/2","title":"Evision.cv_maketype/2","type":"function"},{"doc":"","ref":"Evision.html#cv_mat_depth_mask/0","title":"Evision.cv_mat_depth_mask/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NAME_EXPECTED/0","title":"Evision.cv_NAME_EXPECTED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NAMED/0","title":"Evision.cv_NAMED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NATIVE_DOUBLE/0","title":"Evision.cv_NATIVE_DOUBLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NEIGH_FLANN_KNN/0","title":"Evision.cv_NEIGH_FLANN_KNN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NEIGH_FLANN_RADIUS/0","title":"Evision.cv_NEIGH_FLANN_RADIUS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NEIGH_GRID/0","title":"Evision.cv_NEIGH_GRID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NEXT_AROUND_DST/0","title":"Evision.cv_NEXT_AROUND_DST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NEXT_AROUND_LEFT/0","title":"Evision.cv_NEXT_AROUND_LEFT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NEXT_AROUND_ORG/0","title":"Evision.cv_NEXT_AROUND_ORG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NEXT_AROUND_RIGHT/0","title":"Evision.cv_NEXT_AROUND_RIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NO/0","title":"Evision.cv_NO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NO_CACHE/0","title":"Evision.cv_NO_CACHE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NO_INPUT_SCALE/0","title":"Evision.cv_NO_INPUT_SCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NO_LOCAL_MEM/0","title":"Evision.cv_NO_LOCAL_MEM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NO_OUTPUT_SCALE/0","title":"Evision.cv_NO_OUTPUT_SCALE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NO_SIZE/0","title":"Evision.cv_NO_SIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NO_UV/0","title":"Evision.cv_NO_UV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NONE/0","title":"Evision.cv_NONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NONMAX_SUPPRESSION/0","title":"Evision.cv_NONMAX_SUPPRESSION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_HAMMING2/0","title":"Evision.cv_NORM_HAMMING2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_HAMMING/0","title":"Evision.cv_NORM_HAMMING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_INF/0","title":"Evision.cv_NORM_INF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_L1/0","title":"Evision.cv_NORM_L1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_L2/0","title":"Evision.cv_NORM_L2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_L2SQR/0","title":"Evision.cv_NORM_L2SQR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_MINMAX/0","title":"Evision.cv_NORM_MINMAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_RELATIVE/0","title":"Evision.cv_NORM_RELATIVE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORM_TYPE_MASK/0","title":"Evision.cv_NORM_TYPE_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORMAL/0","title":"Evision.cv_NORMAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORMAL_CLONE/0","title":"Evision.cv_NORMAL_CLONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NORMCONV_FILTER/0","title":"Evision.cv_NORMCONV_FILTER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NOT_DRAW_SINGLE_POINTS/0","title":"Evision.cv_NOT_DRAW_SINGLE_POINTS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NU/0","title":"Evision.cv_NU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NU_SVC/0","title":"Evision.cv_NU_SVC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_NU_SVR/0","title":"Evision.cv_NU_SVR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OAST_9_16/0","title":"Evision.cv_OAST_9_16/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OCL_VECTOR_DEFAULT/0","title":"Evision.cv_OCL_VECTOR_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OCL_VECTOR_MAX/0","title":"Evision.cv_OCL_VECTOR_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OCL_VECTOR_OWN/0","title":"Evision.cv_OCL_VECTOR_OWN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OK/0","title":"Evision.cv_OK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ONE_CLASS/0","title":"Evision.cv_ONE_CLASS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OPENGL_BUFFER/0","title":"Evision.cv_OPENGL_BUFFER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OPTFLOW_FARNEBACK_GAUSSIAN/0","title":"Evision.cv_OPTFLOW_FARNEBACK_GAUSSIAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OPTFLOW_LK_GET_MIN_EIGENVALS/0","title":"Evision.cv_OPTFLOW_LK_GET_MIN_EIGENVALS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OPTFLOW_USE_INITIAL_FLOW/0","title":"Evision.cv_OPTFLOW_USE_INITIAL_FLOW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OpenCLApiCallError/0","title":"Evision.cv_OpenCLApiCallError/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OpenCLDoubleNotSupported/0","title":"Evision.cv_OpenCLDoubleNotSupported/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OpenCLInitError/0","title":"Evision.cv_OpenCLInitError/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OpenCLNoAMDBlasFft/0","title":"Evision.cv_OpenCLNoAMDBlasFft/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OpenGlApiCallError/0","title":"Evision.cv_OpenGlApiCallError/0","type":"function"},{"doc":"","ref":"Evision.html#cv_OpenGlNotSupported/0","title":"Evision.cv_OpenGlNotSupported/0","type":"function"},{"doc":"","ref":"Evision.html#cv_P/0","title":"Evision.cv_P/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PAGE_LOCKED/0","title":"Evision.cv_PAGE_LOCKED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PANORAMA/0","title":"Evision.cv_PANORAMA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PIXEL_PACK_BUFFER/0","title":"Evision.cv_PIXEL_PACK_BUFFER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PIXEL_UNPACK_BUFFER/0","title":"Evision.cv_PIXEL_UNPACK_BUFFER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_POINTS/0","title":"Evision.cv_POINTS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_POLY/0","title":"Evision.cv_POLY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_POLYGON/0","title":"Evision.cv_POLYGON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREDICT_AUTO/0","title":"Evision.cv_PREDICT_AUTO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREDICT_MASK/0","title":"Evision.cv_PREDICT_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREDICT_MAX_VOTE/0","title":"Evision.cv_PREDICT_MAX_VOTE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREDICT_SUM/0","title":"Evision.cv_PREDICT_SUM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREFILTER_NORMALIZED_RESPONSE/0","title":"Evision.cv_PREFILTER_NORMALIZED_RESPONSE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREFILTER_XSOBEL/0","title":"Evision.cv_PREFILTER_XSOBEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREPROCESSED_INPUT/0","title":"Evision.cv_PREPROCESSED_INPUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PRESET_FAST/0","title":"Evision.cv_PRESET_FAST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PRESET_MEDIUM/0","title":"Evision.cv_PRESET_MEDIUM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PRESET_ULTRAFAST/0","title":"Evision.cv_PRESET_ULTRAFAST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREV_AROUND_DST/0","title":"Evision.cv_PREV_AROUND_DST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREV_AROUND_LEFT/0","title":"Evision.cv_PREV_AROUND_LEFT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREV_AROUND_ORG/0","title":"Evision.cv_PREV_AROUND_ORG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PREV_AROUND_RIGHT/0","title":"Evision.cv_PREV_AROUND_RIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PROJ_SPHERICAL_EQRECT/0","title":"Evision.cv_PROJ_SPHERICAL_EQRECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PROJ_SPHERICAL_ORTHO/0","title":"Evision.cv_PROJ_SPHERICAL_ORTHO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PTLOC_ERROR/0","title":"Evision.cv_PTLOC_ERROR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PTLOC_INSIDE/0","title":"Evision.cv_PTLOC_INSIDE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PTLOC_ON_EDGE/0","title":"Evision.cv_PTLOC_ON_EDGE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PTLOC_OUTSIDE_RECT/0","title":"Evision.cv_PTLOC_OUTSIDE_RECT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PTLOC_VERTEX/0","title":"Evision.cv_PTLOC_VERTEX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_PTR_ONLY/0","title":"Evision.cv_PTR_ONLY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_CHECKBOX/0","title":"Evision.cv_QT_CHECKBOX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_FONT_BLACK/0","title":"Evision.cv_QT_FONT_BLACK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_FONT_BOLD/0","title":"Evision.cv_QT_FONT_BOLD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_FONT_DEMIBOLD/0","title":"Evision.cv_QT_FONT_DEMIBOLD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_FONT_LIGHT/0","title":"Evision.cv_QT_FONT_LIGHT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_FONT_NORMAL/0","title":"Evision.cv_QT_FONT_NORMAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_NEW_BUTTONBAR/0","title":"Evision.cv_QT_NEW_BUTTONBAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_PUSH_BUTTON/0","title":"Evision.cv_QT_PUSH_BUTTON/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_RADIOBOX/0","title":"Evision.cv_QT_RADIOBOX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_STYLE_ITALIC/0","title":"Evision.cv_QT_STYLE_ITALIC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_STYLE_NORMAL/0","title":"Evision.cv_QT_STYLE_NORMAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QT_STYLE_OBLIQUE/0","title":"Evision.cv_QT_STYLE_OBLIQUE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QUAD_STRIP/0","title":"Evision.cv_QUAD_STRIP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QUADS/0","title":"Evision.cv_QUADS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QUAT_ASSUME_NOT_UNIT/0","title":"Evision.cv_QUAT_ASSUME_NOT_UNIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_QUAT_ASSUME_UNIT/0","title":"Evision.cv_QUAT_ASSUME_UNIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RANSAC/0","title":"Evision.cv_RANSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RAW_OUTPUT/0","title":"Evision.cv_RAW_OUTPUT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RBF/0","title":"Evision.cv_RBF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_READ/0","title":"Evision.cv_READ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_READ_ONLY/0","title":"Evision.cv_READ_ONLY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_READ_ONLY_CACHE/0","title":"Evision.cv_READ_ONLY_CACHE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_READ_WRITE/0","title":"Evision.cv_READ_WRITE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_READ_WRITE_CACHE/0","title":"Evision.cv_READ_WRITE_CACHE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REAL/0","title":"Evision.cv_REAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RECURS_FILTER/0","title":"Evision.cv_RECURS_FILTER/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REDUCE_AVG/0","title":"Evision.cv_REDUCE_AVG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REDUCE_MAX/0","title":"Evision.cv_REDUCE_MAX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REDUCE_MIN/0","title":"Evision.cv_REDUCE_MIN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REDUCE_SUM/0","title":"Evision.cv_REDUCE_SUM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REG_DISABLE/0","title":"Evision.cv_REG_DISABLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REG_L1/0","title":"Evision.cv_REG_L1/0","type":"function"},{"doc":"","ref":"Evision.html#cv_REG_L2/0","title":"Evision.cv_REG_L2/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RELU/0","title":"Evision.cv_RELU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RETR_CCOMP/0","title":"Evision.cv_RETR_CCOMP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RETR_EXTERNAL/0","title":"Evision.cv_RETR_EXTERNAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RETR_FLOODFILL/0","title":"Evision.cv_RETR_FLOODFILL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RETR_LIST/0","title":"Evision.cv_RETR_LIST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RETR_TREE/0","title":"Evision.cv_RETR_TREE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RGB/0","title":"Evision.cv_RGB/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RGBA/0","title":"Evision.cv_RGBA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RHO/0","title":"Evision.cv_RHO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ROTATE_90_CLOCKWISE/0","title":"Evision.cv_ROTATE_90_CLOCKWISE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ROTATE_90_COUNTERCLOCKWISE/0","title":"Evision.cv_ROTATE_90_COUNTERCLOCKWISE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ROTATE_180/0","title":"Evision.cv_ROTATE_180/0","type":"function"},{"doc":"","ref":"Evision.html#cv_ROW_SAMPLE/0","title":"Evision.cv_ROW_SAMPLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_RPROP/0","title":"Evision.cv_RPROP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SAMPLING_NAPSAC/0","title":"Evision.cv_SAMPLING_NAPSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SAMPLING_PROGRESSIVE_NAPSAC/0","title":"Evision.cv_SAMPLING_PROGRESSIVE_NAPSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SAMPLING_PROSAC/0","title":"Evision.cv_SAMPLING_PROSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SAMPLING_UNIFORM/0","title":"Evision.cv_SAMPLING_UNIFORM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SCALAR/0","title":"Evision.cv_SCALAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SCANS/0","title":"Evision.cv_SCANS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SCORE_METHOD_LMEDS/0","title":"Evision.cv_SCORE_METHOD_LMEDS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SCORE_METHOD_MAGSAC/0","title":"Evision.cv_SCORE_METHOD_MAGSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SCORE_METHOD_MSAC/0","title":"Evision.cv_SCORE_METHOD_MSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SCORE_METHOD_RANSAC/0","title":"Evision.cv_SCORE_METHOD_RANSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SEQ/0","title":"Evision.cv_SEQ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SGD/0","title":"Evision.cv_SGD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SHARED/0","title":"Evision.cv_SHARED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SHARED_ATOMICS/0","title":"Evision.cv_SHARED_ATOMICS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SIGMOID/0","title":"Evision.cv_SIGMOID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SIGMOID_SYM/0","title":"Evision.cv_SIGMOID_SYM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOFT_MARGIN/0","title":"Evision.cv_SOFT_MARGIN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOFTNMS_GAUSSIAN/0","title":"Evision.cv_SOFTNMS_GAUSSIAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOFTNMS_LINEAR/0","title":"Evision.cv_SOFTNMS_LINEAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVELP_MULTI/0","title":"Evision.cv_SOLVELP_MULTI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVELP_SINGLE/0","title":"Evision.cv_SOLVELP_SINGLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVELP_UNBOUNDED/0","title":"Evision.cv_SOLVELP_UNBOUNDED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVELP_UNFEASIBLE/0","title":"Evision.cv_SOLVELP_UNFEASIBLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_AP3P/0","title":"Evision.cv_SOLVEPNP_AP3P/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_DLS/0","title":"Evision.cv_SOLVEPNP_DLS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_EPNP/0","title":"Evision.cv_SOLVEPNP_EPNP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_IPPE/0","title":"Evision.cv_SOLVEPNP_IPPE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_IPPE_SQUARE/0","title":"Evision.cv_SOLVEPNP_IPPE_SQUARE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_ITERATIVE/0","title":"Evision.cv_SOLVEPNP_ITERATIVE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_MAX_COUNT/0","title":"Evision.cv_SOLVEPNP_MAX_COUNT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_P3P/0","title":"Evision.cv_SOLVEPNP_P3P/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_SQPNP/0","title":"Evision.cv_SOLVEPNP_SQPNP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SOLVEPNP_UPNP/0","title":"Evision.cv_SOLVEPNP_UPNP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SORT_ASCENDING/0","title":"Evision.cv_SORT_ASCENDING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SORT_DESCENDING/0","title":"Evision.cv_SORT_DESCENDING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SORT_EVERY_COLUMN/0","title":"Evision.cv_SORT_EVERY_COLUMN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SORT_EVERY_ROW/0","title":"Evision.cv_SORT_EVERY_ROW/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SparseMat_MAGIC_VAL/0","title":"Evision.cv_SparseMat_MAGIC_VAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_START_AUTO_STEP/0","title":"Evision.cv_START_AUTO_STEP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_START_E_STEP/0","title":"Evision.cv_START_E_STEP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_START_M_STEP/0","title":"Evision.cv_START_M_STEP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_ARRAY/0","title":"Evision.cv_STD_ARRAY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_ARRAY_MAT/0","title":"Evision.cv_STD_ARRAY_MAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_BOOL_VECTOR/0","title":"Evision.cv_STD_BOOL_VECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_VECTOR/0","title":"Evision.cv_STD_VECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_VECTOR_CUDA_GPU_MAT/0","title":"Evision.cv_STD_VECTOR_CUDA_GPU_MAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_VECTOR_MAT/0","title":"Evision.cv_STD_VECTOR_MAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_VECTOR_UMAT/0","title":"Evision.cv_STD_VECTOR_UMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STD_VECTOR_VECTOR/0","title":"Evision.cv_STD_VECTOR_VECTOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STR/0","title":"Evision.cv_STR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_STRING/0","title":"Evision.cv_STRING/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsAssert/0","title":"Evision.cv_StsAssert/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsAutoTrace/0","title":"Evision.cv_StsAutoTrace/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBackTrace/0","title":"Evision.cv_StsBackTrace/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBadArg/0","title":"Evision.cv_StsBadArg/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBadFlag/0","title":"Evision.cv_StsBadFlag/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBadFunc/0","title":"Evision.cv_StsBadFunc/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBadMask/0","title":"Evision.cv_StsBadMask/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBadMemBlock/0","title":"Evision.cv_StsBadMemBlock/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBadPoint/0","title":"Evision.cv_StsBadPoint/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsBadSize/0","title":"Evision.cv_StsBadSize/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsDivByZero/0","title":"Evision.cv_StsDivByZero/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsError/0","title":"Evision.cv_StsError/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsFilterOffsetErr/0","title":"Evision.cv_StsFilterOffsetErr/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsFilterStructContentErr/0","title":"Evision.cv_StsFilterStructContentErr/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsInplaceNotSupported/0","title":"Evision.cv_StsInplaceNotSupported/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsInternal/0","title":"Evision.cv_StsInternal/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsKernelStructContentErr/0","title":"Evision.cv_StsKernelStructContentErr/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsNoConv/0","title":"Evision.cv_StsNoConv/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsNoMem/0","title":"Evision.cv_StsNoMem/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsNotImplemented/0","title":"Evision.cv_StsNotImplemented/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsNullPtr/0","title":"Evision.cv_StsNullPtr/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsObjectNotFound/0","title":"Evision.cv_StsObjectNotFound/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsOk/0","title":"Evision.cv_StsOk/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsOutOfRange/0","title":"Evision.cv_StsOutOfRange/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsParseError/0","title":"Evision.cv_StsParseError/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsUnmatchedFormats/0","title":"Evision.cv_StsUnmatchedFormats/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsUnmatchedSizes/0","title":"Evision.cv_StsUnmatchedSizes/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsUnsupportedFormat/0","title":"Evision.cv_StsUnsupportedFormat/0","type":"function"},{"doc":"","ref":"Evision.html#cv_StsVecLengthErr/0","title":"Evision.cv_StsVecLengthErr/0","type":"function"},{"doc":"","ref":"Evision.html#cv_SYMMETRIC_GRID/0","title":"Evision.cv_SYMMETRIC_GRID/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEMP_COPIED_UMAT/0","title":"Evision.cv_TEMP_COPIED_UMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEMP_UMAT/0","title":"Evision.cv_TEMP_UMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_CUSTOM/0","title":"Evision.cv_TEST_CUSTOM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_EQ/0","title":"Evision.cv_TEST_EQ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_ERROR/0","title":"Evision.cv_TEST_ERROR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_GE/0","title":"Evision.cv_TEST_GE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_GT/0","title":"Evision.cv_TEST_GT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_LE/0","title":"Evision.cv_TEST_LE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_LT/0","title":"Evision.cv_TEST_LT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TEST_NE/0","title":"Evision.cv_TEST_NE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_Texture2D_NONE/0","title":"Evision.cv_Texture2D_NONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_BINARY/0","title":"Evision.cv_THRESH_BINARY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_BINARY_INV/0","title":"Evision.cv_THRESH_BINARY_INV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_MASK/0","title":"Evision.cv_THRESH_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_OTSU/0","title":"Evision.cv_THRESH_OTSU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_TOZERO/0","title":"Evision.cv_THRESH_TOZERO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_TOZERO_INV/0","title":"Evision.cv_THRESH_TOZERO_INV/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_TRIANGLE/0","title":"Evision.cv_THRESH_TRIANGLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESH_TRUNC/0","title":"Evision.cv_THRESH_TRUNC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_THRESHOLD/0","title":"Evision.cv_THRESHOLD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TM_CCOEFF/0","title":"Evision.cv_TM_CCOEFF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TM_CCOEFF_NORMED/0","title":"Evision.cv_TM_CCOEFF_NORMED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TM_CCORR/0","title":"Evision.cv_TM_CCORR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TM_CCORR_NORMED/0","title":"Evision.cv_TM_CCORR_NORMED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TM_SQDIFF/0","title":"Evision.cv_TM_SQDIFF/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TM_SQDIFF_NORMED/0","title":"Evision.cv_TM_SQDIFF_NORMED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TRAIN_ERROR/0","title":"Evision.cv_TRAIN_ERROR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TRIANGLE_FAN/0","title":"Evision.cv_TRIANGLE_FAN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TRIANGLE_STRIP/0","title":"Evision.cv_TRIANGLE_STRIP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TRIANGLES/0","title":"Evision.cv_TRIANGLES/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_5_8/0","title":"Evision.cv_TYPE_5_8/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_7_12/0","title":"Evision.cv_TYPE_7_12/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_9_16/0","title":"Evision.cv_TYPE_9_16/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_ACCELERATOR/0","title":"Evision.cv_TYPE_ACCELERATOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_ALL/0","title":"Evision.cv_TYPE_ALL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_CPU/0","title":"Evision.cv_TYPE_CPU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_DEFAULT/0","title":"Evision.cv_TYPE_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_DGPU/0","title":"Evision.cv_TYPE_DGPU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_GPU/0","title":"Evision.cv_TYPE_GPU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_IGPU/0","title":"Evision.cv_TYPE_IGPU/0","type":"function"},{"doc":"","ref":"Evision.html#cv_TYPE_MASK/0","title":"Evision.cv_TYPE_MASK/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UCHAR/0","title":"Evision.cv_UCHAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UINT64/0","title":"Evision.cv_UINT64/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UMAT/0","title":"Evision.cv_UMAT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UMAT_USAGE_FLAGS_32BIT/0","title":"Evision.cv_UMAT_USAGE_FLAGS_32BIT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UNDEFINED/0","title":"Evision.cv_UNDEFINED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UNIFORM/0","title":"Evision.cv_UNIFORM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UNKNOWN_VENDOR/0","title":"Evision.cv_UNKNOWN_VENDOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UNSIGNED_INT/0","title":"Evision.cv_UNSIGNED_INT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UPDATE_MODEL/0","title":"Evision.cv_UPDATE_MODEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_UPDATE_WEIGHTS/0","title":"Evision.cv_UPDATE_WEIGHTS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAC_ACCURATE/0","title":"Evision.cv_USAC_ACCURATE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAC_DEFAULT/0","title":"Evision.cv_USAC_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAC_FAST/0","title":"Evision.cv_USAC_FAST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAC_FM_8PTS/0","title":"Evision.cv_USAC_FM_8PTS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAC_MAGSAC/0","title":"Evision.cv_USAC_MAGSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAC_PARALLEL/0","title":"Evision.cv_USAC_PARALLEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAC_PROSAC/0","title":"Evision.cv_USAC_PROSAC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAGE_ALLOCATE_DEVICE_MEMORY/0","title":"Evision.cv_USAGE_ALLOCATE_DEVICE_MEMORY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAGE_ALLOCATE_HOST_MEMORY/0","title":"Evision.cv_USAGE_ALLOCATE_HOST_MEMORY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAGE_ALLOCATE_SHARED_MEMORY/0","title":"Evision.cv_USAGE_ALLOCATE_SHARED_MEMORY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USAGE_DEFAULT/0","title":"Evision.cv_USAGE_DEFAULT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USE_AVG/0","title":"Evision.cv_USE_AVG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_USER_ALLOCATED/0","title":"Evision.cv_USER_ALLOCATED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VALUE_EXPECTED/0","title":"Evision.cv_VALUE_EXPECTED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VAR_CATEGORICAL/0","title":"Evision.cv_VAR_CATEGORICAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VAR_NUMERICAL/0","title":"Evision.cv_VAR_NUMERICAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VAR_ORDERED/0","title":"Evision.cv_VAR_ORDERED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VENDOR_AMD/0","title":"Evision.cv_VENDOR_AMD/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VENDOR_INTEL/0","title":"Evision.cv_VENDOR_INTEL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VENDOR_NVIDIA/0","title":"Evision.cv_VENDOR_NVIDIA/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEO_ACCELERATION_ANY/0","title":"Evision.cv_VIDEO_ACCELERATION_ANY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEO_ACCELERATION_D3D11/0","title":"Evision.cv_VIDEO_ACCELERATION_D3D11/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEO_ACCELERATION_MFX/0","title":"Evision.cv_VIDEO_ACCELERATION_MFX/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEO_ACCELERATION_NONE/0","title":"Evision.cv_VIDEO_ACCELERATION_NONE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEO_ACCELERATION_VAAPI/0","title":"Evision.cv_VIDEO_ACCELERATION_VAAPI/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_DEPTH/0","title":"Evision.cv_VIDEOWRITER_PROP_DEPTH/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_FRAMEBYTES/0","title":"Evision.cv_VIDEOWRITER_PROP_FRAMEBYTES/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_HW_ACCELERATION/0","title":"Evision.cv_VIDEOWRITER_PROP_HW_ACCELERATION/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL/0","title":"Evision.cv_VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_HW_DEVICE/0","title":"Evision.cv_VIDEOWRITER_PROP_HW_DEVICE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_IS_COLOR/0","title":"Evision.cv_VIDEOWRITER_PROP_IS_COLOR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_NSTRIPES/0","title":"Evision.cv_VIDEOWRITER_PROP_NSTRIPES/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VIDEOWRITER_PROP_QUALITY/0","title":"Evision.cv_VIDEOWRITER_PROP_QUALITY/0","type":"function"},{"doc":"","ref":"Evision.html#cv_VORONOI_SEAM/0","title":"Evision.cv_VORONOI_SEAM/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WARP_FILL_OUTLIERS/0","title":"Evision.cv_WARP_FILL_OUTLIERS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WARP_INVERSE_MAP/0","title":"Evision.cv_WARP_INVERSE_MAP/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WARP_POLAR_LINEAR/0","title":"Evision.cv_WARP_POLAR_LINEAR/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WARP_POLAR_LOG/0","title":"Evision.cv_WARP_POLAR_LOG/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WARP_SHUFFLE_FUNCTIONS/0","title":"Evision.cv_WARP_SHUFFLE_FUNCTIONS/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WAVE_CORRECT_AUTO/0","title":"Evision.cv_WAVE_CORRECT_AUTO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WAVE_CORRECT_HORIZ/0","title":"Evision.cv_WAVE_CORRECT_HORIZ/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WAVE_CORRECT_VERT/0","title":"Evision.cv_WAVE_CORRECT_VERT/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_AUTOSIZE/0","title":"Evision.cv_WINDOW_AUTOSIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_FREERATIO/0","title":"Evision.cv_WINDOW_FREERATIO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_FULLSCREEN/0","title":"Evision.cv_WINDOW_FULLSCREEN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_GUI_EXPANDED/0","title":"Evision.cv_WINDOW_GUI_EXPANDED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_GUI_NORMAL/0","title":"Evision.cv_WINDOW_GUI_NORMAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_KEEPRATIO/0","title":"Evision.cv_WINDOW_KEEPRATIO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_NORMAL/0","title":"Evision.cv_WINDOW_NORMAL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WINDOW_OPENGL/0","title":"Evision.cv_WINDOW_OPENGL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WND_PROP_ASPECT_RATIO/0","title":"Evision.cv_WND_PROP_ASPECT_RATIO/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WND_PROP_AUTOSIZE/0","title":"Evision.cv_WND_PROP_AUTOSIZE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WND_PROP_FULLSCREEN/0","title":"Evision.cv_WND_PROP_FULLSCREEN/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WND_PROP_OPENGL/0","title":"Evision.cv_WND_PROP_OPENGL/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WND_PROP_TOPMOST/0","title":"Evision.cv_WND_PROP_TOPMOST/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WND_PROP_VISIBLE/0","title":"Evision.cv_WND_PROP_VISIBLE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WND_PROP_VSYNC/0","title":"Evision.cv_WND_PROP_VSYNC/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WRITE/0","title":"Evision.cv_WRITE/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WRITE_BASE64/0","title":"Evision.cv_WRITE_BASE64/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WRITE_COMBINED/0","title":"Evision.cv_WRITE_COMBINED/0","type":"function"},{"doc":"","ref":"Evision.html#cv_WRITE_ONLY/0","title":"Evision.cv_WRITE_ONLY/0","type":"function"},{"doc":"Raising version of cvtColor/2 .","ref":"Evision.html#cvtColor!/2","title":"Evision.cvtColor!/2","type":"function"},{"doc":"Raising version of cvtColor/3 .","ref":"Evision.html#cvtColor!/3","title":"Evision.cvtColor!/3","type":"function"},{"doc":"Converts an image from one color space to another. Positional Arguments src : Evision.Mat . input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision floating-point. code : int . color space conversion code (see #ColorConversionCodes). Keyword Arguments dstCn : int . number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code. Return dst : Evision.Mat . output image of the same size and depth as src. The function converts an input image from one color space to another. In case of a transformation to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on. The conventional ranges for R, G, and B channel values are: 0 to 255 for CV_8U images 0 to 65535 for CV_16U images 0 to 1 for CV_32F images In case of linear transformations, the range does not matter. But in case of a non-linear transformation, an input RGB image should be normalized to the proper value range to get the correct results, for example, for RGB \\f$\\rightarrow\\f$ L*u*v* transformation. For example, if you have a 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor , you need first to scale the image down: img * = 1 . / 255 ; cvtColor ( img , img , COLOR_BGR2Luv ) ; If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-bit images in applications that need the full range of colors or that convert an image before an operation and then convert back. If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F. @see @ref imgproc_color_conversions Python prototype (for reference): cvtColor(src, code[, dst[, dstCn]]) -&gt; dst","ref":"Evision.html#cvtColor/2","title":"Evision.cvtColor/2","type":"function"},{"doc":"Converts an image from one color space to another. Positional Arguments src : Evision.Mat . input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision floating-point. code : int . color space conversion code (see #ColorConversionCodes). Keyword Arguments dstCn : int . number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code. Return dst : Evision.Mat . output image of the same size and depth as src. The function converts an input image from one color space to another. In case of a transformation to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on. The conventional ranges for R, G, and B channel values are: 0 to 255 for CV_8U images 0 to 65535 for CV_16U images 0 to 1 for CV_32F images In case of linear transformations, the range does not matter. But in case of a non-linear transformation, an input RGB image should be normalized to the proper value range to get the correct results, for example, for RGB \\f$\\rightarrow\\f$ L*u*v* transformation. For example, if you have a 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor , you need first to scale the image down: img * = 1 . / 255 ; cvtColor ( img , img , COLOR_BGR2Luv ) ; If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-bit images in applications that need the full range of colors or that convert an image before an operation and then convert back. If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F. @see @ref imgproc_color_conversions Python prototype (for reference): cvtColor(src, code[, dst[, dstCn]]) -&gt; dst","ref":"Evision.html#cvtColor/3","title":"Evision.cvtColor/3","type":"function"},{"doc":"Raising version of cvtColorTwoPlane/3 .","ref":"Evision.html#cvtColorTwoPlane!/3","title":"Evision.cvtColorTwoPlane!/3","type":"function"},{"doc":"Raising version of cvtColorTwoPlane/4 .","ref":"Evision.html#cvtColorTwoPlane!/4","title":"Evision.cvtColorTwoPlane!/4","type":"function"},{"doc":"Converts an image from one color space to another where the source image is stored in two planes. Positional Arguments src1 : Evision.Mat . 8-bit image (#CV_8U) of the Y plane. src2 : Evision.Mat . image containing interleaved U/V plane. code : int . Specifies the type of conversion. It can take any of the following values: #COLOR_YUV2BGR_NV12 #COLOR_YUV2RGB_NV12 #COLOR_YUV2BGRA_NV12 #COLOR_YUV2RGBA_NV12 #COLOR_YUV2BGR_NV21 #COLOR_YUV2RGB_NV21 #COLOR_YUV2BGRA_NV21 #COLOR_YUV2RGBA_NV21 Return dst : Evision.Mat . output image. This function only supports YUV420 to RGB conversion as of now. Python prototype (for reference): cvtColorTwoPlane(src1, src2, code[, dst]) -&gt; dst","ref":"Evision.html#cvtColorTwoPlane/3","title":"Evision.cvtColorTwoPlane/3","type":"function"},{"doc":"Converts an image from one color space to another where the source image is stored in two planes. Positional Arguments src1 : Evision.Mat . 8-bit image (#CV_8U) of the Y plane. src2 : Evision.Mat . image containing interleaved U/V plane. code : int . Specifies the type of conversion. It can take any of the following values: #COLOR_YUV2BGR_NV12 #COLOR_YUV2RGB_NV12 #COLOR_YUV2BGRA_NV12 #COLOR_YUV2RGBA_NV12 #COLOR_YUV2BGR_NV21 #COLOR_YUV2RGB_NV21 #COLOR_YUV2BGRA_NV21 #COLOR_YUV2RGBA_NV21 Return dst : Evision.Mat . output image. This function only supports YUV420 to RGB conversion as of now. Python prototype (for reference): cvtColorTwoPlane(src1, src2, code[, dst]) -&gt; dst","ref":"Evision.html#cvtColorTwoPlane/4","title":"Evision.cvtColorTwoPlane/4","type":"function"},{"doc":"Raising version of dct/1 .","ref":"Evision.html#dct!/1","title":"Evision.dct!/1","type":"function"},{"doc":"Raising version of dct/2 .","ref":"Evision.html#dct!/2","title":"Evision.dct!/2","type":"function"},{"doc":"Performs a forward or inverse discrete Cosine transform of 1D or 2D array. Positional Arguments src : Evision.Mat . input floating-point array. Keyword Arguments flags : int . transformation flags as a combination of cv::DftFlags (DCT_*) Return dst : Evision.Mat . output array of the same size and type as src . The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D floating-point array: Forward Cosine transform of a 1D vector of N elements: \\f[Y = C^{(N)} \\cdot X\\f] where \\f[C^{(N)}_{jk}= \\sqrt{\\alpha_j/N} \\cos \\left ( \\frac{\\pi(2k+1)j}{2N} \\right )\\f] and \\f$\\alpha_0=1\\f$, \\f$\\alpha_j=2\\f$ for j &gt; 0 . Inverse Cosine transform of a 1D vector of N elements: \\f[X = \\left (C^{(N)} \\right )^{-1} \\cdot Y = \\left (C^{(N)} \\right )^T \\cdot Y\\f] (since \\f$C^{(N)}\\f$ is an orthogonal matrix, \\f$C^{(N)} \\cdot \\left(C^{(N)}\\right)^T = I\\f$ ) Forward 2D Cosine transform of M x N matrix: \\f[Y = C^{(N)} \\cdot X \\cdot \\left (C^{(N)} \\right )^T\\f] Inverse 2D Cosine transform of M x N matrix: \\f[X = \\left (C^{(N)} \\right )^T \\cdot X \\cdot C^{(N)}\\f] The function chooses the mode of operation by looking at the flags and size of the input array: If (flags &amp; #DCT_INVERSE) == 0 , the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform. If (flags &amp; #DCT_ROWS) != 0 , the function performs a 1D transform of each row. If the array is a single column or a single row, the function performs a 1D transform. If none of the above is true, the function performs a 2D transform. Note : Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you can pad the array when necessary. Also, the function performance depends very much, and not monotonically, on the array size (see getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT of a vector of size N/2 . Thus, the optimal DCT size N1 &gt;= N can be calculated as: size_t getOptimalDCTSize ( size_t N ) { return 2 * getOptimalDFTSize ( ( N + 1 ) / 2 ) ; } N1 = getOptimalDCTSize ( N ) ; @sa dft , getOptimalDFTSize , idct Python prototype (for reference): dct(src[, dst[, flags]]) -&gt; dst","ref":"Evision.html#dct/1","title":"Evision.dct/1","type":"function"},{"doc":"Performs a forward or inverse discrete Cosine transform of 1D or 2D array. Positional Arguments src : Evision.Mat . input floating-point array. Keyword Arguments flags : int . transformation flags as a combination of cv::DftFlags (DCT_*) Return dst : Evision.Mat . output array of the same size and type as src . The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D floating-point array: Forward Cosine transform of a 1D vector of N elements: \\f[Y = C^{(N)} \\cdot X\\f] where \\f[C^{(N)}_{jk}= \\sqrt{\\alpha_j/N} \\cos \\left ( \\frac{\\pi(2k+1)j}{2N} \\right )\\f] and \\f$\\alpha_0=1\\f$, \\f$\\alpha_j=2\\f$ for j &gt; 0 . Inverse Cosine transform of a 1D vector of N elements: \\f[X = \\left (C^{(N)} \\right )^{-1} \\cdot Y = \\left (C^{(N)} \\right )^T \\cdot Y\\f] (since \\f$C^{(N)}\\f$ is an orthogonal matrix, \\f$C^{(N)} \\cdot \\left(C^{(N)}\\right)^T = I\\f$ ) Forward 2D Cosine transform of M x N matrix: \\f[Y = C^{(N)} \\cdot X \\cdot \\left (C^{(N)} \\right )^T\\f] Inverse 2D Cosine transform of M x N matrix: \\f[X = \\left (C^{(N)} \\right )^T \\cdot X \\cdot C^{(N)}\\f] The function chooses the mode of operation by looking at the flags and size of the input array: If (flags &amp; #DCT_INVERSE) == 0 , the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform. If (flags &amp; #DCT_ROWS) != 0 , the function performs a 1D transform of each row. If the array is a single column or a single row, the function performs a 1D transform. If none of the above is true, the function performs a 2D transform. Note : Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you can pad the array when necessary. Also, the function performance depends very much, and not monotonically, on the array size (see getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT of a vector of size N/2 . Thus, the optimal DCT size N1 &gt;= N can be calculated as: size_t getOptimalDCTSize ( size_t N ) { return 2 * getOptimalDFTSize ( ( N + 1 ) / 2 ) ; } N1 = getOptimalDCTSize ( N ) ; @sa dft , getOptimalDFTSize , idct Python prototype (for reference): dct(src[, dst[, flags]]) -&gt; dst","ref":"Evision.html#dct/2","title":"Evision.dct/2","type":"function"},{"doc":"Raising version of decolor/1 .","ref":"Evision.html#decolor!/1","title":"Evision.decolor!/1","type":"function"},{"doc":"Raising version of decolor/2 .","ref":"Evision.html#decolor!/2","title":"Evision.decolor!/2","type":"function"},{"doc":"Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized black-and-white photograph rendering, and in many single channel image processing applications Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Return grayscale : Evision.Mat . Output 8-bit 1-channel image. color_boost : Evision.Mat . Output 8-bit 3-channel image. @cite CL12 . This function is to be applied on color images. Python prototype (for reference): decolor(src[, grayscale[, color_boost]]) -&gt; grayscale, color_boost","ref":"Evision.html#decolor/1","title":"Evision.decolor/1","type":"function"},{"doc":"Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized black-and-white photograph rendering, and in many single channel image processing applications Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Return grayscale : Evision.Mat . Output 8-bit 1-channel image. color_boost : Evision.Mat . Output 8-bit 3-channel image. @cite CL12 . This function is to be applied on color images. Python prototype (for reference): decolor(src[, grayscale[, color_boost]]) -&gt; grayscale, color_boost","ref":"Evision.html#decolor/2","title":"Evision.decolor/2","type":"function"},{"doc":"Raising version of decomposeEssentialMat/1 .","ref":"Evision.html#decomposeEssentialMat!/1","title":"Evision.decomposeEssentialMat!/1","type":"function"},{"doc":"Raising version of decomposeEssentialMat/2 .","ref":"Evision.html#decomposeEssentialMat!/2","title":"Evision.decomposeEssentialMat!/2","type":"function"},{"doc":"Decompose an essential matrix to possible rotations and translation. Positional Arguments e : Evision.Mat . The input essential matrix. Return r1 : Evision.Mat . One possible rotation matrix. r2 : Evision.Mat . Another possible rotation matrix. t : Evision.Mat . One possible translation. This function decomposes the essential matrix E using svd decomposition @cite HartleyZ00. In general, four possible poses exist for the decomposition of E. They are \\f$[R_1, t]\\f$, \\f$[R_1, -t]\\f$, \\f$[R_2, t]\\f$, \\f$[R_2, -t]\\f$. If E gives the epipolar constraint \\f$[p_2; 1]^T A^{-T} E A^{-1} [p_1; 1] = 0\\f$ between the image points \\f$p_1\\f$ in the first image and \\f$p_2\\f$ in second image, then any of the tuples \\f$[R_1, t]\\f$, \\f$[R_1, -t]\\f$, \\f$[R_2, t]\\f$, \\f$[R_2, -t]\\f$ is a change of basis from the first camera's coordinate system to the second camera's coordinate system. However, by decomposing E, one can only get the direction of the translation. For this reason, the translation t is returned with unit length. Python prototype (for reference): decomposeEssentialMat(E[, R1[, R2[, t]]]) -&gt; R1, R2, t","ref":"Evision.html#decomposeEssentialMat/1","title":"Evision.decomposeEssentialMat/1","type":"function"},{"doc":"Decompose an essential matrix to possible rotations and translation. Positional Arguments e : Evision.Mat . The input essential matrix. Return r1 : Evision.Mat . One possible rotation matrix. r2 : Evision.Mat . Another possible rotation matrix. t : Evision.Mat . One possible translation. This function decomposes the essential matrix E using svd decomposition @cite HartleyZ00. In general, four possible poses exist for the decomposition of E. They are \\f$[R_1, t]\\f$, \\f$[R_1, -t]\\f$, \\f$[R_2, t]\\f$, \\f$[R_2, -t]\\f$. If E gives the epipolar constraint \\f$[p_2; 1]^T A^{-T} E A^{-1} [p_1; 1] = 0\\f$ between the image points \\f$p_1\\f$ in the first image and \\f$p_2\\f$ in second image, then any of the tuples \\f$[R_1, t]\\f$, \\f$[R_1, -t]\\f$, \\f$[R_2, t]\\f$, \\f$[R_2, -t]\\f$ is a change of basis from the first camera's coordinate system to the second camera's coordinate system. However, by decomposing E, one can only get the direction of the translation. For this reason, the translation t is returned with unit length. Python prototype (for reference): decomposeEssentialMat(E[, R1[, R2[, t]]]) -&gt; R1, R2, t","ref":"Evision.html#decomposeEssentialMat/2","title":"Evision.decomposeEssentialMat/2","type":"function"},{"doc":"Raising version of decomposeHomographyMat/2 .","ref":"Evision.html#decomposeHomographyMat!/2","title":"Evision.decomposeHomographyMat!/2","type":"function"},{"doc":"Raising version of decomposeHomographyMat/3 .","ref":"Evision.html#decomposeHomographyMat!/3","title":"Evision.decomposeHomographyMat!/3","type":"function"},{"doc":"Decompose a homography matrix to rotation(s), translation(s) and plane normal(s). Positional Arguments h : Evision.Mat . The input homography matrix between two images. k : Evision.Mat . The input camera intrinsic matrix. Return rotations : [Evision.Mat] . Array of rotation matrices. translations : [Evision.Mat] . Array of translation matrices. normals : [Evision.Mat] . Array of plane normal matrices. This function extracts relative camera motion between two views of a planar object and returns up to four mathematical solution tuples of rotation, translation, and plane normal. The decomposition of the homography matrix H is described in detail in @cite Malis. If the homography H, induced by the plane, gives the constraint \\f[s_i \\vecthree{x'_i}{y'_i}{1} \\sim H \\vecthree{x_i}{y_i}{1}\\f] on the source image points \\f$p_i\\f$ and the destination image points \\f$p'_i\\f$, then the tuple of rotations[k] and translations[k] is a change of basis from the source camera's coordinate system to the destination camera's coordinate system. However, by decomposing H, one can only get the translation normalized by the (typically unknown) depth of the scene, i.e. its direction but with normalized length. If point correspondences are available, at least two solutions may further be invalidated, by applying positive depth constraint, i.e. all points must be in front of the camera. Python prototype (for reference): decomposeHomographyMat(H, K[, rotations[, translations[, normals]]]) -&gt; retval, rotations, translations, normals","ref":"Evision.html#decomposeHomographyMat/2","title":"Evision.decomposeHomographyMat/2","type":"function"},{"doc":"Decompose a homography matrix to rotation(s), translation(s) and plane normal(s). Positional Arguments h : Evision.Mat . The input homography matrix between two images. k : Evision.Mat . The input camera intrinsic matrix. Return rotations : [Evision.Mat] . Array of rotation matrices. translations : [Evision.Mat] . Array of translation matrices. normals : [Evision.Mat] . Array of plane normal matrices. This function extracts relative camera motion between two views of a planar object and returns up to four mathematical solution tuples of rotation, translation, and plane normal. The decomposition of the homography matrix H is described in detail in @cite Malis. If the homography H, induced by the plane, gives the constraint \\f[s_i \\vecthree{x'_i}{y'_i}{1} \\sim H \\vecthree{x_i}{y_i}{1}\\f] on the source image points \\f$p_i\\f$ and the destination image points \\f$p'_i\\f$, then the tuple of rotations[k] and translations[k] is a change of basis from the source camera's coordinate system to the destination camera's coordinate system. However, by decomposing H, one can only get the translation normalized by the (typically unknown) depth of the scene, i.e. its direction but with normalized length. If point correspondences are available, at least two solutions may further be invalidated, by applying positive depth constraint, i.e. all points must be in front of the camera. Python prototype (for reference): decomposeHomographyMat(H, K[, rotations[, translations[, normals]]]) -&gt; retval, rotations, translations, normals","ref":"Evision.html#decomposeHomographyMat/3","title":"Evision.decomposeHomographyMat/3","type":"function"},{"doc":"Raising version of decomposeProjectionMatrix/1 .","ref":"Evision.html#decomposeProjectionMatrix!/1","title":"Evision.decomposeProjectionMatrix!/1","type":"function"},{"doc":"Raising version of decomposeProjectionMatrix/2 .","ref":"Evision.html#decomposeProjectionMatrix!/2","title":"Evision.decomposeProjectionMatrix!/2","type":"function"},{"doc":"Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix. Positional Arguments projMatrix : Evision.Mat . 3x4 input projection matrix P. Return cameraMatrix : Evision.Mat . Output 3x3 camera intrinsic matrix \\f$\\cameramatrix{A}\\f$. rotMatrix : Evision.Mat . Output 3x3 external rotation matrix R. transVect : Evision.Mat . Output 4x1 translation vector T. rotMatrixX : Evision.Mat . Optional 3x3 rotation matrix around x-axis. rotMatrixY : Evision.Mat . Optional 3x3 rotation matrix around y-axis. rotMatrixZ : Evision.Mat . Optional 3x3 rotation matrix around z-axis. eulerAngles : Evision.Mat . Optional three-element vector containing three Euler angles of rotation in degrees. The function computes a decomposition of a projection matrix into a calibration and a rotation matrix and the position of a camera. It optionally returns three rotation matrices, one for each axis, and three Euler angles that could be used in OpenGL. Note, there is always more than one sequence of rotations about the three principal axes that results in the same orientation of an object, e.g. see @cite Slabaugh . Returned tree rotation matrices and corresponding three Euler angles are only one of the possible solutions. The function is based on RQDecomp3x3 . Python prototype (for reference): decomposeProjectionMatrix(projMatrix[, cameraMatrix[, rotMatrix[, transVect[, rotMatrixX[, rotMatrixY[, rotMatrixZ[, eulerAngles]]]]]]]) -&gt; cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles","ref":"Evision.html#decomposeProjectionMatrix/1","title":"Evision.decomposeProjectionMatrix/1","type":"function"},{"doc":"Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix. Positional Arguments projMatrix : Evision.Mat . 3x4 input projection matrix P. Return cameraMatrix : Evision.Mat . Output 3x3 camera intrinsic matrix \\f$\\cameramatrix{A}\\f$. rotMatrix : Evision.Mat . Output 3x3 external rotation matrix R. transVect : Evision.Mat . Output 4x1 translation vector T. rotMatrixX : Evision.Mat . Optional 3x3 rotation matrix around x-axis. rotMatrixY : Evision.Mat . Optional 3x3 rotation matrix around y-axis. rotMatrixZ : Evision.Mat . Optional 3x3 rotation matrix around z-axis. eulerAngles : Evision.Mat . Optional three-element vector containing three Euler angles of rotation in degrees. The function computes a decomposition of a projection matrix into a calibration and a rotation matrix and the position of a camera. It optionally returns three rotation matrices, one for each axis, and three Euler angles that could be used in OpenGL. Note, there is always more than one sequence of rotations about the three principal axes that results in the same orientation of an object, e.g. see @cite Slabaugh . Returned tree rotation matrices and corresponding three Euler angles are only one of the possible solutions. The function is based on RQDecomp3x3 . Python prototype (for reference): decomposeProjectionMatrix(projMatrix[, cameraMatrix[, rotMatrix[, transVect[, rotMatrixX[, rotMatrixY[, rotMatrixZ[, eulerAngles]]]]]]]) -&gt; cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles","ref":"Evision.html#decomposeProjectionMatrix/2","title":"Evision.decomposeProjectionMatrix/2","type":"function"},{"doc":"Raising version of demosaicing/2 .","ref":"Evision.html#demosaicing!/2","title":"Evision.demosaicing!/2","type":"function"},{"doc":"Raising version of demosaicing/3 .","ref":"Evision.html#demosaicing!/3","title":"Evision.demosaicing!/3","type":"function"},{"doc":"main function for all demosaicing processes Positional Arguments src : Evision.Mat . input image: 8-bit unsigned or 16-bit unsigned. code : int . Color space conversion code (see the description below). Keyword Arguments dstCn : int . number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code. Return dst : Evision.Mat . output image of the same size and depth as src. The function can do the following transformations: Demosaicing using bilinear interpolation #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY Demosaicing using Variable Number of Gradients. #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG Edge-Aware Demosaicing. #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA Demosaicing with alpha channel #COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA @sa cvtColor Python prototype (for reference): demosaicing(src, code[, dst[, dstCn]]) -&gt; dst","ref":"Evision.html#demosaicing/2","title":"Evision.demosaicing/2","type":"function"},{"doc":"main function for all demosaicing processes Positional Arguments src : Evision.Mat . input image: 8-bit unsigned or 16-bit unsigned. code : int . Color space conversion code (see the description below). Keyword Arguments dstCn : int . number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code. Return dst : Evision.Mat . output image of the same size and depth as src. The function can do the following transformations: Demosaicing using bilinear interpolation #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY Demosaicing using Variable Number of Gradients. #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG Edge-Aware Demosaicing. #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA Demosaicing with alpha channel #COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA @sa cvtColor Python prototype (for reference): demosaicing(src, code[, dst[, dstCn]]) -&gt; dst","ref":"Evision.html#demosaicing/3","title":"Evision.demosaicing/3","type":"function"},{"doc":"Raising version of detailEnhance/1 .","ref":"Evision.html#detailEnhance!/1","title":"Evision.detailEnhance!/1","type":"function"},{"doc":"Raising version of detailEnhance/2 .","ref":"Evision.html#detailEnhance!/2","title":"Evision.detailEnhance!/2","type":"function"},{"doc":"This filter enhances the details of a particular image. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. Return dst : Evision.Mat . Output image with the same size and type as src. Python prototype (for reference): detailEnhance(src[, dst[, sigma_s[, sigma_r]]]) -&gt; dst","ref":"Evision.html#detailEnhance/1","title":"Evision.detailEnhance/1","type":"function"},{"doc":"This filter enhances the details of a particular image. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. Return dst : Evision.Mat . Output image with the same size and type as src. Python prototype (for reference): detailEnhance(src[, dst[, sigma_s[, sigma_r]]]) -&gt; dst","ref":"Evision.html#detailEnhance/2","title":"Evision.detailEnhance/2","type":"function"},{"doc":"Raising version of determinant/1 .","ref":"Evision.html#determinant!/1","title":"Evision.determinant!/1","type":"function"},{"doc":"Returns the determinant of a square floating-point matrix. Positional Arguments mtx : Evision.Mat . input matrix that must have CV_32FC1 or CV_64FC1 type and square size. The function cv::determinant calculates and returns the determinant of the specified matrix. For small matrices ( mtx.cols=mtx.rows\\&lt;=3 ), the direct method is used. For larger matrices, the function uses LU factorization with partial pivoting. For symmetric positively-determined matrices, it is also possible to use eigen decomposition to calculate the determinant. @sa trace, invert, solve, eigen, @ref MatrixExpressions Python prototype (for reference): determinant(mtx) -&gt; retval","ref":"Evision.html#determinant/1","title":"Evision.determinant/1","type":"function"},{"doc":"Raising version of dft/1 .","ref":"Evision.html#dft!/1","title":"Evision.dft!/1","type":"function"},{"doc":"Raising version of dft/2 .","ref":"Evision.html#dft!/2","title":"Evision.dft!/2","type":"function"},{"doc":"Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array. Positional Arguments src : Evision.Mat . input array that could be real or complex. Keyword Arguments flags : int . transformation flags, representing a combination of the #DftFlags nonzeroRows : int . when the parameter is not zero, the function assumes that only the first nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-correlation or convolution using DFT. Return dst : Evision.Mat . output array whose size and type depends on the flags . The function cv::dft performs one of the following: Forward the Fourier transform of a 1D vector of N elements: \\f[Y = F^{(N)} \\cdot X,\\f] where \\f$F^{(N)}_{jk}=\\exp(-2\\pi i j k/N)\\f$ and \\f$i=\\sqrt{-1}\\f$ Inverse the Fourier transform of a 1D vector of N elements: \\f[\\begin{array}{l} X'= \\left (F^{(N)} \\right )^{-1} \\cdot Y = \\left (F^{(N)} \\right )^* \\cdot y \\\\ X = (1/N) \\cdot X, \\end{array}\\f] where \\f$F^*=\\left(\\textrm{Re}(F^{(N)})-\\textrm{Im}(F^{(N)})\\right)^T\\f$ Forward the 2D Fourier transform of a M x N matrix: \\f[Y = F^{(M)} \\cdot X \\cdot F^{(N)}\\f] Inverse the 2D Fourier transform of a M x N matrix: \\f[\\begin{array}{l} X'= \\left (F^{(M)} \\right )^* \\cdot Y \\cdot \\left (F^{(N)} \\right )^* \\\\ X = \\frac{1}{M \\cdot N} \\cdot X' \\end{array}\\f] In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called CCS (complex-conjugate-symmetrical). It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D CCS spectrum looks: \\f[\\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp; \\cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2} \\\\ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp; \\cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2} \\\\ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp; \\cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2} \\\\ \\hdotsfor{9} \\\\ Re Y_{M/2-1,0} &amp; Re Y_{M-3,1} &amp; Im Y_{M-3,1} &amp; \\hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2} \\\\ Im Y_{M/2-1,0} &amp; Re Y_{M-2,1} &amp; Im Y_{M-2,1} &amp; \\hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2} \\\\ Re Y_{M/2,0} &amp; Re Y_{M-1,1} &amp; Im Y_{M-1,1} &amp; \\hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \\end{bmatrix}\\f] In case of 1D transform of a real vector, the output looks like the first row of the matrix above. So, the function chooses an operation mode depending on the flags and size of the input array: If #DFT_ROWS is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set. Otherwise, it performs a 2D transform. If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or 2D transform: When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as input. When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix looks like the first row of the matrix above. If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags DFT_INVERSE and DFT_ROWS. When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags #DFT_INVERSE and #DFT_ROWS. If #DFT_SCALE is set, the scaling is done after the transformation. Unlike dct , the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize method. The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays: void convolveDFT ( InputArray A , InputArray B , OutputArray C ) { // reallocate the output array if needed C . create ( abs ( A . rows - B . rows ) + 1 , abs ( A . cols - B . cols ) + 1 , A . type ( ) ) ; Size dftSize ; // calculate the size of DFT transform dftSize . width = getOptimalDFTSize ( A . cols + B . cols - 1 ) ; dftSize . height = getOptimalDFTSize ( A . rows + B . rows - 1 ) ; // allocate temporary buffers and initialize them with 0 &#39; s Mat tempA ( dftSize , A . type ( ) , Scalar :: all ( 0 ) ) ; Mat tempB ( dftSize , B . type ( ) , Scalar :: all ( 0 ) ) ; // copy A and B to the top - left corners of tempA and tempB , respectively Mat roiA ( tempA , Rect ( 0 , 0 , A . cols , A . rows ) ) ; A . copyTo ( roiA ) ; Mat roiB ( tempB , Rect ( 0 , 0 , B . cols , B . rows ) ) ; B . copyTo ( roiB ) ; // now transform the padded A &amp; B in - place ; // use &quot;nonzeroRows&quot; hint for faster processing dft ( tempA , tempA , 0 , A . rows ) ; dft ( tempB , tempB , 0 , B . rows ) ; // multiply the spectrums ; // the function handles packed spectrum representations well mulSpectrums ( tempA , tempB , tempA ) ; // transform the product back from the frequency domain . // Even though all the result rows will be non - zero , // you need only the first C . rows of them , and thus you // pass nonzeroRows == C . rows dft ( tempA , tempA , DFT_INVERSE + DFT_SCALE , C . rows ) ; // now copy the result back to C . tempA ( Rect ( 0 , 0 , C . cols , C . rows ) ) . copyTo ( C ) ; // all the temporary buffers will be deallocated automatically } To optimize this sample, consider the following approaches: Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols) rightmost columns of the matrices. This DFT-based convolution does not have to be applied to the whole big arrays, especially if B is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array C into multiple tiles. For each tile, estimate which parts of A and B are required to calculate convolution in this tile. If the tiles in C are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle. If different tiles in C can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded. All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-correlation, not convolution, so you need to &quot;flip&quot; the second convolution operand B vertically and horizontally using flip . Note : An example using the discrete fourier transform can be found at opencv_source_code/samples/cpp/dft.cpp (Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv_source/samples/python/deconvolution.py (Python) An example rearranging the quadrants of a Fourier image can be found at opencv_source/samples/python/dft.py @sa dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar , magnitude , phase Python prototype (for reference): dft(src[, dst[, flags[, nonzeroRows]]]) -&gt; dst","ref":"Evision.html#dft/1","title":"Evision.dft/1","type":"function"},{"doc":"Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array. Positional Arguments src : Evision.Mat . input array that could be real or complex. Keyword Arguments flags : int . transformation flags, representing a combination of the #DftFlags nonzeroRows : int . when the parameter is not zero, the function assumes that only the first nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-correlation or convolution using DFT. Return dst : Evision.Mat . output array whose size and type depends on the flags . The function cv::dft performs one of the following: Forward the Fourier transform of a 1D vector of N elements: \\f[Y = F^{(N)} \\cdot X,\\f] where \\f$F^{(N)}_{jk}=\\exp(-2\\pi i j k/N)\\f$ and \\f$i=\\sqrt{-1}\\f$ Inverse the Fourier transform of a 1D vector of N elements: \\f[\\begin{array}{l} X'= \\left (F^{(N)} \\right )^{-1} \\cdot Y = \\left (F^{(N)} \\right )^* \\cdot y \\\\ X = (1/N) \\cdot X, \\end{array}\\f] where \\f$F^*=\\left(\\textrm{Re}(F^{(N)})-\\textrm{Im}(F^{(N)})\\right)^T\\f$ Forward the 2D Fourier transform of a M x N matrix: \\f[Y = F^{(M)} \\cdot X \\cdot F^{(N)}\\f] Inverse the 2D Fourier transform of a M x N matrix: \\f[\\begin{array}{l} X'= \\left (F^{(M)} \\right )^* \\cdot Y \\cdot \\left (F^{(N)} \\right )^* \\\\ X = \\frac{1}{M \\cdot N} \\cdot X' \\end{array}\\f] In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called CCS (complex-conjugate-symmetrical). It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D CCS spectrum looks: \\f[\\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp; \\cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2} \\\\ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp; \\cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2} \\\\ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp; \\cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2} \\\\ \\hdotsfor{9} \\\\ Re Y_{M/2-1,0} &amp; Re Y_{M-3,1} &amp; Im Y_{M-3,1} &amp; \\hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2} \\\\ Im Y_{M/2-1,0} &amp; Re Y_{M-2,1} &amp; Im Y_{M-2,1} &amp; \\hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2} \\\\ Re Y_{M/2,0} &amp; Re Y_{M-1,1} &amp; Im Y_{M-1,1} &amp; \\hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \\end{bmatrix}\\f] In case of 1D transform of a real vector, the output looks like the first row of the matrix above. So, the function chooses an operation mode depending on the flags and size of the input array: If #DFT_ROWS is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set. Otherwise, it performs a 2D transform. If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or 2D transform: When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as input. When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix looks like the first row of the matrix above. If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags DFT_INVERSE and DFT_ROWS. When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags #DFT_INVERSE and #DFT_ROWS. If #DFT_SCALE is set, the scaling is done after the transformation. Unlike dct , the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize method. The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays: void convolveDFT ( InputArray A , InputArray B , OutputArray C ) { // reallocate the output array if needed C . create ( abs ( A . rows - B . rows ) + 1 , abs ( A . cols - B . cols ) + 1 , A . type ( ) ) ; Size dftSize ; // calculate the size of DFT transform dftSize . width = getOptimalDFTSize ( A . cols + B . cols - 1 ) ; dftSize . height = getOptimalDFTSize ( A . rows + B . rows - 1 ) ; // allocate temporary buffers and initialize them with 0 &#39; s Mat tempA ( dftSize , A . type ( ) , Scalar :: all ( 0 ) ) ; Mat tempB ( dftSize , B . type ( ) , Scalar :: all ( 0 ) ) ; // copy A and B to the top - left corners of tempA and tempB , respectively Mat roiA ( tempA , Rect ( 0 , 0 , A . cols , A . rows ) ) ; A . copyTo ( roiA ) ; Mat roiB ( tempB , Rect ( 0 , 0 , B . cols , B . rows ) ) ; B . copyTo ( roiB ) ; // now transform the padded A &amp; B in - place ; // use &quot;nonzeroRows&quot; hint for faster processing dft ( tempA , tempA , 0 , A . rows ) ; dft ( tempB , tempB , 0 , B . rows ) ; // multiply the spectrums ; // the function handles packed spectrum representations well mulSpectrums ( tempA , tempB , tempA ) ; // transform the product back from the frequency domain . // Even though all the result rows will be non - zero , // you need only the first C . rows of them , and thus you // pass nonzeroRows == C . rows dft ( tempA , tempA , DFT_INVERSE + DFT_SCALE , C . rows ) ; // now copy the result back to C . tempA ( Rect ( 0 , 0 , C . cols , C . rows ) ) . copyTo ( C ) ; // all the temporary buffers will be deallocated automatically } To optimize this sample, consider the following approaches: Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols) rightmost columns of the matrices. This DFT-based convolution does not have to be applied to the whole big arrays, especially if B is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array C into multiple tiles. For each tile, estimate which parts of A and B are required to calculate convolution in this tile. If the tiles in C are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle. If different tiles in C can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded. All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-correlation, not convolution, so you need to &quot;flip&quot; the second convolution operand B vertically and horizontally using flip . Note : An example using the discrete fourier transform can be found at opencv_source_code/samples/cpp/dft.cpp (Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv_source/samples/python/deconvolution.py (Python) An example rearranging the quadrants of a Fourier image can be found at opencv_source/samples/python/dft.py @sa dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar , magnitude , phase Python prototype (for reference): dft(src[, dst[, flags[, nonzeroRows]]]) -&gt; dst","ref":"Evision.html#dft/2","title":"Evision.dft/2","type":"function"},{"doc":"Raising version of dilate/2 .","ref":"Evision.html#dilate!/2","title":"Evision.dilate!/2","type":"function"},{"doc":"Raising version of dilate/3 .","ref":"Evision.html#dilate!/3","title":"Evision.dilate!/3","type":"function"},{"doc":"Dilates an image by using a specific structuring element. Positional Arguments src : Evision.Mat . input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. kernel : Evision.Mat . structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using #getStructuringElement Keyword Arguments anchor : Point . position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. iterations : int . number of times dilation is applied. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported. borderValue : Scalar . border value in case of a constant border Return dst : Evision.Mat . output image of the same size and type as src. The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: \\f[\\texttt{dst} (x,y) = \\max _{(x',y'): \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f] The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently. @sa erode, morphologyEx, getStructuringElement Python prototype (for reference): dilate(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -&gt; dst","ref":"Evision.html#dilate/2","title":"Evision.dilate/2","type":"function"},{"doc":"Dilates an image by using a specific structuring element. Positional Arguments src : Evision.Mat . input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. kernel : Evision.Mat . structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using #getStructuringElement Keyword Arguments anchor : Point . position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. iterations : int . number of times dilation is applied. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported. borderValue : Scalar . border value in case of a constant border Return dst : Evision.Mat . output image of the same size and type as src. The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: \\f[\\texttt{dst} (x,y) = \\max _{(x',y'): \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f] The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently. @sa erode, morphologyEx, getStructuringElement Python prototype (for reference): dilate(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -&gt; dst","ref":"Evision.html#dilate/3","title":"Evision.dilate/3","type":"function"},{"doc":"Raising version of displayOverlay/2 .","ref":"Evision.html#displayOverlay!/2","title":"Evision.displayOverlay!/2","type":"function"},{"doc":"Raising version of displayOverlay/3 .","ref":"Evision.html#displayOverlay!/3","title":"Evision.displayOverlay!/3","type":"function"},{"doc":"Displays a text on a window image as an overlay for a specified duration. Positional Arguments winname : String . Name of the window. text : String . Overlay text to write on a window image. Keyword Arguments delayms : int . The period (in milliseconds), during which the overlay text is displayed. If this function is called before the previous overlay text timed out, the timer is restarted and the text is updated. If this value is zero, the text never disappears. The function displayOverlay displays useful information/tips on top of the window for a certain amount of time delayms . The function does not modify the image, displayed in the window, that is, after the specified delay the original content of the window is restored. Python prototype (for reference): displayOverlay(winname, text[, delayms]) -&gt; None","ref":"Evision.html#displayOverlay/2","title":"Evision.displayOverlay/2","type":"function"},{"doc":"Displays a text on a window image as an overlay for a specified duration. Positional Arguments winname : String . Name of the window. text : String . Overlay text to write on a window image. Keyword Arguments delayms : int . The period (in milliseconds), during which the overlay text is displayed. If this function is called before the previous overlay text timed out, the timer is restarted and the text is updated. If this value is zero, the text never disappears. The function displayOverlay displays useful information/tips on top of the window for a certain amount of time delayms . The function does not modify the image, displayed in the window, that is, after the specified delay the original content of the window is restored. Python prototype (for reference): displayOverlay(winname, text[, delayms]) -&gt; None","ref":"Evision.html#displayOverlay/3","title":"Evision.displayOverlay/3","type":"function"},{"doc":"Raising version of displayStatusBar/2 .","ref":"Evision.html#displayStatusBar!/2","title":"Evision.displayStatusBar!/2","type":"function"},{"doc":"Raising version of displayStatusBar/3 .","ref":"Evision.html#displayStatusBar!/3","title":"Evision.displayStatusBar!/3","type":"function"},{"doc":"Displays a text on the window statusbar during the specified period of time. Positional Arguments winname : String . Name of the window. text : String . Text to write on the window statusbar. Keyword Arguments delayms : int . Duration (in milliseconds) to display the text. If this function is called before the previous text timed out, the timer is restarted and the text is updated. If this value is zero, the text never disappears. The function displayStatusBar displays useful information/tips on top of the window for a certain amount of time delayms . This information is displayed on the window statusbar (the window must be created with the CV_GUI_EXPANDED flags). Python prototype (for reference): displayStatusBar(winname, text[, delayms]) -&gt; None","ref":"Evision.html#displayStatusBar/2","title":"Evision.displayStatusBar/2","type":"function"},{"doc":"Displays a text on the window statusbar during the specified period of time. Positional Arguments winname : String . Name of the window. text : String . Text to write on the window statusbar. Keyword Arguments delayms : int . Duration (in milliseconds) to display the text. If this function is called before the previous text timed out, the timer is restarted and the text is updated. If this value is zero, the text never disappears. The function displayStatusBar displays useful information/tips on top of the window for a certain amount of time delayms . This information is displayed on the window statusbar (the window must be created with the CV_GUI_EXPANDED flags). Python prototype (for reference): displayStatusBar(winname, text[, delayms]) -&gt; None","ref":"Evision.html#displayStatusBar/3","title":"Evision.displayStatusBar/3","type":"function"},{"doc":"Raising version of distanceTransform/3 .","ref":"Evision.html#distanceTransform!/3","title":"Evision.distanceTransform!/3","type":"function"},{"doc":"Raising version of distanceTransform/4 .","ref":"Evision.html#distanceTransform!/4","title":"Evision.distanceTransform!/4","type":"function"},{"doc":"Positional Arguments src : Evision.Mat . 8-bit, single-channel (binary) source image. distanceType : int . Type of distance, see #DistanceTypes maskSize : int . Size of the distance transform mask, see #DistanceTransformMasks. In case of the #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times 5\\f$ or any larger aperture. Keyword Arguments dstType : int . Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for the first variant of the function and distanceType == #DIST_L1. Return dst : Evision.Mat . Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src . Has overloading in C++ Python prototype (for reference): distanceTransform(src, distanceType, maskSize[, dst[, dstType]]) -&gt; dst","ref":"Evision.html#distanceTransform/3","title":"Evision.distanceTransform/3","type":"function"},{"doc":"Positional Arguments src : Evision.Mat . 8-bit, single-channel (binary) source image. distanceType : int . Type of distance, see #DistanceTypes maskSize : int . Size of the distance transform mask, see #DistanceTransformMasks. In case of the #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times 5\\f$ or any larger aperture. Keyword Arguments dstType : int . Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for the first variant of the function and distanceType == #DIST_L1. Return dst : Evision.Mat . Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src . Has overloading in C++ Python prototype (for reference): distanceTransform(src, distanceType, maskSize[, dst[, dstType]]) -&gt; dst","ref":"Evision.html#distanceTransform/4","title":"Evision.distanceTransform/4","type":"function"},{"doc":"Raising version of distanceTransformWithLabels/3 .","ref":"Evision.html#distanceTransformWithLabels!/3","title":"Evision.distanceTransformWithLabels!/3","type":"function"},{"doc":"Raising version of distanceTransformWithLabels/4 .","ref":"Evision.html#distanceTransformWithLabels!/4","title":"Evision.distanceTransformWithLabels!/4","type":"function"},{"doc":"Calculates the distance to the closest zero pixel for each pixel of the source image. Positional Arguments src : Evision.Mat . 8-bit, single-channel (binary) source image. distanceType : int . Type of distance, see #DistanceTypes maskSize : int . Size of the distance transform mask, see #DistanceTransformMasks. #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times 5\\f$ or any larger aperture. Keyword Arguments labelType : int . Type of the label array to build, see #DistanceTransformLabelTypes. Return dst : Evision.Mat . Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src. labels : Evision.Mat . Output 2D array of labels (the discrete Voronoi diagram). It has the type CV_32SC1 and the same size as src. The function cv::distanceTransform calculates the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero. When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the algorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library. In other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical, diagonal, or knight's move (the latest is available for a \\f$5\\times 5\\f$ mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all the diagonal shifts must have the same cost (denoted as b ), and all knight's moves must have the same cost (denoted as c ). For the #DIST_C and #DIST_L1 types, the distance is calculated precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a relative error (a \\f$5\\times 5\\f$ mask gives more accurate results). For a , b , and c , OpenCV uses the values suggested in the original paper: DIST_L1: a = 1, b = 2 DIST_L2: 3 x 3 : a=0.955, b=1.3693 5 x 5 : a=1, b=1.4, c=2.1969 DIST_C: a = 1, b = 1 Typically, for a fast, coarse distance estimation #DIST_L2, a \\f$3\\times 3\\f$ mask is used. For a more accurate distance estimation #DIST_L2, a \\f$5\\times 5\\f$ mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels. This variant of the function does not only compute the minimum distance for each pixel \\f$(x, y)\\f$ but also identifies the nearest connected component consisting of zero pixels (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the component/pixel is stored in labels(x, y) . When labelType==#DIST_LABEL_CCOMP, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When labelType==#DIST_LABEL_PIXEL, the function scans through the input image and marks all the zero pixels with distinct labels. In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported yet. Python prototype (for reference): distanceTransformWithLabels(src, distanceType, maskSize[, dst[, labels[, labelType]]]) -&gt; dst, labels","ref":"Evision.html#distanceTransformWithLabels/3","title":"Evision.distanceTransformWithLabels/3","type":"function"},{"doc":"Calculates the distance to the closest zero pixel for each pixel of the source image. Positional Arguments src : Evision.Mat . 8-bit, single-channel (binary) source image. distanceType : int . Type of distance, see #DistanceTypes maskSize : int . Size of the distance transform mask, see #DistanceTransformMasks. #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times 5\\f$ or any larger aperture. Keyword Arguments labelType : int . Type of the label array to build, see #DistanceTransformLabelTypes. Return dst : Evision.Mat . Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src. labels : Evision.Mat . Output 2D array of labels (the discrete Voronoi diagram). It has the type CV_32SC1 and the same size as src. The function cv::distanceTransform calculates the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero. When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the algorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library. In other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical, diagonal, or knight's move (the latest is available for a \\f$5\\times 5\\f$ mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all the diagonal shifts must have the same cost (denoted as b ), and all knight's moves must have the same cost (denoted as c ). For the #DIST_C and #DIST_L1 types, the distance is calculated precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a relative error (a \\f$5\\times 5\\f$ mask gives more accurate results). For a , b , and c , OpenCV uses the values suggested in the original paper: DIST_L1: a = 1, b = 2 DIST_L2: 3 x 3 : a=0.955, b=1.3693 5 x 5 : a=1, b=1.4, c=2.1969 DIST_C: a = 1, b = 1 Typically, for a fast, coarse distance estimation #DIST_L2, a \\f$3\\times 3\\f$ mask is used. For a more accurate distance estimation #DIST_L2, a \\f$5\\times 5\\f$ mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels. This variant of the function does not only compute the minimum distance for each pixel \\f$(x, y)\\f$ but also identifies the nearest connected component consisting of zero pixels (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the component/pixel is stored in labels(x, y) . When labelType==#DIST_LABEL_CCOMP, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When labelType==#DIST_LABEL_PIXEL, the function scans through the input image and marks all the zero pixels with distinct labels. In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported yet. Python prototype (for reference): distanceTransformWithLabels(src, distanceType, maskSize[, dst[, labels[, labelType]]]) -&gt; dst, labels","ref":"Evision.html#distanceTransformWithLabels/4","title":"Evision.distanceTransformWithLabels/4","type":"function"},{"doc":"Raising version of divide/2 .","ref":"Evision.html#divide!/2","title":"Evision.divide!/2","type":"function"},{"doc":"Raising version of divide/3 .","ref":"Evision.html#divide!/3","title":"Evision.divide!/3","type":"function"},{"doc":"Variant 1: Positional Arguments scale : double src2 : Evision.Mat Keyword Arguments dtype : int . Return dst : Evision.Mat . Has overloading in C++ Python prototype (for reference): divide(scale, src2[, dst[, dtype]]) -&gt; dst Variant 2: Performs per-element division of two arrays or a scalar by an array. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and type as src1. Keyword Arguments scale : double . scalar factor. dtype : int . optional depth of the output array; if -1, dst will have depth src2.depth(), but in case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth(). Return dst : Evision.Mat . output array of the same size and type as src2. The function cv::divide divides one array by another: \\f[\\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\\f] or a scalar by an array when there is no src1 : \\f[\\texttt{dst(I) = saturate(scale/src2(I))}\\f] Different channels of multi-channel arrays are processed independently. For integer types when src2(I) is zero, dst(I) will also be zero. Note : In case of floating point data there is no special defined behavior for zero src2(I) values. Regular floating-point division is used. Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values). Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa multiply, add, subtract Python prototype (for reference): divide(src1, src2[, dst[, scale[, dtype]]]) -&gt; dst","ref":"Evision.html#divide/2","title":"Evision.divide/2","type":"function"},{"doc":"Variant 1: Positional Arguments scale : double src2 : Evision.Mat Keyword Arguments dtype : int . Return dst : Evision.Mat . Has overloading in C++ Python prototype (for reference): divide(scale, src2[, dst[, dtype]]) -&gt; dst Variant 2: Performs per-element division of two arrays or a scalar by an array. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and type as src1. Keyword Arguments scale : double . scalar factor. dtype : int . optional depth of the output array; if -1, dst will have depth src2.depth(), but in case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth(). Return dst : Evision.Mat . output array of the same size and type as src2. The function cv::divide divides one array by another: \\f[\\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\\f] or a scalar by an array when there is no src1 : \\f[\\texttt{dst(I) = saturate(scale/src2(I))}\\f] Different channels of multi-channel arrays are processed independently. For integer types when src2(I) is zero, dst(I) will also be zero. Note : In case of floating point data there is no special defined behavior for zero src2(I) values. Regular floating-point division is used. Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values). Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa multiply, add, subtract Python prototype (for reference): divide(src1, src2[, dst[, scale[, dtype]]]) -&gt; dst","ref":"Evision.html#divide/3","title":"Evision.divide/3","type":"function"},{"doc":"Raising version of divSpectrums/3 .","ref":"Evision.html#divSpectrums!/3","title":"Evision.divSpectrums!/3","type":"function"},{"doc":"Raising version of divSpectrums/4 .","ref":"Evision.html#divSpectrums!/4","title":"Evision.divSpectrums!/4","type":"function"},{"doc":"Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum. Positional Arguments a : Evision.Mat . first input array. b : Evision.Mat . second input array of the same size and type as src1 . flags : int . operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a 0 as value. Keyword Arguments conjB : bool . optional flag that conjugates the second input array before the multiplication (true) or not (false). Return c : Evision.Mat . output array of the same size and type as src1 . The function cv::divSpectrums performs the per-element division of the first array by the second array. The arrays are CCS-packed or complex matrices that are results of a real or complex Fourier transform. Python prototype (for reference): divSpectrums(a, b, flags[, c[, conjB]]) -&gt; c","ref":"Evision.html#divSpectrums/3","title":"Evision.divSpectrums/3","type":"function"},{"doc":"Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum. Positional Arguments a : Evision.Mat . first input array. b : Evision.Mat . second input array of the same size and type as src1 . flags : int . operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a 0 as value. Keyword Arguments conjB : bool . optional flag that conjugates the second input array before the multiplication (true) or not (false). Return c : Evision.Mat . output array of the same size and type as src1 . The function cv::divSpectrums performs the per-element division of the first array by the second array. The arrays are CCS-packed or complex matrices that are results of a real or complex Fourier transform. Python prototype (for reference): divSpectrums(a, b, flags[, c[, conjB]]) -&gt; c","ref":"Evision.html#divSpectrums/4","title":"Evision.divSpectrums/4","type":"function"},{"doc":"Raising version of drawChessboardCorners/4 .","ref":"Evision.html#drawChessboardCorners!/4","title":"Evision.drawChessboardCorners!/4","type":"function"},{"doc":"Renders the detected chessboard corners. Positional Arguments patternSize : Size . Number of inner corners per a chessboard row and column (patternSize = cv::Size(points_per_row,points_per_column)). corners : Evision.Mat . Array of detected corners, the output of #findChessboardCorners. patternWasFound : bool . Parameter indicating whether the complete board was found or not. The return value of #findChessboardCorners should be passed here. Return image : Evision.Mat . Destination image. It must be an 8-bit color image. The function draws individual chessboard corners detected either as red circles if the board was not found, or as colored corners connected with lines if the board was found. Python prototype (for reference): drawChessboardCorners(image, patternSize, corners, patternWasFound) -&gt; image","ref":"Evision.html#drawChessboardCorners/4","title":"Evision.drawChessboardCorners/4","type":"function"},{"doc":"Raising version of drawContours/4 .","ref":"Evision.html#drawContours!/4","title":"Evision.drawContours!/4","type":"function"},{"doc":"Raising version of drawContours/5 .","ref":"Evision.html#drawContours!/5","title":"Evision.drawContours!/5","type":"function"},{"doc":"Draws contours outlines or filled contours. Positional Arguments contours : [Evision.Mat] . All the input contours. Each contour is stored as a point vector. contourIdx : int . Parameter indicating a contour to draw. If it is negative, all the contours are drawn. color : Scalar . Color of the contours. Keyword Arguments thickness : int . Thickness of lines the contours are drawn with. If it is negative (for example, thickness=#FILLED ), the contour interiors are drawn. lineType : int . Line connectivity. See #LineTypes hierarchy : Evision.Mat . Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see maxLevel ). maxLevel : int . Maximal level for drawn contours. If it is 0, only the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. offset : Point . Optional contour shift parameter. Shift all the drawn contours by the specified \\f$\\texttt{offset}=(dx,dy)\\f$ . Return image : Evision.Mat . Destination image. The function draws contour outlines in the image if \\f$\\texttt{thickness} \\ge 0\\f$ or fills the area bounded by the contours if \\f$\\texttt{thickness}&lt;0\\f$ . The example below shows how to retrieve connected components from the binary image and label them: : @include snippets/imgproc_drawContours.cpp Note : When thickness=#FILLED, the function is designed to handle connected components with holes correctly even when no hierarchy data is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call #drawContours separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. Python prototype (for reference): drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]) -&gt; image","ref":"Evision.html#drawContours/4","title":"Evision.drawContours/4","type":"function"},{"doc":"Draws contours outlines or filled contours. Positional Arguments contours : [Evision.Mat] . All the input contours. Each contour is stored as a point vector. contourIdx : int . Parameter indicating a contour to draw. If it is negative, all the contours are drawn. color : Scalar . Color of the contours. Keyword Arguments thickness : int . Thickness of lines the contours are drawn with. If it is negative (for example, thickness=#FILLED ), the contour interiors are drawn. lineType : int . Line connectivity. See #LineTypes hierarchy : Evision.Mat . Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see maxLevel ). maxLevel : int . Maximal level for drawn contours. If it is 0, only the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. offset : Point . Optional contour shift parameter. Shift all the drawn contours by the specified \\f$\\texttt{offset}=(dx,dy)\\f$ . Return image : Evision.Mat . Destination image. The function draws contour outlines in the image if \\f$\\texttt{thickness} \\ge 0\\f$ or fills the area bounded by the contours if \\f$\\texttt{thickness}&lt;0\\f$ . The example below shows how to retrieve connected components from the binary image and label them: : @include snippets/imgproc_drawContours.cpp Note : When thickness=#FILLED, the function is designed to handle connected components with holes correctly even when no hierarchy data is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call #drawContours separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. Python prototype (for reference): drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]) -&gt; image","ref":"Evision.html#drawContours/5","title":"Evision.drawContours/5","type":"function"},{"doc":"Raising version of drawFrameAxes/6 .","ref":"Evision.html#drawFrameAxes!/6","title":"Evision.drawFrameAxes!/6","type":"function"},{"doc":"Raising version of drawFrameAxes/7 .","ref":"Evision.html#drawFrameAxes!/7","title":"Evision.drawFrameAxes!/7","type":"function"},{"doc":"Draw axes of the world/object coordinate system from pose estimation. @sa solvePnP Positional Arguments cameraMatrix : Evision.Mat . Input 3x3 floating-point matrix of camera intrinsic parameters. \\f$\\cameramatrix{A}\\f$ distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is empty, the zero distortion coefficients are assumed. rvec : Evision.Mat . Rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. tvec : Evision.Mat . Translation vector. length : float . Length of the painted axes in the same unit than tvec (usually in meters). Keyword Arguments thickness : int . Line thickness of the painted axes. Return image : Evision.Mat . Input/output image. It must have 1 or 3 channels. The number of channels is not altered. This function draws the axes of the world/object coordinate system w.r.t. to the camera frame. OX is drawn in red, OY in green and OZ in blue. Python prototype (for reference): drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length[, thickness]) -&gt; image","ref":"Evision.html#drawFrameAxes/6","title":"Evision.drawFrameAxes/6","type":"function"},{"doc":"Draw axes of the world/object coordinate system from pose estimation. @sa solvePnP Positional Arguments cameraMatrix : Evision.Mat . Input 3x3 floating-point matrix of camera intrinsic parameters. \\f$\\cameramatrix{A}\\f$ distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is empty, the zero distortion coefficients are assumed. rvec : Evision.Mat . Rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. tvec : Evision.Mat . Translation vector. length : float . Length of the painted axes in the same unit than tvec (usually in meters). Keyword Arguments thickness : int . Line thickness of the painted axes. Return image : Evision.Mat . Input/output image. It must have 1 or 3 channels. The number of channels is not altered. This function draws the axes of the world/object coordinate system w.r.t. to the camera frame. OX is drawn in red, OY in green and OZ in blue. Python prototype (for reference): drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length[, thickness]) -&gt; image","ref":"Evision.html#drawFrameAxes/7","title":"Evision.drawFrameAxes/7","type":"function"},{"doc":"Raising version of drawKeypoints/3 .","ref":"Evision.html#drawKeypoints!/3","title":"Evision.drawKeypoints!/3","type":"function"},{"doc":"Raising version of drawKeypoints/4 .","ref":"Evision.html#drawKeypoints!/4","title":"Evision.drawKeypoints!/4","type":"function"},{"doc":"Draws keypoints. Positional Arguments image : Evision.Mat . Source image. keypoints : [KeyPoint] . Keypoints from the source image. Keyword Arguments color : Scalar . Color of keypoints. flags : DrawMatchesFlags . Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags. See details above in drawMatches . Return outImage : Evision.Mat . Output image. Its content depends on the flags value defining what is drawn in the output image. See possible flags bit values below. Note : For Python API, flags are modified as cv.DRAW_MATCHES_FLAGS_DEFAULT, cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG, cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS Python prototype (for reference): drawKeypoints(image, keypoints, outImage[, color[, flags]]) -&gt; outImage","ref":"Evision.html#drawKeypoints/3","title":"Evision.drawKeypoints/3","type":"function"},{"doc":"Draws keypoints. Positional Arguments image : Evision.Mat . Source image. keypoints : [KeyPoint] . Keypoints from the source image. Keyword Arguments color : Scalar . Color of keypoints. flags : DrawMatchesFlags . Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags. See details above in drawMatches . Return outImage : Evision.Mat . Output image. Its content depends on the flags value defining what is drawn in the output image. See possible flags bit values below. Note : For Python API, flags are modified as cv.DRAW_MATCHES_FLAGS_DEFAULT, cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG, cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS Python prototype (for reference): drawKeypoints(image, keypoints, outImage[, color[, flags]]) -&gt; outImage","ref":"Evision.html#drawKeypoints/4","title":"Evision.drawKeypoints/4","type":"function"},{"doc":"Raising version of drawMarker/3 .","ref":"Evision.html#drawMarker!/3","title":"Evision.drawMarker!/3","type":"function"},{"doc":"Raising version of drawMarker/4 .","ref":"Evision.html#drawMarker!/4","title":"Evision.drawMarker!/4","type":"function"},{"doc":"Draws a marker on a predefined position in an image. Positional Arguments position : Point . The point where the crosshair is positioned. color : Scalar . Line color. Keyword Arguments markerType : int . The specific type of marker you want to use, see #MarkerTypes markerSize : int . The length of the marker axis [default = 20 pixels] thickness : int . Line thickness. line_type : int . Type of the line, See #LineTypes Return img : Evision.Mat . Image. The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information. Python prototype (for reference): drawMarker(img, position, color[, markerType[, markerSize[, thickness[, line_type]]]]) -&gt; img","ref":"Evision.html#drawMarker/3","title":"Evision.drawMarker/3","type":"function"},{"doc":"Draws a marker on a predefined position in an image. Positional Arguments position : Point . The point where the crosshair is positioned. color : Scalar . Line color. Keyword Arguments markerType : int . The specific type of marker you want to use, see #MarkerTypes markerSize : int . The length of the marker axis [default = 20 pixels] thickness : int . Line thickness. line_type : int . Type of the line, See #LineTypes Return img : Evision.Mat . Image. The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information. Python prototype (for reference): drawMarker(img, position, color[, markerType[, markerSize[, thickness[, line_type]]]]) -&gt; img","ref":"Evision.html#drawMarker/4","title":"Evision.drawMarker/4","type":"function"},{"doc":"Raising version of drawMatches/6 .","ref":"Evision.html#drawMatches!/6","title":"Evision.drawMatches!/6","type":"function"},{"doc":"Raising version of drawMatches/7 .","ref":"Evision.html#drawMatches!/7","title":"Evision.drawMatches!/7","type":"function"},{"doc":"Raising version of drawMatches/8 .","ref":"Evision.html#drawMatches!/8","title":"Evision.drawMatches!/8","type":"function"},{"doc":"Draws the found matches of keypoints from two images. Positional Arguments img1 : Evision.Mat . First source image. keypoints1 : [KeyPoint] . Keypoints from the first source image. img2 : Evision.Mat . Second source image. keypoints2 : [KeyPoint] . Keypoints from the second source image. matches1to2 : [DMatch] . Matches from the first image to the second one, which means that keypoints1[i] has a corresponding point in keypoints2[matches[i]] . Keyword Arguments matchColor : Scalar . Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1) , the color is generated randomly. singlePointColor : Scalar . Color of single keypoints (circles), which means that keypoints do not have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly. matchesMask : [char] . Mask determining which matches are drawn. If the mask is empty, all matches are drawn. flags : DrawMatchesFlags . Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags. Return outImg : Evision.Mat . Output image. Its content depends on the flags value defining what is drawn in the output image. See possible flags bit values below. This function draws matches of keypoints from two images in the output image. Match is a line connecting two keypoints (circles). See cv::DrawMatchesFlags. Python prototype (for reference): drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -&gt; outImg","ref":"Evision.html#drawMatches/6","title":"Evision.drawMatches/6","type":"function"},{"doc":"Variant 1: Positional Arguments img1 : Evision.Mat keypoints1 : [KeyPoint] img2 : Evision.Mat keypoints2 : [KeyPoint] matches1to2 : [DMatch] matchesThickness : int Keyword Arguments matchColor : Scalar . singlePointColor : Scalar . matchesMask : [char] . flags : DrawMatchesFlags . Return outImg : Evision.Mat Has overloading in C++ Python prototype (for reference): drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -&gt; outImg Variant 2: Draws the found matches of keypoints from two images. Positional Arguments img1 : Evision.Mat . First source image. keypoints1 : [KeyPoint] . Keypoints from the first source image. img2 : Evision.Mat . Second source image. keypoints2 : [KeyPoint] . Keypoints from the second source image. matches1to2 : [DMatch] . Matches from the first image to the second one, which means that keypoints1[i] has a corresponding point in keypoints2[matches[i]] . Keyword Arguments matchColor : Scalar . Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1) , the color is generated randomly. singlePointColor : Scalar . Color of single keypoints (circles), which means that keypoints do not have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly. matchesMask : [char] . Mask determining which matches are drawn. If the mask is empty, all matches are drawn. flags : DrawMatchesFlags . Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags. Return outImg : Evision.Mat . Output image. Its content depends on the flags value defining what is drawn in the output image. See possible flags bit values below. This function draws matches of keypoints from two images in the output image. Match is a line connecting two keypoints (circles). See cv::DrawMatchesFlags. Python prototype (for reference): drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -&gt; outImg","ref":"Evision.html#drawMatches/7","title":"Evision.drawMatches/7","type":"function"},{"doc":"Positional Arguments img1 : Evision.Mat keypoints1 : [KeyPoint] img2 : Evision.Mat keypoints2 : [KeyPoint] matches1to2 : [DMatch] matchesThickness : int Keyword Arguments matchColor : Scalar . singlePointColor : Scalar . matchesMask : [char] . flags : DrawMatchesFlags . Return outImg : Evision.Mat Has overloading in C++ Python prototype (for reference): drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -&gt; outImg","ref":"Evision.html#drawMatches/8","title":"Evision.drawMatches/8","type":"function"},{"doc":"Raising version of drawMatchesKnn/6 .","ref":"Evision.html#drawMatchesKnn!/6","title":"Evision.drawMatchesKnn!/6","type":"function"},{"doc":"Raising version of drawMatchesKnn/7 .","ref":"Evision.html#drawMatchesKnn!/7","title":"Evision.drawMatchesKnn!/7","type":"function"},{"doc":"Positional Arguments img1 : Evision.Mat keypoints1 : [KeyPoint] img2 : Evision.Mat keypoints2 : [KeyPoint] matches1to2 : [vector_DMatch] Keyword Arguments matchColor : Scalar . singlePointColor : Scalar . matchesMask : [vector_char] . flags : DrawMatchesFlags . Return outImg : Evision.Mat Python prototype (for reference): drawMatchesKnn(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -&gt; outImg","ref":"Evision.html#drawMatchesKnn/6","title":"Evision.drawMatchesKnn/6","type":"function"},{"doc":"Positional Arguments img1 : Evision.Mat keypoints1 : [KeyPoint] img2 : Evision.Mat keypoints2 : [KeyPoint] matches1to2 : [vector_DMatch] Keyword Arguments matchColor : Scalar . singlePointColor : Scalar . matchesMask : [vector_char] . flags : DrawMatchesFlags . Return outImg : Evision.Mat Python prototype (for reference): drawMatchesKnn(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -&gt; outImg","ref":"Evision.html#drawMatchesKnn/7","title":"Evision.drawMatchesKnn/7","type":"function"},{"doc":"Raising version of edgePreservingFilter/1 .","ref":"Evision.html#edgePreservingFilter!/1","title":"Evision.edgePreservingFilter!/1","type":"function"},{"doc":"Raising version of edgePreservingFilter/2 .","ref":"Evision.html#edgePreservingFilter!/2","title":"Evision.edgePreservingFilter!/2","type":"function"},{"doc":"Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing filters are used in many different applications @cite EM11 . Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments flags : int . Edge preserving filters: cv::RECURS_FILTER or cv::NORMCONV_FILTER sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. Return dst : Evision.Mat . Output 8-bit 3-channel image. Python prototype (for reference): edgePreservingFilter(src[, dst[, flags[, sigma_s[, sigma_r]]]]) -&gt; dst","ref":"Evision.html#edgePreservingFilter/1","title":"Evision.edgePreservingFilter/1","type":"function"},{"doc":"Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing filters are used in many different applications @cite EM11 . Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments flags : int . Edge preserving filters: cv::RECURS_FILTER or cv::NORMCONV_FILTER sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. Return dst : Evision.Mat . Output 8-bit 3-channel image. Python prototype (for reference): edgePreservingFilter(src[, dst[, flags[, sigma_s[, sigma_r]]]]) -&gt; dst","ref":"Evision.html#edgePreservingFilter/2","title":"Evision.edgePreservingFilter/2","type":"function"},{"doc":"Raising version of eigen/1 .","ref":"Evision.html#eigen!/1","title":"Evision.eigen!/1","type":"function"},{"doc":"Raising version of eigen/2 .","ref":"Evision.html#eigen!/2","title":"Evision.eigen!/2","type":"function"},{"doc":"Calculates eigenvalues and eigenvectors of a symmetric matrix. Positional Arguments src : Evision.Mat . input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical (src ^T^ == src). Return eigenvalues : Evision.Mat . output vector of eigenvalues of the same type as src; the eigenvalues are stored in the descending order. eigenvectors : Evision.Mat . output matrix of eigenvectors; it has the same size and type as src; the eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric matrix src: src * eigenvectors . row ( i ) . t ( ) = eigenvalues . at &lt; srcType &gt; ( i ) * eigenvectors . row ( i ) . t ( ) Note : Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix. @sa eigenNonSymmetric, completeSymm , PCA Python prototype (for reference): eigen(src[, eigenvalues[, eigenvectors]]) -&gt; retval, eigenvalues, eigenvectors","ref":"Evision.html#eigen/1","title":"Evision.eigen/1","type":"function"},{"doc":"Calculates eigenvalues and eigenvectors of a symmetric matrix. Positional Arguments src : Evision.Mat . input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical (src ^T^ == src). Return eigenvalues : Evision.Mat . output vector of eigenvalues of the same type as src; the eigenvalues are stored in the descending order. eigenvectors : Evision.Mat . output matrix of eigenvectors; it has the same size and type as src; the eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric matrix src: src * eigenvectors . row ( i ) . t ( ) = eigenvalues . at &lt; srcType &gt; ( i ) * eigenvectors . row ( i ) . t ( ) Note : Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix. @sa eigenNonSymmetric, completeSymm , PCA Python prototype (for reference): eigen(src[, eigenvalues[, eigenvectors]]) -&gt; retval, eigenvalues, eigenvectors","ref":"Evision.html#eigen/2","title":"Evision.eigen/2","type":"function"},{"doc":"Raising version of eigenNonSymmetric/1 .","ref":"Evision.html#eigenNonSymmetric!/1","title":"Evision.eigenNonSymmetric!/1","type":"function"},{"doc":"Raising version of eigenNonSymmetric/2 .","ref":"Evision.html#eigenNonSymmetric!/2","title":"Evision.eigenNonSymmetric!/2","type":"function"},{"doc":"Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only). Positional Arguments src : Evision.Mat . input matrix (CV_32FC1 or CV_64FC1 type). Return eigenvalues : Evision.Mat . output vector of eigenvalues (type is the same type as src). eigenvectors : Evision.Mat . output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. Note : Assumes real eigenvalues. The function calculates eigenvalues and eigenvectors (optional) of the square matrix src: src * eigenvectors . row ( i ) . t ( ) = eigenvalues . at &lt; srcType &gt; ( i ) * eigenvectors . row ( i ) . t ( ) @sa eigen Python prototype (for reference): eigenNonSymmetric(src[, eigenvalues[, eigenvectors]]) -&gt; eigenvalues, eigenvectors","ref":"Evision.html#eigenNonSymmetric/1","title":"Evision.eigenNonSymmetric/1","type":"function"},{"doc":"Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only). Positional Arguments src : Evision.Mat . input matrix (CV_32FC1 or CV_64FC1 type). Return eigenvalues : Evision.Mat . output vector of eigenvalues (type is the same type as src). eigenvectors : Evision.Mat . output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. Note : Assumes real eigenvalues. The function calculates eigenvalues and eigenvectors (optional) of the square matrix src: src * eigenvectors . row ( i ) . t ( ) = eigenvalues . at &lt; srcType &gt; ( i ) * eigenvectors . row ( i ) . t ( ) @sa eigen Python prototype (for reference): eigenNonSymmetric(src[, eigenvalues[, eigenvectors]]) -&gt; eigenvalues, eigenvectors","ref":"Evision.html#eigenNonSymmetric/2","title":"Evision.eigenNonSymmetric/2","type":"function"},{"doc":"Raising version of ellipse2Poly/6 .","ref":"Evision.html#ellipse2Poly!/6","title":"Evision.ellipse2Poly!/6","type":"function"},{"doc":"Approximates an elliptic arc with a polyline. Positional Arguments center : Point . Center of the arc. axes : Size . Half of the size of the ellipse main axes. See #ellipse for details. angle : int . Rotation angle of the ellipse in degrees. See #ellipse for details. arcStart : int . Starting angle of the elliptic arc in degrees. arcEnd : int . Ending angle of the elliptic arc in degrees. delta : int . Angle between the subsequent polyline vertices. It defines the approximation accuracy. Return pts : [Point] . Output vector of polyline vertices. The function ellipse2Poly computes the vertices of a polyline that approximates the specified elliptic arc. It is used by #ellipse. If arcStart is greater than arcEnd , they are swapped. Python prototype (for reference): ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta) -&gt; pts","ref":"Evision.html#ellipse2Poly/6","title":"Evision.ellipse2Poly/6","type":"function"},{"doc":"Raising version of ellipse/3 .","ref":"Evision.html#ellipse!/3","title":"Evision.ellipse!/3","type":"function"},{"doc":"Raising version of ellipse/4 .","ref":"Evision.html#ellipse!/4","title":"Evision.ellipse!/4","type":"function"},{"doc":"Raising version of ellipse/7 .","ref":"Evision.html#ellipse!/7","title":"Evision.ellipse!/7","type":"function"},{"doc":"Raising version of ellipse/8 .","ref":"Evision.html#ellipse!/8","title":"Evision.ellipse!/8","type":"function"},{"doc":"Positional Arguments box : {centre={x, y}, size={s1, s2}, angle} . Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle. color : Scalar . Ellipse color. Keyword Arguments thickness : int . Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. lineType : int . Type of the ellipse boundary. See #LineTypes Return img : Evision.Mat . Image. Has overloading in C++ Python prototype (for reference): ellipse(img, box, color[, thickness[, lineType]]) -&gt; img","ref":"Evision.html#ellipse/3","title":"Evision.ellipse/3","type":"function"},{"doc":"Positional Arguments box : {centre={x, y}, size={s1, s2}, angle} . Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle. color : Scalar . Ellipse color. Keyword Arguments thickness : int . Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. lineType : int . Type of the ellipse boundary. See #LineTypes Return img : Evision.Mat . Image. Has overloading in C++ Python prototype (for reference): ellipse(img, box, color[, thickness[, lineType]]) -&gt; img","ref":"Evision.html#ellipse/4","title":"Evision.ellipse/4","type":"function"},{"doc":"Draws a simple or thick elliptic arc or fills an ellipse sector. Positional Arguments center : Point . Center of the ellipse. axes : Size . Half of the size of the ellipse main axes. angle : double . Ellipse rotation angle in degrees. startAngle : double . Starting angle of the elliptic arc in degrees. endAngle : double . Ending angle of the elliptic arc in degrees. color : Scalar . Ellipse color. Keyword Arguments thickness : int . Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. lineType : int . Type of the ellipse boundary. See #LineTypes shift : int . Number of fractional bits in the coordinates of the center and values of axes. Return img : Evision.Mat . Image. The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass startAngle=0 and endAngle=360 . If startAngle is greater than endAngle , they are swapped. The figure below explains the meaning of the parameters to draw the blue arc. Python prototype (for reference): ellipse(img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#ellipse/7","title":"Evision.ellipse/7","type":"function"},{"doc":"Draws a simple or thick elliptic arc or fills an ellipse sector. Positional Arguments center : Point . Center of the ellipse. axes : Size . Half of the size of the ellipse main axes. angle : double . Ellipse rotation angle in degrees. startAngle : double . Starting angle of the elliptic arc in degrees. endAngle : double . Ending angle of the elliptic arc in degrees. color : Scalar . Ellipse color. Keyword Arguments thickness : int . Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. lineType : int . Type of the ellipse boundary. See #LineTypes shift : int . Number of fractional bits in the coordinates of the center and values of axes. Return img : Evision.Mat . Image. The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass startAngle=0 and endAngle=360 . If startAngle is greater than endAngle , they are swapped. The figure below explains the meaning of the parameters to draw the blue arc. Python prototype (for reference): ellipse(img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#ellipse/8","title":"Evision.ellipse/8","type":"function"},{"doc":"Raising version of emd/3 .","ref":"Evision.html#emd!/3","title":"Evision.emd!/3","type":"function"},{"doc":"Raising version of emd/4 .","ref":"Evision.html#emd!/4","title":"Evision.emd!/4","type":"function"},{"doc":"Computes the &quot;minimal work&quot; distance between two weighted point configurations. Positional Arguments signature1 : Evision.Mat . First signature, a \\f$\\texttt{size1}\\times \\texttt{dims}+1\\f$ floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used. The weights must be non-negative and have at least one non-zero value. signature2 : Evision.Mat . Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra &quot;dummy&quot; point is added to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value. distType : int . Used metric. See #DistanceTypes. Keyword Arguments cost : Evision.Mat . User-defined \\f$\\texttt{size1}\\times \\texttt{size2}\\f$ cost matrix. Also, if a cost matrix is used, lower boundary lowerBound cannot be calculated because it needs a metric function. Return lowerBound : Ptr&lt;float&gt; . Optional input/output parameter: lower boundary of a distance between the two signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). You must * initialize \\ lowerBound . If the calculated distance between mass centers is greater or equal to *lowerBound (it means that the signatures are far enough), the function does not calculate EMD. In any case *lowerBound is set to the calculated distance between mass centers on return. Thus, if you want to calculate both distance between mass centers and EMD, *lowerBound should be set to 0. flow : Evision.Mat . Resultant \\f$\\texttt{size1} \\times \\texttt{size2}\\f$ flow matrix: \\f$\\texttt{flow}_{i,j}\\f$ is a flow from \\f$i\\f$ -th point of signature1 to \\f$j\\f$ -th point of signature2 . The function computes the earth mover distance and/or a lower boundary of the distance between the two weighted point configurations. One of the applications described in @cite RubnerSept98, @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation problem that is solved using some modification of a simplex algorithm, thus the complexity is exponential in the worst case, though, on average it is much faster. In the case of a real metric the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used to determine roughly whether the two signatures are far enough so that they cannot relate to the same object. Python prototype (for reference): EMD(signature1, signature2, distType[, cost[, lowerBound[, flow]]]) -&gt; retval, lowerBound, flow","ref":"Evision.html#emd/3","title":"Evision.emd/3","type":"function"},{"doc":"Computes the &quot;minimal work&quot; distance between two weighted point configurations. Positional Arguments signature1 : Evision.Mat . First signature, a \\f$\\texttt{size1}\\times \\texttt{dims}+1\\f$ floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used. The weights must be non-negative and have at least one non-zero value. signature2 : Evision.Mat . Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra &quot;dummy&quot; point is added to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value. distType : int . Used metric. See #DistanceTypes. Keyword Arguments cost : Evision.Mat . User-defined \\f$\\texttt{size1}\\times \\texttt{size2}\\f$ cost matrix. Also, if a cost matrix is used, lower boundary lowerBound cannot be calculated because it needs a metric function. Return lowerBound : Ptr&lt;float&gt; . Optional input/output parameter: lower boundary of a distance between the two signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). You must * initialize \\ lowerBound . If the calculated distance between mass centers is greater or equal to *lowerBound (it means that the signatures are far enough), the function does not calculate EMD. In any case *lowerBound is set to the calculated distance between mass centers on return. Thus, if you want to calculate both distance between mass centers and EMD, *lowerBound should be set to 0. flow : Evision.Mat . Resultant \\f$\\texttt{size1} \\times \\texttt{size2}\\f$ flow matrix: \\f$\\texttt{flow}_{i,j}\\f$ is a flow from \\f$i\\f$ -th point of signature1 to \\f$j\\f$ -th point of signature2 . The function computes the earth mover distance and/or a lower boundary of the distance between the two weighted point configurations. One of the applications described in @cite RubnerSept98, @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation problem that is solved using some modification of a simplex algorithm, thus the complexity is exponential in the worst case, though, on average it is much faster. In the case of a real metric the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used to determine roughly whether the two signatures are far enough so that they cannot relate to the same object. Python prototype (for reference): EMD(signature1, signature2, distType[, cost[, lowerBound[, flow]]]) -&gt; retval, lowerBound, flow","ref":"Evision.html#emd/4","title":"Evision.emd/4","type":"function"},{"doc":"Raising version of equalizeHist/1 .","ref":"Evision.html#equalizeHist!/1","title":"Evision.equalizeHist!/1","type":"function"},{"doc":"Raising version of equalizeHist/2 .","ref":"Evision.html#equalizeHist!/2","title":"Evision.equalizeHist!/2","type":"function"},{"doc":"Equalizes the histogram of a grayscale image. Positional Arguments src : Evision.Mat . Source 8-bit single channel image. Return dst : Evision.Mat . Destination image of the same size and type as src . The function equalizes the histogram of the input image using the following algorithm: Calculate the histogram \\f$H\\f$ for src . Normalize the histogram so that the sum of histogram bins is 255. Compute the integral of the histogram: \\f[H'_i = \\sum _{0 \\le j &lt; i} H(j)\\f] Transform the image using \\f$H'\\f$ as a look-up table: \\f$\\texttt{dst}(x,y) = H'(\\texttt{src}(x,y))\\f$ The algorithm normalizes the brightness and increases the contrast of the image. Python prototype (for reference): equalizeHist(src[, dst]) -&gt; dst","ref":"Evision.html#equalizeHist/1","title":"Evision.equalizeHist/1","type":"function"},{"doc":"Equalizes the histogram of a grayscale image. Positional Arguments src : Evision.Mat . Source 8-bit single channel image. Return dst : Evision.Mat . Destination image of the same size and type as src . The function equalizes the histogram of the input image using the following algorithm: Calculate the histogram \\f$H\\f$ for src . Normalize the histogram so that the sum of histogram bins is 255. Compute the integral of the histogram: \\f[H'_i = \\sum _{0 \\le j &lt; i} H(j)\\f] Transform the image using \\f$H'\\f$ as a look-up table: \\f$\\texttt{dst}(x,y) = H'(\\texttt{src}(x,y))\\f$ The algorithm normalizes the brightness and increases the contrast of the image. Python prototype (for reference): equalizeHist(src[, dst]) -&gt; dst","ref":"Evision.html#equalizeHist/2","title":"Evision.equalizeHist/2","type":"function"},{"doc":"Raising version of erode/2 .","ref":"Evision.html#erode!/2","title":"Evision.erode!/2","type":"function"},{"doc":"Raising version of erode/3 .","ref":"Evision.html#erode!/3","title":"Evision.erode!/3","type":"function"},{"doc":"Erodes an image by using a specific structuring element. Positional Arguments src : Evision.Mat . input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. kernel : Evision.Mat . structuring element used for erosion; if element=Mat() , a 3 x 3 rectangular structuring element is used. Kernel can be created using #getStructuringElement. Keyword Arguments anchor : Point . position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. iterations : int . number of times erosion is applied. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. borderValue : Scalar . border value in case of a constant border Return dst : Evision.Mat . output image of the same size and type as src. The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken: \\f[\\texttt{dst} (x,y) = \\min _{(x',y'): \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f] The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently. @sa dilate, morphologyEx, getStructuringElement Python prototype (for reference): erode(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -&gt; dst","ref":"Evision.html#erode/2","title":"Evision.erode/2","type":"function"},{"doc":"Erodes an image by using a specific structuring element. Positional Arguments src : Evision.Mat . input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. kernel : Evision.Mat . structuring element used for erosion; if element=Mat() , a 3 x 3 rectangular structuring element is used. Kernel can be created using #getStructuringElement. Keyword Arguments anchor : Point . position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. iterations : int . number of times erosion is applied. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. borderValue : Scalar . border value in case of a constant border Return dst : Evision.Mat . output image of the same size and type as src. The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken: \\f[\\texttt{dst} (x,y) = \\min _{(x',y'): \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f] The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently. @sa dilate, morphologyEx, getStructuringElement Python prototype (for reference): erode(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -&gt; dst","ref":"Evision.html#erode/3","title":"Evision.erode/3","type":"function"},{"doc":"Raising version of estimateAffine2D/2 .","ref":"Evision.html#estimateAffine2D!/2","title":"Evision.estimateAffine2D!/2","type":"function"},{"doc":"Raising version of estimateAffine2D/3 .","ref":"Evision.html#estimateAffine2D!/3","title":"Evision.estimateAffine2D!/3","type":"function"},{"doc":"Raising version of estimateAffine2D/4 .","ref":"Evision.html#estimateAffine2D!/4","title":"Evision.estimateAffine2D!/4","type":"function"},{"doc":"Computes an optimal affine transformation between two 2D point sets. Positional Arguments from : Evision.Mat . First input 2D point set containing \\f$(X,Y)\\f$. to : Evision.Mat . Second input 2D point set containing \\f$(x,y)\\f$. Keyword Arguments method : int . Robust method used to compute transformation. The following methods are possible: @ref RANSAC - RANSAC-based robust method @ref LMEDS - Least-Median robust method RANSAC is the default method. ransacReprojThreshold : double . Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. Applies only to RANSAC. maxIters : size_t . The maximum number of robust method iterations. confidence : double . Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation. refineIters : size_t . Maximum number of iterations of refining algorithm (Levenberg-Marquardt). Passing 0 will disable refining, so the output matrix will be output of robust method. Return inliers : Evision.Mat . Output vector indicating which points are inliers (1-inlier, 0-outlier). It computes \\f[ \\begin{bmatrix} x\\\\ y\\\\ \\end{bmatrix} \\begin{bmatrix} a_{11} &amp; a_{12}\\\\ a_{21} &amp; a_{22}\\\\ \\end{bmatrix} \\begin{bmatrix} X\\\\ Y\\\\ \\end{bmatrix} + \\begin{bmatrix} b_1\\\\ b_2\\\\ \\end{bmatrix} \\f] @return Output 2D affine transformation matrix \\f$2 \\times 3\\f$ or empty matrix if transformation could not be estimated. The returned matrix has the following form: \\f[ \\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1\\\\ a_{21} &amp; a_{22} &amp; b_2\\\\ \\end{bmatrix} \\f] The function estimates an optimal 2D affine transformation between two 2D point sets using the selected robust algorithm. The computed transformation is then refined further (using only inliers) with the Levenberg-Marquardt method to reduce the re-projection error even more. Note : The RANSAC method can handle practically any ratio of outliers but needs a threshold to distinguish inliers from outliers. The method LMeDS does not need any threshold but it works correctly only when there are more than 50% of inliers. @sa estimateAffinePartial2D, getAffineTransform Python prototype (for reference): estimateAffine2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -&gt; retval, inliers","ref":"Evision.html#estimateAffine2D/2","title":"Evision.estimateAffine2D/2","type":"function"},{"doc":"Variant 1: Positional Arguments pts1 : Evision.Mat pts2 : Evision.Mat params : UsacParams Return inliers : Evision.Mat . Python prototype (for reference): estimateAffine2D(pts1, pts2, params[, inliers]) -&gt; retval, inliers Variant 2: Computes an optimal affine transformation between two 2D point sets. Positional Arguments from : Evision.Mat . First input 2D point set containing \\f$(X,Y)\\f$. to : Evision.Mat . Second input 2D point set containing \\f$(x,y)\\f$. Keyword Arguments method : int . Robust method used to compute transformation. The following methods are possible: @ref RANSAC - RANSAC-based robust method @ref LMEDS - Least-Median robust method RANSAC is the default method. ransacReprojThreshold : double . Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. Applies only to RANSAC. maxIters : size_t . The maximum number of robust method iterations. confidence : double . Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation. refineIters : size_t . Maximum number of iterations of refining algorithm (Levenberg-Marquardt). Passing 0 will disable refining, so the output matrix will be output of robust method. Return inliers : Evision.Mat . Output vector indicating which points are inliers (1-inlier, 0-outlier). It computes \\f[ \\begin{bmatrix} x\\\\ y\\\\ \\end{bmatrix} \\begin{bmatrix} a_{11} &amp; a_{12}\\\\ a_{21} &amp; a_{22}\\\\ \\end{bmatrix} \\begin{bmatrix} X\\\\ Y\\\\ \\end{bmatrix} + \\begin{bmatrix} b_1\\\\ b_2\\\\ \\end{bmatrix} \\f] @return Output 2D affine transformation matrix \\f$2 \\times 3\\f$ or empty matrix if transformation could not be estimated. The returned matrix has the following form: \\f[ \\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1\\\\ a_{21} &amp; a_{22} &amp; b_2\\\\ \\end{bmatrix} \\f] The function estimates an optimal 2D affine transformation between two 2D point sets using the selected robust algorithm. The computed transformation is then refined further (using only inliers) with the Levenberg-Marquardt method to reduce the re-projection error even more. Note : The RANSAC method can handle practically any ratio of outliers but needs a threshold to distinguish inliers from outliers. The method LMeDS does not need any threshold but it works correctly only when there are more than 50% of inliers. @sa estimateAffinePartial2D, getAffineTransform Python prototype (for reference): estimateAffine2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -&gt; retval, inliers","ref":"Evision.html#estimateAffine2D/3","title":"Evision.estimateAffine2D/3","type":"function"},{"doc":"Positional Arguments pts1 : Evision.Mat pts2 : Evision.Mat params : UsacParams Return inliers : Evision.Mat . Python prototype (for reference): estimateAffine2D(pts1, pts2, params[, inliers]) -&gt; retval, inliers","ref":"Evision.html#estimateAffine2D/4","title":"Evision.estimateAffine2D/4","type":"function"},{"doc":"Raising version of estimateAffine3D/2 .","ref":"Evision.html#estimateAffine3D!/2","title":"Evision.estimateAffine3D!/2","type":"function"},{"doc":"Raising version of estimateAffine3D/3 .","ref":"Evision.html#estimateAffine3D!/3","title":"Evision.estimateAffine3D!/3","type":"function"},{"doc":"Computes an optimal affine transformation between two 3D point sets. Positional Arguments src : Evision.Mat . First input 3D point set. dst : Evision.Mat . Second input 3D point set. Keyword Arguments force_rotation : bool . If true, the returned rotation will never be a reflection. This might be unwanted, e.g. when optimizing a transform between a right- and a left-handed coordinate system. Return scale : double* . If null is passed, the scale parameter c will be assumed to be 1.0. Else the pointed-to variable will be set to the optimal scale. It computes \\f$R,s,t\\f$ minimizing \\f$\\sum{i} dst_i - c \\cdot R \\cdot src_i \\f$ where \\f$R\\f$ is a 3x3 rotation matrix, \\f$t\\f$ is a 3x1 translation vector and \\f$s\\f$ is a scalar size value. This is an implementation of the algorithm by Umeyama \\cite umeyama1991least . The estimated affine transform has a homogeneous scale which is a subclass of affine transformations with 7 degrees of freedom. The paired point sets need to comprise at least 3 points each. @return 3D affine transformation matrix \\f$3 \\times 4\\f$ of the form \\f[T = \\begin{bmatrix} R &amp; t\\\\ \\end{bmatrix} \\f] Python prototype (for reference): estimateAffine3D(src, dst[, force_rotation]) -&gt; retval, scale","ref":"Evision.html#estimateAffine3D/2","title":"Evision.estimateAffine3D/2","type":"function"},{"doc":"Computes an optimal affine transformation between two 3D point sets. Positional Arguments src : Evision.Mat . First input 3D point set. dst : Evision.Mat . Second input 3D point set. Keyword Arguments force_rotation : bool . If true, the returned rotation will never be a reflection. This might be unwanted, e.g. when optimizing a transform between a right- and a left-handed coordinate system. Return scale : double* . If null is passed, the scale parameter c will be assumed to be 1.0. Else the pointed-to variable will be set to the optimal scale. It computes \\f$R,s,t\\f$ minimizing \\f$\\sum{i} dst_i - c \\cdot R \\cdot src_i \\f$ where \\f$R\\f$ is a 3x3 rotation matrix, \\f$t\\f$ is a 3x1 translation vector and \\f$s\\f$ is a scalar size value. This is an implementation of the algorithm by Umeyama \\cite umeyama1991least . The estimated affine transform has a homogeneous scale which is a subclass of affine transformations with 7 degrees of freedom. The paired point sets need to comprise at least 3 points each. @return 3D affine transformation matrix \\f$3 \\times 4\\f$ of the form \\f[T = \\begin{bmatrix} R &amp; t\\\\ \\end{bmatrix} \\f] Python prototype (for reference): estimateAffine3D(src, dst[, force_rotation]) -&gt; retval, scale","ref":"Evision.html#estimateAffine3D/3","title":"Evision.estimateAffine3D/3","type":"function"},{"doc":"Raising version of estimateAffinePartial2D/2 .","ref":"Evision.html#estimateAffinePartial2D!/2","title":"Evision.estimateAffinePartial2D!/2","type":"function"},{"doc":"Raising version of estimateAffinePartial2D/3 .","ref":"Evision.html#estimateAffinePartial2D!/3","title":"Evision.estimateAffinePartial2D!/3","type":"function"},{"doc":"Computes an optimal limited affine transformation with 4 degrees of freedom between two 2D point sets. Positional Arguments from : Evision.Mat . First input 2D point set. to : Evision.Mat . Second input 2D point set. Keyword Arguments method : int . Robust method used to compute transformation. The following methods are possible: @ref RANSAC - RANSAC-based robust method @ref LMEDS - Least-Median robust method RANSAC is the default method. ransacReprojThreshold : double . Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. Applies only to RANSAC. maxIters : size_t . The maximum number of robust method iterations. confidence : double . Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation. refineIters : size_t . Maximum number of iterations of refining algorithm (Levenberg-Marquardt). Passing 0 will disable refining, so the output matrix will be output of robust method. Return inliers : Evision.Mat . Output vector indicating which points are inliers. @return Output 2D affine transformation (4 degrees of freedom) matrix \\f$2 \\times 3\\f$ or empty matrix if transformation could not be estimated. The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust estimation. The computed transformation is then refined further (using only inliers) with the Levenberg-Marquardt method to reduce the re-projection error even more. Estimated transformation matrix is: \\f[ \\begin{bmatrix} \\cos(\\theta) \\cdot s &amp; -\\sin(\\theta) \\cdot s &amp; t_x \\\\ \\sin(\\theta) \\cdot s &amp; \\cos(\\theta) \\cdot s &amp; t_y \\end{bmatrix} \\f] Where \\f$ \\theta \\f$ is the rotation angle, \\f$ s \\f$ the scaling factor and \\f$ t_x, t_y \\f$ are translations in \\f$ x, y \\f$ axes respectively. Note : The RANSAC method can handle practically any ratio of outliers but need a threshold to distinguish inliers from outliers. The method LMeDS does not need any threshold but it works correctly only when there are more than 50% of inliers. @sa estimateAffine2D, getAffineTransform Python prototype (for reference): estimateAffinePartial2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -&gt; retval, inliers","ref":"Evision.html#estimateAffinePartial2D/2","title":"Evision.estimateAffinePartial2D/2","type":"function"},{"doc":"Computes an optimal limited affine transformation with 4 degrees of freedom between two 2D point sets. Positional Arguments from : Evision.Mat . First input 2D point set. to : Evision.Mat . Second input 2D point set. Keyword Arguments method : int . Robust method used to compute transformation. The following methods are possible: @ref RANSAC - RANSAC-based robust method @ref LMEDS - Least-Median robust method RANSAC is the default method. ransacReprojThreshold : double . Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. Applies only to RANSAC. maxIters : size_t . The maximum number of robust method iterations. confidence : double . Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation. refineIters : size_t . Maximum number of iterations of refining algorithm (Levenberg-Marquardt). Passing 0 will disable refining, so the output matrix will be output of robust method. Return inliers : Evision.Mat . Output vector indicating which points are inliers. @return Output 2D affine transformation (4 degrees of freedom) matrix \\f$2 \\times 3\\f$ or empty matrix if transformation could not be estimated. The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust estimation. The computed transformation is then refined further (using only inliers) with the Levenberg-Marquardt method to reduce the re-projection error even more. Estimated transformation matrix is: \\f[ \\begin{bmatrix} \\cos(\\theta) \\cdot s &amp; -\\sin(\\theta) \\cdot s &amp; t_x \\\\ \\sin(\\theta) \\cdot s &amp; \\cos(\\theta) \\cdot s &amp; t_y \\end{bmatrix} \\f] Where \\f$ \\theta \\f$ is the rotation angle, \\f$ s \\f$ the scaling factor and \\f$ t_x, t_y \\f$ are translations in \\f$ x, y \\f$ axes respectively. Note : The RANSAC method can handle practically any ratio of outliers but need a threshold to distinguish inliers from outliers. The method LMeDS does not need any threshold but it works correctly only when there are more than 50% of inliers. @sa estimateAffine2D, getAffineTransform Python prototype (for reference): estimateAffinePartial2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -&gt; retval, inliers","ref":"Evision.html#estimateAffinePartial2D/3","title":"Evision.estimateAffinePartial2D/3","type":"function"},{"doc":"Raising version of estimateChessboardSharpness/3 .","ref":"Evision.html#estimateChessboardSharpness!/3","title":"Evision.estimateChessboardSharpness!/3","type":"function"},{"doc":"Raising version of estimateChessboardSharpness/4 .","ref":"Evision.html#estimateChessboardSharpness!/4","title":"Evision.estimateChessboardSharpness!/4","type":"function"},{"doc":"Estimates the sharpness of a detected chessboard. Positional Arguments image : Evision.Mat . Gray image used to find chessboard corners patternSize : Size . Size of a found chessboard pattern corners : Evision.Mat . Corners found by #findChessboardCornersSB Keyword Arguments rise_distance : float . Rise distance 0.8 means 10% ... 90% of the final signal strength vertical : bool . By default edge responses for horizontal lines are calculated Return sharpness : Evision.Mat . Optional output array with a sharpness value for calculated edge responses (see description) Image sharpness, as well as brightness, are a critical parameter for accuracte camera calibration. For accessing these parameters for filtering out problematic calibraiton images, this method calculates edge profiles by traveling from black to white chessboard cell centers. Based on this, the number of pixels is calculated required to transit from black to white. This width of the transition area is a good indication of how sharp the chessboard is imaged and should be below ~3.0 pixels. The optional sharpness array is of type CV_32FC1 and has for each calculated profile one row with the following five entries: 0 = x coordinate of the underlying edge in the image 1 = y coordinate of the underlying edge in the image 2 = width of the transition area (sharpness) 3 = signal strength in the black cell (min brightness) 4 = signal strength in the white cell (max brightness) @return Scalar(average sharpness, average min brightness, average max brightness,0) Python prototype (for reference): estimateChessboardSharpness(image, patternSize, corners[, rise_distance[, vertical[, sharpness]]]) -&gt; retval, sharpness","ref":"Evision.html#estimateChessboardSharpness/3","title":"Evision.estimateChessboardSharpness/3","type":"function"},{"doc":"Estimates the sharpness of a detected chessboard. Positional Arguments image : Evision.Mat . Gray image used to find chessboard corners patternSize : Size . Size of a found chessboard pattern corners : Evision.Mat . Corners found by #findChessboardCornersSB Keyword Arguments rise_distance : float . Rise distance 0.8 means 10% ... 90% of the final signal strength vertical : bool . By default edge responses for horizontal lines are calculated Return sharpness : Evision.Mat . Optional output array with a sharpness value for calculated edge responses (see description) Image sharpness, as well as brightness, are a critical parameter for accuracte camera calibration. For accessing these parameters for filtering out problematic calibraiton images, this method calculates edge profiles by traveling from black to white chessboard cell centers. Based on this, the number of pixels is calculated required to transit from black to white. This width of the transition area is a good indication of how sharp the chessboard is imaged and should be below ~3.0 pixels. The optional sharpness array is of type CV_32FC1 and has for each calculated profile one row with the following five entries: 0 = x coordinate of the underlying edge in the image 1 = y coordinate of the underlying edge in the image 2 = width of the transition area (sharpness) 3 = signal strength in the black cell (min brightness) 4 = signal strength in the white cell (max brightness) @return Scalar(average sharpness, average min brightness, average max brightness,0) Python prototype (for reference): estimateChessboardSharpness(image, patternSize, corners[, rise_distance[, vertical[, sharpness]]]) -&gt; retval, sharpness","ref":"Evision.html#estimateChessboardSharpness/4","title":"Evision.estimateChessboardSharpness/4","type":"function"},{"doc":"Raising version of estimateTranslation3D/2 .","ref":"Evision.html#estimateTranslation3D!/2","title":"Evision.estimateTranslation3D!/2","type":"function"},{"doc":"Raising version of estimateTranslation3D/3 .","ref":"Evision.html#estimateTranslation3D!/3","title":"Evision.estimateTranslation3D!/3","type":"function"},{"doc":"Computes an optimal translation between two 3D point sets. Positional Arguments src : Evision.Mat . First input 3D point set containing \\f$(X,Y,Z)\\f$. dst : Evision.Mat . Second input 3D point set containing \\f$(x,y,z)\\f$. Keyword Arguments ransacThreshold : double . Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. confidence : double . Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation. Return out : Evision.Mat . Output 3D translation vector \\f$3 \\times 1\\f$ of the form \\f[ \\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3 \\\\ \\end{bmatrix} \\f] inliers : Evision.Mat . Output vector indicating which points are inliers (1-inlier, 0-outlier). It computes \\f[ \\begin{bmatrix} x\\\\ y\\\\ z\\\\ \\end{bmatrix} \\begin{bmatrix} X\\\\ Y\\\\ Z\\\\ \\end{bmatrix} + \\begin{bmatrix} b_1\\\\ b_2\\\\ b_3\\\\ \\end{bmatrix} \\f] The function estimates an optimal 3D translation between two 3D point sets using the RANSAC algorithm. Python prototype (for reference): estimateTranslation3D(src, dst[, out[, inliers[, ransacThreshold[, confidence]]]]) -&gt; retval, out, inliers","ref":"Evision.html#estimateTranslation3D/2","title":"Evision.estimateTranslation3D/2","type":"function"},{"doc":"Computes an optimal translation between two 3D point sets. Positional Arguments src : Evision.Mat . First input 3D point set containing \\f$(X,Y,Z)\\f$. dst : Evision.Mat . Second input 3D point set containing \\f$(x,y,z)\\f$. Keyword Arguments ransacThreshold : double . Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. confidence : double . Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation. Return out : Evision.Mat . Output 3D translation vector \\f$3 \\times 1\\f$ of the form \\f[ \\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3 \\\\ \\end{bmatrix} \\f] inliers : Evision.Mat . Output vector indicating which points are inliers (1-inlier, 0-outlier). It computes \\f[ \\begin{bmatrix} x\\\\ y\\\\ z\\\\ \\end{bmatrix} \\begin{bmatrix} X\\\\ Y\\\\ Z\\\\ \\end{bmatrix} + \\begin{bmatrix} b_1\\\\ b_2\\\\ b_3\\\\ \\end{bmatrix} \\f] The function estimates an optimal 3D translation between two 3D point sets using the RANSAC algorithm. Python prototype (for reference): estimateTranslation3D(src, dst[, out[, inliers[, ransacThreshold[, confidence]]]]) -&gt; retval, out, inliers","ref":"Evision.html#estimateTranslation3D/3","title":"Evision.estimateTranslation3D/3","type":"function"},{"doc":"Raising version of exp/1 .","ref":"Evision.html#exp!/1","title":"Evision.exp!/1","type":"function"},{"doc":"Raising version of exp/2 .","ref":"Evision.html#exp!/2","title":"Evision.exp!/2","type":"function"},{"doc":"Calculates the exponent of every array element. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::exp calculates the exponent of every element of the input array: \\f[\\texttt{dst} [I] = e^{ src(I) }\\f] The maximum relative error is about 7e-6 for single-precision input and less than 1e-10 for double-precision input. Currently, the function converts denormalized values to zeros on output. Special values (NaN, Inf) are not handled. @sa log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude Python prototype (for reference): exp(src[, dst]) -&gt; dst","ref":"Evision.html#exp/1","title":"Evision.exp/1","type":"function"},{"doc":"Calculates the exponent of every array element. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::exp calculates the exponent of every element of the input array: \\f[\\texttt{dst} [I] = e^{ src(I) }\\f] The maximum relative error is about 7e-6 for single-precision input and less than 1e-10 for double-precision input. Currently, the function converts denormalized values to zeros on output. Special values (NaN, Inf) are not handled. @sa log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude Python prototype (for reference): exp(src[, dst]) -&gt; dst","ref":"Evision.html#exp/2","title":"Evision.exp/2","type":"function"},{"doc":"Raising version of extractChannel/2 .","ref":"Evision.html#extractChannel!/2","title":"Evision.extractChannel!/2","type":"function"},{"doc":"Raising version of extractChannel/3 .","ref":"Evision.html#extractChannel!/3","title":"Evision.extractChannel!/3","type":"function"},{"doc":"Extracts a single channel from src (coi is 0-based index) Positional Arguments src : Evision.Mat . input array coi : int . index of channel to extract Return dst : Evision.Mat . output array @sa mixChannels, split Python prototype (for reference): extractChannel(src, coi[, dst]) -&gt; dst","ref":"Evision.html#extractChannel/2","title":"Evision.extractChannel/2","type":"function"},{"doc":"Extracts a single channel from src (coi is 0-based index) Positional Arguments src : Evision.Mat . input array coi : int . index of channel to extract Return dst : Evision.Mat . output array @sa mixChannels, split Python prototype (for reference): extractChannel(src, coi[, dst]) -&gt; dst","ref":"Evision.html#extractChannel/3","title":"Evision.extractChannel/3","type":"function"},{"doc":"Raising version of fastAtan2/2 .","ref":"Evision.html#fastAtan2!/2","title":"Evision.fastAtan2!/2","type":"function"},{"doc":"Calculates the angle of a 2D vector in degrees. Positional Arguments y : float . y-coordinate of the vector. x : float . x-coordinate of the vector. The function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured in degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees. Python prototype (for reference): fastAtan2(y, x) -&gt; retval","ref":"Evision.html#fastAtan2/2","title":"Evision.fastAtan2/2","type":"function"},{"doc":"Raising version of fastNlMeansDenoising/1 .","ref":"Evision.html#fastNlMeansDenoising!/1","title":"Evision.fastNlMeansDenoising!/1","type":"function"},{"doc":"Raising version of fastNlMeansDenoising/2 .","ref":"Evision.html#fastNlMeansDenoising!/2","title":"Evision.fastNlMeansDenoising!/2","type":"function"},{"doc":"Raising version of fastNlMeansDenoising/3 .","ref":"Evision.html#fastNlMeansDenoising!/3","title":"Evision.fastNlMeansDenoising!/3","type":"function"},{"doc":"Perform image denoising using Non-local Means Denoising algorithm http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ with several computational optimizations. Noise expected to be a gaussian white noise Positional Arguments src : Evision.Mat . Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel image. Keyword Arguments h : float . Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as src . This function expected to be applied to grayscale images. For colored images look at fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting image to CIELAB colorspace and then separately denoise L and AB components with different h parameter. Python prototype (for reference): fastNlMeansDenoising(src[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoising/1","title":"Evision.fastNlMeansDenoising/1","type":"function"},{"doc":"Variant 1: Perform image denoising using Non-local Means Denoising algorithm http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ with several computational optimizations. Noise expected to be a gaussian white noise Positional Arguments src : Evision.Mat . Input 8-bit or 16-bit (only with NORM_L1) 1-channel, 2-channel, 3-channel or 4-channel image. h : [float] . Array of parameters regulating filter strength, either one parameter applied to all channels or one per channel in dst. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise Keyword Arguments templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels normType : int . Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1 Return dst : Evision.Mat . Output image with the same size and type as src . This function expected to be applied to grayscale images. For colored images look at fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting image to CIELAB colorspace and then separately denoise L and AB components with different h parameter. Python prototype (for reference): fastNlMeansDenoising(src, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -&gt; dst Variant 2: Perform image denoising using Non-local Means Denoising algorithm http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ with several computational optimizations. Noise expected to be a gaussian white noise Positional Arguments src : Evision.Mat . Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel image. Keyword Arguments h : float . Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as src . This function expected to be applied to grayscale images. For colored images look at fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting image to CIELAB colorspace and then separately denoise L and AB components with different h parameter. Python prototype (for reference): fastNlMeansDenoising(src[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoising/2","title":"Evision.fastNlMeansDenoising/2","type":"function"},{"doc":"Perform image denoising using Non-local Means Denoising algorithm http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ with several computational optimizations. Noise expected to be a gaussian white noise Positional Arguments src : Evision.Mat . Input 8-bit or 16-bit (only with NORM_L1) 1-channel, 2-channel, 3-channel or 4-channel image. h : [float] . Array of parameters regulating filter strength, either one parameter applied to all channels or one per channel in dst. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise Keyword Arguments templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels normType : int . Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1 Return dst : Evision.Mat . Output image with the same size and type as src . This function expected to be applied to grayscale images. For colored images look at fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting image to CIELAB colorspace and then separately denoise L and AB components with different h parameter. Python prototype (for reference): fastNlMeansDenoising(src, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoising/3","title":"Evision.fastNlMeansDenoising/3","type":"function"},{"doc":"Raising version of fastNlMeansDenoisingColored/1 .","ref":"Evision.html#fastNlMeansDenoisingColored!/1","title":"Evision.fastNlMeansDenoisingColored!/1","type":"function"},{"doc":"Raising version of fastNlMeansDenoisingColored/2 .","ref":"Evision.html#fastNlMeansDenoisingColored!/2","title":"Evision.fastNlMeansDenoisingColored!/2","type":"function"},{"doc":"Modification of fastNlMeansDenoising function for colored images Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments h : float . Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise hColor : float . The same as h but for color components. For most images value equals 10 will be enough to remove colored noise and do not distort colors templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as src . The function converts image to CIELAB colorspace and then separately denoise L and AB components with given h parameters using fastNlMeansDenoising function. Python prototype (for reference): fastNlMeansDenoisingColored(src[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoisingColored/1","title":"Evision.fastNlMeansDenoisingColored/1","type":"function"},{"doc":"Modification of fastNlMeansDenoising function for colored images Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments h : float . Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise hColor : float . The same as h but for color components. For most images value equals 10 will be enough to remove colored noise and do not distort colors templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as src . The function converts image to CIELAB colorspace and then separately denoise L and AB components with given h parameters using fastNlMeansDenoising function. Python prototype (for reference): fastNlMeansDenoisingColored(src[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoisingColored/2","title":"Evision.fastNlMeansDenoisingColored/2","type":"function"},{"doc":"Raising version of fastNlMeansDenoisingColoredMulti/3 .","ref":"Evision.html#fastNlMeansDenoisingColoredMulti!/3","title":"Evision.fastNlMeansDenoisingColoredMulti!/3","type":"function"},{"doc":"Raising version of fastNlMeansDenoisingColoredMulti/4 .","ref":"Evision.html#fastNlMeansDenoisingColoredMulti!/4","title":"Evision.fastNlMeansDenoisingColoredMulti!/4","type":"function"},{"doc":"Modification of fastNlMeansDenoisingMulti function for colored images sequences Positional Arguments srcImgs : [Evision.Mat] . Input 8-bit 3-channel images sequence. All images should have the same type and size. imgToDenoiseIndex : int . Target image to denoise index in srcImgs sequence temporalWindowSize : int . Number of surrounding images to use for target image denoising. Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image. Keyword Arguments h : float . Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise. hColor : float . The same as h but for color components. templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as srcImgs images. The function converts images to CIELAB colorspace and then separately denoise L and AB components with given h parameters using fastNlMeansDenoisingMulti function. Python prototype (for reference): fastNlMeansDenoisingColoredMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoisingColoredMulti/3","title":"Evision.fastNlMeansDenoisingColoredMulti/3","type":"function"},{"doc":"Modification of fastNlMeansDenoisingMulti function for colored images sequences Positional Arguments srcImgs : [Evision.Mat] . Input 8-bit 3-channel images sequence. All images should have the same type and size. imgToDenoiseIndex : int . Target image to denoise index in srcImgs sequence temporalWindowSize : int . Number of surrounding images to use for target image denoising. Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image. Keyword Arguments h : float . Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise. hColor : float . The same as h but for color components. templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as srcImgs images. The function converts images to CIELAB colorspace and then separately denoise L and AB components with given h parameters using fastNlMeansDenoisingMulti function. Python prototype (for reference): fastNlMeansDenoisingColoredMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoisingColoredMulti/4","title":"Evision.fastNlMeansDenoisingColoredMulti/4","type":"function"},{"doc":"Raising version of fastNlMeansDenoisingMulti/3 .","ref":"Evision.html#fastNlMeansDenoisingMulti!/3","title":"Evision.fastNlMeansDenoisingMulti!/3","type":"function"},{"doc":"Raising version of fastNlMeansDenoisingMulti/4 .","ref":"Evision.html#fastNlMeansDenoisingMulti!/4","title":"Evision.fastNlMeansDenoisingMulti!/4","type":"function"},{"doc":"Raising version of fastNlMeansDenoisingMulti/5 .","ref":"Evision.html#fastNlMeansDenoisingMulti!/5","title":"Evision.fastNlMeansDenoisingMulti!/5","type":"function"},{"doc":"Modification of fastNlMeansDenoising function for images sequence where consecutive images have been captured in small period of time. For example video. This version of the function is for grayscale images or for manual manipulation with colorspaces. For more details see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394 Positional Arguments srcImgs : [Evision.Mat] . Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel images sequence. All images should have the same type and size. imgToDenoiseIndex : int . Target image to denoise index in srcImgs sequence temporalWindowSize : int . Number of surrounding images to use for target image denoising. Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image. Keyword Arguments h : float . Parameter regulating filter strength. Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as srcImgs images. Python prototype (for reference): fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoisingMulti/3","title":"Evision.fastNlMeansDenoisingMulti/3","type":"function"},{"doc":"Variant 1: Modification of fastNlMeansDenoising function for images sequence where consecutive images have been captured in small period of time. For example video. This version of the function is for grayscale images or for manual manipulation with colorspaces. For more details see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394 Positional Arguments srcImgs : [Evision.Mat] . Input 8-bit or 16-bit (only with NORM_L1) 1-channel, 2-channel, 3-channel or 4-channel images sequence. All images should have the same type and size. imgToDenoiseIndex : int . Target image to denoise index in srcImgs sequence temporalWindowSize : int . Number of surrounding images to use for target image denoising. Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image. h : [float] . Array of parameters regulating filter strength, either one parameter applied to all channels or one per channel in dst. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise Keyword Arguments templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels normType : int . Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1 Return dst : Evision.Mat . Output image with the same size and type as srcImgs images. Python prototype (for reference): fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -&gt; dst Variant 2: Modification of fastNlMeansDenoising function for images sequence where consecutive images have been captured in small period of time. For example video. This version of the function is for grayscale images or for manual manipulation with colorspaces. For more details see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394 Positional Arguments srcImgs : [Evision.Mat] . Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel images sequence. All images should have the same type and size. imgToDenoiseIndex : int . Target image to denoise index in srcImgs sequence temporalWindowSize : int . Number of surrounding images to use for target image denoising. Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image. Keyword Arguments h : float . Parameter regulating filter strength. Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels Return dst : Evision.Mat . Output image with the same size and type as srcImgs images. Python prototype (for reference): fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoisingMulti/4","title":"Evision.fastNlMeansDenoisingMulti/4","type":"function"},{"doc":"Modification of fastNlMeansDenoising function for images sequence where consecutive images have been captured in small period of time. For example video. This version of the function is for grayscale images or for manual manipulation with colorspaces. For more details see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394 Positional Arguments srcImgs : [Evision.Mat] . Input 8-bit or 16-bit (only with NORM_L1) 1-channel, 2-channel, 3-channel or 4-channel images sequence. All images should have the same type and size. imgToDenoiseIndex : int . Target image to denoise index in srcImgs sequence temporalWindowSize : int . Number of surrounding images to use for target image denoising. Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image. h : [float] . Array of parameters regulating filter strength, either one parameter applied to all channels or one per channel in dst. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise Keyword Arguments templateWindowSize : int . Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels searchWindowSize : int . Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels normType : int . Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1 Return dst : Evision.Mat . Output image with the same size and type as srcImgs images. Python prototype (for reference): fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -&gt; dst","ref":"Evision.html#fastNlMeansDenoisingMulti/5","title":"Evision.fastNlMeansDenoisingMulti/5","type":"function"},{"doc":"Raising version of fillConvexPoly/3 .","ref":"Evision.html#fillConvexPoly!/3","title":"Evision.fillConvexPoly!/3","type":"function"},{"doc":"Raising version of fillConvexPoly/4 .","ref":"Evision.html#fillConvexPoly!/4","title":"Evision.fillConvexPoly!/4","type":"function"},{"doc":"Fills a convex polygon. Positional Arguments points : Evision.Mat . Polygon vertices. color : Scalar . Polygon color. Keyword Arguments lineType : int . Type of the polygon boundaries. See #LineTypes shift : int . Number of fractional bits in the vertex coordinates. Return img : Evision.Mat . Image. The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the function #fillPoly . It can fill not only convex polygons but any monotonic polygon without self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-most and/or the bottom edge could be horizontal). Python prototype (for reference): fillConvexPoly(img, points, color[, lineType[, shift]]) -&gt; img","ref":"Evision.html#fillConvexPoly/3","title":"Evision.fillConvexPoly/3","type":"function"},{"doc":"Fills a convex polygon. Positional Arguments points : Evision.Mat . Polygon vertices. color : Scalar . Polygon color. Keyword Arguments lineType : int . Type of the polygon boundaries. See #LineTypes shift : int . Number of fractional bits in the vertex coordinates. Return img : Evision.Mat . Image. The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the function #fillPoly . It can fill not only convex polygons but any monotonic polygon without self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-most and/or the bottom edge could be horizontal). Python prototype (for reference): fillConvexPoly(img, points, color[, lineType[, shift]]) -&gt; img","ref":"Evision.html#fillConvexPoly/4","title":"Evision.fillConvexPoly/4","type":"function"},{"doc":"Raising version of fillPoly/3 .","ref":"Evision.html#fillPoly!/3","title":"Evision.fillPoly!/3","type":"function"},{"doc":"Raising version of fillPoly/4 .","ref":"Evision.html#fillPoly!/4","title":"Evision.fillPoly!/4","type":"function"},{"doc":"Fills the area bounded by one or more polygons. Positional Arguments pts : [Evision.Mat] . Array of polygons where each polygon is represented as an array of points. color : Scalar . Polygon color. Keyword Arguments lineType : int . Type of the polygon boundaries. See #LineTypes shift : int . Number of fractional bits in the vertex coordinates. offset : Point . Optional offset of all points of the contours. Return img : Evision.Mat . Image. The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-intersections (some of their parts), and so forth. Python prototype (for reference): fillPoly(img, pts, color[, lineType[, shift[, offset]]]) -&gt; img","ref":"Evision.html#fillPoly/3","title":"Evision.fillPoly/3","type":"function"},{"doc":"Fills the area bounded by one or more polygons. Positional Arguments pts : [Evision.Mat] . Array of polygons where each polygon is represented as an array of points. color : Scalar . Polygon color. Keyword Arguments lineType : int . Type of the polygon boundaries. See #LineTypes shift : int . Number of fractional bits in the vertex coordinates. offset : Point . Optional offset of all points of the contours. Return img : Evision.Mat . Image. The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-intersections (some of their parts), and so forth. Python prototype (for reference): fillPoly(img, pts, color[, lineType[, shift[, offset]]]) -&gt; img","ref":"Evision.html#fillPoly/4","title":"Evision.fillPoly/4","type":"function"},{"doc":"Raising version of filter2D/3 .","ref":"Evision.html#filter2D!/3","title":"Evision.filter2D!/3","type":"function"},{"doc":"Raising version of filter2D/4 .","ref":"Evision.html#filter2D!/4","title":"Evision.filter2D!/4","type":"function"},{"doc":"Convolves an image with the kernel. Positional Arguments src : Evision.Mat . input image. ddepth : int . desired depth of the destination image, see @ref filter_depths &quot;combinations&quot; kernel : Evision.Mat . convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. Keyword Arguments anchor : Point . anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center. delta : double . optional value added to the filtered pixels before storing them in dst. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and the same number of channels as src. The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode. The function does actually compute correlation, not the convolution: \\f[\\texttt{dst} (x,y) = \\sum _{ \\substack{0\\leq x' &lt; \\texttt{kernel.cols}\\\\{0\\leq y' &lt; \\texttt{kernel.rows}}}} \\texttt{kernel} (x',y')* \\texttt{src} (x+x'- \\texttt{anchor.x} ,y+y'- \\texttt{anchor.y} )\\f] That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using #flip and set the new anchor to (kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1) . The function uses the DFT-based algorithm in case of sufficiently large kernels (~ 11 x 11 or larger) and the direct algorithm for small kernels. @sa sepFilter2D, dft, matchTemplate Python prototype (for reference): filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]]) -&gt; dst","ref":"Evision.html#filter2D/3","title":"Evision.filter2D/3","type":"function"},{"doc":"Convolves an image with the kernel. Positional Arguments src : Evision.Mat . input image. ddepth : int . desired depth of the destination image, see @ref filter_depths &quot;combinations&quot; kernel : Evision.Mat . convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. Keyword Arguments anchor : Point . anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center. delta : double . optional value added to the filtered pixels before storing them in dst. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and the same number of channels as src. The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode. The function does actually compute correlation, not the convolution: \\f[\\texttt{dst} (x,y) = \\sum _{ \\substack{0\\leq x' &lt; \\texttt{kernel.cols}\\\\{0\\leq y' &lt; \\texttt{kernel.rows}}}} \\texttt{kernel} (x',y')* \\texttt{src} (x+x'- \\texttt{anchor.x} ,y+y'- \\texttt{anchor.y} )\\f] That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using #flip and set the new anchor to (kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1) . The function uses the DFT-based algorithm in case of sufficiently large kernels (~ 11 x 11 or larger) and the direct algorithm for small kernels. @sa sepFilter2D, dft, matchTemplate Python prototype (for reference): filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]]) -&gt; dst","ref":"Evision.html#filter2D/4","title":"Evision.filter2D/4","type":"function"},{"doc":"Raising version of filterHomographyDecompByVisibleRefpoints/4 .","ref":"Evision.html#filterHomographyDecompByVisibleRefpoints!/4","title":"Evision.filterHomographyDecompByVisibleRefpoints!/4","type":"function"},{"doc":"Raising version of filterHomographyDecompByVisibleRefpoints/5 .","ref":"Evision.html#filterHomographyDecompByVisibleRefpoints!/5","title":"Evision.filterHomographyDecompByVisibleRefpoints!/5","type":"function"},{"doc":"Filters homography decompositions based on additional information. Positional Arguments rotations : [Evision.Mat] . Vector of rotation matrices. normals : [Evision.Mat] . Vector of plane normal matrices. beforePoints : Evision.Mat . Vector of (rectified) visible reference points before the homography is applied afterPoints : Evision.Mat . Vector of (rectified) visible reference points after the homography is applied Keyword Arguments pointsMask : Evision.Mat . optional Mat/Vector of 8u type representing the mask for the inliers as given by the #findHomography function Return possibleSolutions : Evision.Mat . Vector of int indices representing the viable solution set after filtering This function is intended to filter the output of the #decomposeHomographyMat based on additional information as described in @cite Malis . The summary of the method: the #decomposeHomographyMat function returns 2 unique solutions and their &quot;opposites&quot; for a total of 4 solutions. If we have access to the sets of points visible in the camera frame before and after the homography transformation is applied, we can determine which are the true potential solutions and which are the opposites by verifying which homographies are consistent with all visible reference points being in front of the camera. The inputs are left unchanged; the filtered solution set is returned as indices into the existing one. Python prototype (for reference): filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints[, possibleSolutions[, pointsMask]]) -&gt; possibleSolutions","ref":"Evision.html#filterHomographyDecompByVisibleRefpoints/4","title":"Evision.filterHomographyDecompByVisibleRefpoints/4","type":"function"},{"doc":"Filters homography decompositions based on additional information. Positional Arguments rotations : [Evision.Mat] . Vector of rotation matrices. normals : [Evision.Mat] . Vector of plane normal matrices. beforePoints : Evision.Mat . Vector of (rectified) visible reference points before the homography is applied afterPoints : Evision.Mat . Vector of (rectified) visible reference points after the homography is applied Keyword Arguments pointsMask : Evision.Mat . optional Mat/Vector of 8u type representing the mask for the inliers as given by the #findHomography function Return possibleSolutions : Evision.Mat . Vector of int indices representing the viable solution set after filtering This function is intended to filter the output of the #decomposeHomographyMat based on additional information as described in @cite Malis . The summary of the method: the #decomposeHomographyMat function returns 2 unique solutions and their &quot;opposites&quot; for a total of 4 solutions. If we have access to the sets of points visible in the camera frame before and after the homography transformation is applied, we can determine which are the true potential solutions and which are the opposites by verifying which homographies are consistent with all visible reference points being in front of the camera. The inputs are left unchanged; the filtered solution set is returned as indices into the existing one. Python prototype (for reference): filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints[, possibleSolutions[, pointsMask]]) -&gt; possibleSolutions","ref":"Evision.html#filterHomographyDecompByVisibleRefpoints/5","title":"Evision.filterHomographyDecompByVisibleRefpoints/5","type":"function"},{"doc":"Raising version of filterSpeckles/4 .","ref":"Evision.html#filterSpeckles!/4","title":"Evision.filterSpeckles!/4","type":"function"},{"doc":"Raising version of filterSpeckles/5 .","ref":"Evision.html#filterSpeckles!/5","title":"Evision.filterSpeckles!/5","type":"function"},{"doc":"Filters off small noise blobs (speckles) in the disparity map Positional Arguments newVal : double . The disparity value used to paint-off the speckles maxSpeckleSize : int . The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm maxDiff : double . Maximum difference between neighbor disparity pixels to put them into the same blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point disparity map, where disparity values are multiplied by 16, this scale factor should be taken into account when specifying this parameter value. Return img : Evision.Mat . The input 16-bit signed disparity image buf : Evision.Mat . The optional temporary buffer to avoid memory allocation within the function. Python prototype (for reference): filterSpeckles(img, newVal, maxSpeckleSize, maxDiff[, buf]) -&gt; img, buf","ref":"Evision.html#filterSpeckles/4","title":"Evision.filterSpeckles/4","type":"function"},{"doc":"Filters off small noise blobs (speckles) in the disparity map Positional Arguments newVal : double . The disparity value used to paint-off the speckles maxSpeckleSize : int . The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm maxDiff : double . Maximum difference between neighbor disparity pixels to put them into the same blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point disparity map, where disparity values are multiplied by 16, this scale factor should be taken into account when specifying this parameter value. Return img : Evision.Mat . The input 16-bit signed disparity image buf : Evision.Mat . The optional temporary buffer to avoid memory allocation within the function. Python prototype (for reference): filterSpeckles(img, newVal, maxSpeckleSize, maxDiff[, buf]) -&gt; img, buf","ref":"Evision.html#filterSpeckles/5","title":"Evision.filterSpeckles/5","type":"function"},{"doc":"Raising version of find4QuadCornerSubpix/3 .","ref":"Evision.html#find4QuadCornerSubpix!/3","title":"Evision.find4QuadCornerSubpix!/3","type":"function"},{"doc":"Positional Arguments img : Evision.Mat region_size : Size Return corners : Evision.Mat Python prototype (for reference): find4QuadCornerSubpix(img, corners, region_size) -&gt; retval, corners","ref":"Evision.html#find4QuadCornerSubpix/3","title":"Evision.find4QuadCornerSubpix/3","type":"function"},{"doc":"Raising version of findChessboardCorners/2 .","ref":"Evision.html#findChessboardCorners!/2","title":"Evision.findChessboardCorners!/2","type":"function"},{"doc":"Raising version of findChessboardCorners/3 .","ref":"Evision.html#findChessboardCorners!/3","title":"Evision.findChessboardCorners!/3","type":"function"},{"doc":"Finds the positions of internal corners of the chessboard. Positional Arguments image : Evision.Mat . Source chessboard view. It must be an 8-bit grayscale or color image. patternSize : Size . Number of inner corners per a chessboard row and column ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ). Keyword Arguments flags : int .Various operation flags that can be zero or a combination of the following values: @ref CALIB_CB_ADAPTIVE_THRESH Use adaptive thresholding to convert the image to black and white, rather than a fixed threshold level (computed from the average image brightness). @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before applying fixed or adaptive thresholding. @ref CALIB_CB_FILTER_QUADS Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads extracted at the contour retrieval stage. @ref CALIB_CB_FAST_CHECK Run a fast check on the image that looks for chessboard corners, and shortcut the call if none is found. This can drastically speed up the call in the degenerate condition when no chessboard is observed. Return corners : Evision.Mat . Output array of detected corners. The function attempts to determine whether the input image is a view of the chessboard pattern and locate the internal chessboard corners. The function returns a non-zero value if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black squares touch each other. The detected coordinates are approximate, and to determine their positions more accurately, the function calls cornerSubPix. You also may use the function cornerSubPix with different parameters if returned coordinates are not accurate enough. Sample usage of detecting and drawing chessboard corners: : Size patternsize ( 8 , 6 ) ; // interior number of corners Mat gray = ... . ; // source image vector &lt; Point2f &gt; corners ; // this will be filled by the detected corners // CALIB_CB_FAST_CHECK saves a lot of time on images // that do not contain any chessboard corners bool patternfound = findChessboardCorners ( gray , patternsize , corners , CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE + CALIB_CB_FAST_CHECK ) ; if ( patternfound ) cornerSubPix ( gray , corners , Size ( 11 , 11 ) , Size ( - 1 , - 1 ) , TermCriteria ( CV_TERMCRIT_EPS + CV_TERMCRIT_ITER , 30 , 0.1 ) ) ; drawChessboardCorners ( img , patternsize , Mat ( corners ) , patternfound ) ; Note : The function requires white space (like a square-thick border, the wider the better) around the board to make the detection more robust in various environments. Otherwise, if there is no border and the background is dark, the outer black squares cannot be segmented properly and so the square grouping and ordering algorithm fails. Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard. Python prototype (for reference): findChessboardCorners(image, patternSize[, corners[, flags]]) -&gt; retval, corners","ref":"Evision.html#findChessboardCorners/2","title":"Evision.findChessboardCorners/2","type":"function"},{"doc":"Finds the positions of internal corners of the chessboard. Positional Arguments image : Evision.Mat . Source chessboard view. It must be an 8-bit grayscale or color image. patternSize : Size . Number of inner corners per a chessboard row and column ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ). Keyword Arguments flags : int .Various operation flags that can be zero or a combination of the following values: @ref CALIB_CB_ADAPTIVE_THRESH Use adaptive thresholding to convert the image to black and white, rather than a fixed threshold level (computed from the average image brightness). @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before applying fixed or adaptive thresholding. @ref CALIB_CB_FILTER_QUADS Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads extracted at the contour retrieval stage. @ref CALIB_CB_FAST_CHECK Run a fast check on the image that looks for chessboard corners, and shortcut the call if none is found. This can drastically speed up the call in the degenerate condition when no chessboard is observed. Return corners : Evision.Mat . Output array of detected corners. The function attempts to determine whether the input image is a view of the chessboard pattern and locate the internal chessboard corners. The function returns a non-zero value if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black squares touch each other. The detected coordinates are approximate, and to determine their positions more accurately, the function calls cornerSubPix. You also may use the function cornerSubPix with different parameters if returned coordinates are not accurate enough. Sample usage of detecting and drawing chessboard corners: : Size patternsize ( 8 , 6 ) ; // interior number of corners Mat gray = ... . ; // source image vector &lt; Point2f &gt; corners ; // this will be filled by the detected corners // CALIB_CB_FAST_CHECK saves a lot of time on images // that do not contain any chessboard corners bool patternfound = findChessboardCorners ( gray , patternsize , corners , CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE + CALIB_CB_FAST_CHECK ) ; if ( patternfound ) cornerSubPix ( gray , corners , Size ( 11 , 11 ) , Size ( - 1 , - 1 ) , TermCriteria ( CV_TERMCRIT_EPS + CV_TERMCRIT_ITER , 30 , 0.1 ) ) ; drawChessboardCorners ( img , patternsize , Mat ( corners ) , patternfound ) ; Note : The function requires white space (like a square-thick border, the wider the better) around the board to make the detection more robust in various environments. Otherwise, if there is no border and the background is dark, the outer black squares cannot be segmented properly and so the square grouping and ordering algorithm fails. Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard. Python prototype (for reference): findChessboardCorners(image, patternSize[, corners[, flags]]) -&gt; retval, corners","ref":"Evision.html#findChessboardCorners/3","title":"Evision.findChessboardCorners/3","type":"function"},{"doc":"Raising version of findChessboardCornersSB/2 .","ref":"Evision.html#findChessboardCornersSB!/2","title":"Evision.findChessboardCornersSB!/2","type":"function"},{"doc":"Raising version of findChessboardCornersSB/3 .","ref":"Evision.html#findChessboardCornersSB!/3","title":"Evision.findChessboardCornersSB!/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat patternSize : Size Keyword Arguments flags : int . Return corners : Evision.Mat . Has overloading in C++ Python prototype (for reference): findChessboardCornersSB(image, patternSize[, corners[, flags]]) -&gt; retval, corners","ref":"Evision.html#findChessboardCornersSB/2","title":"Evision.findChessboardCornersSB/2","type":"function"},{"doc":"Positional Arguments image : Evision.Mat patternSize : Size Keyword Arguments flags : int . Return corners : Evision.Mat . Has overloading in C++ Python prototype (for reference): findChessboardCornersSB(image, patternSize[, corners[, flags]]) -&gt; retval, corners","ref":"Evision.html#findChessboardCornersSB/3","title":"Evision.findChessboardCornersSB/3","type":"function"},{"doc":"Raising version of findChessboardCornersSBWithMeta/3 .","ref":"Evision.html#findChessboardCornersSBWithMeta!/3","title":"Evision.findChessboardCornersSBWithMeta!/3","type":"function"},{"doc":"Raising version of findChessboardCornersSBWithMeta/4 .","ref":"Evision.html#findChessboardCornersSBWithMeta!/4","title":"Evision.findChessboardCornersSBWithMeta!/4","type":"function"},{"doc":"Finds the positions of internal corners of the chessboard using a sector based approach. Positional Arguments image : Evision.Mat . Source chessboard view. It must be an 8-bit grayscale or color image. patternSize : Size . Number of inner corners per a chessboard row and column ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ). flags : int . Various operation flags that can be zero or a combination of the following values: @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before detection. @ref CALIB_CB_EXHAUSTIVE Run an exhaustive search to improve detection rate. @ref CALIB_CB_ACCURACY Up sample input image to improve sub-pixel accuracy due to aliasing effects. @ref CALIB_CB_LARGER The detected pattern is allowed to be larger than patternSize (see description). @ref CALIB_CB_MARKER The detected pattern must have a marker (see description). This should be used if an accurate camera calibration is required. Return corners : Evision.Mat . Output array of detected corners. meta : Evision.Mat . Optional output arrray of detected corners (CV_8UC1 and size = cv::Size(columns,rows)). Each entry stands for one corner of the pattern and can have one of the following values: 0 = no meta data attached 1 = left-top corner of a black cell 2 = left-top corner of a white cell 3 = left-top corner of a black cell with a white marker dot 4 = left-top corner of a white cell with a black marker dot (pattern origin in case of markers otherwise first corner) The function is analog to #findChessboardCorners but uses a localized radon transformation approximated by box filters being more robust to all sort of noise, faster on larger images and is able to directly return the sub-pixel position of the internal chessboard corners. The Method is based on the paper @cite duda2018 &quot;Accurate Detection and Localization of Checkerboard Corners for Calibration&quot; demonstrating that the returned sub-pixel positions are more accurate than the one returned by cornerSubPix allowing a precise camera calibration for demanding applications. In the case, the flags @ref CALIB_CB_LARGER or @ref CALIB_CB_MARKER are given, the result can be recovered from the optional meta array. Both flags are helpful to use calibration patterns exceeding the field of view of the camera. These oversized patterns allow more accurate calibrations as corners can be utilized, which are as close as possible to the image borders. For a consistent coordinate system across all images, the optional marker (see image below) can be used to move the origin of the board to the location where the black circle is located. Note : The function requires a white boarder with roughly the same width as one of the checkerboard fields around the whole board to improve the detection in various environments. In addition, because of the localized radon transformation it is beneficial to use round corners for the field corners which are located on the outside of the board. The following figure illustrates a sample checkerboard optimized for the detection. However, any other checkerboard can be used as well. Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard. Python prototype (for reference): findChessboardCornersSBWithMeta(image, patternSize, flags[, corners[, meta]]) -&gt; retval, corners, meta","ref":"Evision.html#findChessboardCornersSBWithMeta/3","title":"Evision.findChessboardCornersSBWithMeta/3","type":"function"},{"doc":"Finds the positions of internal corners of the chessboard using a sector based approach. Positional Arguments image : Evision.Mat . Source chessboard view. It must be an 8-bit grayscale or color image. patternSize : Size . Number of inner corners per a chessboard row and column ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ). flags : int . Various operation flags that can be zero or a combination of the following values: @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before detection. @ref CALIB_CB_EXHAUSTIVE Run an exhaustive search to improve detection rate. @ref CALIB_CB_ACCURACY Up sample input image to improve sub-pixel accuracy due to aliasing effects. @ref CALIB_CB_LARGER The detected pattern is allowed to be larger than patternSize (see description). @ref CALIB_CB_MARKER The detected pattern must have a marker (see description). This should be used if an accurate camera calibration is required. Return corners : Evision.Mat . Output array of detected corners. meta : Evision.Mat . Optional output arrray of detected corners (CV_8UC1 and size = cv::Size(columns,rows)). Each entry stands for one corner of the pattern and can have one of the following values: 0 = no meta data attached 1 = left-top corner of a black cell 2 = left-top corner of a white cell 3 = left-top corner of a black cell with a white marker dot 4 = left-top corner of a white cell with a black marker dot (pattern origin in case of markers otherwise first corner) The function is analog to #findChessboardCorners but uses a localized radon transformation approximated by box filters being more robust to all sort of noise, faster on larger images and is able to directly return the sub-pixel position of the internal chessboard corners. The Method is based on the paper @cite duda2018 &quot;Accurate Detection and Localization of Checkerboard Corners for Calibration&quot; demonstrating that the returned sub-pixel positions are more accurate than the one returned by cornerSubPix allowing a precise camera calibration for demanding applications. In the case, the flags @ref CALIB_CB_LARGER or @ref CALIB_CB_MARKER are given, the result can be recovered from the optional meta array. Both flags are helpful to use calibration patterns exceeding the field of view of the camera. These oversized patterns allow more accurate calibrations as corners can be utilized, which are as close as possible to the image borders. For a consistent coordinate system across all images, the optional marker (see image below) can be used to move the origin of the board to the location where the black circle is located. Note : The function requires a white boarder with roughly the same width as one of the checkerboard fields around the whole board to improve the detection in various environments. In addition, because of the localized radon transformation it is beneficial to use round corners for the field corners which are located on the outside of the board. The following figure illustrates a sample checkerboard optimized for the detection. However, any other checkerboard can be used as well. Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard. Python prototype (for reference): findChessboardCornersSBWithMeta(image, patternSize, flags[, corners[, meta]]) -&gt; retval, corners, meta","ref":"Evision.html#findChessboardCornersSBWithMeta/4","title":"Evision.findChessboardCornersSBWithMeta/4","type":"function"},{"doc":"Raising version of findCirclesGrid/2 .","ref":"Evision.html#findCirclesGrid!/2","title":"Evision.findCirclesGrid!/2","type":"function"},{"doc":"Raising version of findCirclesGrid/3 .","ref":"Evision.html#findCirclesGrid!/3","title":"Evision.findCirclesGrid!/3","type":"function"},{"doc":"Raising version of findCirclesGrid/5 .","ref":"Evision.html#findCirclesGrid!/5","title":"Evision.findCirclesGrid!/5","type":"function"},{"doc":"Raising version of findCirclesGrid/6 .","ref":"Evision.html#findCirclesGrid!/6","title":"Evision.findCirclesGrid!/6","type":"function"},{"doc":"Positional Arguments image : Evision.Mat patternSize : Size Keyword Arguments flags : int . blobDetector : Ptr&lt;FeatureDetector&gt; . Return centers : Evision.Mat . Has overloading in C++ Python prototype (for reference): findCirclesGrid(image, patternSize[, centers[, flags[, blobDetector]]]) -&gt; retval, centers","ref":"Evision.html#findCirclesGrid/2","title":"Evision.findCirclesGrid/2","type":"function"},{"doc":"Positional Arguments image : Evision.Mat patternSize : Size Keyword Arguments flags : int . blobDetector : Ptr&lt;FeatureDetector&gt; . Return centers : Evision.Mat . Has overloading in C++ Python prototype (for reference): findCirclesGrid(image, patternSize[, centers[, flags[, blobDetector]]]) -&gt; retval, centers","ref":"Evision.html#findCirclesGrid/3","title":"Evision.findCirclesGrid/3","type":"function"},{"doc":"Finds centers in the grid of circles. Positional Arguments image : Evision.Mat . grid view of input circles; it must be an 8-bit grayscale or color image. patternSize : Size . number of circles per row and column ( patternSize = Size(points_per_row, points_per_colum) ). flags : int . various operation flags that can be one of the following values: @ref CALIB_CB_SYMMETRIC_GRID uses symmetric pattern of circles. @ref CALIB_CB_ASYMMETRIC_GRID uses asymmetric pattern of circles. @ref CALIB_CB_CLUSTERING uses a special algorithm for grid detection. It is more robust to perspective distortions but much more sensitive to background clutter. blobDetector : Ptr&lt;FeatureDetector&gt; . feature detector that finds blobs like dark circles on light background. If blobDetector is NULL then image represents Point2f array of candidates. parameters : CirclesGridFinderParameters . struct for finding circles in a grid pattern. Return centers : Evision.Mat . output array of detected centers. The function attempts to determine whether the input image contains a grid of circles. If it is, the function locates centers of the circles. The function returns a non-zero value if all of the centers have been found and they have been placed in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0. Sample usage of detecting and drawing the centers of circles: : Size patternsize ( 7 , 7 ) ; // number of centers Mat gray = ... ; // source image vector &lt; Point2f &gt; centers ; // this will be filled by the detected centers bool patternfound = findCirclesGrid ( gray , patternsize , centers ) ; drawChessboardCorners ( img , patternsize , Mat ( centers ) , patternfound ) ; Note : The function requires white space (like a square-thick border, the wider the better) around the board to make the detection more robust in various environments. Python prototype (for reference): findCirclesGrid(image, patternSize, flags, blobDetector, parameters[, centers]) -&gt; retval, centers","ref":"Evision.html#findCirclesGrid/5","title":"Evision.findCirclesGrid/5","type":"function"},{"doc":"Finds centers in the grid of circles. Positional Arguments image : Evision.Mat . grid view of input circles; it must be an 8-bit grayscale or color image. patternSize : Size . number of circles per row and column ( patternSize = Size(points_per_row, points_per_colum) ). flags : int . various operation flags that can be one of the following values: @ref CALIB_CB_SYMMETRIC_GRID uses symmetric pattern of circles. @ref CALIB_CB_ASYMMETRIC_GRID uses asymmetric pattern of circles. @ref CALIB_CB_CLUSTERING uses a special algorithm for grid detection. It is more robust to perspective distortions but much more sensitive to background clutter. blobDetector : Ptr&lt;FeatureDetector&gt; . feature detector that finds blobs like dark circles on light background. If blobDetector is NULL then image represents Point2f array of candidates. parameters : CirclesGridFinderParameters . struct for finding circles in a grid pattern. Return centers : Evision.Mat . output array of detected centers. The function attempts to determine whether the input image contains a grid of circles. If it is, the function locates centers of the circles. The function returns a non-zero value if all of the centers have been found and they have been placed in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0. Sample usage of detecting and drawing the centers of circles: : Size patternsize ( 7 , 7 ) ; // number of centers Mat gray = ... ; // source image vector &lt; Point2f &gt; centers ; // this will be filled by the detected centers bool patternfound = findCirclesGrid ( gray , patternsize , centers ) ; drawChessboardCorners ( img , patternsize , Mat ( centers ) , patternfound ) ; Note : The function requires white space (like a square-thick border, the wider the better) around the board to make the detection more robust in various environments. Python prototype (for reference): findCirclesGrid(image, patternSize, flags, blobDetector, parameters[, centers]) -&gt; retval, centers","ref":"Evision.html#findCirclesGrid/6","title":"Evision.findCirclesGrid/6","type":"function"},{"doc":"Raising version of findContours/3 .","ref":"Evision.html#findContours!/3","title":"Evision.findContours!/3","type":"function"},{"doc":"Raising version of findContours/4 .","ref":"Evision.html#findContours!/4","title":"Evision.findContours!/4","type":"function"},{"doc":"Finds contours in a binary image. Positional Arguments image : Evision.Mat . Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold , #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one. If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1). mode : int . Contour retrieval mode, see #RetrievalModes method : int . Contour approximation method, see #ContourApproximationModes Keyword Arguments offset : Point . Optional offset by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context. Return contours : [Evision.Mat] . Detected contours. Each contour is stored as a vector of points (e.g. std::vector&lt;std::vector&lt;cv::Point&gt; &gt;). hierarchy : Evision.Mat . Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has as many elements as the number of contours. For each i-th contour contours[i], the elements hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices in contours of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative. The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the OpenCV sample directory. Note : Since opencv 3.2 source image is not modified by this function. Note : In Python, hierarchy is nested inside a top level array. Use hierarchy[0][i] to access hierarchical elements of i-th contour. Python prototype (for reference): findContours(image, mode, method[, contours[, hierarchy[, offset]]]) -&gt; contours, hierarchy","ref":"Evision.html#findContours/3","title":"Evision.findContours/3","type":"function"},{"doc":"Finds contours in a binary image. Positional Arguments image : Evision.Mat . Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold , #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one. If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1). mode : int . Contour retrieval mode, see #RetrievalModes method : int . Contour approximation method, see #ContourApproximationModes Keyword Arguments offset : Point . Optional offset by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context. Return contours : [Evision.Mat] . Detected contours. Each contour is stored as a vector of points (e.g. std::vector&lt;std::vector&lt;cv::Point&gt; &gt;). hierarchy : Evision.Mat . Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has as many elements as the number of contours. For each i-th contour contours[i], the elements hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices in contours of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative. The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the OpenCV sample directory. Note : Since opencv 3.2 source image is not modified by this function. Note : In Python, hierarchy is nested inside a top level array. Use hierarchy[0][i] to access hierarchical elements of i-th contour. Python prototype (for reference): findContours(image, mode, method[, contours[, hierarchy[, offset]]]) -&gt; contours, hierarchy","ref":"Evision.html#findContours/4","title":"Evision.findContours/4","type":"function"},{"doc":"Raising version of findEssentialMat/2 .","ref":"Evision.html#findEssentialMat!/2","title":"Evision.findEssentialMat!/2","type":"function"},{"doc":"Raising version of findEssentialMat/3 .","ref":"Evision.html#findEssentialMat!/3","title":"Evision.findEssentialMat!/3","type":"function"},{"doc":"Raising version of findEssentialMat/4 .","ref":"Evision.html#findEssentialMat!/4","title":"Evision.findEssentialMat!/4","type":"function"},{"doc":"Raising version of findEssentialMat/6 .","ref":"Evision.html#findEssentialMat!/6","title":"Evision.findEssentialMat!/6","type":"function"},{"doc":"Raising version of findEssentialMat/7 .","ref":"Evision.html#findEssentialMat!/7","title":"Evision.findEssentialMat!/7","type":"function"},{"doc":"Raising version of findEssentialMat/8 .","ref":"Evision.html#findEssentialMat!/8","title":"Evision.findEssentialMat!/8","type":"function"},{"doc":"Positional Arguments points1 : Evision.Mat . Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . Keyword Arguments focal : double . focal length of the camera. Note that this function assumes that points1 and points2 are feature points from cameras with same focal length and principal point. pp : Point2d . principal point of the camera. method : int . Method for computing a fundamental matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. maxIters : int . The maximum number of robust method iterations. Return mask : Evision.Mat . Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. Has overloading in C++ This function differs from the one above that it computes camera intrinsic matrix from focal length and principal point: \\f[A = \\begin{bmatrix} f &amp; 0 &amp; x_{pp} \\\\ 0 &amp; f &amp; y_{pp} \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\f] Python prototype (for reference): findEssentialMat(points1, points2[, focal[, pp[, method[, prob[, threshold[, maxIters[, mask]]]]]]]) -&gt; retval, mask","ref":"Evision.html#findEssentialMat/2","title":"Evision.findEssentialMat/2","type":"function"},{"doc":"Variant 1: Calculates an essential matrix from the corresponding points in two images. Positional Arguments points1 : Evision.Mat . Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera intrinsic matrix. If this assumption does not hold for your use case, use #undistortPoints with P = cv::NoArray() for both cameras to transform image points to normalized image coordinates, which are valid for the identity camera intrinsic matrix. When passing these coordinates, pass the identity matrix for this parameter. Keyword Arguments method : int . Method for computing an essential matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. maxIters : int . The maximum number of robust method iterations. Return mask : Evision.Mat . Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 . @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation: \\f[[p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\\f] where \\f$E\\f$ is an essential matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the second images, respectively. The result of this function may be passed further to #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras. Python prototype (for reference): findEssentialMat(points1, points2, cameraMatrix[, method[, prob[, threshold[, maxIters[, mask]]]]]) -&gt; retval, mask Variant 2: Positional Arguments points1 : Evision.Mat . Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . Keyword Arguments focal : double . focal length of the camera. Note that this function assumes that points1 and points2 are feature points from cameras with same focal length and principal point. pp : Point2d . principal point of the camera. method : int . Method for computing a fundamental matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. maxIters : int . The maximum number of robust method iterations. Return mask : Evision.Mat . Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. Has overloading in C++ This function differs from the one above that it computes camera intrinsic matrix from focal length and principal point: \\f[A = \\begin{bmatrix} f &amp; 0 &amp; x_{pp} \\\\ 0 &amp; f &amp; y_{pp} \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\f] Python prototype (for reference): findEssentialMat(points1, points2[, focal[, pp[, method[, prob[, threshold[, maxIters[, mask]]]]]]]) -&gt; retval, mask","ref":"Evision.html#findEssentialMat/3","title":"Evision.findEssentialMat/3","type":"function"},{"doc":"Calculates an essential matrix from the corresponding points in two images. Positional Arguments points1 : Evision.Mat . Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera intrinsic matrix. If this assumption does not hold for your use case, use #undistortPoints with P = cv::NoArray() for both cameras to transform image points to normalized image coordinates, which are valid for the identity camera intrinsic matrix. When passing these coordinates, pass the identity matrix for this parameter. Keyword Arguments method : int . Method for computing an essential matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. maxIters : int . The maximum number of robust method iterations. Return mask : Evision.Mat . Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 . @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation: \\f[[p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\\f] where \\f$E\\f$ is an essential matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the second images, respectively. The result of this function may be passed further to #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras. Python prototype (for reference): findEssentialMat(points1, points2, cameraMatrix[, method[, prob[, threshold[, maxIters[, mask]]]]]) -&gt; retval, mask","ref":"Evision.html#findEssentialMat/4","title":"Evision.findEssentialMat/4","type":"function"},{"doc":"Calculates an essential matrix from the corresponding points in two images from potentially two different cameras. Positional Arguments points1 : Evision.Mat . Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix1 : Evision.Mat . Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix. If this assumption does not hold for your use case, use #undistortPoints with P = cv::NoArray() for both cameras to transform image points to normalized image coordinates, which are valid for the identity camera matrix. When passing these coordinates, pass the identity matrix for this parameter. distCoeffs1 : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. cameraMatrix2 : Evision.Mat . Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix. If this assumption does not hold for your use case, use #undistortPoints with P = cv::NoArray() for both cameras to transform image points to normalized image coordinates, which are valid for the identity camera matrix. When passing these coordinates, pass the identity matrix for this parameter. distCoeffs2 : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments method : int . Method for computing an essential matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. Return mask : Evision.Mat . Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 . @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation: \\f[[p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\\f] where \\f$E\\f$ is an essential matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the second images, respectively. The result of this function may be passed further to #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras. Python prototype (for reference): findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, method[, prob[, threshold[, mask]]]]) -&gt; retval, mask","ref":"Evision.html#findEssentialMat/6","title":"Evision.findEssentialMat/6","type":"function"},{"doc":"Variant 1: Positional Arguments points1 : Evision.Mat points2 : Evision.Mat cameraMatrix1 : Evision.Mat cameraMatrix2 : Evision.Mat dist_coeff1 : Evision.Mat dist_coeff2 : Evision.Mat params : UsacParams Return mask : Evision.Mat . Python prototype (for reference): findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, params[, mask]) -&gt; retval, mask Variant 2: Calculates an essential matrix from the corresponding points in two images from potentially two different cameras. Positional Arguments points1 : Evision.Mat . Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix1 : Evision.Mat . Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix. If this assumption does not hold for your use case, use #undistortPoints with P = cv::NoArray() for both cameras to transform image points to normalized image coordinates, which are valid for the identity camera matrix. When passing these coordinates, pass the identity matrix for this parameter. distCoeffs1 : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. cameraMatrix2 : Evision.Mat . Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix. If this assumption does not hold for your use case, use #undistortPoints with P = cv::NoArray() for both cameras to transform image points to normalized image coordinates, which are valid for the identity camera matrix. When passing these coordinates, pass the identity matrix for this parameter. distCoeffs2 : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments method : int . Method for computing an essential matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. Return mask : Evision.Mat . Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 . @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation: \\f[[p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\\f] where \\f$E\\f$ is an essential matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the second images, respectively. The result of this function may be passed further to #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras. Python prototype (for reference): findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, method[, prob[, threshold[, mask]]]]) -&gt; retval, mask","ref":"Evision.html#findEssentialMat/7","title":"Evision.findEssentialMat/7","type":"function"},{"doc":"Positional Arguments points1 : Evision.Mat points2 : Evision.Mat cameraMatrix1 : Evision.Mat cameraMatrix2 : Evision.Mat dist_coeff1 : Evision.Mat dist_coeff2 : Evision.Mat params : UsacParams Return mask : Evision.Mat . Python prototype (for reference): findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, params[, mask]) -&gt; retval, mask","ref":"Evision.html#findEssentialMat/8","title":"Evision.findEssentialMat/8","type":"function"},{"doc":"Raising version of findFundamentalMat/2 .","ref":"Evision.html#findFundamentalMat!/2","title":"Evision.findFundamentalMat!/2","type":"function"},{"doc":"Raising version of findFundamentalMat/3 .","ref":"Evision.html#findFundamentalMat!/3","title":"Evision.findFundamentalMat!/3","type":"function"},{"doc":"Raising version of findFundamentalMat/4 .","ref":"Evision.html#findFundamentalMat!/4","title":"Evision.findFundamentalMat!/4","type":"function"},{"doc":"Raising version of findFundamentalMat/6 .","ref":"Evision.html#findFundamentalMat!/6","title":"Evision.findFundamentalMat!/6","type":"function"},{"doc":"Raising version of findFundamentalMat/7 .","ref":"Evision.html#findFundamentalMat!/7","title":"Evision.findFundamentalMat!/7","type":"function"},{"doc":"Positional Arguments points1 : Evision.Mat points2 : Evision.Mat Keyword Arguments method : int . ransacReprojThreshold : double . confidence : double . Return mask : Evision.Mat . Has overloading in C++ Python prototype (for reference): findFundamentalMat(points1, points2[, method[, ransacReprojThreshold[, confidence[, mask]]]]) -&gt; retval, mask","ref":"Evision.html#findFundamentalMat/2","title":"Evision.findFundamentalMat/2","type":"function"},{"doc":"Variant 1: Positional Arguments points1 : Evision.Mat points2 : Evision.Mat params : UsacParams Return mask : Evision.Mat . Has overloading in C++ Python prototype (for reference): findFundamentalMat(points1, points2, params[, mask]) -&gt; retval, mask Variant 2: Positional Arguments points1 : Evision.Mat points2 : Evision.Mat Keyword Arguments method : int . ransacReprojThreshold : double . confidence : double . Return mask : Evision.Mat . Has overloading in C++ Python prototype (for reference): findFundamentalMat(points1, points2[, method[, ransacReprojThreshold[, confidence[, mask]]]]) -&gt; retval, mask","ref":"Evision.html#findFundamentalMat/3","title":"Evision.findFundamentalMat/3","type":"function"},{"doc":"Positional Arguments points1 : Evision.Mat points2 : Evision.Mat params : UsacParams Return mask : Evision.Mat . Has overloading in C++ Python prototype (for reference): findFundamentalMat(points1, points2, params[, mask]) -&gt; retval, mask","ref":"Evision.html#findFundamentalMat/4","title":"Evision.findFundamentalMat/4","type":"function"},{"doc":"Calculates a fundamental matrix from the corresponding points in two images. Positional Arguments points1 : Evision.Mat . Array of N points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . method : int . Method for computing a fundamental matrix. @ref FM_7POINT for a 7-point algorithm. \\f$N = 7\\f$ @ref FM_8POINT for an 8-point algorithm. \\f$N \\ge 8\\f$ @ref FM_RANSAC for the RANSAC algorithm. \\f$N \\ge 8\\f$ @ref FM_LMEDS for the LMedS algorithm. \\f$N \\ge 8\\f$ ransacReprojThreshold : double . Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. confidence : double . Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. maxIters : int . The maximum number of robust method iterations. Return mask : Evision.Mat . optional output mask The epipolar geometry is described by the following equation: \\f[[p_2; 1]^T F [p_1; 1] = 0\\f] where \\f$F\\f$ is a fundamental matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the second images, respectively. The function calculates the fundamental matrix using one of four methods listed above and returns the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point algorithm, the function may return up to 3 solutions ( \\f$9 \\times 3\\f$ matrix that stores all 3 matrices sequentially). The calculated fundamental matrix may be passed further to computeCorrespondEpilines that finds the epipolar lines corresponding to the specified points. It can also be passed to #stereoRectifyUncalibrated to compute the rectification transformation. : // Example . Estimation of fundamental matrix using the RANSAC algorithm int point_count = 100 ; vector &lt; Point2f &gt; points1 ( point_count ) ; vector &lt; Point2f &gt; points2 ( point_count ) ; // initialize the points here ... for ( int i = 0 ; i &lt; point_count ; i ++ ) { points1 [ i ] = ... ; points2 [ i ] = ... ; } Mat fundamental_matrix = findFundamentalMat ( points1 , points2 , FM_RANSAC , 3 , 0.99 ) ; Python prototype (for reference): findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters[, mask]) -&gt; retval, mask","ref":"Evision.html#findFundamentalMat/6","title":"Evision.findFundamentalMat/6","type":"function"},{"doc":"Calculates a fundamental matrix from the corresponding points in two images. Positional Arguments points1 : Evision.Mat . Array of N points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . method : int . Method for computing a fundamental matrix. @ref FM_7POINT for a 7-point algorithm. \\f$N = 7\\f$ @ref FM_8POINT for an 8-point algorithm. \\f$N \\ge 8\\f$ @ref FM_RANSAC for the RANSAC algorithm. \\f$N \\ge 8\\f$ @ref FM_LMEDS for the LMedS algorithm. \\f$N \\ge 8\\f$ ransacReprojThreshold : double . Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. confidence : double . Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. maxIters : int . The maximum number of robust method iterations. Return mask : Evision.Mat . optional output mask The epipolar geometry is described by the following equation: \\f[[p_2; 1]^T F [p_1; 1] = 0\\f] where \\f$F\\f$ is a fundamental matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the second images, respectively. The function calculates the fundamental matrix using one of four methods listed above and returns the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point algorithm, the function may return up to 3 solutions ( \\f$9 \\times 3\\f$ matrix that stores all 3 matrices sequentially). The calculated fundamental matrix may be passed further to computeCorrespondEpilines that finds the epipolar lines corresponding to the specified points. It can also be passed to #stereoRectifyUncalibrated to compute the rectification transformation. : // Example . Estimation of fundamental matrix using the RANSAC algorithm int point_count = 100 ; vector &lt; Point2f &gt; points1 ( point_count ) ; vector &lt; Point2f &gt; points2 ( point_count ) ; // initialize the points here ... for ( int i = 0 ; i &lt; point_count ; i ++ ) { points1 [ i ] = ... ; points2 [ i ] = ... ; } Mat fundamental_matrix = findFundamentalMat ( points1 , points2 , FM_RANSAC , 3 , 0.99 ) ; Python prototype (for reference): findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters[, mask]) -&gt; retval, mask","ref":"Evision.html#findFundamentalMat/7","title":"Evision.findFundamentalMat/7","type":"function"},{"doc":"Raising version of findHomography/2 .","ref":"Evision.html#findHomography!/2","title":"Evision.findHomography!/2","type":"function"},{"doc":"Raising version of findHomography/3 .","ref":"Evision.html#findHomography!/3","title":"Evision.findHomography!/3","type":"function"},{"doc":"Raising version of findHomography/4 .","ref":"Evision.html#findHomography!/4","title":"Evision.findHomography!/4","type":"function"},{"doc":"Finds a perspective transformation between two planes. Positional Arguments srcPoints : Evision.Mat . Coordinates of the points in the original plane, a matrix of the type CV_32FC2 or vector\\&lt;Point2f&gt; . dstPoints : Evision.Mat . Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or a vector\\&lt;Point2f&gt; . Keyword Arguments method : int . Method used to compute a homography matrix. The following methods are possible: 0 - a regular method using all the points, i.e., the least squares method @ref RANSAC - RANSAC-based robust method @ref LMEDS - Least-Median robust method @ref RHO - PROSAC-based robust method ransacReprojThreshold : double . Maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC and RHO methods only). That is, if \\f[\\| \\texttt{dstPoints} _i - \\texttt{convertPointsHomogeneous} ( \\texttt{H} * \\texttt{srcPoints} _i) \\|_2 &gt; \\texttt{ransacReprojThreshold}\\f] then the point \\f$i\\f$ is considered as an outlier. If srcPoints and dstPoints are measured in pixels, it usually makes sense to set this parameter somewhere in the range of 1 to 10. maxIters : int . The maximum number of RANSAC iterations. confidence : double . Confidence level, between 0 and 1. Return mask : Evision.Mat . Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input mask values are ignored. The function finds and returns the perspective transformation \\f$H\\f$ between the source and the destination planes: \\f[s_i \\vecthree{x'_i}{y'_i}{1} \\sim H \\vecthree{x_i}{y_i}{1}\\f] so that the back-projection error \\f[\\sum _i \\left ( x'_i- \\frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \\right )^2+ \\left ( y'_i- \\frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \\right )^2\\f] is minimized. If the parameter method is set to the default value 0, the function uses all the point pairs to compute an initial homography estimate with a simple least-squares scheme. However, if not all of the point pairs ( \\f$srcPoints_i\\f$, \\f$dstPoints_i\\f$ ) fit the rigid perspective transformation (that is, there are some outliers), this initial estimate will be poor. In this case, you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the computed homography (which is the number of inliers for RANSAC or the least median re-projection error for LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and the mask of inliers/outliers. Regardless of the method, robust or not, the computed homography matrix is refined further (using inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the re-projection error even more. The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to distinguish inliers from outliers. The method LMeDS does not need any threshold but it works correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the noise is rather small, use the default method (method=0). The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is determined up to a scale. Thus, it is normalized so that \\f$h_{33}=1\\f$. Note that whenever an \\f$H\\f$ matrix cannot be estimated, an empty one will be returned. @sa getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective, perspectiveTransform Python prototype (for reference): findHomography(srcPoints, dstPoints[, method[, ransacReprojThreshold[, mask[, maxIters[, confidence]]]]]) -&gt; retval, mask","ref":"Evision.html#findHomography/2","title":"Evision.findHomography/2","type":"function"},{"doc":"Variant 1: Positional Arguments srcPoints : Evision.Mat dstPoints : Evision.Mat params : UsacParams Return mask : Evision.Mat . Has overloading in C++ Python prototype (for reference): findHomography(srcPoints, dstPoints, params[, mask]) -&gt; retval, mask Variant 2: Finds a perspective transformation between two planes. Positional Arguments srcPoints : Evision.Mat . Coordinates of the points in the original plane, a matrix of the type CV_32FC2 or vector\\&lt;Point2f&gt; . dstPoints : Evision.Mat . Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or a vector\\&lt;Point2f&gt; . Keyword Arguments method : int . Method used to compute a homography matrix. The following methods are possible: 0 - a regular method using all the points, i.e., the least squares method @ref RANSAC - RANSAC-based robust method @ref LMEDS - Least-Median robust method @ref RHO - PROSAC-based robust method ransacReprojThreshold : double . Maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC and RHO methods only). That is, if \\f[\\| \\texttt{dstPoints} _i - \\texttt{convertPointsHomogeneous} ( \\texttt{H} * \\texttt{srcPoints} _i) \\|_2 &gt; \\texttt{ransacReprojThreshold}\\f] then the point \\f$i\\f$ is considered as an outlier. If srcPoints and dstPoints are measured in pixels, it usually makes sense to set this parameter somewhere in the range of 1 to 10. maxIters : int . The maximum number of RANSAC iterations. confidence : double . Confidence level, between 0 and 1. Return mask : Evision.Mat . Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input mask values are ignored. The function finds and returns the perspective transformation \\f$H\\f$ between the source and the destination planes: \\f[s_i \\vecthree{x'_i}{y'_i}{1} \\sim H \\vecthree{x_i}{y_i}{1}\\f] so that the back-projection error \\f[\\sum _i \\left ( x'_i- \\frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \\right )^2+ \\left ( y'_i- \\frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \\right )^2\\f] is minimized. If the parameter method is set to the default value 0, the function uses all the point pairs to compute an initial homography estimate with a simple least-squares scheme. However, if not all of the point pairs ( \\f$srcPoints_i\\f$, \\f$dstPoints_i\\f$ ) fit the rigid perspective transformation (that is, there are some outliers), this initial estimate will be poor. In this case, you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the computed homography (which is the number of inliers for RANSAC or the least median re-projection error for LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and the mask of inliers/outliers. Regardless of the method, robust or not, the computed homography matrix is refined further (using inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the re-projection error even more. The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to distinguish inliers from outliers. The method LMeDS does not need any threshold but it works correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the noise is rather small, use the default method (method=0). The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is determined up to a scale. Thus, it is normalized so that \\f$h_{33}=1\\f$. Note that whenever an \\f$H\\f$ matrix cannot be estimated, an empty one will be returned. @sa getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective, perspectiveTransform Python prototype (for reference): findHomography(srcPoints, dstPoints[, method[, ransacReprojThreshold[, mask[, maxIters[, confidence]]]]]) -&gt; retval, mask","ref":"Evision.html#findHomography/3","title":"Evision.findHomography/3","type":"function"},{"doc":"Positional Arguments srcPoints : Evision.Mat dstPoints : Evision.Mat params : UsacParams Return mask : Evision.Mat . Has overloading in C++ Python prototype (for reference): findHomography(srcPoints, dstPoints, params[, mask]) -&gt; retval, mask","ref":"Evision.html#findHomography/4","title":"Evision.findHomography/4","type":"function"},{"doc":"Raising version of findNonZero/1 .","ref":"Evision.html#findNonZero!/1","title":"Evision.findNonZero!/1","type":"function"},{"doc":"Raising version of findNonZero/2 .","ref":"Evision.html#findNonZero!/2","title":"Evision.findNonZero!/2","type":"function"},{"doc":"Returns the list of locations of non-zero pixels Positional Arguments src : Evision.Mat . single-channel array Return idx : Evision.Mat . the output array, type of cv::Mat or std::vector&lt;Point&gt;, corresponding to non-zero indices in the input Given a binary matrix (likely returned from an operation such as threshold(), compare(), &gt;, ==, etc, return all of the non-zero indices as a cv::Mat or std::vector&lt;cv::Point&gt; (x,y) For example: cv::Mat binaryImage; // input, binary image cv::Mat locations; // output, locations of non-zero pixels cv::findNonZero(binaryImage, locations); // access pixel coordinates Point pnt = locations.at&lt;Point&gt;(i); or cv::Mat binaryImage; // input, binary image vector&lt;Point&gt; locations; // output, locations of non-zero pixels cv::findNonZero(binaryImage, locations); // access pixel coordinates Point pnt = locations[i]; Python prototype (for reference): findNonZero(src[, idx]) -&gt; idx","ref":"Evision.html#findNonZero/1","title":"Evision.findNonZero/1","type":"function"},{"doc":"Returns the list of locations of non-zero pixels Positional Arguments src : Evision.Mat . single-channel array Return idx : Evision.Mat . the output array, type of cv::Mat or std::vector&lt;Point&gt;, corresponding to non-zero indices in the input Given a binary matrix (likely returned from an operation such as threshold(), compare(), &gt;, ==, etc, return all of the non-zero indices as a cv::Mat or std::vector&lt;cv::Point&gt; (x,y) For example: cv::Mat binaryImage; // input, binary image cv::Mat locations; // output, locations of non-zero pixels cv::findNonZero(binaryImage, locations); // access pixel coordinates Point pnt = locations.at&lt;Point&gt;(i); or cv::Mat binaryImage; // input, binary image vector&lt;Point&gt; locations; // output, locations of non-zero pixels cv::findNonZero(binaryImage, locations); // access pixel coordinates Point pnt = locations[i]; Python prototype (for reference): findNonZero(src[, idx]) -&gt; idx","ref":"Evision.html#findNonZero/2","title":"Evision.findNonZero/2","type":"function"},{"doc":"Raising version of findTransformECC/3 .","ref":"Evision.html#findTransformECC!/3","title":"Evision.findTransformECC!/3","type":"function"},{"doc":"Raising version of findTransformECC/4 .","ref":"Evision.html#findTransformECC!/4","title":"Evision.findTransformECC!/4","type":"function"},{"doc":"Raising version of findTransformECC/7 .","ref":"Evision.html#findTransformECC!/7","title":"Evision.findTransformECC!/7","type":"function"},{"doc":"Positional Arguments templateImage : Evision.Mat inputImage : Evision.Mat Keyword Arguments motionType : int . criteria : TermCriteria . inputMask : Evision.Mat . Return warpMatrix : Evision.Mat Has overloading in C++ Python prototype (for reference): findTransformECC(templateImage, inputImage, warpMatrix[, motionType[, criteria[, inputMask]]]) -&gt; retval, warpMatrix","ref":"Evision.html#findTransformECC/3","title":"Evision.findTransformECC/3","type":"function"},{"doc":"Positional Arguments templateImage : Evision.Mat inputImage : Evision.Mat Keyword Arguments motionType : int . criteria : TermCriteria . inputMask : Evision.Mat . Return warpMatrix : Evision.Mat Has overloading in C++ Python prototype (for reference): findTransformECC(templateImage, inputImage, warpMatrix[, motionType[, criteria[, inputMask]]]) -&gt; retval, warpMatrix","ref":"Evision.html#findTransformECC/4","title":"Evision.findTransformECC/4","type":"function"},{"doc":"Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 . Positional Arguments templateImage : Evision.Mat . single-channel template image; CV_8U or CV_32F array. inputImage : Evision.Mat . single-channel input image which should be warped with the final warpMatrix in order to provide an image similar to templateImage, same type as templateImage. motionType : int . parameter, specifying the type of motion: MOTION_TRANSLATION sets a translational motion model; warpMatrix is \\f$2\\times 3\\f$ with the first \\f$2\\times 2\\f$ part being the unity matrix and the rest two parameters being estimated. MOTION_EUCLIDEAN sets a Euclidean (rigid) transformation as motion model; three parameters are estimated; warpMatrix is \\f$2\\times 3\\f$. MOTION_AFFINE sets an affine motion model (DEFAULT); six parameters are estimated; warpMatrix is \\f$2\\times 3\\f$. MOTION_HOMOGRAPHY sets a homography as a motion model; eight parameters are estimated;`warpMatrix` is \\f$3\\times 3\\f$. criteria : TermCriteria . parameter, specifying the termination criteria of the ECC algorithm; criteria.epsilon defines the threshold of the increment in the correlation coefficient between two iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion). Default values are shown in the declaration above. inputMask : Evision.Mat . An optional mask to indicate valid values of inputImage. gaussFiltSize : int . An optional value indicating size of gaussian blur filter; (DEFAULT: 5) Return warpMatrix : Evision.Mat . floating-point \\f$2\\times 3\\f$ or \\f$3\\times 3\\f$ mapping matrix (warp). The function estimates the optimum transformation (warpMatrix) with respect to ECC criterion (@cite EP08), that is \\f[\\texttt{warpMatrix} = \\arg\\max_{W} \\texttt{ECC}(\\texttt{templateImage}(x,y),\\texttt{inputImage}(x',y'))\\f] where \\f[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = W \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\f] (the equation holds with homogeneous coordinates for homography). It returns the final enhanced correlation coefficient, that is the correlation coefficient between the template image and the final warped input image. When a \\f$3\\times 3\\f$ matrix is given with motionType =0, 1 or 2, the third row is ignored. Unlike findHomography and estimateRigidTransform, the function findTransformECC implements an area-based alignment that builds on intensity similarities. In essence, the function updates the initial transformation that roughly aligns the images. If this information is missing, the identity warp (unity matrix) is used as an initialization. Note that if images undergo strong displacements/rotations, an initial transformation that roughly aligns the images is necessary (e.g., a simple euclidean/similarity transform that allows for the images showing the same image content approximately). Use inverse warping in the second image to take an image close to the first one, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV sample image_alignment.cpp that demonstrates the use of the function. Note that the function throws an exception if algorithm does not converges. @sa computeECC, estimateAffine2D, estimateAffinePartial2D, findHomography Python prototype (for reference): findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize) -&gt; retval, warpMatrix","ref":"Evision.html#findTransformECC/7","title":"Evision.findTransformECC/7","type":"function"},{"doc":"Raising version of fitEllipse/1 .","ref":"Evision.html#fitEllipse!/1","title":"Evision.fitEllipse!/1","type":"function"},{"doc":"Fits an ellipse around a set of 2D points. Positional Arguments points : Evision.Mat . Input 2D point set, stored in std::vector\\&lt;&gt; or Mat The function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by @cite Fitzgibbon95 is used. Developer should keep in mind that it is possible that the returned ellipse/rotatedRect data contains negative indices, due to the data points being close to the border of the containing Mat element. Python prototype (for reference): fitEllipse(points) -&gt; retval","ref":"Evision.html#fitEllipse/1","title":"Evision.fitEllipse/1","type":"function"},{"doc":"Raising version of fitEllipseAMS/1 .","ref":"Evision.html#fitEllipseAMS!/1","title":"Evision.fitEllipseAMS!/1","type":"function"},{"doc":"Fits an ellipse around a set of 2D points. Positional Arguments points : Evision.Mat . Input 2D point set, stored in std::vector\\&lt;&gt; or Mat The function calculates the ellipse that fits a set of 2D points. It returns the rotated rectangle in which the ellipse is inscribed. The Approximate Mean Square (AMS) proposed by @cite Taubin1991 is used. For an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$, which is a set of six free coefficients \\f$ A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} \\f$. However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$, the position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines, quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits. If the fit is found to be a parabolic or hyperbolic function then the standard #fitEllipse method is used. The AMS method restricts the fit to parabolic, hyperbolic and elliptical curves by imposing the condition that \\f$ A^T ( D_x^T D_x + D_y^T D_y) A = 1 \\f$ where the matrices \\f$ Dx \\f$ and \\f$ Dy \\f$ are the partial derivatives of the design matrix \\f$ D \\f$ with respect to x and y. The matrices are formed row by row applying the following to each of the points in the set: \\f{align }{ D(i,:)&amp;=\\left{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\\right} &amp; D_x(i,:)&amp;=\\left{2 x_i,y_i,0,1,0,0\\right} &amp; D_y(i,:)&amp;=\\left{0,x_i,2 y_i,0,1,0\\right} \\f} The AMS method minimizes the cost function \\f{equation }{ \\epsilon ^2=\\frac{ A^T D^T D A }{ A^T (D_x^T D_x + D_y^T D_y) A^T } \\f} The minimum cost is found by solving the generalized eigenvalue problem. \\f{equation*}{ D^T D A = \\lambda \\left( D_x^T D_x + D_y^T D_y\\right) A \\f} Python prototype (for reference): fitEllipseAMS(points) -&gt; retval","ref":"Evision.html#fitEllipseAMS/1","title":"Evision.fitEllipseAMS/1","type":"function"},{"doc":"Raising version of fitEllipseDirect/1 .","ref":"Evision.html#fitEllipseDirect!/1","title":"Evision.fitEllipseDirect!/1","type":"function"},{"doc":"Fits an ellipse around a set of 2D points. Positional Arguments points : Evision.Mat . Input 2D point set, stored in std::vector\\&lt;&gt; or Mat The function calculates the ellipse that fits a set of 2D points. It returns the rotated rectangle in which the ellipse is inscribed. The Direct least square (Direct) method by @cite Fitzgibbon1999 is used. For an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$, which is a set of six free coefficients \\f$ A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} \\f$. However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$, the position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines, quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits. The Direct method confines the fit to ellipses by ensuring that \\f$ 4 A_{xx} A_{yy}- A_{xy}^2 &gt; 0 \\f$. The condition imposed is that \\f$ 4 A_{xx} A_{yy}- A_{xy}^2=1 \\f$ which satisfies the inequality and as the coefficients can be arbitrarily scaled is not overly restrictive. \\f{equation }{ \\epsilon ^2= A^T D^T D A \\quad \\text{with} \\quad A^T C A =1 \\quad \\text{and} \\quad C=\\left(\\begin{matrix} 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\end{matrix} \\right) \\f} The minimum cost is found by solving the generalized eigenvalue problem. \\f{equation }{ D^T D A = \\lambda \\left( C\\right) A \\f} The system produces only one positive eigenvalue \\f$ \\lambda\\f$ which is chosen as the solution with its eigenvector \\f$\\mathbf{u}\\f$. These are used to find the coefficients \\f{equation*}{ A = \\sqrt{\\frac{1}{\\mathbf{u}^T C \\mathbf{u}}} \\mathbf{u} \\f} The scaling factor guarantees that \\f$A^T C A =1\\f$. Python prototype (for reference): fitEllipseDirect(points) -&gt; retval","ref":"Evision.html#fitEllipseDirect/1","title":"Evision.fitEllipseDirect/1","type":"function"},{"doc":"Raising version of fitLine/5 .","ref":"Evision.html#fitLine!/5","title":"Evision.fitLine!/5","type":"function"},{"doc":"Raising version of fitLine/6 .","ref":"Evision.html#fitLine!/6","title":"Evision.fitLine!/6","type":"function"},{"doc":"Fits a line to a 2D or 3D point set. Positional Arguments points : Evision.Mat . Input vector of 2D or 3D points, stored in std::vector\\&lt;&gt; or Mat. distType : int . Distance used by the M-estimator, see #DistanceTypes param : double . Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value is chosen. reps : double . Sufficient accuracy for the radius (distance between the coordinate origin and the line). aeps : double . Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps. Return line : Evision.Mat . Output line parameters. In case of 2D fitting, it should be a vector of 4 elements (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line and (x0, y0, z0) is a point on the line. The function fitLine fits a line to a 2D or 3D point set by minimizing \\f$\\sum_i \\rho(r_i)\\f$ where \\f$r_i\\f$ is a distance between the \\f$i^{th}\\f$ point, the line and \\f$\\rho(r)\\f$ is a distance function, one of the following: DIST_L2 \\f[\\rho (r) = r^2/2 \\quad \\text{(the simplest and the fastest least-squares method)}\\f] DIST_L1 \\f[\\rho (r) = r\\f] DIST_L12 \\f[\\rho (r) = 2 \\cdot ( \\sqrt{1 + \\frac{r^2}{2}} - 1)\\f] DIST_FAIR \\f[\\rho \\left (r \\right ) = C^2 \\cdot \\left ( \\frac{r}{C} - \\log{\\left(1 + \\frac{r}{C}\\right)} \\right ) \\quad \\text{where} \\quad C=1.3998\\f] DIST_WELSCH \\f[\\rho \\left (r \\right ) = \\frac{C^2}{2} \\cdot \\left ( 1 - \\exp{\\left(-\\left(\\frac{r}{C}\\right)^2\\right)} \\right ) \\quad \\text{where} \\quad C=2.9846\\f] DIST_HUBER \\f[\\rho (r) = \\fork{r^2/2}{if (r &lt; C)}{C \\cdot (r-C/2)}{otherwise} \\quad \\text{where} \\quad C=1.345\\f] The algorithm is based on the M-estimator ( http://en.wikipedia.org/wiki/M-estimator ) technique that iteratively fits the line using the weighted least-squares algorithm. After each iteration the weights \\f$w_i\\f$ are adjusted to be inversely proportional to \\f$\\rho(r_i)\\f$ . Python prototype (for reference): fitLine(points, distType, param, reps, aeps[, line]) -&gt; line","ref":"Evision.html#fitLine/5","title":"Evision.fitLine/5","type":"function"},{"doc":"Fits a line to a 2D or 3D point set. Positional Arguments points : Evision.Mat . Input vector of 2D or 3D points, stored in std::vector\\&lt;&gt; or Mat. distType : int . Distance used by the M-estimator, see #DistanceTypes param : double . Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value is chosen. reps : double . Sufficient accuracy for the radius (distance between the coordinate origin and the line). aeps : double . Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps. Return line : Evision.Mat . Output line parameters. In case of 2D fitting, it should be a vector of 4 elements (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line and (x0, y0, z0) is a point on the line. The function fitLine fits a line to a 2D or 3D point set by minimizing \\f$\\sum_i \\rho(r_i)\\f$ where \\f$r_i\\f$ is a distance between the \\f$i^{th}\\f$ point, the line and \\f$\\rho(r)\\f$ is a distance function, one of the following: DIST_L2 \\f[\\rho (r) = r^2/2 \\quad \\text{(the simplest and the fastest least-squares method)}\\f] DIST_L1 \\f[\\rho (r) = r\\f] DIST_L12 \\f[\\rho (r) = 2 \\cdot ( \\sqrt{1 + \\frac{r^2}{2}} - 1)\\f] DIST_FAIR \\f[\\rho \\left (r \\right ) = C^2 \\cdot \\left ( \\frac{r}{C} - \\log{\\left(1 + \\frac{r}{C}\\right)} \\right ) \\quad \\text{where} \\quad C=1.3998\\f] DIST_WELSCH \\f[\\rho \\left (r \\right ) = \\frac{C^2}{2} \\cdot \\left ( 1 - \\exp{\\left(-\\left(\\frac{r}{C}\\right)^2\\right)} \\right ) \\quad \\text{where} \\quad C=2.9846\\f] DIST_HUBER \\f[\\rho (r) = \\fork{r^2/2}{if (r &lt; C)}{C \\cdot (r-C/2)}{otherwise} \\quad \\text{where} \\quad C=1.345\\f] The algorithm is based on the M-estimator ( http://en.wikipedia.org/wiki/M-estimator ) technique that iteratively fits the line using the weighted least-squares algorithm. After each iteration the weights \\f$w_i\\f$ are adjusted to be inversely proportional to \\f$\\rho(r_i)\\f$ . Python prototype (for reference): fitLine(points, distType, param, reps, aeps[, line]) -&gt; line","ref":"Evision.html#fitLine/6","title":"Evision.fitLine/6","type":"function"},{"doc":"Raising version of flip/2 .","ref":"Evision.html#flip!/2","title":"Evision.flip!/2","type":"function"},{"doc":"Raising version of flip/3 .","ref":"Evision.html#flip!/3","title":"Evision.flip!/3","type":"function"},{"doc":"Flips a 2D array around vertical, horizontal, or both axes. Positional Arguments src : Evision.Mat . input array. flipCode : int . a flag to specify how to flip the array; 0 means flipping around the x-axis and positive value (for example, 1) means flipping around y-axis. Negative value (for example, -1) means flipping around both axes. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::flip flips the array in one of three different ways (row and column indices are 0-based): \\f[\\texttt{dst} _{ij} = \\left\\{ \\begin{array}{l l} \\texttt{src} _{\\texttt{src.rows}-i-1,j} &amp; if\\; \\texttt{flipCode} = 0 \\\\ \\texttt{src} _{i, \\texttt{src.cols} -j-1} &amp; if\\; \\texttt{flipCode} &gt; 0 \\\\ \\texttt{src} _{ \\texttt{src.rows} -i-1, \\texttt{src.cols} -j-1} &amp; if\\; \\texttt{flipCode} &lt; 0 \\\\ \\end{array} \\right.\\f] The example scenarios of using the function are the following: Vertical flipping of the image (flipCode == 0) to switch between top-left and bottom-left image origin. This is a typical operation in video processing on Microsoft Windows* OS. Horizontal flipping of the image with the subsequent horizontal shift and absolute difference calculation to check for a vertical-axis symmetry (flipCode &gt; 0). Simultaneous horizontal and vertical flipping of the image with the subsequent shift and absolute difference calculation to check for a central symmetry (flipCode \\&lt; 0). Reversing the order of point arrays (flipCode &gt; 0 or flipCode == 0). @sa transpose , repeat , completeSymm Python prototype (for reference): flip(src, flipCode[, dst]) -&gt; dst","ref":"Evision.html#flip/2","title":"Evision.flip/2","type":"function"},{"doc":"Flips a 2D array around vertical, horizontal, or both axes. Positional Arguments src : Evision.Mat . input array. flipCode : int . a flag to specify how to flip the array; 0 means flipping around the x-axis and positive value (for example, 1) means flipping around y-axis. Negative value (for example, -1) means flipping around both axes. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::flip flips the array in one of three different ways (row and column indices are 0-based): \\f[\\texttt{dst} _{ij} = \\left\\{ \\begin{array}{l l} \\texttt{src} _{\\texttt{src.rows}-i-1,j} &amp; if\\; \\texttt{flipCode} = 0 \\\\ \\texttt{src} _{i, \\texttt{src.cols} -j-1} &amp; if\\; \\texttt{flipCode} &gt; 0 \\\\ \\texttt{src} _{ \\texttt{src.rows} -i-1, \\texttt{src.cols} -j-1} &amp; if\\; \\texttt{flipCode} &lt; 0 \\\\ \\end{array} \\right.\\f] The example scenarios of using the function are the following: Vertical flipping of the image (flipCode == 0) to switch between top-left and bottom-left image origin. This is a typical operation in video processing on Microsoft Windows* OS. Horizontal flipping of the image with the subsequent horizontal shift and absolute difference calculation to check for a vertical-axis symmetry (flipCode &gt; 0). Simultaneous horizontal and vertical flipping of the image with the subsequent shift and absolute difference calculation to check for a central symmetry (flipCode \\&lt; 0). Reversing the order of point arrays (flipCode &gt; 0 or flipCode == 0). @sa transpose , repeat , completeSymm Python prototype (for reference): flip(src, flipCode[, dst]) -&gt; dst","ref":"Evision.html#flip/3","title":"Evision.flip/3","type":"function"},{"doc":"Raising version of floodFill/4 .","ref":"Evision.html#floodFill!/4","title":"Evision.floodFill!/4","type":"function"},{"doc":"Raising version of floodFill/5 .","ref":"Evision.html#floodFill!/5","title":"Evision.floodFill!/5","type":"function"},{"doc":"Fills a connected component with the given color. Positional Arguments seedPoint : Point . Starting point. newVal : Scalar . New value of the repainted domain pixels. Keyword Arguments loDiff : Scalar . Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. upDiff : Scalar . Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. flags : int . Operation flags. The first 8 bits contain a connectivity value. The default value of 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 \\&lt;\\&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags. Return image : Evision.Mat . Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See the details below. mask : Evision.Mat . Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. If an empty Mat is passed it will be created automatically. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap. rect : Rect* . Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain. The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at \\f$(x,y)\\f$ is considered to belong to the repainted domain if: in case of a grayscale image and floating range \\f[\\texttt{src} (x',y')- \\texttt{loDiff} \\leq \\texttt{src} (x,y) \\leq \\texttt{src} (x',y')+ \\texttt{upDiff}\\f] in case of a grayscale image and fixed range \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)- \\texttt{loDiff} \\leq \\texttt{src} (x,y) \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)+ \\texttt{upDiff}\\f] in case of a color image and floating range \\f[\\texttt{src} (x',y')_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} (x',y')_r+ \\texttt{upDiff} _r,\\f] \\f[\\texttt{src} (x',y')_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} (x',y')_g+ \\texttt{upDiff} _g\\f] and \\f[\\texttt{src} (x',y')_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} (x',y')_b+ \\texttt{upDiff} _b\\f] in case of a color image and fixed range \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r+ \\texttt{upDiff} _r,\\f] \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g+ \\texttt{upDiff} _g\\f] and \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b+ \\texttt{upDiff} _b\\f] where \\f$src(x',y')\\f$ is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to: Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range. Color/brightness of the seed point in case of a fixed range. Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on. Note : Since the mask is larger than the filled image, a pixel \\f$(x, y)\\f$ in image corresponds to the pixel \\f$(x+1, y+1)\\f$ in the mask . @sa findContours Python prototype (for reference): floodFill(image, mask, seedPoint, newVal[, loDiff[, upDiff[, flags]]]) -&gt; retval, image, mask, rect","ref":"Evision.html#floodFill/4","title":"Evision.floodFill/4","type":"function"},{"doc":"Fills a connected component with the given color. Positional Arguments seedPoint : Point . Starting point. newVal : Scalar . New value of the repainted domain pixels. Keyword Arguments loDiff : Scalar . Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. upDiff : Scalar . Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. flags : int . Operation flags. The first 8 bits contain a connectivity value. The default value of 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 \\&lt;\\&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags. Return image : Evision.Mat . Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See the details below. mask : Evision.Mat . Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. If an empty Mat is passed it will be created automatically. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap. rect : Rect* . Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain. The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at \\f$(x,y)\\f$ is considered to belong to the repainted domain if: in case of a grayscale image and floating range \\f[\\texttt{src} (x',y')- \\texttt{loDiff} \\leq \\texttt{src} (x,y) \\leq \\texttt{src} (x',y')+ \\texttt{upDiff}\\f] in case of a grayscale image and fixed range \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)- \\texttt{loDiff} \\leq \\texttt{src} (x,y) \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)+ \\texttt{upDiff}\\f] in case of a color image and floating range \\f[\\texttt{src} (x',y')_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} (x',y')_r+ \\texttt{upDiff} _r,\\f] \\f[\\texttt{src} (x',y')_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} (x',y')_g+ \\texttt{upDiff} _g\\f] and \\f[\\texttt{src} (x',y')_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} (x',y')_b+ \\texttt{upDiff} _b\\f] in case of a color image and fixed range \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r+ \\texttt{upDiff} _r,\\f] \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g+ \\texttt{upDiff} _g\\f] and \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b+ \\texttt{upDiff} _b\\f] where \\f$src(x',y')\\f$ is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to: Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range. Color/brightness of the seed point in case of a fixed range. Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on. Note : Since the mask is larger than the filled image, a pixel \\f$(x, y)\\f$ in image corresponds to the pixel \\f$(x+1, y+1)\\f$ in the mask . @sa findContours Python prototype (for reference): floodFill(image, mask, seedPoint, newVal[, loDiff[, upDiff[, flags]]]) -&gt; retval, image, mask, rect","ref":"Evision.html#floodFill/5","title":"Evision.floodFill/5","type":"function"},{"doc":"Raising version of gaussianBlur/3 .","ref":"Evision.html#gaussianBlur!/3","title":"Evision.gaussianBlur!/3","type":"function"},{"doc":"Raising version of gaussianBlur/4 .","ref":"Evision.html#gaussianBlur!/4","title":"Evision.gaussianBlur!/4","type":"function"},{"doc":"Blurs an image using a Gaussian filter. Positional Arguments src : Evision.Mat . input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. ksize : Size . Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma. sigmaX : double . Gaussian kernel standard deviation in X direction. Keyword Arguments sigmaY : double . Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see #getGaussianKernel for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src. The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported. @sa sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur Python prototype (for reference): GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]]) -&gt; dst","ref":"Evision.html#gaussianBlur/3","title":"Evision.gaussianBlur/3","type":"function"},{"doc":"Blurs an image using a Gaussian filter. Positional Arguments src : Evision.Mat . input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. ksize : Size . Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma. sigmaX : double . Gaussian kernel standard deviation in X direction. Keyword Arguments sigmaY : double . Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see #getGaussianKernel for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src. The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported. @sa sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur Python prototype (for reference): GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]]) -&gt; dst","ref":"Evision.html#gaussianBlur/4","title":"Evision.gaussianBlur/4","type":"function"},{"doc":"Raising version of gemm/5 .","ref":"Evision.html#gemm!/5","title":"Evision.gemm!/5","type":"function"},{"doc":"Raising version of gemm/6 .","ref":"Evision.html#gemm!/6","title":"Evision.gemm!/6","type":"function"},{"doc":"Performs generalized matrix multiplication. Positional Arguments src1 : Evision.Mat . first multiplied input matrix that could be real(CV_32FC1, CV_64FC1) or complex(CV_32FC2, CV_64FC2). src2 : Evision.Mat . second multiplied input matrix of the same type as src1. alpha : double . weight of the matrix product. src3 : Evision.Mat . third optional delta matrix added to the matrix product; it should have the same type as src1 and src2. beta : double . weight of src3. Keyword Arguments flags : int . operation flags (cv::GemmFlags) Return dst : Evision.Mat . output matrix; it has the proper size and the same type as input matrices. The function cv::gemm performs generalized matrix multiplication similar to the gemm functions in BLAS level 3. For example, gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) corresponds to \\f[\\texttt{dst} = \\texttt{alpha} \\cdot \\texttt{src1} ^T \\cdot \\texttt{src2} + \\texttt{beta} \\cdot \\texttt{src3} ^T\\f] In case of complex (two-channel) data, performed a complex matrix multiplication. The function can be replaced with a matrix expression. For example, the above call can be replaced with: dst = alpha*src1.t()*src2 + beta*src3.t(); @sa mulTransposed , transform Python prototype (for reference): gemm(src1, src2, alpha, src3, beta[, dst[, flags]]) -&gt; dst","ref":"Evision.html#gemm/5","title":"Evision.gemm/5","type":"function"},{"doc":"Performs generalized matrix multiplication. Positional Arguments src1 : Evision.Mat . first multiplied input matrix that could be real(CV_32FC1, CV_64FC1) or complex(CV_32FC2, CV_64FC2). src2 : Evision.Mat . second multiplied input matrix of the same type as src1. alpha : double . weight of the matrix product. src3 : Evision.Mat . third optional delta matrix added to the matrix product; it should have the same type as src1 and src2. beta : double . weight of src3. Keyword Arguments flags : int . operation flags (cv::GemmFlags) Return dst : Evision.Mat . output matrix; it has the proper size and the same type as input matrices. The function cv::gemm performs generalized matrix multiplication similar to the gemm functions in BLAS level 3. For example, gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) corresponds to \\f[\\texttt{dst} = \\texttt{alpha} \\cdot \\texttt{src1} ^T \\cdot \\texttt{src2} + \\texttt{beta} \\cdot \\texttt{src3} ^T\\f] In case of complex (two-channel) data, performed a complex matrix multiplication. The function can be replaced with a matrix expression. For example, the above call can be replaced with: dst = alpha*src1.t()*src2 + beta*src3.t(); @sa mulTransposed , transform Python prototype (for reference): gemm(src1, src2, alpha, src3, beta[, dst[, flags]]) -&gt; dst","ref":"Evision.html#gemm/6","title":"Evision.gemm/6","type":"function"},{"doc":"Raising version of getAffineTransform/2 .","ref":"Evision.html#getAffineTransform!/2","title":"Evision.getAffineTransform!/2","type":"function"},{"doc":"Positional Arguments src : Evision.Mat dst : Evision.Mat Has overloading in C++ Python prototype (for reference): getAffineTransform(src, dst) -&gt; retval","ref":"Evision.html#getAffineTransform/2","title":"Evision.getAffineTransform/2","type":"function"},{"doc":"Raising version of getBuildInformation/0 .","ref":"Evision.html#getBuildInformation!/0","title":"Evision.getBuildInformation!/0","type":"function"},{"doc":"Returns full configuration time cmake output. Returned value is raw cmake output including version control system revision, compiler version, compiler flags, enabled modules and third party libraries, etc. Output format depends on target architecture. Python prototype (for reference): getBuildInformation() -&gt; retval","ref":"Evision.html#getBuildInformation/0","title":"Evision.getBuildInformation/0","type":"function"},{"doc":"Raising version of getCPUFeaturesLine/0 .","ref":"Evision.html#getCPUFeaturesLine!/0","title":"Evision.getCPUFeaturesLine!/0","type":"function"},{"doc":"Returns list of CPU features enabled during compilation. Returned value is a string containing space separated list of CPU features with following markers: no markers - baseline features prefix * - features enabled in dispatcher suffix ? - features enabled but not available in HW Example: SSE SSE2 SSE3 *SSE4.1 *SSE4.2 *FP16 *AVX *AVX2 *AVX512-SKX? Python prototype (for reference): getCPUFeaturesLine() -&gt; retval","ref":"Evision.html#getCPUFeaturesLine/0","title":"Evision.getCPUFeaturesLine/0","type":"function"},{"doc":"Raising version of getCPUTickCount/0 .","ref":"Evision.html#getCPUTickCount!/0","title":"Evision.getCPUTickCount!/0","type":"function"},{"doc":"Returns the number of CPU ticks. The function returns the current number of CPU ticks on some architectures (such as x86, x64, PowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for very accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU systems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU with its own counter. So, theoretically (and practically) the subsequent calls to the function do not necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU frequency depending on the load, the number of CPU clocks spent in some code cannot be directly converted to time units. Therefore, getTickCount is generally a preferable solution for measuring execution time. Python prototype (for reference): getCPUTickCount() -&gt; retval","ref":"Evision.html#getCPUTickCount/0","title":"Evision.getCPUTickCount/0","type":"function"},{"doc":"Raising version of getDefaultNewCameraMatrix/1 .","ref":"Evision.html#getDefaultNewCameraMatrix!/1","title":"Evision.getDefaultNewCameraMatrix!/1","type":"function"},{"doc":"Raising version of getDefaultNewCameraMatrix/2 .","ref":"Evision.html#getDefaultNewCameraMatrix!/2","title":"Evision.getDefaultNewCameraMatrix!/2","type":"function"},{"doc":"Returns the default new camera matrix. Positional Arguments cameraMatrix : Evision.Mat . Input camera matrix. Keyword Arguments imgsize : Size . Camera view image size in pixels. centerPrincipalPoint : bool . Location of the principal point in the new camera matrix. The parameter indicates whether this location should be at the image center or not. The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true). In the latter case, the new camera matrix will be: \\f[\\begin{bmatrix} f_x &amp;&amp; 0 &amp;&amp; ( \\texttt{imgSize.width} -1)*0.5 \\\\ 0 &amp;&amp; f_y &amp;&amp; ( \\texttt{imgSize.height} -1)*0.5 \\\\ 0 &amp;&amp; 0 &amp;&amp; 1 \\end{bmatrix} ,\\f] where \\f$f_x\\f$ and \\f$f_y\\f$ are \\f$(0,0)\\f$ and \\f$(1,1)\\f$ elements of cameraMatrix, respectively. By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not move the principal point. However, when you work with stereo, it is important to move the principal points in both views to the same y-coordinate (which is required by most of stereo correspondence algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for each view where the principal points are located at the center. Python prototype (for reference): getDefaultNewCameraMatrix(cameraMatrix[, imgsize[, centerPrincipalPoint]]) -&gt; retval","ref":"Evision.html#getDefaultNewCameraMatrix/1","title":"Evision.getDefaultNewCameraMatrix/1","type":"function"},{"doc":"Returns the default new camera matrix. Positional Arguments cameraMatrix : Evision.Mat . Input camera matrix. Keyword Arguments imgsize : Size . Camera view image size in pixels. centerPrincipalPoint : bool . Location of the principal point in the new camera matrix. The parameter indicates whether this location should be at the image center or not. The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true). In the latter case, the new camera matrix will be: \\f[\\begin{bmatrix} f_x &amp;&amp; 0 &amp;&amp; ( \\texttt{imgSize.width} -1)*0.5 \\\\ 0 &amp;&amp; f_y &amp;&amp; ( \\texttt{imgSize.height} -1)*0.5 \\\\ 0 &amp;&amp; 0 &amp;&amp; 1 \\end{bmatrix} ,\\f] where \\f$f_x\\f$ and \\f$f_y\\f$ are \\f$(0,0)\\f$ and \\f$(1,1)\\f$ elements of cameraMatrix, respectively. By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not move the principal point. However, when you work with stereo, it is important to move the principal points in both views to the same y-coordinate (which is required by most of stereo correspondence algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for each view where the principal points are located at the center. Python prototype (for reference): getDefaultNewCameraMatrix(cameraMatrix[, imgsize[, centerPrincipalPoint]]) -&gt; retval","ref":"Evision.html#getDefaultNewCameraMatrix/2","title":"Evision.getDefaultNewCameraMatrix/2","type":"function"},{"doc":"Raising version of getDerivKernels/3 .","ref":"Evision.html#getDerivKernels!/3","title":"Evision.getDerivKernels!/3","type":"function"},{"doc":"Raising version of getDerivKernels/4 .","ref":"Evision.html#getDerivKernels!/4","title":"Evision.getDerivKernels!/4","type":"function"},{"doc":"Returns filter coefficients for computing spatial image derivatives. Positional Arguments dx : int . Derivative order in respect of x. dy : int . Derivative order in respect of y. ksize : int . Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7. Keyword Arguments normalize : bool . Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator \\f$=2^{ksize*2-dx-dy-2}\\f$. If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set normalize=false . ktype : int . Type of filter coefficients. It can be CV_32f or CV_64F . Return kx : Evision.Mat . Output matrix of row filter coefficients. It has the type ktype . ky : Evision.Mat . Output matrix of column filter coefficients. It has the type ktype . The function computes and returns the filter coefficients for spatial image derivatives. When ksize=FILTER_SCHARR , the Scharr \\f$3 \\times 3\\f$ kernels are generated (see #Scharr). Otherwise, Sobel kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to Python prototype (for reference): getDerivKernels(dx, dy, ksize[, kx[, ky[, normalize[, ktype]]]]) -&gt; kx, ky","ref":"Evision.html#getDerivKernels/3","title":"Evision.getDerivKernels/3","type":"function"},{"doc":"Returns filter coefficients for computing spatial image derivatives. Positional Arguments dx : int . Derivative order in respect of x. dy : int . Derivative order in respect of y. ksize : int . Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7. Keyword Arguments normalize : bool . Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator \\f$=2^{ksize*2-dx-dy-2}\\f$. If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set normalize=false . ktype : int . Type of filter coefficients. It can be CV_32f or CV_64F . Return kx : Evision.Mat . Output matrix of row filter coefficients. It has the type ktype . ky : Evision.Mat . Output matrix of column filter coefficients. It has the type ktype . The function computes and returns the filter coefficients for spatial image derivatives. When ksize=FILTER_SCHARR , the Scharr \\f$3 \\times 3\\f$ kernels are generated (see #Scharr). Otherwise, Sobel kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to Python prototype (for reference): getDerivKernels(dx, dy, ksize[, kx[, ky[, normalize[, ktype]]]]) -&gt; kx, ky","ref":"Evision.html#getDerivKernels/4","title":"Evision.getDerivKernels/4","type":"function"},{"doc":"Raising version of getFontScaleFromHeight/2 .","ref":"Evision.html#getFontScaleFromHeight!/2","title":"Evision.getFontScaleFromHeight!/2","type":"function"},{"doc":"Raising version of getFontScaleFromHeight/3 .","ref":"Evision.html#getFontScaleFromHeight!/3","title":"Evision.getFontScaleFromHeight!/3","type":"function"},{"doc":"Calculates the font-specific size to use to achieve a given height in pixels. Positional Arguments fontFace : int . Font to use, see cv::HersheyFonts. pixelHeight : int . Pixel height to compute the fontScale for Keyword Arguments thickness : int . Thickness of lines used to render the text.See putText for details. @return The fontSize to use for cv::putText @see cv::putText Python prototype (for reference): getFontScaleFromHeight(fontFace, pixelHeight[, thickness]) -&gt; retval","ref":"Evision.html#getFontScaleFromHeight/2","title":"Evision.getFontScaleFromHeight/2","type":"function"},{"doc":"Calculates the font-specific size to use to achieve a given height in pixels. Positional Arguments fontFace : int . Font to use, see cv::HersheyFonts. pixelHeight : int . Pixel height to compute the fontScale for Keyword Arguments thickness : int . Thickness of lines used to render the text.See putText for details. @return The fontSize to use for cv::putText @see cv::putText Python prototype (for reference): getFontScaleFromHeight(fontFace, pixelHeight[, thickness]) -&gt; retval","ref":"Evision.html#getFontScaleFromHeight/3","title":"Evision.getFontScaleFromHeight/3","type":"function"},{"doc":"Raising version of getGaborKernel/5 .","ref":"Evision.html#getGaborKernel!/5","title":"Evision.getGaborKernel!/5","type":"function"},{"doc":"Raising version of getGaborKernel/6 .","ref":"Evision.html#getGaborKernel!/6","title":"Evision.getGaborKernel!/6","type":"function"},{"doc":"Returns Gabor filter coefficients. Positional Arguments ksize : Size . Size of the filter returned. sigma : double . Standard deviation of the gaussian envelope. theta : double . Orientation of the normal to the parallel stripes of a Gabor function. lambd : double . Wavelength of the sinusoidal factor. gamma : double . Spatial aspect ratio. Keyword Arguments psi : double . Phase offset. ktype : int . Type of filter coefficients. It can be CV_32F or CV_64F . For more details about gabor filter equations and parameters, see: Gabor Filter . Python prototype (for reference): getGaborKernel(ksize, sigma, theta, lambd, gamma[, psi[, ktype]]) -&gt; retval","ref":"Evision.html#getGaborKernel/5","title":"Evision.getGaborKernel/5","type":"function"},{"doc":"Returns Gabor filter coefficients. Positional Arguments ksize : Size . Size of the filter returned. sigma : double . Standard deviation of the gaussian envelope. theta : double . Orientation of the normal to the parallel stripes of a Gabor function. lambd : double . Wavelength of the sinusoidal factor. gamma : double . Spatial aspect ratio. Keyword Arguments psi : double . Phase offset. ktype : int . Type of filter coefficients. It can be CV_32F or CV_64F . For more details about gabor filter equations and parameters, see: Gabor Filter . Python prototype (for reference): getGaborKernel(ksize, sigma, theta, lambd, gamma[, psi[, ktype]]) -&gt; retval","ref":"Evision.html#getGaborKernel/6","title":"Evision.getGaborKernel/6","type":"function"},{"doc":"Raising version of getGaussianKernel/2 .","ref":"Evision.html#getGaussianKernel!/2","title":"Evision.getGaussianKernel!/2","type":"function"},{"doc":"Raising version of getGaussianKernel/3 .","ref":"Evision.html#getGaussianKernel!/3","title":"Evision.getGaussianKernel!/3","type":"function"},{"doc":"Returns Gaussian filter coefficients. Positional Arguments ksize : int . Aperture size. It should be odd ( \\f$\\texttt{ksize} \\mod 2 = 1\\f$ ) and positive. sigma : double . Gaussian standard deviation. If it is non-positive, it is computed from ksize as sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8 . Keyword Arguments ktype : int . Type of filter coefficients. It can be CV_32F or CV_64F . The function computes and returns the \\f$\\texttt{ksize} \\times 1\\f$ matrix of Gaussian filter coefficients: \\f[G_i= \\alpha *e^{-(i-( \\texttt{ksize} -1)/2)^2/(2* \\texttt{sigma}^2)},\\f] where \\f$i=0..\\texttt{ksize}-1\\f$ and \\f$\\alpha\\f$ is the scale factor chosen so that \\f$\\sum_i G_i=1\\f$. Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-level GaussianBlur. @sa sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur Python prototype (for reference): getGaussianKernel(ksize, sigma[, ktype]) -&gt; retval","ref":"Evision.html#getGaussianKernel/2","title":"Evision.getGaussianKernel/2","type":"function"},{"doc":"Returns Gaussian filter coefficients. Positional Arguments ksize : int . Aperture size. It should be odd ( \\f$\\texttt{ksize} \\mod 2 = 1\\f$ ) and positive. sigma : double . Gaussian standard deviation. If it is non-positive, it is computed from ksize as sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8 . Keyword Arguments ktype : int . Type of filter coefficients. It can be CV_32F or CV_64F . The function computes and returns the \\f$\\texttt{ksize} \\times 1\\f$ matrix of Gaussian filter coefficients: \\f[G_i= \\alpha *e^{-(i-( \\texttt{ksize} -1)/2)^2/(2* \\texttt{sigma}^2)},\\f] where \\f$i=0..\\texttt{ksize}-1\\f$ and \\f$\\alpha\\f$ is the scale factor chosen so that \\f$\\sum_i G_i=1\\f$. Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-level GaussianBlur. @sa sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur Python prototype (for reference): getGaussianKernel(ksize, sigma[, ktype]) -&gt; retval","ref":"Evision.html#getGaussianKernel/3","title":"Evision.getGaussianKernel/3","type":"function"},{"doc":"Raising version of getHardwareFeatureName/1 .","ref":"Evision.html#getHardwareFeatureName!/1","title":"Evision.getHardwareFeatureName!/1","type":"function"},{"doc":"Returns feature name by ID Positional Arguments feature : int Returns empty string if feature is not defined Python prototype (for reference): getHardwareFeatureName(feature) -&gt; retval","ref":"Evision.html#getHardwareFeatureName/1","title":"Evision.getHardwareFeatureName/1","type":"function"},{"doc":"Raising version of getLogLevel/0 .","ref":"Evision.html#getLogLevel!/0","title":"Evision.getLogLevel!/0","type":"function"},{"doc":"Python prototype (for reference): getLogLevel() -&gt; retval","ref":"Evision.html#getLogLevel/0","title":"Evision.getLogLevel/0","type":"function"},{"doc":"Raising version of getNumberOfCPUs/0 .","ref":"Evision.html#getNumberOfCPUs!/0","title":"Evision.getNumberOfCPUs!/0","type":"function"},{"doc":"Returns the number of logical CPUs available for the process. Python prototype (for reference): getNumberOfCPUs() -&gt; retval","ref":"Evision.html#getNumberOfCPUs/0","title":"Evision.getNumberOfCPUs/0","type":"function"},{"doc":"Raising version of getNumThreads/0 .","ref":"Evision.html#getNumThreads!/0","title":"Evision.getNumThreads!/0","type":"function"},{"doc":"Returns the number of threads used by OpenCV for parallel regions. Always returns 1 if OpenCV is built without threading support. The exact meaning of return value depends on the threading framework used by OpenCV library: TBB - The number of threads, that OpenCV will try to use for parallel regions. If there is any tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns default number of threads used by TBB library. OpenMP - An upper bound on the number of threads that could be used to form a new team. Concurrency - The number of threads, that OpenCV will try to use for parallel regions. GCD - Unsupported; returns the GCD thread pool limit (512) for compatibility. C= - The number of threads, that OpenCV will try to use for parallel regions, if before called setNumThreads with threads &gt; 0, otherwise returns the number of logical CPUs, available for the process. @sa setNumThreads, getThreadNum Python prototype (for reference): getNumThreads() -&gt; retval","ref":"Evision.html#getNumThreads/0","title":"Evision.getNumThreads/0","type":"function"},{"doc":"Raising version of getOptimalDFTSize/1 .","ref":"Evision.html#getOptimalDFTSize!/1","title":"Evision.getOptimalDFTSize!/1","type":"function"},{"doc":"Returns the optimal DFT size for a given vector size. Positional Arguments vecsize : int . vector size. DFT performance is not a monotonic function of a vector size. Therefore, when you calculate convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to pad the input data with zeros to get a bit larger array that can be transformed much faster than the original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process. Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5*5*3*2*2) are also processed quite efficiently. The function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize so that the DFT of a vector of size N can be processed efficiently. In the current implementation N = 2 ^p^ * 3 ^q^ * 5 ^r^ for some integer p, q, r. The function returns a negative number if vecsize is too large (very close to INT_MAX ). While the function cannot be used directly to estimate the optimal vector size for DCT transform (since the current DCT implementation supports only even-size vectors), it can be easily processed as getOptimalDFTSize((vecsize+1)/2)*2. @sa dft , dct , idft , idct , mulSpectrums Python prototype (for reference): getOptimalDFTSize(vecsize) -&gt; retval","ref":"Evision.html#getOptimalDFTSize/1","title":"Evision.getOptimalDFTSize/1","type":"function"},{"doc":"Raising version of getOptimalNewCameraMatrix/4 .","ref":"Evision.html#getOptimalNewCameraMatrix!/4","title":"Evision.getOptimalNewCameraMatrix!/4","type":"function"},{"doc":"Raising version of getOptimalNewCameraMatrix/5 .","ref":"Evision.html#getOptimalNewCameraMatrix!/5","title":"Evision.getOptimalNewCameraMatrix!/5","type":"function"},{"doc":"Returns the new camera intrinsic matrix based on the free scaling parameter. Positional Arguments cameraMatrix : Evision.Mat . Input camera intrinsic matrix. distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. imageSize : Size . Original image size. alpha : double . Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) and 1 (when all the source image pixels are retained in the undistorted image). See #stereoRectify for details. Keyword Arguments newImgSize : Size . Image size after rectification. By default, it is set to imageSize . centerPrincipalPoint : bool . Optional flag that indicates whether in the new camera intrinsic matrix the principal point should be at the image center or not. By default, the principal point is chosen to best fit a subset of the source image (determined by alpha) to the corrected image. Return validPixROI : Rect* . Optional output rectangle that outlines all-good-pixels region in the undistorted image. See roi1, roi2 description in #stereoRectify . @return new_camera_matrix Output new camera intrinsic matrix. The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter. By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original image pixels if there is valuable information in the corners alpha=1 , or get something in between. When alpha&gt;0 , the undistorted result is likely to have some black pixels corresponding to &quot;virtual&quot; pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to #initUndistortRectifyMap to produce the maps for #remap . Python prototype (for reference): getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha[, newImgSize[, centerPrincipalPoint]]) -&gt; retval, validPixROI","ref":"Evision.html#getOptimalNewCameraMatrix/4","title":"Evision.getOptimalNewCameraMatrix/4","type":"function"},{"doc":"Returns the new camera intrinsic matrix based on the free scaling parameter. Positional Arguments cameraMatrix : Evision.Mat . Input camera intrinsic matrix. distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. imageSize : Size . Original image size. alpha : double . Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) and 1 (when all the source image pixels are retained in the undistorted image). See #stereoRectify for details. Keyword Arguments newImgSize : Size . Image size after rectification. By default, it is set to imageSize . centerPrincipalPoint : bool . Optional flag that indicates whether in the new camera intrinsic matrix the principal point should be at the image center or not. By default, the principal point is chosen to best fit a subset of the source image (determined by alpha) to the corrected image. Return validPixROI : Rect* . Optional output rectangle that outlines all-good-pixels region in the undistorted image. See roi1, roi2 description in #stereoRectify . @return new_camera_matrix Output new camera intrinsic matrix. The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter. By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original image pixels if there is valuable information in the corners alpha=1 , or get something in between. When alpha&gt;0 , the undistorted result is likely to have some black pixels corresponding to &quot;virtual&quot; pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to #initUndistortRectifyMap to produce the maps for #remap . Python prototype (for reference): getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha[, newImgSize[, centerPrincipalPoint]]) -&gt; retval, validPixROI","ref":"Evision.html#getOptimalNewCameraMatrix/5","title":"Evision.getOptimalNewCameraMatrix/5","type":"function"},{"doc":"Raising version of getPerspectiveTransform/2 .","ref":"Evision.html#getPerspectiveTransform!/2","title":"Evision.getPerspectiveTransform!/2","type":"function"},{"doc":"Raising version of getPerspectiveTransform/3 .","ref":"Evision.html#getPerspectiveTransform!/3","title":"Evision.getPerspectiveTransform!/3","type":"function"},{"doc":"Calculates a perspective transform from four pairs of the corresponding points. Positional Arguments src : Evision.Mat . Coordinates of quadrangle vertices in the source image. dst : Evision.Mat . Coordinates of the corresponding quadrangle vertices in the destination image. Keyword Arguments solveMethod : int . method passed to cv::solve (#DecompTypes) The function calculates the \\f$3 \\times 3\\f$ matrix of a perspective transform so that: \\f[\\begin{bmatrix} t_i x'_i \\\\ t_i y'_i \\\\ t_i \\end{bmatrix} = \\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\f] where \\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\\f] @sa findHomography, warpPerspective, perspectiveTransform Python prototype (for reference): getPerspectiveTransform(src, dst[, solveMethod]) -&gt; retval","ref":"Evision.html#getPerspectiveTransform/2","title":"Evision.getPerspectiveTransform/2","type":"function"},{"doc":"Calculates a perspective transform from four pairs of the corresponding points. Positional Arguments src : Evision.Mat . Coordinates of quadrangle vertices in the source image. dst : Evision.Mat . Coordinates of the corresponding quadrangle vertices in the destination image. Keyword Arguments solveMethod : int . method passed to cv::solve (#DecompTypes) The function calculates the \\f$3 \\times 3\\f$ matrix of a perspective transform so that: \\f[\\begin{bmatrix} t_i x'_i \\\\ t_i y'_i \\\\ t_i \\end{bmatrix} = \\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\f] where \\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\\f] @sa findHomography, warpPerspective, perspectiveTransform Python prototype (for reference): getPerspectiveTransform(src, dst[, solveMethod]) -&gt; retval","ref":"Evision.html#getPerspectiveTransform/3","title":"Evision.getPerspectiveTransform/3","type":"function"},{"doc":"Raising version of getRectSubPix/3 .","ref":"Evision.html#getRectSubPix!/3","title":"Evision.getRectSubPix!/3","type":"function"},{"doc":"Raising version of getRectSubPix/4 .","ref":"Evision.html#getRectSubPix!/4","title":"Evision.getRectSubPix!/4","type":"function"},{"doc":"Retrieves a pixel rectangle from an image with sub-pixel accuracy. Positional Arguments image : Evision.Mat . Source image. patchSize : Size . Size of the extracted patch. center : Point2f . Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image. Keyword Arguments patchType : int . Depth of the extracted pixels. By default, they have the same depth as src . Return patch : Evision.Mat . Extracted patch that has the size patchSize and the same number of channels as src . The function getRectSubPix extracts pixels from src: \\f[patch(x, y) = src(x + \\texttt{center.x} - ( \\texttt{dst.cols} -1)*0.5, y + \\texttt{center.y} - ( \\texttt{dst.rows} -1)*0.5)\\f] where the values of the pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multi-channel images is processed independently. Also the image should be a single channel or three channel image. While the center of the rectangle must be inside the image, parts of the rectangle may be outside. @sa warpAffine, warpPerspective Python prototype (for reference): getRectSubPix(image, patchSize, center[, patch[, patchType]]) -&gt; patch","ref":"Evision.html#getRectSubPix/3","title":"Evision.getRectSubPix/3","type":"function"},{"doc":"Retrieves a pixel rectangle from an image with sub-pixel accuracy. Positional Arguments image : Evision.Mat . Source image. patchSize : Size . Size of the extracted patch. center : Point2f . Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image. Keyword Arguments patchType : int . Depth of the extracted pixels. By default, they have the same depth as src . Return patch : Evision.Mat . Extracted patch that has the size patchSize and the same number of channels as src . The function getRectSubPix extracts pixels from src: \\f[patch(x, y) = src(x + \\texttt{center.x} - ( \\texttt{dst.cols} -1)*0.5, y + \\texttt{center.y} - ( \\texttt{dst.rows} -1)*0.5)\\f] where the values of the pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multi-channel images is processed independently. Also the image should be a single channel or three channel image. While the center of the rectangle must be inside the image, parts of the rectangle may be outside. @sa warpAffine, warpPerspective Python prototype (for reference): getRectSubPix(image, patchSize, center[, patch[, patchType]]) -&gt; patch","ref":"Evision.html#getRectSubPix/4","title":"Evision.getRectSubPix/4","type":"function"},{"doc":"Raising version of getRotationMatrix2D/3 .","ref":"Evision.html#getRotationMatrix2D!/3","title":"Evision.getRotationMatrix2D!/3","type":"function"},{"doc":"Calculates an affine matrix of 2D rotation. Positional Arguments center : Point2f . Center of the rotation in the source image. angle : double . Rotation angle in degrees. Positive values mean counter-clockwise rotation (the coordinate origin is assumed to be the top-left corner). scale : double . Isotropic scale factor. The function calculates the following matrix: \\f[\\begin{bmatrix} \\alpha &amp; \\beta &amp; (1- \\alpha ) \\cdot \\texttt{center.x} - \\beta \\cdot \\texttt{center.y} \\\\ - \\beta &amp; \\alpha &amp; \\beta \\cdot \\texttt{center.x} + (1- \\alpha ) \\cdot \\texttt{center.y} \\end{bmatrix}\\f] where \\f[\\begin{array}{l} \\alpha = \\texttt{scale} \\cdot \\cos \\texttt{angle} , \\\\ \\beta = \\texttt{scale} \\cdot \\sin \\texttt{angle} \\end{array}\\f] The transformation maps the rotation center to itself. If this is not the target, adjust the shift. @sa getAffineTransform, warpAffine, transform Python prototype (for reference): getRotationMatrix2D(center, angle, scale) -&gt; retval","ref":"Evision.html#getRotationMatrix2D/3","title":"Evision.getRotationMatrix2D/3","type":"function"},{"doc":"Raising version of getStructuringElement/2 .","ref":"Evision.html#getStructuringElement!/2","title":"Evision.getStructuringElement!/2","type":"function"},{"doc":"Raising version of getStructuringElement/3 .","ref":"Evision.html#getStructuringElement!/3","title":"Evision.getStructuringElement!/3","type":"function"},{"doc":"Returns a structuring element of the specified size and shape for morphological operations. Positional Arguments shape : int . Element shape that could be one of #MorphShapes ksize : Size . Size of the structuring element. Keyword Arguments anchor : Point . Anchor position within the element. The default value \\f$(-1, -1)\\f$ means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted. The function constructs and returns the structuring element that can be further passed to #erode, #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as the structuring element. Python prototype (for reference): getStructuringElement(shape, ksize[, anchor]) -&gt; retval","ref":"Evision.html#getStructuringElement/2","title":"Evision.getStructuringElement/2","type":"function"},{"doc":"Returns a structuring element of the specified size and shape for morphological operations. Positional Arguments shape : int . Element shape that could be one of #MorphShapes ksize : Size . Size of the structuring element. Keyword Arguments anchor : Point . Anchor position within the element. The default value \\f$(-1, -1)\\f$ means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted. The function constructs and returns the structuring element that can be further passed to #erode, #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as the structuring element. Python prototype (for reference): getStructuringElement(shape, ksize[, anchor]) -&gt; retval","ref":"Evision.html#getStructuringElement/3","title":"Evision.getStructuringElement/3","type":"function"},{"doc":"Raising version of getTextSize/4 .","ref":"Evision.html#getTextSize!/4","title":"Evision.getTextSize!/4","type":"function"},{"doc":"Calculates the width and height of a text string. Positional Arguments text : String . Input text string. fontFace : int . Font to use, see #HersheyFonts. fontScale : double . Font scale factor that is multiplied by the font-specific base size. thickness : int . Thickness of lines used to render the text. See #putText for details. Return baseLine : int* . y-coordinate of the baseline relative to the bottom-most text point. The function cv::getTextSize calculates and returns the size of a box that contains the specified text. That is, the following code renders some text, the tight box surrounding it, and the baseline: : String text = &quot;Funny text inside the box&quot; ; int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX ; double fontScale = 2 ; int thickness = 3 ; Mat img ( 600 , 800 , CV_8UC3 , Scalar :: all ( 0 ) ) ; int baseline = 0 ; Size textSize = getTextSize ( text , fontFace , fontScale , thickness , &amp; baseline ) ; baseline + = thickness ; // center the text Point textOrg ( ( img . cols - textSize . width ) / 2 , ( img . rows + textSize . height ) / 2 ) ; // draw the box rectangle ( img , textOrg + Point ( 0 , baseline ) , textOrg + Point ( textSize . width , - textSize . height ) , Scalar ( 0 , 0 , 255 ) ) ; // ... and the baseline first line ( img , textOrg + Point ( 0 , thickness ) , textOrg + Point ( textSize . width , thickness ) , Scalar ( 0 , 0 , 255 ) ) ; // then put the text itself putText ( img , text , textOrg , fontFace , fontScale , Scalar :: all ( 255 ) , thickness , 8 ) ; @return The size of a box that contains the specified text. @see putText Python prototype (for reference): getTextSize(text, fontFace, fontScale, thickness) -&gt; retval, baseLine","ref":"Evision.html#getTextSize/4","title":"Evision.getTextSize/4","type":"function"},{"doc":"Raising version of getThreadNum/0 .","ref":"Evision.html#getThreadNum!/0","title":"Evision.getThreadNum!/0","type":"function"},{"doc":"Returns the index of the currently executed thread within the current parallel region. Always returns 0 if called outside of parallel region. @deprecated Current implementation doesn't corresponding to this documentation. The exact meaning of the return value depends on the threading framework used by OpenCV library: TBB - Unsupported with current 4.1 TBB release. Maybe will be supported in future. OpenMP - The thread number, within the current team, of the calling thread. Concurrency - An ID for the virtual processor that the current context is executing on (0 for master thread and unique number for others, but not necessary 1,2,3,...). GCD - System calling thread's ID. Never returns 0 inside parallel region. C= - The index of the current parallel task. @sa setNumThreads, getNumThreads Python prototype (for reference): getThreadNum() -&gt; retval","ref":"Evision.html#getThreadNum/0","title":"Evision.getThreadNum/0","type":"function"},{"doc":"Raising version of getTickCount/0 .","ref":"Evision.html#getTickCount!/0","title":"Evision.getTickCount!/0","type":"function"},{"doc":"Returns the number of ticks. The function returns the number of ticks after the certain event (for example, when the machine was turned on). It can be used to initialize RNG or to measure a function execution time by reading the tick count before and after the function call. @sa getTickFrequency, TickMeter Python prototype (for reference): getTickCount() -&gt; retval","ref":"Evision.html#getTickCount/0","title":"Evision.getTickCount/0","type":"function"},{"doc":"Raising version of getTickFrequency/0 .","ref":"Evision.html#getTickFrequency!/0","title":"Evision.getTickFrequency!/0","type":"function"},{"doc":"Returns the number of ticks per second. The function returns the number of ticks per second. That is, the following code computes the execution time in seconds: double t = ( double ) getTickCount ( ) ; // do something ... t = ( ( double ) getTickCount ( ) - t ) / getTickFrequency ( ) ; @sa getTickCount, TickMeter Python prototype (for reference): getTickFrequency() -&gt; retval","ref":"Evision.html#getTickFrequency/0","title":"Evision.getTickFrequency/0","type":"function"},{"doc":"Raising version of getTrackbarPos/2 .","ref":"Evision.html#getTrackbarPos!/2","title":"Evision.getTrackbarPos!/2","type":"function"},{"doc":"Returns the trackbar position. Positional Arguments trackbarname : String . Name of the trackbar. winname : String . Name of the window that is the parent of the trackbar. The function returns the current position of the specified trackbar. Note : [ Qt Backend Only ] winname can be empty if the trackbar is attached to the control panel. Python prototype (for reference): getTrackbarPos(trackbarname, winname) -&gt; retval","ref":"Evision.html#getTrackbarPos/2","title":"Evision.getTrackbarPos/2","type":"function"},{"doc":"Raising version of getValidDisparityROI/5 .","ref":"Evision.html#getValidDisparityROI!/5","title":"Evision.getValidDisparityROI!/5","type":"function"},{"doc":"Positional Arguments roi1 : Rect roi2 : Rect minDisparity : int numberOfDisparities : int blockSize : int Python prototype (for reference): getValidDisparityROI(roi1, roi2, minDisparity, numberOfDisparities, blockSize) -&gt; retval","ref":"Evision.html#getValidDisparityROI/5","title":"Evision.getValidDisparityROI/5","type":"function"},{"doc":"Raising version of getVersionMajor/0 .","ref":"Evision.html#getVersionMajor!/0","title":"Evision.getVersionMajor!/0","type":"function"},{"doc":"Returns major library version Python prototype (for reference): getVersionMajor() -&gt; retval","ref":"Evision.html#getVersionMajor/0","title":"Evision.getVersionMajor/0","type":"function"},{"doc":"Raising version of getVersionMinor/0 .","ref":"Evision.html#getVersionMinor!/0","title":"Evision.getVersionMinor!/0","type":"function"},{"doc":"Returns minor library version Python prototype (for reference): getVersionMinor() -&gt; retval","ref":"Evision.html#getVersionMinor/0","title":"Evision.getVersionMinor/0","type":"function"},{"doc":"Raising version of getVersionRevision/0 .","ref":"Evision.html#getVersionRevision!/0","title":"Evision.getVersionRevision!/0","type":"function"},{"doc":"Returns revision field of the library version Python prototype (for reference): getVersionRevision() -&gt; retval","ref":"Evision.html#getVersionRevision/0","title":"Evision.getVersionRevision/0","type":"function"},{"doc":"Raising version of getVersionString/0 .","ref":"Evision.html#getVersionString!/0","title":"Evision.getVersionString!/0","type":"function"},{"doc":"Returns library version string For example &quot;3.4.1-dev&quot;. @sa getMajorVersion, getMinorVersion, getRevisionVersion Python prototype (for reference): getVersionString() -&gt; retval","ref":"Evision.html#getVersionString/0","title":"Evision.getVersionString/0","type":"function"},{"doc":"Raising version of getWindowImageRect/1 .","ref":"Evision.html#getWindowImageRect!/1","title":"Evision.getWindowImageRect!/1","type":"function"},{"doc":"Provides rectangle of image in the window. Positional Arguments winname : String . Name of the window. The function getWindowImageRect returns the client screen coordinates, width and height of the image rendering area. @sa resizeWindow moveWindow Python prototype (for reference): getWindowImageRect(winname) -&gt; retval","ref":"Evision.html#getWindowImageRect/1","title":"Evision.getWindowImageRect/1","type":"function"},{"doc":"Raising version of getWindowProperty/2 .","ref":"Evision.html#getWindowProperty!/2","title":"Evision.getWindowProperty!/2","type":"function"},{"doc":"Provides parameters of a window. Positional Arguments winname : String . Name of the window. prop_id : int . Window property to retrieve. The following operation flags are available: (cv::WindowPropertyFlags) The function getWindowProperty returns properties of a window. @sa setWindowProperty Python prototype (for reference): getWindowProperty(winname, prop_id) -&gt; retval","ref":"Evision.html#getWindowProperty/2","title":"Evision.getWindowProperty/2","type":"function"},{"doc":"Raising version of goodFeaturesToTrack/4 .","ref":"Evision.html#goodFeaturesToTrack!/4","title":"Evision.goodFeaturesToTrack!/4","type":"function"},{"doc":"Raising version of goodFeaturesToTrack/5 .","ref":"Evision.html#goodFeaturesToTrack!/5","title":"Evision.goodFeaturesToTrack!/5","type":"function"},{"doc":"Raising version of goodFeaturesToTrack/7 .","ref":"Evision.html#goodFeaturesToTrack!/7","title":"Evision.goodFeaturesToTrack!/7","type":"function"},{"doc":"Raising version of goodFeaturesToTrack/8 .","ref":"Evision.html#goodFeaturesToTrack!/8","title":"Evision.goodFeaturesToTrack!/8","type":"function"},{"doc":"Determines strong corners on an image. Positional Arguments image : Evision.Mat . Input 8-bit or floating-point 32-bit, single-channel image. maxCorners : int . Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. maxCorners &lt;= 0 implies that no limit on the maximum is set and all detected corners are returned. qualityLevel : double . Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. minDistance : double . Minimum possible Euclidean distance between the returned corners. Keyword Arguments mask : Evision.Mat . Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. blockSize : int . Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . useHarrisDetector : bool . Parameter indicating whether to use a Harris detector (see #cornerHarris) or #cornerMinEigenVal. k : double . Free parameter of the Harris detector. Return corners : Evision.Mat . Output vector of detected corners. The function finds the most prominent corners in the image or in the specified image region, as described in @cite Shi94 Function calculates the corner quality measure at every source image pixel using the #cornerMinEigenVal or #cornerHarris . Function performs a non-maximum suppression (the local maximums in 3 x 3 neighborhood are retained). The corners with the minimal eigenvalue less than \\f$\\texttt{qualityLevel} \\cdot \\max_{x,y} qualityMeasureMap(x,y)\\f$ are rejected. The remaining corners are sorted by the quality measure in the descending order. Function throws away each corner for which there is a stronger corner at a distance less than maxDistance. The function can be used to initialize a point-based tracker of an object. Note : If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B . @sa cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform, Python prototype (for reference): goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners[, mask[, blockSize[, useHarrisDetector[, k]]]]]) -&gt; corners","ref":"Evision.html#goodFeaturesToTrack/4","title":"Evision.goodFeaturesToTrack/4","type":"function"},{"doc":"Determines strong corners on an image. Positional Arguments image : Evision.Mat . Input 8-bit or floating-point 32-bit, single-channel image. maxCorners : int . Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. maxCorners &lt;= 0 implies that no limit on the maximum is set and all detected corners are returned. qualityLevel : double . Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. minDistance : double . Minimum possible Euclidean distance between the returned corners. Keyword Arguments mask : Evision.Mat . Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. blockSize : int . Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . useHarrisDetector : bool . Parameter indicating whether to use a Harris detector (see #cornerHarris) or #cornerMinEigenVal. k : double . Free parameter of the Harris detector. Return corners : Evision.Mat . Output vector of detected corners. The function finds the most prominent corners in the image or in the specified image region, as described in @cite Shi94 Function calculates the corner quality measure at every source image pixel using the #cornerMinEigenVal or #cornerHarris . Function performs a non-maximum suppression (the local maximums in 3 x 3 neighborhood are retained). The corners with the minimal eigenvalue less than \\f$\\texttt{qualityLevel} \\cdot \\max_{x,y} qualityMeasureMap(x,y)\\f$ are rejected. The remaining corners are sorted by the quality measure in the descending order. Function throws away each corner for which there is a stronger corner at a distance less than maxDistance. The function can be used to initialize a point-based tracker of an object. Note : If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B . @sa cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform, Python prototype (for reference): goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners[, mask[, blockSize[, useHarrisDetector[, k]]]]]) -&gt; corners","ref":"Evision.html#goodFeaturesToTrack/5","title":"Evision.goodFeaturesToTrack/5","type":"function"},{"doc":"Positional Arguments image : Evision.Mat maxCorners : int qualityLevel : double minDistance : double mask : Evision.Mat blockSize : int gradientSize : int Keyword Arguments useHarrisDetector : bool . k : double . Return corners : Evision.Mat . Python prototype (for reference): goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize[, corners[, useHarrisDetector[, k]]]) -&gt; corners","ref":"Evision.html#goodFeaturesToTrack/7","title":"Evision.goodFeaturesToTrack/7","type":"function"},{"doc":"Positional Arguments image : Evision.Mat maxCorners : int qualityLevel : double minDistance : double mask : Evision.Mat blockSize : int gradientSize : int Keyword Arguments useHarrisDetector : bool . k : double . Return corners : Evision.Mat . Python prototype (for reference): goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize[, corners[, useHarrisDetector[, k]]]) -&gt; corners","ref":"Evision.html#goodFeaturesToTrack/8","title":"Evision.goodFeaturesToTrack/8","type":"function"},{"doc":"Raising version of goodFeaturesToTrackWithQuality/5 .","ref":"Evision.html#goodFeaturesToTrackWithQuality!/5","title":"Evision.goodFeaturesToTrackWithQuality!/5","type":"function"},{"doc":"Raising version of goodFeaturesToTrackWithQuality/6 .","ref":"Evision.html#goodFeaturesToTrackWithQuality!/6","title":"Evision.goodFeaturesToTrackWithQuality!/6","type":"function"},{"doc":"Same as above, but returns also quality measure of the detected corners. Positional Arguments image : Evision.Mat . Input 8-bit or floating-point 32-bit, single-channel image. maxCorners : int . Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. maxCorners &lt;= 0 implies that no limit on the maximum is set and all detected corners are returned. qualityLevel : double . Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. minDistance : double . Minimum possible Euclidean distance between the returned corners. mask : Evision.Mat . Region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. Keyword Arguments blockSize : int . Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . gradientSize : int . Aperture parameter for the Sobel operator used for derivatives computation. See cornerEigenValsAndVecs . useHarrisDetector : bool . Parameter indicating whether to use a Harris detector (see #cornerHarris) or #cornerMinEigenVal. k : double . Free parameter of the Harris detector. Return corners : Evision.Mat . Output vector of detected corners. cornersQuality : Evision.Mat . Output vector of quality measure of the detected corners. Python prototype (for reference): goodFeaturesToTrackWithQuality(image, maxCorners, qualityLevel, minDistance, mask[, corners[, cornersQuality[, blockSize[, gradientSize[, useHarrisDetector[, k]]]]]]) -&gt; corners, cornersQuality","ref":"Evision.html#goodFeaturesToTrackWithQuality/5","title":"Evision.goodFeaturesToTrackWithQuality/5","type":"function"},{"doc":"Same as above, but returns also quality measure of the detected corners. Positional Arguments image : Evision.Mat . Input 8-bit or floating-point 32-bit, single-channel image. maxCorners : int . Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. maxCorners &lt;= 0 implies that no limit on the maximum is set and all detected corners are returned. qualityLevel : double . Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. minDistance : double . Minimum possible Euclidean distance between the returned corners. mask : Evision.Mat . Region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. Keyword Arguments blockSize : int . Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . gradientSize : int . Aperture parameter for the Sobel operator used for derivatives computation. See cornerEigenValsAndVecs . useHarrisDetector : bool . Parameter indicating whether to use a Harris detector (see #cornerHarris) or #cornerMinEigenVal. k : double . Free parameter of the Harris detector. Return corners : Evision.Mat . Output vector of detected corners. cornersQuality : Evision.Mat . Output vector of quality measure of the detected corners. Python prototype (for reference): goodFeaturesToTrackWithQuality(image, maxCorners, qualityLevel, minDistance, mask[, corners[, cornersQuality[, blockSize[, gradientSize[, useHarrisDetector[, k]]]]]]) -&gt; corners, cornersQuality","ref":"Evision.html#goodFeaturesToTrackWithQuality/6","title":"Evision.goodFeaturesToTrackWithQuality/6","type":"function"},{"doc":"Raising version of grabCut/6 .","ref":"Evision.html#grabCut!/6","title":"Evision.grabCut!/6","type":"function"},{"doc":"Raising version of grabCut/7 .","ref":"Evision.html#grabCut!/7","title":"Evision.grabCut!/7","type":"function"},{"doc":"Runs the GrabCut algorithm. Positional Arguments img : Evision.Mat . Input 8-bit 3-channel image. rect : Rect . ROI containing a segmented object. The pixels outside of the ROI are marked as &quot;obvious background&quot;. The parameter is only used when mode==#GC_INIT_WITH_RECT . iterCount : int . Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or mode==GC_EVAL . Keyword Arguments mode : int . Operation mode that could be one of the #GrabCutModes Return mask : Evision.Mat . Input/output 8-bit single-channel mask. The mask is initialized by the function when mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses. bgdModel : Evision.Mat . Temporary array for the background model. Do not modify it while you are processing the same image. fgdModel : Evision.Mat . Temporary arrays for the foreground model. Do not modify it while you are processing the same image. The function implements the GrabCut image segmentation algorithm . Python prototype (for reference): grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode]) -&gt; mask, bgdModel, fgdModel","ref":"Evision.html#grabCut/6","title":"Evision.grabCut/6","type":"function"},{"doc":"Runs the GrabCut algorithm. Positional Arguments img : Evision.Mat . Input 8-bit 3-channel image. rect : Rect . ROI containing a segmented object. The pixels outside of the ROI are marked as &quot;obvious background&quot;. The parameter is only used when mode==#GC_INIT_WITH_RECT . iterCount : int . Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or mode==GC_EVAL . Keyword Arguments mode : int . Operation mode that could be one of the #GrabCutModes Return mask : Evision.Mat . Input/output 8-bit single-channel mask. The mask is initialized by the function when mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses. bgdModel : Evision.Mat . Temporary array for the background model. Do not modify it while you are processing the same image. fgdModel : Evision.Mat . Temporary arrays for the foreground model. Do not modify it while you are processing the same image. The function implements the GrabCut image segmentation algorithm . Python prototype (for reference): grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode]) -&gt; mask, bgdModel, fgdModel","ref":"Evision.html#grabCut/7","title":"Evision.grabCut/7","type":"function"},{"doc":"Raising version of groupRectangles/2 .","ref":"Evision.html#groupRectangles!/2","title":"Evision.groupRectangles!/2","type":"function"},{"doc":"Raising version of groupRectangles/3 .","ref":"Evision.html#groupRectangles!/3","title":"Evision.groupRectangles!/3","type":"function"},{"doc":"Positional Arguments groupThreshold : int Keyword Arguments eps : double . Return rectList : [Rect] weights : [int] Has overloading in C++ Python prototype (for reference): groupRectangles(rectList, groupThreshold[, eps]) -&gt; rectList, weights","ref":"Evision.html#groupRectangles/2","title":"Evision.groupRectangles/2","type":"function"},{"doc":"Positional Arguments groupThreshold : int Keyword Arguments eps : double . Return rectList : [Rect] weights : [int] Has overloading in C++ Python prototype (for reference): groupRectangles(rectList, groupThreshold[, eps]) -&gt; rectList, weights","ref":"Evision.html#groupRectangles/3","title":"Evision.groupRectangles/3","type":"function"},{"doc":"Raising version of haveImageReader/1 .","ref":"Evision.html#haveImageReader!/1","title":"Evision.haveImageReader!/1","type":"function"},{"doc":"Returns true if the specified image can be decoded by OpenCV Positional Arguments filename : String . File name of the image Python prototype (for reference): haveImageReader(filename) -&gt; retval","ref":"Evision.html#haveImageReader/1","title":"Evision.haveImageReader/1","type":"function"},{"doc":"Raising version of haveImageWriter/1 .","ref":"Evision.html#haveImageWriter!/1","title":"Evision.haveImageWriter!/1","type":"function"},{"doc":"Returns true if an image with the specified filename can be encoded by OpenCV Positional Arguments filename : String . File name of the image Python prototype (for reference): haveImageWriter(filename) -&gt; retval","ref":"Evision.html#haveImageWriter/1","title":"Evision.haveImageWriter/1","type":"function"},{"doc":"Raising version of haveOpenVX/0 .","ref":"Evision.html#haveOpenVX!/0","title":"Evision.haveOpenVX!/0","type":"function"},{"doc":"Python prototype (for reference): haveOpenVX() -&gt; retval","ref":"Evision.html#haveOpenVX/0","title":"Evision.haveOpenVX/0","type":"function"},{"doc":"Raising version of hconcat/1 .","ref":"Evision.html#hconcat!/1","title":"Evision.hconcat!/1","type":"function"},{"doc":"Raising version of hconcat/2 .","ref":"Evision.html#hconcat!/2","title":"Evision.hconcat!/2","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] . input array or vector of matrices. all of the matrices must have the same number of rows and the same depth. Return dst : Evision.Mat . output array. It has the same number of rows and depth as the src, and the sum of cols of the src. same depth. Has overloading in C++ std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),}; cv::Mat out; cv::hconcat( matrices, out ); //out: //[1, 2, 3; // 1, 2, 3; // 1, 2, 3; // 1, 2, 3] Python prototype (for reference): hconcat(src[, dst]) -&gt; dst","ref":"Evision.html#hconcat/1","title":"Evision.hconcat/1","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] . input array or vector of matrices. all of the matrices must have the same number of rows and the same depth. Return dst : Evision.Mat . output array. It has the same number of rows and depth as the src, and the sum of cols of the src. same depth. Has overloading in C++ std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),}; cv::Mat out; cv::hconcat( matrices, out ); //out: //[1, 2, 3; // 1, 2, 3; // 1, 2, 3; // 1, 2, 3] Python prototype (for reference): hconcat(src[, dst]) -&gt; dst","ref":"Evision.html#hconcat/2","title":"Evision.hconcat/2","type":"function"},{"doc":"Raising version of houghCircles/4 .","ref":"Evision.html#houghCircles!/4","title":"Evision.houghCircles!/4","type":"function"},{"doc":"Raising version of houghCircles/5 .","ref":"Evision.html#houghCircles!/5","title":"Evision.houghCircles!/5","type":"function"},{"doc":"Finds circles in a grayscale image using the Hough transform. Positional Arguments image : Evision.Mat . 8-bit, single-channel, grayscale input image. method : int . Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT. dp : double . Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5, unless some small very circles need to be detected. minDist : double . Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. Keyword Arguments param1 : double . First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT, it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images. param2 : double . Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle &quot;perfectness&quot; measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles. minRadius : int . Minimum circle radius. maxRadius : int . Maximum circle radius. If &lt;= 0, uses the maximum image dimension. If &lt; 0, #HOUGH_GRADIENT returns centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses. Return circles : Evision.Mat . Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector \\f$(x, y, radius)\\f$ or \\f$(x, y, radius, votes)\\f$ . The function finds circles in a grayscale image using a modification of the Hough transform. Example: : @include snippets/imgproc_HoughLinesCircles.cpp Note : Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure. It also helps to smooth image a bit unless it's already soft. For example, GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help. @sa fitEllipse, minEnclosingCircle Python prototype (for reference): HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]]) -&gt; circles","ref":"Evision.html#houghCircles/4","title":"Evision.houghCircles/4","type":"function"},{"doc":"Finds circles in a grayscale image using the Hough transform. Positional Arguments image : Evision.Mat . 8-bit, single-channel, grayscale input image. method : int . Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT. dp : double . Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5, unless some small very circles need to be detected. minDist : double . Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. Keyword Arguments param1 : double . First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT, it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images. param2 : double . Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle &quot;perfectness&quot; measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles. minRadius : int . Minimum circle radius. maxRadius : int . Maximum circle radius. If &lt;= 0, uses the maximum image dimension. If &lt; 0, #HOUGH_GRADIENT returns centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses. Return circles : Evision.Mat . Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector \\f$(x, y, radius)\\f$ or \\f$(x, y, radius, votes)\\f$ . The function finds circles in a grayscale image using a modification of the Hough transform. Example: : @include snippets/imgproc_HoughLinesCircles.cpp Note : Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure. It also helps to smooth image a bit unless it's already soft. For example, GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help. @sa fitEllipse, minEnclosingCircle Python prototype (for reference): HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]]) -&gt; circles","ref":"Evision.html#houghCircles/5","title":"Evision.houghCircles/5","type":"function"},{"doc":"Raising version of houghLines/4 .","ref":"Evision.html#houghLines!/4","title":"Evision.houghLines!/4","type":"function"},{"doc":"Raising version of houghLines/5 .","ref":"Evision.html#houghLines!/5","title":"Evision.houghLines!/5","type":"function"},{"doc":"Finds lines in a binary image using the standard Hough transform. Positional Arguments image : Evision.Mat . 8-bit, single-channel binary source image. The image may be modified by the function. rho : double . Distance resolution of the accumulator in pixels. theta : double . Angle resolution of the accumulator in radians. threshold : int . Accumulator threshold parameter. Only those lines are returned that get enough votes ( \\f$&gt;\\texttt{threshold}\\f$ ). Keyword Arguments srn : double . For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. stn : double . For the multi-scale Hough transform, it is a divisor for the distance resolution theta. min_theta : double . For standard and multi-scale Hough transform, minimum angle to check for lines. Must fall between 0 and max_theta. max_theta : double . For standard and multi-scale Hough transform, maximum angle to check for lines. Must fall between min_theta and CV_PI. Return lines : Evision.Mat . Output vector of lines. Each line is represented by a 2 or 3 element vector \\f$(\\rho, \\theta)\\f$ or \\f$(\\rho, \\theta, \\textrm{votes})\\f$ . \\f$\\rho\\f$ is the distance from the coordinate origin \\f$(0,0)\\f$ (top-left corner of the image). \\f$\\theta\\f$ is the line rotation angle in radians ( \\f$0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal line}\\f$ ). \\f$\\textrm{votes}\\f$ is the value of accumulator. The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm for a good explanation of Hough transform. Python prototype (for reference): HoughLines(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -&gt; lines","ref":"Evision.html#houghLines/4","title":"Evision.houghLines/4","type":"function"},{"doc":"Finds lines in a binary image using the standard Hough transform. Positional Arguments image : Evision.Mat . 8-bit, single-channel binary source image. The image may be modified by the function. rho : double . Distance resolution of the accumulator in pixels. theta : double . Angle resolution of the accumulator in radians. threshold : int . Accumulator threshold parameter. Only those lines are returned that get enough votes ( \\f$&gt;\\texttt{threshold}\\f$ ). Keyword Arguments srn : double . For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. stn : double . For the multi-scale Hough transform, it is a divisor for the distance resolution theta. min_theta : double . For standard and multi-scale Hough transform, minimum angle to check for lines. Must fall between 0 and max_theta. max_theta : double . For standard and multi-scale Hough transform, maximum angle to check for lines. Must fall between min_theta and CV_PI. Return lines : Evision.Mat . Output vector of lines. Each line is represented by a 2 or 3 element vector \\f$(\\rho, \\theta)\\f$ or \\f$(\\rho, \\theta, \\textrm{votes})\\f$ . \\f$\\rho\\f$ is the distance from the coordinate origin \\f$(0,0)\\f$ (top-left corner of the image). \\f$\\theta\\f$ is the line rotation angle in radians ( \\f$0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal line}\\f$ ). \\f$\\textrm{votes}\\f$ is the value of accumulator. The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm for a good explanation of Hough transform. Python prototype (for reference): HoughLines(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -&gt; lines","ref":"Evision.html#houghLines/5","title":"Evision.houghLines/5","type":"function"},{"doc":"Raising version of houghLinesP/4 .","ref":"Evision.html#houghLinesP!/4","title":"Evision.houghLinesP!/4","type":"function"},{"doc":"Raising version of houghLinesP/5 .","ref":"Evision.html#houghLinesP!/5","title":"Evision.houghLinesP!/5","type":"function"},{"doc":"Finds line segments in a binary image using the probabilistic Hough transform. Positional Arguments image : Evision.Mat . 8-bit, single-channel binary source image. The image may be modified by the function. rho : double . Distance resolution of the accumulator in pixels. theta : double . Angle resolution of the accumulator in radians. threshold : int . Accumulator threshold parameter. Only those lines are returned that get enough votes ( \\f$&gt;\\texttt{threshold}\\f$ ). Keyword Arguments minLineLength : double . Minimum line length. Line segments shorter than that are rejected. maxLineGap : double . Maximum allowed gap between points on the same line to link them. Return lines : Evision.Mat . Output vector of lines. Each line is represented by a 4-element vector \\f$(x_1, y_1, x_2, y_2)\\f$ , where \\f$(x_1,y_1)\\f$ and \\f$(x_2, y_2)\\f$ are the ending points of each detected line segment. The function implements the probabilistic Hough transform algorithm for line detection, described in @cite Matas00 See the line detection example below: @include snippets/imgproc_HoughLinesP.cpp This is a sample picture the function parameters have been tuned for: And this is the output of the above program in case of the probabilistic Hough transform: @sa LineSegmentDetector Python prototype (for reference): HoughLinesP(image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]]) -&gt; lines","ref":"Evision.html#houghLinesP/4","title":"Evision.houghLinesP/4","type":"function"},{"doc":"Finds line segments in a binary image using the probabilistic Hough transform. Positional Arguments image : Evision.Mat . 8-bit, single-channel binary source image. The image may be modified by the function. rho : double . Distance resolution of the accumulator in pixels. theta : double . Angle resolution of the accumulator in radians. threshold : int . Accumulator threshold parameter. Only those lines are returned that get enough votes ( \\f$&gt;\\texttt{threshold}\\f$ ). Keyword Arguments minLineLength : double . Minimum line length. Line segments shorter than that are rejected. maxLineGap : double . Maximum allowed gap between points on the same line to link them. Return lines : Evision.Mat . Output vector of lines. Each line is represented by a 4-element vector \\f$(x_1, y_1, x_2, y_2)\\f$ , where \\f$(x_1,y_1)\\f$ and \\f$(x_2, y_2)\\f$ are the ending points of each detected line segment. The function implements the probabilistic Hough transform algorithm for line detection, described in @cite Matas00 See the line detection example below: @include snippets/imgproc_HoughLinesP.cpp This is a sample picture the function parameters have been tuned for: And this is the output of the above program in case of the probabilistic Hough transform: @sa LineSegmentDetector Python prototype (for reference): HoughLinesP(image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]]) -&gt; lines","ref":"Evision.html#houghLinesP/5","title":"Evision.houghLinesP/5","type":"function"},{"doc":"Raising version of houghLinesPointSet/9 .","ref":"Evision.html#houghLinesPointSet!/9","title":"Evision.houghLinesPointSet!/9","type":"function"},{"doc":"Raising version of houghLinesPointSet/10 .","ref":"Evision.html#houghLinesPointSet!/10","title":"Evision.houghLinesPointSet!/10","type":"function"},{"doc":"Finds lines in a set of points using the standard Hough transform. Positional Arguments point : Evision.Mat . Input vector of points. Each vector must be encoded as a Point vector \\f$(x,y)\\f$. Type must be CV_32FC2 or CV_32SC2. lines_max : int . Max count of Hough lines. threshold : int . Accumulator threshold parameter. Only those lines are returned that get enough votes ( \\f$&gt;\\texttt{threshold}\\f$ ). min_rho : double . Minimum value for \\f$\\rho\\f$ for the accumulator (Note: \\f$\\rho\\f$ can be negative. The absolute value \\f$|\\rho|\\f$ is the distance of a line to the origin.). max_rho : double . Maximum value for \\f$\\rho\\f$ for the accumulator. rho_step : double . Distance resolution of the accumulator. min_theta : double . Minimum angle value of the accumulator in radians. max_theta : double . Maximum angle value of the accumulator in radians. theta_step : double . Angle resolution of the accumulator in radians. Return lines : Evision.Mat . Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt; \\f$(votes, rho, theta)\\f$. The larger the value of 'votes', the higher the reliability of the Hough line. The function finds lines in a set of points using a modification of the Hough transform. @include snippets/imgproc_HoughLinesPointSet.cpp Python prototype (for reference): HoughLinesPointSet(point, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step[, lines]) -&gt; lines","ref":"Evision.html#houghLinesPointSet/9","title":"Evision.houghLinesPointSet/9","type":"function"},{"doc":"Finds lines in a set of points using the standard Hough transform. Positional Arguments point : Evision.Mat . Input vector of points. Each vector must be encoded as a Point vector \\f$(x,y)\\f$. Type must be CV_32FC2 or CV_32SC2. lines_max : int . Max count of Hough lines. threshold : int . Accumulator threshold parameter. Only those lines are returned that get enough votes ( \\f$&gt;\\texttt{threshold}\\f$ ). min_rho : double . Minimum value for \\f$\\rho\\f$ for the accumulator (Note: \\f$\\rho\\f$ can be negative. The absolute value \\f$|\\rho|\\f$ is the distance of a line to the origin.). max_rho : double . Maximum value for \\f$\\rho\\f$ for the accumulator. rho_step : double . Distance resolution of the accumulator. min_theta : double . Minimum angle value of the accumulator in radians. max_theta : double . Maximum angle value of the accumulator in radians. theta_step : double . Angle resolution of the accumulator in radians. Return lines : Evision.Mat . Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt; \\f$(votes, rho, theta)\\f$. The larger the value of 'votes', the higher the reliability of the Hough line. The function finds lines in a set of points using a modification of the Hough transform. @include snippets/imgproc_HoughLinesPointSet.cpp Python prototype (for reference): HoughLinesPointSet(point, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step[, lines]) -&gt; lines","ref":"Evision.html#houghLinesPointSet/10","title":"Evision.houghLinesPointSet/10","type":"function"},{"doc":"Raising version of houghLinesWithAccumulator/4 .","ref":"Evision.html#houghLinesWithAccumulator!/4","title":"Evision.houghLinesWithAccumulator!/4","type":"function"},{"doc":"Raising version of houghLinesWithAccumulator/5 .","ref":"Evision.html#houghLinesWithAccumulator!/5","title":"Evision.houghLinesWithAccumulator!/5","type":"function"},{"doc":"Finds lines in a binary image using the standard Hough transform and get accumulator. Positional Arguments image : Evision.Mat rho : double theta : double threshold : int Keyword Arguments srn : double . stn : double . min_theta : double . max_theta : double . Return lines : Evision.Mat . Note : This function is for bindings use only. Use original function in C++ code @sa HoughLines Python prototype (for reference): HoughLinesWithAccumulator(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -&gt; lines","ref":"Evision.html#houghLinesWithAccumulator/4","title":"Evision.houghLinesWithAccumulator/4","type":"function"},{"doc":"Finds lines in a binary image using the standard Hough transform and get accumulator. Positional Arguments image : Evision.Mat rho : double theta : double threshold : int Keyword Arguments srn : double . stn : double . min_theta : double . max_theta : double . Return lines : Evision.Mat . Note : This function is for bindings use only. Use original function in C++ code @sa HoughLines Python prototype (for reference): HoughLinesWithAccumulator(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -&gt; lines","ref":"Evision.html#houghLinesWithAccumulator/5","title":"Evision.houghLinesWithAccumulator/5","type":"function"},{"doc":"Raising version of huMoments/1 .","ref":"Evision.html#huMoments!/1","title":"Evision.huMoments!/1","type":"function"},{"doc":"Raising version of huMoments/2 .","ref":"Evision.html#huMoments!/2","title":"Evision.huMoments!/2","type":"function"},{"doc":"Positional Arguments m : Moments Return hu : Evision.Mat . Has overloading in C++ Python prototype (for reference): HuMoments(m[, hu]) -&gt; hu","ref":"Evision.html#huMoments/1","title":"Evision.huMoments/1","type":"function"},{"doc":"Positional Arguments m : Moments Return hu : Evision.Mat . Has overloading in C++ Python prototype (for reference): HuMoments(m[, hu]) -&gt; hu","ref":"Evision.html#huMoments/2","title":"Evision.huMoments/2","type":"function"},{"doc":"Raising version of idct/1 .","ref":"Evision.html#idct!/1","title":"Evision.idct!/1","type":"function"},{"doc":"Raising version of idct/2 .","ref":"Evision.html#idct!/2","title":"Evision.idct!/2","type":"function"},{"doc":"Calculates the inverse Discrete Cosine Transform of a 1D or 2D array. Positional Arguments src : Evision.Mat . input floating-point single-channel array. Keyword Arguments flags : int . operation flags. Return dst : Evision.Mat . output array of the same size and type as src. idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE). @sa dct, dft, idft, getOptimalDFTSize Python prototype (for reference): idct(src[, dst[, flags]]) -&gt; dst","ref":"Evision.html#idct/1","title":"Evision.idct/1","type":"function"},{"doc":"Calculates the inverse Discrete Cosine Transform of a 1D or 2D array. Positional Arguments src : Evision.Mat . input floating-point single-channel array. Keyword Arguments flags : int . operation flags. Return dst : Evision.Mat . output array of the same size and type as src. idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE). @sa dct, dft, idft, getOptimalDFTSize Python prototype (for reference): idct(src[, dst[, flags]]) -&gt; dst","ref":"Evision.html#idct/2","title":"Evision.idct/2","type":"function"},{"doc":"Raising version of idft/1 .","ref":"Evision.html#idft!/1","title":"Evision.idft!/1","type":"function"},{"doc":"Raising version of idft/2 .","ref":"Evision.html#idft!/2","title":"Evision.idft!/2","type":"function"},{"doc":"Calculates the inverse Discrete Fourier Transform of a 1D or 2D array. Positional Arguments src : Evision.Mat . input floating-point real or complex array. Keyword Arguments flags : int . operation flags (see dft and #DftFlags). nonzeroRows : int . number of dst rows to process; the rest of the rows have undefined content (see the convolution sample in dft description. Return dst : Evision.Mat . output array whose size and type depend on the flags. idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) . Note : None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of dft or idft explicitly to make these transforms mutually inverse. @sa dft, dct, idct, mulSpectrums, getOptimalDFTSize Python prototype (for reference): idft(src[, dst[, flags[, nonzeroRows]]]) -&gt; dst","ref":"Evision.html#idft/1","title":"Evision.idft/1","type":"function"},{"doc":"Calculates the inverse Discrete Fourier Transform of a 1D or 2D array. Positional Arguments src : Evision.Mat . input floating-point real or complex array. Keyword Arguments flags : int . operation flags (see dft and #DftFlags). nonzeroRows : int . number of dst rows to process; the rest of the rows have undefined content (see the convolution sample in dft description. Return dst : Evision.Mat . output array whose size and type depend on the flags. idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) . Note : None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of dft or idft explicitly to make these transforms mutually inverse. @sa dft, dct, idct, mulSpectrums, getOptimalDFTSize Python prototype (for reference): idft(src[, dst[, flags[, nonzeroRows]]]) -&gt; dst","ref":"Evision.html#idft/2","title":"Evision.idft/2","type":"function"},{"doc":"Raising version of illuminationChange/2 .","ref":"Evision.html#illuminationChange!/2","title":"Evision.illuminationChange!/2","type":"function"},{"doc":"Raising version of illuminationChange/3 .","ref":"Evision.html#illuminationChange!/3","title":"Evision.illuminationChange!/3","type":"function"},{"doc":"Applying an appropriate non-linear transformation to the gradient field inside the selection and then integrating back with a Poisson solver, modifies locally the apparent illumination of an image. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. Keyword Arguments alpha : float . Value ranges between 0-2. beta : float . Value ranges between 0-2. Return dst : Evision.Mat . Output image with the same size and type as src. This is useful to highlight under-exposed foreground objects or to reduce specular reflections. Python prototype (for reference): illuminationChange(src, mask[, dst[, alpha[, beta]]]) -&gt; dst","ref":"Evision.html#illuminationChange/2","title":"Evision.illuminationChange/2","type":"function"},{"doc":"Applying an appropriate non-linear transformation to the gradient field inside the selection and then integrating back with a Poisson solver, modifies locally the apparent illumination of an image. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. Keyword Arguments alpha : float . Value ranges between 0-2. beta : float . Value ranges between 0-2. Return dst : Evision.Mat . Output image with the same size and type as src. This is useful to highlight under-exposed foreground objects or to reduce specular reflections. Python prototype (for reference): illuminationChange(src, mask[, dst[, alpha[, beta]]]) -&gt; dst","ref":"Evision.html#illuminationChange/3","title":"Evision.illuminationChange/3","type":"function"},{"doc":"Raising version of imcount/1 .","ref":"Evision.html#imcount!/1","title":"Evision.imcount!/1","type":"function"},{"doc":"Raising version of imcount/2 .","ref":"Evision.html#imcount!/2","title":"Evision.imcount!/2","type":"function"},{"doc":"Returns the number of images inside the give file Positional Arguments filename : String . Name of file to be loaded. Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. The function imcount will return the number of pages in a multi-page image, or 1 for single-page images Python prototype (for reference): imcount(filename[, flags]) -&gt; retval","ref":"Evision.html#imcount/1","title":"Evision.imcount/1","type":"function"},{"doc":"Returns the number of images inside the give file Positional Arguments filename : String . Name of file to be loaded. Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. The function imcount will return the number of pages in a multi-page image, or 1 for single-page images Python prototype (for reference): imcount(filename[, flags]) -&gt; retval","ref":"Evision.html#imcount/2","title":"Evision.imcount/2","type":"function"},{"doc":"Raising version of imdecode/2 .","ref":"Evision.html#imdecode!/2","title":"Evision.imdecode!/2","type":"function"},{"doc":"","ref":"Evision.html#imdecode/2","title":"Evision.imdecode/2","type":"function"},{"doc":"Raising version of imencode/2 .","ref":"Evision.html#imencode!/2","title":"Evision.imencode!/2","type":"function"},{"doc":"Raising version of imencode/3 .","ref":"Evision.html#imencode!/3","title":"Evision.imencode!/3","type":"function"},{"doc":"Encodes an image into a memory buffer. Positional Arguments ext : String . File extension that defines the output format. Must include a leading period. img : Evision.Mat . Image to be written. Keyword Arguments params : [int] . Format-specific parameters. See cv::imwrite and cv::ImwriteFlags. Return buf : [uchar] . Output buffer resized to fit the compressed image. The function imencode compresses the image and stores it in the memory buffer that is resized to fit the result. See cv::imwrite for the list of supported formats and flags description. Python prototype (for reference): imencode(ext, img[, params]) -&gt; retval, buf","ref":"Evision.html#imencode/2","title":"Evision.imencode/2","type":"function"},{"doc":"Encodes an image into a memory buffer. Positional Arguments ext : String . File extension that defines the output format. Must include a leading period. img : Evision.Mat . Image to be written. Keyword Arguments params : [int] . Format-specific parameters. See cv::imwrite and cv::ImwriteFlags. Return buf : [uchar] . Output buffer resized to fit the compressed image. The function imencode compresses the image and stores it in the memory buffer that is resized to fit the result. See cv::imwrite for the list of supported formats and flags description. Python prototype (for reference): imencode(ext, img[, params]) -&gt; retval, buf","ref":"Evision.html#imencode/3","title":"Evision.imencode/3","type":"function"},{"doc":"Raising version of imread/1 .","ref":"Evision.html#imread!/1","title":"Evision.imread!/1","type":"function"},{"doc":"Raising version of imread/2 .","ref":"Evision.html#imread!/2","title":"Evision.imread!/2","type":"function"},{"doc":"Loads an image from a file. Positional Arguments filename : String . Name of file to be loaded. Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes @anchor imread The function imread loads an image from the specified file and returns it. If the image cannot be read (because of missing file, improper permissions, unsupported or invalid format), the function returns an empty matrix ( Mat::data==NULL ). Currently, the following file formats are supported: Windows bitmaps - *.bmp, *.dib (always supported) JPEG files - *.jpeg, *.jpg, *.jpe (see the Note section) JPEG 2000 files - *.jp2 (see the Note section) Portable Network Graphics - *.png (see the Note section) WebP - *.webp (see the Note section) Portable image format - *.pbm, *.pgm, *.ppm *.pxm, *.pnm (always supported) PFM files - *.pfm (see the Note section) Sun rasters - *.sr, *.ras (always supported) TIFF files - *.tiff, *.tif (see the Note section) OpenEXR Image files - *.exr (see the Note section) Radiance HDR - *.hdr, *.pic (always supported) Raster and Vector geospatial data supported by GDAL (see the Note section) Note : The function determines the type of an image by the content, not by the file extension. In the case of color images, the decoded images will have the channels stored in B G R order. When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available. Results may differ to the output of cvtColor() On Microsoft Windows* OS and MacOSX*, the codecs shipped with an OpenCV image (libjpeg, libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs, and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware that currently these native image loaders give images with different pixel values because of the color management embedded into MacOSX. On Linux*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for codecs supplied with an OS image. Install the relevant packages (do not forget the development files, for example, &quot;libjpeg-dev&quot;, in Debian* and Ubuntu*) to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake. In the case you set WITH_GDAL flag to true in CMake and @ref IMREAD_LOAD_GDAL to load the image, then the GDAL driver will be used in order to decode the image, supporting the following formats: Raster , Vector . If EXIF information is embedded in the image file, the EXIF orientation will be taken into account and thus the image will be rotated accordingly except if the flags @ref IMREAD_IGNORE_ORIENTATION or @ref IMREAD_UNCHANGED are passed. Use the IMREAD_UNCHANGED flag to keep the floating point values from PFM image. By default number of pixels must be less than 2^30. Limit can be set using system variable OPENCV_IO_MAX_IMAGE_PIXELS Python prototype (for reference): imread(filename[, flags]) -&gt; retval","ref":"Evision.html#imread/1","title":"Evision.imread/1","type":"function"},{"doc":"Loads an image from a file. Positional Arguments filename : String . Name of file to be loaded. Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes @anchor imread The function imread loads an image from the specified file and returns it. If the image cannot be read (because of missing file, improper permissions, unsupported or invalid format), the function returns an empty matrix ( Mat::data==NULL ). Currently, the following file formats are supported: Windows bitmaps - *.bmp, *.dib (always supported) JPEG files - *.jpeg, *.jpg, *.jpe (see the Note section) JPEG 2000 files - *.jp2 (see the Note section) Portable Network Graphics - *.png (see the Note section) WebP - *.webp (see the Note section) Portable image format - *.pbm, *.pgm, *.ppm *.pxm, *.pnm (always supported) PFM files - *.pfm (see the Note section) Sun rasters - *.sr, *.ras (always supported) TIFF files - *.tiff, *.tif (see the Note section) OpenEXR Image files - *.exr (see the Note section) Radiance HDR - *.hdr, *.pic (always supported) Raster and Vector geospatial data supported by GDAL (see the Note section) Note : The function determines the type of an image by the content, not by the file extension. In the case of color images, the decoded images will have the channels stored in B G R order. When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available. Results may differ to the output of cvtColor() On Microsoft Windows* OS and MacOSX*, the codecs shipped with an OpenCV image (libjpeg, libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs, and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware that currently these native image loaders give images with different pixel values because of the color management embedded into MacOSX. On Linux*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for codecs supplied with an OS image. Install the relevant packages (do not forget the development files, for example, &quot;libjpeg-dev&quot;, in Debian* and Ubuntu*) to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake. In the case you set WITH_GDAL flag to true in CMake and @ref IMREAD_LOAD_GDAL to load the image, then the GDAL driver will be used in order to decode the image, supporting the following formats: Raster , Vector . If EXIF information is embedded in the image file, the EXIF orientation will be taken into account and thus the image will be rotated accordingly except if the flags @ref IMREAD_IGNORE_ORIENTATION or @ref IMREAD_UNCHANGED are passed. Use the IMREAD_UNCHANGED flag to keep the floating point values from PFM image. By default number of pixels must be less than 2^30. Limit can be set using system variable OPENCV_IO_MAX_IMAGE_PIXELS Python prototype (for reference): imread(filename[, flags]) -&gt; retval","ref":"Evision.html#imread/2","title":"Evision.imread/2","type":"function"},{"doc":"Raising version of imreadmulti/1 .","ref":"Evision.html#imreadmulti!/1","title":"Evision.imreadmulti!/1","type":"function"},{"doc":"Raising version of imreadmulti/2 .","ref":"Evision.html#imreadmulti!/2","title":"Evision.imreadmulti!/2","type":"function"},{"doc":"Raising version of imreadmulti/3 .","ref":"Evision.html#imreadmulti!/3","title":"Evision.imreadmulti!/3","type":"function"},{"doc":"Raising version of imreadmulti/4 .","ref":"Evision.html#imreadmulti!/4","title":"Evision.imreadmulti!/4","type":"function"},{"doc":"Loads a multi-page image from a file. Positional Arguments filename : String . Name of file to be loaded. Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. Return mats : [Evision.Mat] . A vector of Mat objects holding each page. The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects. @sa cv::imread Python prototype (for reference): imreadmulti(filename[, mats[, flags]]) -&gt; retval, mats","ref":"Evision.html#imreadmulti/1","title":"Evision.imreadmulti/1","type":"function"},{"doc":"Loads a multi-page image from a file. Positional Arguments filename : String . Name of file to be loaded. Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. Return mats : [Evision.Mat] . A vector of Mat objects holding each page. The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects. @sa cv::imread Python prototype (for reference): imreadmulti(filename[, mats[, flags]]) -&gt; retval, mats","ref":"Evision.html#imreadmulti/2","title":"Evision.imreadmulti/2","type":"function"},{"doc":"Loads a of images of a multi-page image from a file. Positional Arguments filename : String . Name of file to be loaded. start : int . Start index of the image to load count : int . Count number of images to load Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. Return mats : [Evision.Mat] . A vector of Mat objects holding each page. The function imreadmulti loads a specified range from a multi-page image from the specified file into a vector of Mat objects. @sa cv::imread Python prototype (for reference): imreadmulti(filename, start, count[, mats[, flags]]) -&gt; retval, mats","ref":"Evision.html#imreadmulti/3","title":"Evision.imreadmulti/3","type":"function"},{"doc":"Loads a of images of a multi-page image from a file. Positional Arguments filename : String . Name of file to be loaded. start : int . Start index of the image to load count : int . Count number of images to load Keyword Arguments flags : int . Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. Return mats : [Evision.Mat] . A vector of Mat objects holding each page. The function imreadmulti loads a specified range from a multi-page image from the specified file into a vector of Mat objects. @sa cv::imread Python prototype (for reference): imreadmulti(filename, start, count[, mats[, flags]]) -&gt; retval, mats","ref":"Evision.html#imreadmulti/4","title":"Evision.imreadmulti/4","type":"function"},{"doc":"Raising version of imwrite/2 .","ref":"Evision.html#imwrite!/2","title":"Evision.imwrite!/2","type":"function"},{"doc":"Raising version of imwrite/3 .","ref":"Evision.html#imwrite!/3","title":"Evision.imwrite!/3","type":"function"},{"doc":"Saves an image to a specified file. Positional Arguments filename : String . Name of the file. img : Evision.Mat . (Mat or vector of Mat) Image or Images to be saved. Keyword Arguments params : [int] . Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see cv::ImwriteFlags The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions). In general, only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions: 16-bit unsigned (CV_16U) images can be saved in the case of PNG, JPEG 2000, and TIFF formats 32-bit float (CV_32F) images can be saved in PFM, TIFF, OpenEXR, and Radiance HDR formats; 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel) PNG images with an alpha channel can be saved using this function. To do this, create 8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below). Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below). If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way. If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: @include snippets/imgcodecs_imwrite.cpp Python prototype (for reference): imwrite(filename, img[, params]) -&gt; retval","ref":"Evision.html#imwrite/2","title":"Evision.imwrite/2","type":"function"},{"doc":"Saves an image to a specified file. Positional Arguments filename : String . Name of the file. img : Evision.Mat . (Mat or vector of Mat) Image or Images to be saved. Keyword Arguments params : [int] . Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see cv::ImwriteFlags The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions). In general, only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions: 16-bit unsigned (CV_16U) images can be saved in the case of PNG, JPEG 2000, and TIFF formats 32-bit float (CV_32F) images can be saved in PFM, TIFF, OpenEXR, and Radiance HDR formats; 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel) PNG images with an alpha channel can be saved using this function. To do this, create 8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below). Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below). If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way. If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: @include snippets/imgcodecs_imwrite.cpp Python prototype (for reference): imwrite(filename, img[, params]) -&gt; retval","ref":"Evision.html#imwrite/3","title":"Evision.imwrite/3","type":"function"},{"doc":"Raising version of imwritemulti/2 .","ref":"Evision.html#imwritemulti!/2","title":"Evision.imwritemulti!/2","type":"function"},{"doc":"Raising version of imwritemulti/3 .","ref":"Evision.html#imwritemulti!/3","title":"Evision.imwritemulti!/3","type":"function"},{"doc":"Positional Arguments filename : String img : [Evision.Mat] Keyword Arguments params : [int] . Python prototype (for reference): imwritemulti(filename, img[, params]) -&gt; retval","ref":"Evision.html#imwritemulti/2","title":"Evision.imwritemulti/2","type":"function"},{"doc":"Positional Arguments filename : String img : [Evision.Mat] Keyword Arguments params : [int] . Python prototype (for reference): imwritemulti(filename, img[, params]) -&gt; retval","ref":"Evision.html#imwritemulti/3","title":"Evision.imwritemulti/3","type":"function"},{"doc":"Raising version of initCameraMatrix2D/3 .","ref":"Evision.html#initCameraMatrix2D!/3","title":"Evision.initCameraMatrix2D!/3","type":"function"},{"doc":"Raising version of initCameraMatrix2D/4 .","ref":"Evision.html#initCameraMatrix2D!/4","title":"Evision.initCameraMatrix2D!/4","type":"function"},{"doc":"Finds an initial camera intrinsic matrix from 3D-2D point correspondences. Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-view vectors are concatenated. See #calibrateCamera for details. imagePoints : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points. In the old interface all the per-view vectors are concatenated. imageSize : Size . Image size in pixels used to initialize the principal point. Keyword Arguments aspectRatio : double . If it is zero or negative, both \\f$f_x\\f$ and \\f$f_y\\f$ are estimated independently. Otherwise, \\f$f_x = f_y * \\texttt{aspectRatio}\\f$ . The function estimates and returns an initial camera intrinsic matrix for the camera calibration process. Currently, the function only supports planar calibration patterns, which are patterns where each object point has z-coordinate =0. Python prototype (for reference): initCameraMatrix2D(objectPoints, imagePoints, imageSize[, aspectRatio]) -&gt; retval","ref":"Evision.html#initCameraMatrix2D/3","title":"Evision.initCameraMatrix2D/3","type":"function"},{"doc":"Finds an initial camera intrinsic matrix from 3D-2D point correspondences. Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-view vectors are concatenated. See #calibrateCamera for details. imagePoints : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points. In the old interface all the per-view vectors are concatenated. imageSize : Size . Image size in pixels used to initialize the principal point. Keyword Arguments aspectRatio : double . If it is zero or negative, both \\f$f_x\\f$ and \\f$f_y\\f$ are estimated independently. Otherwise, \\f$f_x = f_y * \\texttt{aspectRatio}\\f$ . The function estimates and returns an initial camera intrinsic matrix for the camera calibration process. Currently, the function only supports planar calibration patterns, which are patterns where each object point has z-coordinate =0. Python prototype (for reference): initCameraMatrix2D(objectPoints, imagePoints, imageSize[, aspectRatio]) -&gt; retval","ref":"Evision.html#initCameraMatrix2D/4","title":"Evision.initCameraMatrix2D/4","type":"function"},{"doc":"Raising version of initInverseRectificationMap/6 .","ref":"Evision.html#initInverseRectificationMap!/6","title":"Evision.initInverseRectificationMap!/6","type":"function"},{"doc":"Raising version of initInverseRectificationMap/7 .","ref":"Evision.html#initInverseRectificationMap!/7","title":"Evision.initInverseRectificationMap!/7","type":"function"},{"doc":"Computes the projection and inverse-rectification transformation map. In essense, this is the inverse of #initUndistortRectifyMap to accomodate stereo-rectification of projectors ('inverse-cameras') in projector-camera pairs. Positional Arguments cameraMatrix : Evision.Mat . Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. r : Evision.Mat . Optional rectification transformation in the object space (3x3 matrix). R1 or R2, computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation is assumed. newCameraMatrix : Evision.Mat . New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$. size : Size . Distorted image size. m1type : int . Type of the first output map. Can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps Return map1 : Evision.Mat . The first output map for #remap. map2 : Evision.Mat . The second output map for #remap. The function computes the joint projection and inverse rectification transformation and represents the result in the form of maps for #remap. The projected image looks like a distorted version of the original which, once projected by a projector, should visually match the original. In case of a monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by #getOptimalNewCameraMatrix for a better control over scaling. In case of a projector-camera pair, newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify . The projector is oriented differently in the coordinate space, according to R. In case of projector-camera pairs, this helps align the projector (in the same manner as #initUndistortRectifyMap for the camera) to create a stereo-rectified pair. This allows epipolar lines on both images to become horizontal and have the same y-coordinate (in case of a horizontally aligned projector-camera pair). The function builds the maps for the inverse mapping algorithm that is used by #remap. That is, for each pixel \\f$(u, v)\\f$ in the destination (projected and inverse-rectified) image, the function computes the corresponding coordinates in the source image (that is, in the original digital image). The following process is applied: \\f[ \\begin{array}{l} \\text{newCameraMatrix}\\\\ x \\leftarrow (u - {c'}_x)/{f'}_x \\\\ y \\leftarrow (v - {c'}_y)/{f'}_y \\\\ \\\\\\text{Undistortion} \\\\\\scriptsize{\\textit{though equation shown is for radial undistortion, function implements cv::undistortPoints()}}\\\\ r^2 \\leftarrow x^2 + y^2 \\\\ \\theta \\leftarrow \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}\\\\ x' \\leftarrow \\frac{x}{\\theta} \\\\ y' \\leftarrow \\frac{y}{\\theta} \\\\ \\\\\\text{Rectification}\\\\ {[X\\,Y\\,W]} ^T \\leftarrow R*[x' \\, y' \\, 1]^T \\\\ x'' \\leftarrow X/W \\\\ y'' \\leftarrow Y/W \\\\ \\\\\\text{cameraMatrix}\\\\ map_x(u,v) \\leftarrow x'' f_x + c_x \\\\ map_y(u,v) \\leftarrow y'' f_y + c_y \\end{array} \\f] where \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ are the distortion coefficients vector distCoeffs. In case of a stereo-rectified projector-camera pair, this function is called for the projector while #initUndistortRectifyMap is called for the camera head. This is done after #stereoRectify, which in turn is called after #stereoCalibrate. If the projector-camera pair is not calibrated, it is still possible to compute the rectification transformations directly from the fundamental matrix using #stereoRectifyUncalibrated. For the projector and camera, the function computes homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D space. R can be computed from H as \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f] where cameraMatrix can be chosen arbitrarily. Python prototype (for reference): initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -&gt; map1, map2","ref":"Evision.html#initInverseRectificationMap/6","title":"Evision.initInverseRectificationMap/6","type":"function"},{"doc":"Computes the projection and inverse-rectification transformation map. In essense, this is the inverse of #initUndistortRectifyMap to accomodate stereo-rectification of projectors ('inverse-cameras') in projector-camera pairs. Positional Arguments cameraMatrix : Evision.Mat . Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. r : Evision.Mat . Optional rectification transformation in the object space (3x3 matrix). R1 or R2, computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation is assumed. newCameraMatrix : Evision.Mat . New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$. size : Size . Distorted image size. m1type : int . Type of the first output map. Can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps Return map1 : Evision.Mat . The first output map for #remap. map2 : Evision.Mat . The second output map for #remap. The function computes the joint projection and inverse rectification transformation and represents the result in the form of maps for #remap. The projected image looks like a distorted version of the original which, once projected by a projector, should visually match the original. In case of a monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by #getOptimalNewCameraMatrix for a better control over scaling. In case of a projector-camera pair, newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify . The projector is oriented differently in the coordinate space, according to R. In case of projector-camera pairs, this helps align the projector (in the same manner as #initUndistortRectifyMap for the camera) to create a stereo-rectified pair. This allows epipolar lines on both images to become horizontal and have the same y-coordinate (in case of a horizontally aligned projector-camera pair). The function builds the maps for the inverse mapping algorithm that is used by #remap. That is, for each pixel \\f$(u, v)\\f$ in the destination (projected and inverse-rectified) image, the function computes the corresponding coordinates in the source image (that is, in the original digital image). The following process is applied: \\f[ \\begin{array}{l} \\text{newCameraMatrix}\\\\ x \\leftarrow (u - {c'}_x)/{f'}_x \\\\ y \\leftarrow (v - {c'}_y)/{f'}_y \\\\ \\\\\\text{Undistortion} \\\\\\scriptsize{\\textit{though equation shown is for radial undistortion, function implements cv::undistortPoints()}}\\\\ r^2 \\leftarrow x^2 + y^2 \\\\ \\theta \\leftarrow \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}\\\\ x' \\leftarrow \\frac{x}{\\theta} \\\\ y' \\leftarrow \\frac{y}{\\theta} \\\\ \\\\\\text{Rectification}\\\\ {[X\\,Y\\,W]} ^T \\leftarrow R*[x' \\, y' \\, 1]^T \\\\ x'' \\leftarrow X/W \\\\ y'' \\leftarrow Y/W \\\\ \\\\\\text{cameraMatrix}\\\\ map_x(u,v) \\leftarrow x'' f_x + c_x \\\\ map_y(u,v) \\leftarrow y'' f_y + c_y \\end{array} \\f] where \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ are the distortion coefficients vector distCoeffs. In case of a stereo-rectified projector-camera pair, this function is called for the projector while #initUndistortRectifyMap is called for the camera head. This is done after #stereoRectify, which in turn is called after #stereoCalibrate. If the projector-camera pair is not calibrated, it is still possible to compute the rectification transformations directly from the fundamental matrix using #stereoRectifyUncalibrated. For the projector and camera, the function computes homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D space. R can be computed from H as \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f] where cameraMatrix can be chosen arbitrarily. Python prototype (for reference): initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -&gt; map1, map2","ref":"Evision.html#initInverseRectificationMap/7","title":"Evision.initInverseRectificationMap/7","type":"function"},{"doc":"Raising version of initUndistortRectifyMap/6 .","ref":"Evision.html#initUndistortRectifyMap!/6","title":"Evision.initUndistortRectifyMap!/6","type":"function"},{"doc":"Raising version of initUndistortRectifyMap/7 .","ref":"Evision.html#initUndistortRectifyMap!/7","title":"Evision.initUndistortRectifyMap!/7","type":"function"},{"doc":"Computes the undistortion and rectification transformation map. Positional Arguments cameraMatrix : Evision.Mat . Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. r : Evision.Mat . Optional rectification transformation in the object space (3x3 matrix). R1 or R2 , computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation is assumed. In cvInitUndistortMap R assumed to be an identity matrix. newCameraMatrix : Evision.Mat . New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$. size : Size . Undistorted image size. m1type : int . Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps Return map1 : Evision.Mat . The first output map. map2 : Evision.Mat . The second output map. The function computes the joint undistortion and rectification transformation and represents the result in the form of maps for #remap. The undistorted image looks like original, as if it is captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by #getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera, newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify . Also, this new camera is oriented differently in the coordinate space, according to R. That, for example, helps to align two heads of a stereo camera so that the epipolar lines on both images become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera). The function actually builds the maps for the inverse mapping algorithm that is used by #remap. That is, for each pixel \\f$(u, v)\\f$ in the destination (corrected and rectified) image, the function computes the corresponding coordinates in the source image (that is, in the original image from camera). The following process is applied: \\f[ \\begin{array}{l} x \\leftarrow (u - {c'}_x)/{f'}_x \\\\ y \\leftarrow (v - {c'}_y)/{f'}_y \\\\ {[X\\,Y\\,W]} ^T \\leftarrow R^{-1}*[x \\, y \\, 1]^T \\\\ x' \\leftarrow X/W \\\\ y' \\leftarrow Y/W \\\\ r^2 \\leftarrow x'^2 + y'^2 \\\\ x'' \\leftarrow x' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + 2p_1 x' y' + p_2(r^2 + 2 x'^2) + s_1 r^2 + s_2 r^4\\\\ y'' \\leftarrow y' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\\\ s\\vecthree{x'''}{y'''}{1} = \\vecthreethree{R_{33}(\\tau_x, \\tau_y)}{0}{-R_{13}((\\tau_x, \\tau_y)} {0}{R_{33}(\\tau_x, \\tau_y)}{-R_{23}(\\tau_x, \\tau_y)} {0}{0}{1} R(\\tau_x, \\tau_y) \\vecthree{x''}{y''}{1}\\\\ map_x(u,v) \\leftarrow x''' f_x + c_x \\\\ map_y(u,v) \\leftarrow y''' f_y + c_y \\end{array} \\f] where \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ are the distortion coefficients. In case of a stereo camera, this function is called twice: once for each camera head, after #stereoRectify, which in its turn is called after #stereoCalibrate. But if the stereo camera was not calibrated, it is still possible to compute the rectification transformations directly from the fundamental matrix using #stereoRectifyUncalibrated. For each camera, the function computes homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D space. R can be computed from H as \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f] where cameraMatrix can be chosen arbitrarily. Python prototype (for reference): initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -&gt; map1, map2","ref":"Evision.html#initUndistortRectifyMap/6","title":"Evision.initUndistortRectifyMap/6","type":"function"},{"doc":"Computes the undistortion and rectification transformation map. Positional Arguments cameraMatrix : Evision.Mat . Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. r : Evision.Mat . Optional rectification transformation in the object space (3x3 matrix). R1 or R2 , computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation is assumed. In cvInitUndistortMap R assumed to be an identity matrix. newCameraMatrix : Evision.Mat . New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$. size : Size . Undistorted image size. m1type : int . Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps Return map1 : Evision.Mat . The first output map. map2 : Evision.Mat . The second output map. The function computes the joint undistortion and rectification transformation and represents the result in the form of maps for #remap. The undistorted image looks like original, as if it is captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by #getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera, newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify . Also, this new camera is oriented differently in the coordinate space, according to R. That, for example, helps to align two heads of a stereo camera so that the epipolar lines on both images become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera). The function actually builds the maps for the inverse mapping algorithm that is used by #remap. That is, for each pixel \\f$(u, v)\\f$ in the destination (corrected and rectified) image, the function computes the corresponding coordinates in the source image (that is, in the original image from camera). The following process is applied: \\f[ \\begin{array}{l} x \\leftarrow (u - {c'}_x)/{f'}_x \\\\ y \\leftarrow (v - {c'}_y)/{f'}_y \\\\ {[X\\,Y\\,W]} ^T \\leftarrow R^{-1}*[x \\, y \\, 1]^T \\\\ x' \\leftarrow X/W \\\\ y' \\leftarrow Y/W \\\\ r^2 \\leftarrow x'^2 + y'^2 \\\\ x'' \\leftarrow x' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + 2p_1 x' y' + p_2(r^2 + 2 x'^2) + s_1 r^2 + s_2 r^4\\\\ y'' \\leftarrow y' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\\\ s\\vecthree{x'''}{y'''}{1} = \\vecthreethree{R_{33}(\\tau_x, \\tau_y)}{0}{-R_{13}((\\tau_x, \\tau_y)} {0}{R_{33}(\\tau_x, \\tau_y)}{-R_{23}(\\tau_x, \\tau_y)} {0}{0}{1} R(\\tau_x, \\tau_y) \\vecthree{x''}{y''}{1}\\\\ map_x(u,v) \\leftarrow x''' f_x + c_x \\\\ map_y(u,v) \\leftarrow y''' f_y + c_y \\end{array} \\f] where \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ are the distortion coefficients. In case of a stereo camera, this function is called twice: once for each camera head, after #stereoRectify, which in its turn is called after #stereoCalibrate. But if the stereo camera was not calibrated, it is still possible to compute the rectification transformations directly from the fundamental matrix using #stereoRectifyUncalibrated. For each camera, the function computes homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D space. R can be computed from H as \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f] where cameraMatrix can be chosen arbitrarily. Python prototype (for reference): initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -&gt; map1, map2","ref":"Evision.html#initUndistortRectifyMap/7","title":"Evision.initUndistortRectifyMap/7","type":"function"},{"doc":"Raising version of inpaint/4 .","ref":"Evision.html#inpaint!/4","title":"Evision.inpaint!/4","type":"function"},{"doc":"Raising version of inpaint/5 .","ref":"Evision.html#inpaint!/5","title":"Evision.inpaint!/5","type":"function"},{"doc":"Restores the selected region in an image using the region neighborhood. Positional Arguments src : Evision.Mat . Input 8-bit, 16-bit unsigned or 32-bit float 1-channel or 8-bit 3-channel image. inpaintMask : Evision.Mat . Inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted. inpaintRadius : double . Radius of a circular neighborhood of each point inpainted that is considered by the algorithm. flags : int . Inpainting method that could be cv::INPAINT_NS or cv::INPAINT_TELEA Return dst : Evision.Mat . Output image with the same size and type as src . The function reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video. See http://en.wikipedia.org/wiki/Inpainting for more details. Note : An example using the inpainting technique can be found at opencv_source_code/samples/cpp/inpaint.cpp (Python) An example using the inpainting technique can be found at opencv_source_code/samples/python/inpaint.py Python prototype (for reference): inpaint(src, inpaintMask, inpaintRadius, flags[, dst]) -&gt; dst","ref":"Evision.html#inpaint/4","title":"Evision.inpaint/4","type":"function"},{"doc":"Restores the selected region in an image using the region neighborhood. Positional Arguments src : Evision.Mat . Input 8-bit, 16-bit unsigned or 32-bit float 1-channel or 8-bit 3-channel image. inpaintMask : Evision.Mat . Inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted. inpaintRadius : double . Radius of a circular neighborhood of each point inpainted that is considered by the algorithm. flags : int . Inpainting method that could be cv::INPAINT_NS or cv::INPAINT_TELEA Return dst : Evision.Mat . Output image with the same size and type as src . The function reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video. See http://en.wikipedia.org/wiki/Inpainting for more details. Note : An example using the inpainting technique can be found at opencv_source_code/samples/cpp/inpaint.cpp (Python) An example using the inpainting technique can be found at opencv_source_code/samples/python/inpaint.py Python prototype (for reference): inpaint(src, inpaintMask, inpaintRadius, flags[, dst]) -&gt; dst","ref":"Evision.html#inpaint/5","title":"Evision.inpaint/5","type":"function"},{"doc":"Raising version of inRange/3 .","ref":"Evision.html#inRange!/3","title":"Evision.inRange!/3","type":"function"},{"doc":"Raising version of inRange/4 .","ref":"Evision.html#inRange!/4","title":"Evision.inRange!/4","type":"function"},{"doc":"Checks if array elements lie between the elements of two other arrays. Positional Arguments src : Evision.Mat . first input array. lowerb : Evision.Mat . inclusive lower boundary array or a scalar. upperb : Evision.Mat . inclusive upper boundary array or a scalar. Return dst : Evision.Mat . output array of the same size as src and CV_8U type. The function checks the range as follows: For every element of a single-channel input array: \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0 \\leq \\texttt{src} (I)_0 \\leq \\texttt{upperb} (I)_0\\f] For two-channel arrays: \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0 \\leq \\texttt{src} (I)_0 \\leq \\texttt{upperb} (I)_0 \\land \\texttt{lowerb} (I)_1 \\leq \\texttt{src} (I)_1 \\leq \\texttt{upperb} (I)_1\\f] and so forth. That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the specified 1D, 2D, 3D, ... box and 0 otherwise. When the lower and/or upper boundary parameters are scalars, the indexes (I) at lowerb and upperb in the above formulas should be omitted. Python prototype (for reference): inRange(src, lowerb, upperb[, dst]) -&gt; dst","ref":"Evision.html#inRange/3","title":"Evision.inRange/3","type":"function"},{"doc":"Checks if array elements lie between the elements of two other arrays. Positional Arguments src : Evision.Mat . first input array. lowerb : Evision.Mat . inclusive lower boundary array or a scalar. upperb : Evision.Mat . inclusive upper boundary array or a scalar. Return dst : Evision.Mat . output array of the same size as src and CV_8U type. The function checks the range as follows: For every element of a single-channel input array: \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0 \\leq \\texttt{src} (I)_0 \\leq \\texttt{upperb} (I)_0\\f] For two-channel arrays: \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0 \\leq \\texttt{src} (I)_0 \\leq \\texttt{upperb} (I)_0 \\land \\texttt{lowerb} (I)_1 \\leq \\texttt{src} (I)_1 \\leq \\texttt{upperb} (I)_1\\f] and so forth. That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the specified 1D, 2D, 3D, ... box and 0 otherwise. When the lower and/or upper boundary parameters are scalars, the indexes (I) at lowerb and upperb in the above formulas should be omitted. Python prototype (for reference): inRange(src, lowerb, upperb[, dst]) -&gt; dst","ref":"Evision.html#inRange/4","title":"Evision.inRange/4","type":"function"},{"doc":"Raising version of insertChannel/3 .","ref":"Evision.html#insertChannel!/3","title":"Evision.insertChannel!/3","type":"function"},{"doc":"Inserts a single channel to dst (coi is 0-based index) Positional Arguments src : Evision.Mat . input array coi : int . index of channel for insertion Return dst : Evision.Mat . output array @sa mixChannels, merge Python prototype (for reference): insertChannel(src, dst, coi) -&gt; dst","ref":"Evision.html#insertChannel/3","title":"Evision.insertChannel/3","type":"function"},{"doc":"Raising version of integral2/1 .","ref":"Evision.html#integral2!/1","title":"Evision.integral2!/1","type":"function"},{"doc":"Raising version of integral2/2 .","ref":"Evision.html#integral2!/2","title":"Evision.integral2!/2","type":"function"},{"doc":"Positional Arguments src : Evision.Mat Keyword Arguments sdepth : int . sqdepth : int . Return sum : Evision.Mat . sqsum : Evision.Mat . Has overloading in C++ Python prototype (for reference): integral2(src[, sum[, sqsum[, sdepth[, sqdepth]]]]) -&gt; sum, sqsum","ref":"Evision.html#integral2/1","title":"Evision.integral2/1","type":"function"},{"doc":"Positional Arguments src : Evision.Mat Keyword Arguments sdepth : int . sqdepth : int . Return sum : Evision.Mat . sqsum : Evision.Mat . Has overloading in C++ Python prototype (for reference): integral2(src[, sum[, sqsum[, sdepth[, sqdepth]]]]) -&gt; sum, sqsum","ref":"Evision.html#integral2/2","title":"Evision.integral2/2","type":"function"},{"doc":"Raising version of integral3/1 .","ref":"Evision.html#integral3!/1","title":"Evision.integral3!/1","type":"function"},{"doc":"Raising version of integral3/2 .","ref":"Evision.html#integral3!/2","title":"Evision.integral3!/2","type":"function"},{"doc":"Calculates the integral of an image. Positional Arguments src : Evision.Mat . input image as \\f$W \\times H\\f$, 8-bit or floating-point (32f or 64f). Keyword Arguments sdepth : int . desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F. sqdepth : int . desired depth of the integral image of squared pixel values, CV_32F or CV_64F. Return sum : Evision.Mat . integral image as \\f$(W+1)\\times (H+1)\\f$ , 32-bit integer or floating-point (32f or 64f). sqsum : Evision.Mat . integral image for squared pixel values; it is \\f$(W+1)\\times (H+1)\\f$, double-precision floating-point (64f) array. tilted : Evision.Mat . integral for the image rotated by 45 degrees; it is \\f$(W+1)\\times (H+1)\\f$ array with the same data type as sum. The function calculates one or more integral images for the source image as follows: \\f[\\texttt{sum} (X,Y) = \\sum _{x&lt;X,y&lt;Y} \\texttt{image} (x,y)\\f] \\f[\\texttt{sqsum} (X,Y) = \\sum _{x&lt;X,y&lt;Y} \\texttt{image} (x,y)^2\\f] \\f[\\texttt{tilted} (X,Y) = \\sum _{y&lt;Y,abs(x-X+1) \\leq Y-y-1} \\texttt{image} (x,y)\\f] Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-right or rotated rectangular region of the image in a constant time, for example: \\f[\\sum _{x_1 \\leq x &lt; x_2, \\, y_1 \\leq y &lt; y_2} \\texttt{image} (x,y) = \\texttt{sum} (x_2,y_2)- \\texttt{sum} (x_1,y_2)- \\texttt{sum} (x_2,y_1)+ \\texttt{sum} (x_1,y_1)\\f] It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-channel images, sums for each channel are accumulated independently. As a practical example, the next figure shows the calculation of the integral of a straight rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the original image are shown, as well as the relative pixels in the integral images sum and tilted . Python prototype (for reference): integral3(src[, sum[, sqsum[, tilted[, sdepth[, sqdepth]]]]]) -&gt; sum, sqsum, tilted","ref":"Evision.html#integral3/1","title":"Evision.integral3/1","type":"function"},{"doc":"Calculates the integral of an image. Positional Arguments src : Evision.Mat . input image as \\f$W \\times H\\f$, 8-bit or floating-point (32f or 64f). Keyword Arguments sdepth : int . desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F. sqdepth : int . desired depth of the integral image of squared pixel values, CV_32F or CV_64F. Return sum : Evision.Mat . integral image as \\f$(W+1)\\times (H+1)\\f$ , 32-bit integer or floating-point (32f or 64f). sqsum : Evision.Mat . integral image for squared pixel values; it is \\f$(W+1)\\times (H+1)\\f$, double-precision floating-point (64f) array. tilted : Evision.Mat . integral for the image rotated by 45 degrees; it is \\f$(W+1)\\times (H+1)\\f$ array with the same data type as sum. The function calculates one or more integral images for the source image as follows: \\f[\\texttt{sum} (X,Y) = \\sum _{x&lt;X,y&lt;Y} \\texttt{image} (x,y)\\f] \\f[\\texttt{sqsum} (X,Y) = \\sum _{x&lt;X,y&lt;Y} \\texttt{image} (x,y)^2\\f] \\f[\\texttt{tilted} (X,Y) = \\sum _{y&lt;Y,abs(x-X+1) \\leq Y-y-1} \\texttt{image} (x,y)\\f] Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-right or rotated rectangular region of the image in a constant time, for example: \\f[\\sum _{x_1 \\leq x &lt; x_2, \\, y_1 \\leq y &lt; y_2} \\texttt{image} (x,y) = \\texttt{sum} (x_2,y_2)- \\texttt{sum} (x_1,y_2)- \\texttt{sum} (x_2,y_1)+ \\texttt{sum} (x_1,y_1)\\f] It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-channel images, sums for each channel are accumulated independently. As a practical example, the next figure shows the calculation of the integral of a straight rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the original image are shown, as well as the relative pixels in the integral images sum and tilted . Python prototype (for reference): integral3(src[, sum[, sqsum[, tilted[, sdepth[, sqdepth]]]]]) -&gt; sum, sqsum, tilted","ref":"Evision.html#integral3/2","title":"Evision.integral3/2","type":"function"},{"doc":"Raising version of integral/1 .","ref":"Evision.html#integral!/1","title":"Evision.integral!/1","type":"function"},{"doc":"Raising version of integral/2 .","ref":"Evision.html#integral!/2","title":"Evision.integral!/2","type":"function"},{"doc":"Positional Arguments src : Evision.Mat Keyword Arguments sdepth : int . Return sum : Evision.Mat . Has overloading in C++ Python prototype (for reference): integral(src[, sum[, sdepth]]) -&gt; sum","ref":"Evision.html#integral/1","title":"Evision.integral/1","type":"function"},{"doc":"Positional Arguments src : Evision.Mat Keyword Arguments sdepth : int . Return sum : Evision.Mat . Has overloading in C++ Python prototype (for reference): integral(src[, sum[, sdepth]]) -&gt; sum","ref":"Evision.html#integral/2","title":"Evision.integral/2","type":"function"},{"doc":"Raising version of intersectConvexConvex/2 .","ref":"Evision.html#intersectConvexConvex!/2","title":"Evision.intersectConvexConvex!/2","type":"function"},{"doc":"Raising version of intersectConvexConvex/3 .","ref":"Evision.html#intersectConvexConvex!/3","title":"Evision.intersectConvexConvex!/3","type":"function"},{"doc":"Finds intersection of two convex polygons Positional Arguments p1 : Evision.Mat . First polygon p2 : Evision.Mat . Second polygon Keyword Arguments handleNested : bool . When true, an intersection is found if one of the polygons is fully enclosed in the other. When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested. Return p12 : Evision.Mat . Output polygon describing the intersecting area @returns Absolute value of area of intersecting polygon Note : intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't. Python prototype (for reference): intersectConvexConvex(p1, p2[, p12[, handleNested]]) -&gt; retval, p12","ref":"Evision.html#intersectConvexConvex/2","title":"Evision.intersectConvexConvex/2","type":"function"},{"doc":"Finds intersection of two convex polygons Positional Arguments p1 : Evision.Mat . First polygon p2 : Evision.Mat . Second polygon Keyword Arguments handleNested : bool . When true, an intersection is found if one of the polygons is fully enclosed in the other. When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested. Return p12 : Evision.Mat . Output polygon describing the intersecting area @returns Absolute value of area of intersecting polygon Note : intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't. Python prototype (for reference): intersectConvexConvex(p1, p2[, p12[, handleNested]]) -&gt; retval, p12","ref":"Evision.html#intersectConvexConvex/3","title":"Evision.intersectConvexConvex/3","type":"function"},{"doc":"Raising version of invert/1 .","ref":"Evision.html#invert!/1","title":"Evision.invert!/1","type":"function"},{"doc":"Raising version of invert/2 .","ref":"Evision.html#invert!/2","title":"Evision.invert!/2","type":"function"},{"doc":"Finds the inverse or pseudo-inverse of a matrix. Positional Arguments src : Evision.Mat . input floating-point M x N matrix. Keyword Arguments flags : int . inversion method (cv::DecompTypes) Return dst : Evision.Mat . output matrix of N x M size and the same type as src. The function cv::invert inverts the matrix src and stores the result in dst . When the matrix src is singular or non-square, the function calculates the pseudo-inverse matrix (the dst matrix) so that norm(src*dst - I) is minimal, where I is an identity matrix. In case of the #DECOMP_LU method, the function returns non-zero value if the inverse has been successfully calculated and 0 if src is singular. In case of the #DECOMP_SVD method, the function returns the inverse condition number of src (the ratio of the smallest singular value to the largest singular value) and 0 if src is singular. The SVD method calculates a pseudo-inverse matrix if src is singular. Similarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with non-singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in dst and returns non-zero. Otherwise, it returns 0. @sa solve, SVD Python prototype (for reference): invert(src[, dst[, flags]]) -&gt; retval, dst","ref":"Evision.html#invert/1","title":"Evision.invert/1","type":"function"},{"doc":"Finds the inverse or pseudo-inverse of a matrix. Positional Arguments src : Evision.Mat . input floating-point M x N matrix. Keyword Arguments flags : int . inversion method (cv::DecompTypes) Return dst : Evision.Mat . output matrix of N x M size and the same type as src. The function cv::invert inverts the matrix src and stores the result in dst . When the matrix src is singular or non-square, the function calculates the pseudo-inverse matrix (the dst matrix) so that norm(src*dst - I) is minimal, where I is an identity matrix. In case of the #DECOMP_LU method, the function returns non-zero value if the inverse has been successfully calculated and 0 if src is singular. In case of the #DECOMP_SVD method, the function returns the inverse condition number of src (the ratio of the smallest singular value to the largest singular value) and 0 if src is singular. The SVD method calculates a pseudo-inverse matrix if src is singular. Similarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with non-singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in dst and returns non-zero. Otherwise, it returns 0. @sa solve, SVD Python prototype (for reference): invert(src[, dst[, flags]]) -&gt; retval, dst","ref":"Evision.html#invert/2","title":"Evision.invert/2","type":"function"},{"doc":"Raising version of invertAffineTransform/1 .","ref":"Evision.html#invertAffineTransform!/1","title":"Evision.invertAffineTransform!/1","type":"function"},{"doc":"Raising version of invertAffineTransform/2 .","ref":"Evision.html#invertAffineTransform!/2","title":"Evision.invertAffineTransform!/2","type":"function"},{"doc":"Inverts an affine transformation. Positional Arguments m : Evision.Mat . Original affine transformation. Return iM : Evision.Mat . Output reverse affine transformation. The function computes an inverse affine transformation represented by \\f$2 \\times 3\\f$ matrix M: \\f[\\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1 \\\\ a_{21} &amp; a_{22} &amp; b_2 \\end{bmatrix}\\f] The result is also a \\f$2 \\times 3\\f$ matrix of the same type as M. Python prototype (for reference): invertAffineTransform(M[, iM]) -&gt; iM","ref":"Evision.html#invertAffineTransform/1","title":"Evision.invertAffineTransform/1","type":"function"},{"doc":"Inverts an affine transformation. Positional Arguments m : Evision.Mat . Original affine transformation. Return iM : Evision.Mat . Output reverse affine transformation. The function computes an inverse affine transformation represented by \\f$2 \\times 3\\f$ matrix M: \\f[\\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1 \\\\ a_{21} &amp; a_{22} &amp; b_2 \\end{bmatrix}\\f] The result is also a \\f$2 \\times 3\\f$ matrix of the same type as M. Python prototype (for reference): invertAffineTransform(M[, iM]) -&gt; iM","ref":"Evision.html#invertAffineTransform/2","title":"Evision.invertAffineTransform/2","type":"function"},{"doc":"Raising version of isContourConvex/1 .","ref":"Evision.html#isContourConvex!/1","title":"Evision.isContourConvex!/1","type":"function"},{"doc":"Tests a contour convexity. Positional Arguments contour : Evision.Mat . Input vector of 2D points, stored in std::vector\\&lt;&gt; or Mat The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-intersections. Otherwise, the function output is undefined. Python prototype (for reference): isContourConvex(contour) -&gt; retval","ref":"Evision.html#isContourConvex/1","title":"Evision.isContourConvex/1","type":"function"},{"doc":"Raising version of kmeans/6 .","ref":"Evision.html#kmeans!/6","title":"Evision.kmeans!/6","type":"function"},{"doc":"Raising version of kmeans/7 .","ref":"Evision.html#kmeans!/7","title":"Evision.kmeans!/7","type":"function"},{"doc":"Finds centers of clusters and groups input samples around the clusters. Positional Arguments data : Evision.Mat . Data for clustering. An array of N-Dimensional points with float coordinates is needed. Examples of this array can be: Mat points(count, 2, CV_32F); Mat points(count, 1, CV_32FC2); Mat points(1, count, CV_32FC2); std::vector\\&lt;cv::Point2f&gt; points(sampleCount); k : int . Number of clusters to split the set by. criteria : TermCriteria . The algorithm termination criteria, that is, the maximum number of iterations and/or the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster centers moves by less than criteria.epsilon on some iteration, the algorithm stops. attempts : int . Flag to specify the number of times the algorithm is executed using different initial labellings. The algorithm returns the labels that yield the best compactness (see the last function parameter). flags : int . Flag that can take values of cv::KmeansFlags Return bestLabels : Evision.Mat . Input/output integer array that stores the cluster indices for every sample. centers : Evision.Mat . Output matrix of the cluster centers, one row per each cluster center. The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters and groups the input samples around the clusters. As an output, \\f$\\texttt{bestLabels}_i\\f$ contains a 0-based cluster index for the sample stored in the \\f$i^{th}\\f$ row of the samples matrix. Note : (Python) An example on K-means clustering can be found at opencv_source_code/samples/python/kmeans.py @return The function returns the compactness measure that is computed as \\f[\\sum _i \\| \\texttt{samples} _i - \\texttt{centers} _{ \\texttt{labels} _i} \\| ^2\\f] after every attempt. The best (minimum) value is chosen and the corresponding labels and the compactness value are returned by the function. Basically, you can use only the core of the function, set the number of attempts to 1, initialize labels each time using a custom algorithm, pass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best (most-compact) clustering. Python prototype (for reference): kmeans(data, K, bestLabels, criteria, attempts, flags[, centers]) -&gt; retval, bestLabels, centers","ref":"Evision.html#kmeans/6","title":"Evision.kmeans/6","type":"function"},{"doc":"Finds centers of clusters and groups input samples around the clusters. Positional Arguments data : Evision.Mat . Data for clustering. An array of N-Dimensional points with float coordinates is needed. Examples of this array can be: Mat points(count, 2, CV_32F); Mat points(count, 1, CV_32FC2); Mat points(1, count, CV_32FC2); std::vector\\&lt;cv::Point2f&gt; points(sampleCount); k : int . Number of clusters to split the set by. criteria : TermCriteria . The algorithm termination criteria, that is, the maximum number of iterations and/or the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster centers moves by less than criteria.epsilon on some iteration, the algorithm stops. attempts : int . Flag to specify the number of times the algorithm is executed using different initial labellings. The algorithm returns the labels that yield the best compactness (see the last function parameter). flags : int . Flag that can take values of cv::KmeansFlags Return bestLabels : Evision.Mat . Input/output integer array that stores the cluster indices for every sample. centers : Evision.Mat . Output matrix of the cluster centers, one row per each cluster center. The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters and groups the input samples around the clusters. As an output, \\f$\\texttt{bestLabels}_i\\f$ contains a 0-based cluster index for the sample stored in the \\f$i^{th}\\f$ row of the samples matrix. Note : (Python) An example on K-means clustering can be found at opencv_source_code/samples/python/kmeans.py @return The function returns the compactness measure that is computed as \\f[\\sum _i \\| \\texttt{samples} _i - \\texttt{centers} _{ \\texttt{labels} _i} \\| ^2\\f] after every attempt. The best (minimum) value is chosen and the corresponding labels and the compactness value are returned by the function. Basically, you can use only the core of the function, set the number of attempts to 1, initialize labels each time using a custom algorithm, pass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best (most-compact) clustering. Python prototype (for reference): kmeans(data, K, bestLabels, criteria, attempts, flags[, centers]) -&gt; retval, bestLabels, centers","ref":"Evision.html#kmeans/7","title":"Evision.kmeans/7","type":"function"},{"doc":"Raising version of laplacian/2 .","ref":"Evision.html#laplacian!/2","title":"Evision.laplacian!/2","type":"function"},{"doc":"Raising version of laplacian/3 .","ref":"Evision.html#laplacian!/3","title":"Evision.laplacian!/3","type":"function"},{"doc":"Calculates the Laplacian of an image. Positional Arguments src : Evision.Mat . Source image. ddepth : int . Desired depth of the destination image. Keyword Arguments ksize : int . Aperture size used to compute the second-derivative filters. See #getDerivKernels for details. The size must be positive and odd. scale : double . Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See #getDerivKernels for details. delta : double . Optional delta value that is added to the results prior to storing them in dst . borderType : int . Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Destination image of the same size and the same number of channels as src . The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator: \\f[\\texttt{dst} = \\Delta \\texttt{src} = \\frac{\\partial^2 \\texttt{src}}{\\partial x^2} + \\frac{\\partial^2 \\texttt{src}}{\\partial y^2}\\f] This is done when ksize &gt; 1 . When ksize == 1 , the Laplacian is computed by filtering the image with the following \\f$3 \\times 3\\f$ aperture: \\f[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\f] @sa Sobel, Scharr Python prototype (for reference): Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]]) -&gt; dst","ref":"Evision.html#laplacian/2","title":"Evision.laplacian/2","type":"function"},{"doc":"Calculates the Laplacian of an image. Positional Arguments src : Evision.Mat . Source image. ddepth : int . Desired depth of the destination image. Keyword Arguments ksize : int . Aperture size used to compute the second-derivative filters. See #getDerivKernels for details. The size must be positive and odd. scale : double . Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See #getDerivKernels for details. delta : double . Optional delta value that is added to the results prior to storing them in dst . borderType : int . Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Destination image of the same size and the same number of channels as src . The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator: \\f[\\texttt{dst} = \\Delta \\texttt{src} = \\frac{\\partial^2 \\texttt{src}}{\\partial x^2} + \\frac{\\partial^2 \\texttt{src}}{\\partial y^2}\\f] This is done when ksize &gt; 1 . When ksize == 1 , the Laplacian is computed by filtering the image with the following \\f$3 \\times 3\\f$ aperture: \\f[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\f] @sa Sobel, Scharr Python prototype (for reference): Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]]) -&gt; dst","ref":"Evision.html#laplacian/3","title":"Evision.laplacian/3","type":"function"},{"doc":"Raising version of line/4 .","ref":"Evision.html#line!/4","title":"Evision.line!/4","type":"function"},{"doc":"Raising version of line/5 .","ref":"Evision.html#line!/5","title":"Evision.line!/5","type":"function"},{"doc":"Draws a line segment connecting two points. Positional Arguments pt1 : Point . First point of the line segment. pt2 : Point . Second point of the line segment. color : Scalar . Line color. Keyword Arguments thickness : int . Line thickness. lineType : int . Type of the line. See #LineTypes. shift : int . Number of fractional bits in the point coordinates. Return img : Evision.Mat . Image. The function line draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering. Python prototype (for reference): line(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#line/4","title":"Evision.line/4","type":"function"},{"doc":"Draws a line segment connecting two points. Positional Arguments pt1 : Point . First point of the line segment. pt2 : Point . Second point of the line segment. color : Scalar . Line color. Keyword Arguments thickness : int . Line thickness. lineType : int . Type of the line. See #LineTypes. shift : int . Number of fractional bits in the point coordinates. Return img : Evision.Mat . Image. The function line draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering. Python prototype (for reference): line(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#line/5","title":"Evision.line/5","type":"function"},{"doc":"Raising version of linearPolar/4 .","ref":"Evision.html#linearPolar!/4","title":"Evision.linearPolar!/4","type":"function"},{"doc":"Raising version of linearPolar/5 .","ref":"Evision.html#linearPolar!/5","title":"Evision.linearPolar!/5","type":"function"},{"doc":"Remaps an image to polar coordinates space. Positional Arguments src : Evision.Mat . Source image center : Point2f . The transformation center; maxRadius : double . The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too. flags : int . A combination of interpolation methods, see #InterpolationFlags Return dst : Evision.Mat . Destination image. It will have same size and type as src. @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags) @internal Transform the source image using the following transformation (See @ref polar_remaps_reference_image &quot;Polar remaps reference image c)&quot;): \\f[\\begin{array}{l} dst( \\rho , \\phi ) = src(x,y) \\\\ dst.size() \\leftarrow src.size() \\end{array}\\f] where \\f[\\begin{array}{l} I = (dx,dy) = (x - center.x,y - center.y) \\\\ \\rho = Kmag \\cdot \\texttt{magnitude} (I) ,\\\\ \\phi = angle \\cdot \\texttt{angle} (I) \\end{array}\\f] and \\f[\\begin{array}{l} Kx = src.cols / maxRadius \\\\ Ky = src.rows / 2\\Pi \\end{array}\\f] Note : The function can not operate in-place. To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees. @sa cv::logPolar @endinternal Python prototype (for reference): linearPolar(src, center, maxRadius, flags[, dst]) -&gt; dst","ref":"Evision.html#linearPolar/4","title":"Evision.linearPolar/4","type":"function"},{"doc":"Remaps an image to polar coordinates space. Positional Arguments src : Evision.Mat . Source image center : Point2f . The transformation center; maxRadius : double . The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too. flags : int . A combination of interpolation methods, see #InterpolationFlags Return dst : Evision.Mat . Destination image. It will have same size and type as src. @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags) @internal Transform the source image using the following transformation (See @ref polar_remaps_reference_image &quot;Polar remaps reference image c)&quot;): \\f[\\begin{array}{l} dst( \\rho , \\phi ) = src(x,y) \\\\ dst.size() \\leftarrow src.size() \\end{array}\\f] where \\f[\\begin{array}{l} I = (dx,dy) = (x - center.x,y - center.y) \\\\ \\rho = Kmag \\cdot \\texttt{magnitude} (I) ,\\\\ \\phi = angle \\cdot \\texttt{angle} (I) \\end{array}\\f] and \\f[\\begin{array}{l} Kx = src.cols / maxRadius \\\\ Ky = src.rows / 2\\Pi \\end{array}\\f] Note : The function can not operate in-place. To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees. @sa cv::logPolar @endinternal Python prototype (for reference): linearPolar(src, center, maxRadius, flags[, dst]) -&gt; dst","ref":"Evision.html#linearPolar/5","title":"Evision.linearPolar/5","type":"function"},{"doc":"Raising version of log/1 .","ref":"Evision.html#log!/1","title":"Evision.log!/1","type":"function"},{"doc":"Raising version of log/2 .","ref":"Evision.html#log!/2","title":"Evision.log!/2","type":"function"},{"doc":"Calculates the natural logarithm of every array element. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array of the same size and type as src . The function cv::log calculates the natural logarithm of every element of the input array: \\f[\\texttt{dst} (I) = \\log (\\texttt{src}(I)) \\f] Output on zero, negative and special (NaN, Inf) values is undefined. @sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude Python prototype (for reference): log(src[, dst]) -&gt; dst","ref":"Evision.html#log/1","title":"Evision.log/1","type":"function"},{"doc":"Calculates the natural logarithm of every array element. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array of the same size and type as src . The function cv::log calculates the natural logarithm of every element of the input array: \\f[\\texttt{dst} (I) = \\log (\\texttt{src}(I)) \\f] Output on zero, negative and special (NaN, Inf) values is undefined. @sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude Python prototype (for reference): log(src[, dst]) -&gt; dst","ref":"Evision.html#log/2","title":"Evision.log/2","type":"function"},{"doc":"Raising version of logPolar/4 .","ref":"Evision.html#logPolar!/4","title":"Evision.logPolar!/4","type":"function"},{"doc":"Raising version of logPolar/5 .","ref":"Evision.html#logPolar!/5","title":"Evision.logPolar!/5","type":"function"},{"doc":"Remaps an image to semilog-polar coordinates space. Positional Arguments src : Evision.Mat . Source image center : Point2f . The transformation center; where the output precision is maximal m : double . Magnitude scale parameter. It determines the radius of the bounding circle to transform too. flags : int . A combination of interpolation methods, see #InterpolationFlags Return dst : Evision.Mat . Destination image. It will have same size and type as src. @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG); @internal Transform the source image using the following transformation (See @ref polar_remaps_reference_image &quot;Polar remaps reference image d)&quot;): \\f[\\begin{array}{l} dst( \\rho , \\phi ) = src(x,y) \\\\ dst.size() \\leftarrow src.size() \\end{array}\\f] where \\f[\\begin{array}{l} I = (dx,dy) = (x - center.x,y - center.y) \\\\ \\rho = M \\cdot log_e(\\texttt{magnitude} (I)) ,\\\\ \\phi = Kangle \\cdot \\texttt{angle} (I) \\\\ \\end{array}\\f] and \\f[\\begin{array}{l} M = src.cols / log_e(maxRadius) \\\\ Kangle = src.rows / 2\\Pi \\\\ \\end{array}\\f] The function emulates the human &quot;foveal&quot; vision and can be used for fast scale and rotation-invariant template matching, for object tracking and so forth. Note : The function can not operate in-place. To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees. @sa cv::linearPolar @endinternal Python prototype (for reference): logPolar(src, center, M, flags[, dst]) -&gt; dst","ref":"Evision.html#logPolar/4","title":"Evision.logPolar/4","type":"function"},{"doc":"Remaps an image to semilog-polar coordinates space. Positional Arguments src : Evision.Mat . Source image center : Point2f . The transformation center; where the output precision is maximal m : double . Magnitude scale parameter. It determines the radius of the bounding circle to transform too. flags : int . A combination of interpolation methods, see #InterpolationFlags Return dst : Evision.Mat . Destination image. It will have same size and type as src. @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG); @internal Transform the source image using the following transformation (See @ref polar_remaps_reference_image &quot;Polar remaps reference image d)&quot;): \\f[\\begin{array}{l} dst( \\rho , \\phi ) = src(x,y) \\\\ dst.size() \\leftarrow src.size() \\end{array}\\f] where \\f[\\begin{array}{l} I = (dx,dy) = (x - center.x,y - center.y) \\\\ \\rho = M \\cdot log_e(\\texttt{magnitude} (I)) ,\\\\ \\phi = Kangle \\cdot \\texttt{angle} (I) \\\\ \\end{array}\\f] and \\f[\\begin{array}{l} M = src.cols / log_e(maxRadius) \\\\ Kangle = src.rows / 2\\Pi \\\\ \\end{array}\\f] The function emulates the human &quot;foveal&quot; vision and can be used for fast scale and rotation-invariant template matching, for object tracking and so forth. Note : The function can not operate in-place. To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees. @sa cv::linearPolar @endinternal Python prototype (for reference): logPolar(src, center, M, flags[, dst]) -&gt; dst","ref":"Evision.html#logPolar/5","title":"Evision.logPolar/5","type":"function"},{"doc":"Raising version of lut/2 .","ref":"Evision.html#lut!/2","title":"Evision.lut!/2","type":"function"},{"doc":"Raising version of lut/3 .","ref":"Evision.html#lut!/3","title":"Evision.lut!/3","type":"function"},{"doc":"Performs a look-up table transform of an array. Positional Arguments src : Evision.Mat . input array of 8-bit elements. lut : Evision.Mat . look-up table of 256 elements; in case of multi-channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input array. Return dst : Evision.Mat . output array of the same size and number of channels as src, and the same depth as lut. The function LUT fills the output array with values from the look-up table. Indices of the entries are taken from the input array. That is, the function processes each element of src as follows: \\f[\\texttt{dst} (I) \\leftarrow \\texttt{lut(src(I) + d)}\\f] where \\f[d = \\fork{0}{if (\\texttt{src}) has depth (\\texttt{CV_8U})}{128}{if (\\texttt{src}) has depth (\\texttt{CV_8S})}\\f] @sa convertScaleAbs, Mat::convertTo Python prototype (for reference): LUT(src, lut[, dst]) -&gt; dst","ref":"Evision.html#lut/2","title":"Evision.lut/2","type":"function"},{"doc":"Performs a look-up table transform of an array. Positional Arguments src : Evision.Mat . input array of 8-bit elements. lut : Evision.Mat . look-up table of 256 elements; in case of multi-channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input array. Return dst : Evision.Mat . output array of the same size and number of channels as src, and the same depth as lut. The function LUT fills the output array with values from the look-up table. Indices of the entries are taken from the input array. That is, the function processes each element of src as follows: \\f[\\texttt{dst} (I) \\leftarrow \\texttt{lut(src(I) + d)}\\f] where \\f[d = \\fork{0}{if (\\texttt{src}) has depth (\\texttt{CV_8U})}{128}{if (\\texttt{src}) has depth (\\texttt{CV_8S})}\\f] @sa convertScaleAbs, Mat::convertTo Python prototype (for reference): LUT(src, lut[, dst]) -&gt; dst","ref":"Evision.html#lut/3","title":"Evision.lut/3","type":"function"},{"doc":"Raising version of magnitude/2 .","ref":"Evision.html#magnitude!/2","title":"Evision.magnitude!/2","type":"function"},{"doc":"Raising version of magnitude/3 .","ref":"Evision.html#magnitude!/3","title":"Evision.magnitude!/3","type":"function"},{"doc":"Calculates the magnitude of 2D vectors. Positional Arguments x : Evision.Mat . floating-point array of x-coordinates of the vectors. y : Evision.Mat . floating-point array of y-coordinates of the vectors; it must have the same size as x. Return magnitude : Evision.Mat . output array of the same size and type as x. The function cv::magnitude calculates the magnitude of 2D vectors formed from the corresponding elements of x and y arrays: \\f[\\texttt{dst} (I) = \\sqrt{\\texttt{x}(I)^2 + \\texttt{y}(I)^2}\\f] @sa cartToPolar, polarToCart, phase, sqrt Python prototype (for reference): magnitude(x, y[, magnitude]) -&gt; magnitude","ref":"Evision.html#magnitude/2","title":"Evision.magnitude/2","type":"function"},{"doc":"Calculates the magnitude of 2D vectors. Positional Arguments x : Evision.Mat . floating-point array of x-coordinates of the vectors. y : Evision.Mat . floating-point array of y-coordinates of the vectors; it must have the same size as x. Return magnitude : Evision.Mat . output array of the same size and type as x. The function cv::magnitude calculates the magnitude of 2D vectors formed from the corresponding elements of x and y arrays: \\f[\\texttt{dst} (I) = \\sqrt{\\texttt{x}(I)^2 + \\texttt{y}(I)^2}\\f] @sa cartToPolar, polarToCart, phase, sqrt Python prototype (for reference): magnitude(x, y[, magnitude]) -&gt; magnitude","ref":"Evision.html#magnitude/3","title":"Evision.magnitude/3","type":"function"},{"doc":"Raising version of mahalanobis/3 .","ref":"Evision.html#mahalanobis!/3","title":"Evision.mahalanobis!/3","type":"function"},{"doc":"Calculates the Mahalanobis distance between two vectors. Positional Arguments v1 : Evision.Mat . first 1D input vector. v2 : Evision.Mat . second 1D input vector. icovar : Evision.Mat . inverse covariance matrix. The function cv::Mahalanobis calculates and returns the weighted distance between two vectors: \\f[d( \\texttt{vec1} , \\texttt{vec2} )= \\sqrt{\\sum_{i,j}{\\texttt{icovar(i,j)}\\cdot(\\texttt{vec1}(I)-\\texttt{vec2}(I))\\cdot(\\texttt{vec1(j)}-\\texttt{vec2(j)})} }\\f] The covariance matrix may be calculated using the #calcCovarMatrix function and then inverted using the invert function (preferably using the #DECOMP_SVD method, as the most accurate). Python prototype (for reference): Mahalanobis(v1, v2, icovar) -&gt; retval","ref":"Evision.html#mahalanobis/3","title":"Evision.mahalanobis/3","type":"function"},{"doc":"Raising version of matchShapes/4 .","ref":"Evision.html#matchShapes!/4","title":"Evision.matchShapes!/4","type":"function"},{"doc":"Compares two shapes. Positional Arguments contour1 : Evision.Mat . First contour or grayscale image. contour2 : Evision.Mat . Second contour or grayscale image. method : int . Comparison method, see #ShapeMatchModes parameter : double . Method-specific parameter (not supported now). The function compares two shapes. All three implemented methods use the Hu invariants (see #HuMoments) Python prototype (for reference): matchShapes(contour1, contour2, method, parameter) -&gt; retval","ref":"Evision.html#matchShapes/4","title":"Evision.matchShapes/4","type":"function"},{"doc":"Raising version of matchTemplate/3 .","ref":"Evision.html#matchTemplate!/3","title":"Evision.matchTemplate!/3","type":"function"},{"doc":"Raising version of matchTemplate/4 .","ref":"Evision.html#matchTemplate!/4","title":"Evision.matchTemplate!/4","type":"function"},{"doc":"Compares a template against overlapped image regions. Positional Arguments image : Evision.Mat . Image where the search is running. It must be 8-bit or 32-bit floating-point. templ : Evision.Mat . Searched template. It must be not greater than the source image and have the same data type. method : int . Parameter specifying the comparison method, see #TemplateMatchModes Keyword Arguments mask : Evision.Mat . Optional mask. It must have the same size as templ. It must either have the same number of channels as template or only one channel, which is then used for all template and image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask, meaning only elements where mask is nonzero are used and are kept unchanged independent of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are used as weights. The exact formulas are documented in #TemplateMatchModes. Return result : Evision.Mat . Map of comparison results. It must be single-channel 32-bit floating-point. If image is \\f$W \\times H\\f$ and templ is \\f$w \\times h\\f$ , then result is \\f$(W-w+1) \\times (H-h+1)\\f$ . The function slides through image , compares the overlapped patches of size \\f$w \\times h\\f$ against templ using the specified method and stores the comparison results in result . #TemplateMatchModes describes the formulae for the available comparison methods ( \\f$I\\f$ denotes image, \\f$T\\f$ template, \\f$R\\f$ result, \\f$M\\f$ the optional mask ). The summation is done over template and/or the image patch: \\f$x' = 0...w-1, y' = 0...h-1\\f$ After the function finishes the comparison, the best matches can be found as global minimums (when #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in the denominator is done over all of the channels and separate mean values are used for each channel. That is, the function can take a color template and a color image. The result will still be a single-channel image, which is easier to analyze. Python prototype (for reference): matchTemplate(image, templ, method[, result[, mask]]) -&gt; result","ref":"Evision.html#matchTemplate/3","title":"Evision.matchTemplate/3","type":"function"},{"doc":"Compares a template against overlapped image regions. Positional Arguments image : Evision.Mat . Image where the search is running. It must be 8-bit or 32-bit floating-point. templ : Evision.Mat . Searched template. It must be not greater than the source image and have the same data type. method : int . Parameter specifying the comparison method, see #TemplateMatchModes Keyword Arguments mask : Evision.Mat . Optional mask. It must have the same size as templ. It must either have the same number of channels as template or only one channel, which is then used for all template and image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask, meaning only elements where mask is nonzero are used and are kept unchanged independent of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are used as weights. The exact formulas are documented in #TemplateMatchModes. Return result : Evision.Mat . Map of comparison results. It must be single-channel 32-bit floating-point. If image is \\f$W \\times H\\f$ and templ is \\f$w \\times h\\f$ , then result is \\f$(W-w+1) \\times (H-h+1)\\f$ . The function slides through image , compares the overlapped patches of size \\f$w \\times h\\f$ against templ using the specified method and stores the comparison results in result . #TemplateMatchModes describes the formulae for the available comparison methods ( \\f$I\\f$ denotes image, \\f$T\\f$ template, \\f$R\\f$ result, \\f$M\\f$ the optional mask ). The summation is done over template and/or the image patch: \\f$x' = 0...w-1, y' = 0...h-1\\f$ After the function finishes the comparison, the best matches can be found as global minimums (when #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in the denominator is done over all of the channels and separate mean values are used for each channel. That is, the function can take a color template and a color image. The result will still be a single-channel image, which is easier to analyze. Python prototype (for reference): matchTemplate(image, templ, method[, result[, mask]]) -&gt; result","ref":"Evision.html#matchTemplate/4","title":"Evision.matchTemplate/4","type":"function"},{"doc":"Raising version of matMulDeriv/2 .","ref":"Evision.html#matMulDeriv!/2","title":"Evision.matMulDeriv!/2","type":"function"},{"doc":"Raising version of matMulDeriv/3 .","ref":"Evision.html#matMulDeriv!/3","title":"Evision.matMulDeriv!/3","type":"function"},{"doc":"Computes partial derivatives of the matrix product for each multiplied matrix. Positional Arguments a : Evision.Mat . First multiplied matrix. b : Evision.Mat . Second multiplied matrix. Return dABdA : Evision.Mat . First output derivative matrix d(A*B)/dA of size \\f$\\texttt{A.rows B.cols} \\times {A.rows A.cols}\\f$ . dABdB : Evision.Mat . Second output derivative matrix d(A*B)/dB of size \\f$\\texttt{A.rows B.cols} \\times {B.rows B.cols}\\f$ . The function computes partial derivatives of the elements of the matrix product \\f$A*B\\f$ with regard to the elements of each of the two input matrices. The function is used to compute the Jacobian matrices in #stereoCalibrate but can also be used in any other similar optimization function. Python prototype (for reference): matMulDeriv(A, B[, dABdA[, dABdB]]) -&gt; dABdA, dABdB","ref":"Evision.html#matMulDeriv/2","title":"Evision.matMulDeriv/2","type":"function"},{"doc":"Computes partial derivatives of the matrix product for each multiplied matrix. Positional Arguments a : Evision.Mat . First multiplied matrix. b : Evision.Mat . Second multiplied matrix. Return dABdA : Evision.Mat . First output derivative matrix d(A*B)/dA of size \\f$\\texttt{A.rows B.cols} \\times {A.rows A.cols}\\f$ . dABdB : Evision.Mat . Second output derivative matrix d(A*B)/dB of size \\f$\\texttt{A.rows B.cols} \\times {B.rows B.cols}\\f$ . The function computes partial derivatives of the elements of the matrix product \\f$A*B\\f$ with regard to the elements of each of the two input matrices. The function is used to compute the Jacobian matrices in #stereoCalibrate but can also be used in any other similar optimization function. Python prototype (for reference): matMulDeriv(A, B[, dABdA[, dABdB]]) -&gt; dABdA, dABdB","ref":"Evision.html#matMulDeriv/3","title":"Evision.matMulDeriv/3","type":"function"},{"doc":"Raising version of max/2 .","ref":"Evision.html#max!/2","title":"Evision.max!/2","type":"function"},{"doc":"Raising version of max/3 .","ref":"Evision.html#max!/3","title":"Evision.max!/3","type":"function"},{"doc":"Calculates per-element maximum of two arrays or an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and type as src1 . Return dst : Evision.Mat . output array of the same size and type as src1. The function cv::max calculates the per-element maximum of two arrays: \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{src2} (I))\\f] or array and a scalar: \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{value} )\\f] @sa min, compare, inRange, minMaxLoc, @ref MatrixExpressions Python prototype (for reference): max(src1, src2[, dst]) -&gt; dst","ref":"Evision.html#max/2","title":"Evision.max/2","type":"function"},{"doc":"Calculates per-element maximum of two arrays or an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and type as src1 . Return dst : Evision.Mat . output array of the same size and type as src1. The function cv::max calculates the per-element maximum of two arrays: \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{src2} (I))\\f] or array and a scalar: \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{value} )\\f] @sa min, compare, inRange, minMaxLoc, @ref MatrixExpressions Python prototype (for reference): max(src1, src2[, dst]) -&gt; dst","ref":"Evision.html#max/3","title":"Evision.max/3","type":"function"},{"doc":"Raising version of mean/1 .","ref":"Evision.html#mean!/1","title":"Evision.mean!/1","type":"function"},{"doc":"Raising version of mean/2 .","ref":"Evision.html#mean!/2","title":"Evision.mean!/2","type":"function"},{"doc":"Calculates an average (mean) of array elements. Positional Arguments src : Evision.Mat . input array that should have from 1 to 4 channels so that the result can be stored in Scalar_ . Keyword Arguments mask : Evision.Mat . optional operation mask. The function cv::mean calculates the mean value M of array elements, independently for each channel, and return it: \\f[\\begin{array}{l} N = \\sum _{I: \\; \\texttt{mask} (I) \\ne 0} 1 \\\\ M_c = \\left ( \\sum _{I: \\; \\texttt{mask} (I) \\ne 0}{ \\texttt{mtx} (I)_c} \\right )/N \\end{array}\\f] When all the mask elements are 0's, the function returns Scalar::all(0) @sa countNonZero, meanStdDev, norm, minMaxLoc Python prototype (for reference): mean(src[, mask]) -&gt; retval","ref":"Evision.html#mean/1","title":"Evision.mean/1","type":"function"},{"doc":"Calculates an average (mean) of array elements. Positional Arguments src : Evision.Mat . input array that should have from 1 to 4 channels so that the result can be stored in Scalar_ . Keyword Arguments mask : Evision.Mat . optional operation mask. The function cv::mean calculates the mean value M of array elements, independently for each channel, and return it: \\f[\\begin{array}{l} N = \\sum _{I: \\; \\texttt{mask} (I) \\ne 0} 1 \\\\ M_c = \\left ( \\sum _{I: \\; \\texttt{mask} (I) \\ne 0}{ \\texttt{mtx} (I)_c} \\right )/N \\end{array}\\f] When all the mask elements are 0's, the function returns Scalar::all(0) @sa countNonZero, meanStdDev, norm, minMaxLoc Python prototype (for reference): mean(src[, mask]) -&gt; retval","ref":"Evision.html#mean/2","title":"Evision.mean/2","type":"function"},{"doc":"Raising version of meanShift/3 .","ref":"Evision.html#meanShift!/3","title":"Evision.meanShift!/3","type":"function"},{"doc":"Finds an object on a back projection image. Positional Arguments probImage : Evision.Mat . Back projection of the object histogram. See calcBackProject for details. criteria : TermCriteria . Stop criteria for the iterative search algorithm. returns : Number of iterations CAMSHIFT took to converge. The function implements the iterative object search algorithm. It takes the input back projection of an object and the initial position. The mass center in window of the back projection image is computed and the search window center shifts to the mass center. The procedure is repeated until the specified number of iterations criteria.maxCount is done or until the window center shifts by less than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search window size or orientation do not change during the search. You can simply pass the output of calcBackProject to this function. But better results can be obtained if you pre-filter the back projection and remove the noise. For example, you can do this by retrieving connected components with findContours , throwing away contours with small area ( contourArea ), and rendering the remaining contours with drawContours. Return window : Rect . Initial search window. Python prototype (for reference): meanShift(probImage, window, criteria) -&gt; retval, window","ref":"Evision.html#meanShift/3","title":"Evision.meanShift/3","type":"function"},{"doc":"Raising version of meanStdDev/1 .","ref":"Evision.html#meanStdDev!/1","title":"Evision.meanStdDev!/1","type":"function"},{"doc":"Raising version of meanStdDev/2 .","ref":"Evision.html#meanStdDev!/2","title":"Evision.meanStdDev!/2","type":"function"},{"doc":"Positional Arguments src : Evision.Mat . input array that should have from 1 to 4 channels so that the results can be stored in Scalar_ 's. Keyword Arguments mask : Evision.Mat . optional operation mask. Return mean : Evision.Mat . output parameter: calculated mean value. stddev : Evision.Mat . output parameter: calculated standard deviation. Calculates a mean and standard deviation of array elements. The function cv::meanStdDev calculates the mean and the standard deviation M of array elements independently for each channel and returns it via the output parameters: \\f[\\begin{array}{l} N = \\sum _{I, \\texttt{mask} (I) \\ne 0} 1 \\\\ \\texttt{mean} _c = \\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\texttt{src} (I)_c}{N} \\\\ \\texttt{stddev} _c = \\sqrt{\\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\left ( \\texttt{src} (I)_c - \\texttt{mean} _c \\right )^2}{N}} \\end{array}\\f] When all the mask elements are 0's, the function returns mean=stddev=Scalar::all(0). Note : The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-channel array M x N to the single-channel array M*N x mtx.channels() (only possible when the matrix is continuous) and then pass the matrix to calcCovarMatrix . @sa countNonZero, mean, norm, minMaxLoc, calcCovarMatrix Python prototype (for reference): meanStdDev(src[, mean[, stddev[, mask]]]) -&gt; mean, stddev","ref":"Evision.html#meanStdDev/1","title":"Evision.meanStdDev/1","type":"function"},{"doc":"Positional Arguments src : Evision.Mat . input array that should have from 1 to 4 channels so that the results can be stored in Scalar_ 's. Keyword Arguments mask : Evision.Mat . optional operation mask. Return mean : Evision.Mat . output parameter: calculated mean value. stddev : Evision.Mat . output parameter: calculated standard deviation. Calculates a mean and standard deviation of array elements. The function cv::meanStdDev calculates the mean and the standard deviation M of array elements independently for each channel and returns it via the output parameters: \\f[\\begin{array}{l} N = \\sum _{I, \\texttt{mask} (I) \\ne 0} 1 \\\\ \\texttt{mean} _c = \\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\texttt{src} (I)_c}{N} \\\\ \\texttt{stddev} _c = \\sqrt{\\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\left ( \\texttt{src} (I)_c - \\texttt{mean} _c \\right )^2}{N}} \\end{array}\\f] When all the mask elements are 0's, the function returns mean=stddev=Scalar::all(0). Note : The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-channel array M x N to the single-channel array M*N x mtx.channels() (only possible when the matrix is continuous) and then pass the matrix to calcCovarMatrix . @sa countNonZero, mean, norm, minMaxLoc, calcCovarMatrix Python prototype (for reference): meanStdDev(src[, mean[, stddev[, mask]]]) -&gt; mean, stddev","ref":"Evision.html#meanStdDev/2","title":"Evision.meanStdDev/2","type":"function"},{"doc":"Raising version of medianBlur/2 .","ref":"Evision.html#medianBlur!/2","title":"Evision.medianBlur!/2","type":"function"},{"doc":"Raising version of medianBlur/3 .","ref":"Evision.html#medianBlur!/3","title":"Evision.medianBlur!/3","type":"function"},{"doc":"Blurs an image using the median filter. Positional Arguments src : Evision.Mat . input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U. ksize : int . aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ... Return dst : Evision.Mat . destination array of the same size and type as src. The function smoothes an image using the median filter with the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ aperture. Each channel of a multi-channel image is processed independently. In-place operation is supported. Note : The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes @sa bilateralFilter, blur, boxFilter, GaussianBlur Python prototype (for reference): medianBlur(src, ksize[, dst]) -&gt; dst","ref":"Evision.html#medianBlur/2","title":"Evision.medianBlur/2","type":"function"},{"doc":"Blurs an image using the median filter. Positional Arguments src : Evision.Mat . input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U. ksize : int . aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ... Return dst : Evision.Mat . destination array of the same size and type as src. The function smoothes an image using the median filter with the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ aperture. Each channel of a multi-channel image is processed independently. In-place operation is supported. Note : The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes @sa bilateralFilter, blur, boxFilter, GaussianBlur Python prototype (for reference): medianBlur(src, ksize[, dst]) -&gt; dst","ref":"Evision.html#medianBlur/3","title":"Evision.medianBlur/3","type":"function"},{"doc":"Raising version of merge/1 .","ref":"Evision.html#merge!/1","title":"Evision.merge!/1","type":"function"},{"doc":"Raising version of merge/2 .","ref":"Evision.html#merge!/2","title":"Evision.merge!/2","type":"function"},{"doc":"Positional Arguments mv : [Evision.Mat] . input vector of matrices to be merged; all the matrices in mv must have the same size and the same depth. Return dst : Evision.Mat . output array of the same size and the same depth as mv[0]; The number of channels will be the total number of channels in the matrix array. Has overloading in C++ Python prototype (for reference): merge(mv[, dst]) -&gt; dst","ref":"Evision.html#merge/1","title":"Evision.merge/1","type":"function"},{"doc":"Positional Arguments mv : [Evision.Mat] . input vector of matrices to be merged; all the matrices in mv must have the same size and the same depth. Return dst : Evision.Mat . output array of the same size and the same depth as mv[0]; The number of channels will be the total number of channels in the matrix array. Has overloading in C++ Python prototype (for reference): merge(mv[, dst]) -&gt; dst","ref":"Evision.html#merge/2","title":"Evision.merge/2","type":"function"},{"doc":"Raising version of min/2 .","ref":"Evision.html#min!/2","title":"Evision.min!/2","type":"function"},{"doc":"Raising version of min/3 .","ref":"Evision.html#min!/3","title":"Evision.min!/3","type":"function"},{"doc":"Calculates per-element minimum of two arrays or an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and type as src1. Return dst : Evision.Mat . output array of the same size and type as src1. The function cv::min calculates the per-element minimum of two arrays: \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{src2} (I))\\f] or array and a scalar: \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{value} )\\f] @sa max, compare, inRange, minMaxLoc Python prototype (for reference): min(src1, src2[, dst]) -&gt; dst","ref":"Evision.html#min/2","title":"Evision.min/2","type":"function"},{"doc":"Calculates per-element minimum of two arrays or an array and a scalar. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and type as src1. Return dst : Evision.Mat . output array of the same size and type as src1. The function cv::min calculates the per-element minimum of two arrays: \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{src2} (I))\\f] or array and a scalar: \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{value} )\\f] @sa max, compare, inRange, minMaxLoc Python prototype (for reference): min(src1, src2[, dst]) -&gt; dst","ref":"Evision.html#min/3","title":"Evision.min/3","type":"function"},{"doc":"Raising version of minAreaRect/1 .","ref":"Evision.html#minAreaRect!/1","title":"Evision.minAreaRect!/1","type":"function"},{"doc":"Finds a rotated rectangle of the minimum area enclosing the input 2D point set. Positional Arguments points : Evision.Mat . Input vector of 2D points, stored in std::vector\\&lt;&gt; or Mat The function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a specified point set. Developer should keep in mind that the returned RotatedRect can contain negative indices when data is close to the containing Mat element boundary. Python prototype (for reference): minAreaRect(points) -&gt; retval","ref":"Evision.html#minAreaRect/1","title":"Evision.minAreaRect/1","type":"function"},{"doc":"Raising version of minEnclosingCircle/1 .","ref":"Evision.html#minEnclosingCircle!/1","title":"Evision.minEnclosingCircle!/1","type":"function"},{"doc":"Finds a circle of the minimum area enclosing a 2D point set. Positional Arguments points : Evision.Mat . Input vector of 2D points, stored in std::vector\\&lt;&gt; or Mat Return center : Point2f . Output center of the circle. radius : float . Output radius of the circle. The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm. Python prototype (for reference): minEnclosingCircle(points) -&gt; center, radius","ref":"Evision.html#minEnclosingCircle/1","title":"Evision.minEnclosingCircle/1","type":"function"},{"doc":"Raising version of minEnclosingTriangle/1 .","ref":"Evision.html#minEnclosingTriangle!/1","title":"Evision.minEnclosingTriangle!/1","type":"function"},{"doc":"Raising version of minEnclosingTriangle/2 .","ref":"Evision.html#minEnclosingTriangle!/2","title":"Evision.minEnclosingTriangle!/2","type":"function"},{"doc":"Finds a triangle of minimum area enclosing a 2D point set and returns its area. Positional Arguments points : Evision.Mat . Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\\&lt;&gt; or Mat Return triangle : Evision.Mat . Output vector of three 2D points defining the vertices of the triangle. The depth of the OutputArray must be CV_32F. The function finds a triangle of minimum area enclosing the given set of 2D points and returns its area. The output for a given 2D point set is shown in the image below. 2D points are depicted in red and the enclosing triangle in yellow*. The implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's @cite KleeLaskowski85 papers. O'Rourke provides a \\f$\\theta(n)\\f$ algorithm for finding the minimal enclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function takes a 2D point set as input an additional preprocessing step of computing the convex hull of the 2D point set is required. The complexity of the #convexHull function is \\f$O(n log(n))\\f$ which is higher than \\f$\\theta(n)\\f$. Thus the overall complexity of the function is \\f$O(n log(n))\\f$. Python prototype (for reference): minEnclosingTriangle(points[, triangle]) -&gt; retval, triangle","ref":"Evision.html#minEnclosingTriangle/1","title":"Evision.minEnclosingTriangle/1","type":"function"},{"doc":"Finds a triangle of minimum area enclosing a 2D point set and returns its area. Positional Arguments points : Evision.Mat . Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\\&lt;&gt; or Mat Return triangle : Evision.Mat . Output vector of three 2D points defining the vertices of the triangle. The depth of the OutputArray must be CV_32F. The function finds a triangle of minimum area enclosing the given set of 2D points and returns its area. The output for a given 2D point set is shown in the image below. 2D points are depicted in red and the enclosing triangle in yellow*. The implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's @cite KleeLaskowski85 papers. O'Rourke provides a \\f$\\theta(n)\\f$ algorithm for finding the minimal enclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function takes a 2D point set as input an additional preprocessing step of computing the convex hull of the 2D point set is required. The complexity of the #convexHull function is \\f$O(n log(n))\\f$ which is higher than \\f$\\theta(n)\\f$. Thus the overall complexity of the function is \\f$O(n log(n))\\f$. Python prototype (for reference): minEnclosingTriangle(points[, triangle]) -&gt; retval, triangle","ref":"Evision.html#minEnclosingTriangle/2","title":"Evision.minEnclosingTriangle/2","type":"function"},{"doc":"Raising version of minMaxLoc/1 .","ref":"Evision.html#minMaxLoc!/1","title":"Evision.minMaxLoc!/1","type":"function"},{"doc":"Raising version of minMaxLoc/2 .","ref":"Evision.html#minMaxLoc!/2","title":"Evision.minMaxLoc!/2","type":"function"},{"doc":"Finds the global minimum and maximum in an array. Positional Arguments src : Evision.Mat . input single-channel array. Keyword Arguments mask : Evision.Mat . optional mask used to select a sub-array. Return minVal : double* . pointer to the returned minimum value; NULL is used if not required. maxVal : double* . pointer to the returned maximum value; NULL is used if not required. minLoc : Point* . pointer to the returned minimum location (in 2D case); NULL is used if not required. maxLoc : Point* . pointer to the returned maximum location (in 2D case); NULL is used if not required. The function cv::minMaxLoc finds the minimum and maximum element values and their positions. The extremums are searched across the whole array or, if mask is not an empty array, in the specified array region. The function do not work with multi-channel arrays. If you need to find minimum or maximum elements across all the channels, use Mat::reshape first to reinterpret the array as single-channel. Or you may extract the particular channel using either extractImageCOI , or mixChannels , or split . @sa max, min, reduceArgMin, reduceArgMax, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape Python prototype (for reference): minMaxLoc(src[, mask]) -&gt; minVal, maxVal, minLoc, maxLoc","ref":"Evision.html#minMaxLoc/1","title":"Evision.minMaxLoc/1","type":"function"},{"doc":"Finds the global minimum and maximum in an array. Positional Arguments src : Evision.Mat . input single-channel array. Keyword Arguments mask : Evision.Mat . optional mask used to select a sub-array. Return minVal : double* . pointer to the returned minimum value; NULL is used if not required. maxVal : double* . pointer to the returned maximum value; NULL is used if not required. minLoc : Point* . pointer to the returned minimum location (in 2D case); NULL is used if not required. maxLoc : Point* . pointer to the returned maximum location (in 2D case); NULL is used if not required. The function cv::minMaxLoc finds the minimum and maximum element values and their positions. The extremums are searched across the whole array or, if mask is not an empty array, in the specified array region. The function do not work with multi-channel arrays. If you need to find minimum or maximum elements across all the channels, use Mat::reshape first to reinterpret the array as single-channel. Or you may extract the particular channel using either extractImageCOI , or mixChannels , or split . @sa max, min, reduceArgMin, reduceArgMax, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape Python prototype (for reference): minMaxLoc(src[, mask]) -&gt; minVal, maxVal, minLoc, maxLoc","ref":"Evision.html#minMaxLoc/2","title":"Evision.minMaxLoc/2","type":"function"},{"doc":"Raising version of mixChannels/3 .","ref":"Evision.html#mixChannels!/3","title":"Evision.mixChannels!/3","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] . input array or vector of matrices; all of the matrices must have the same size and the same depth. fromTo : [int] . array of index pairs specifying which channels are copied and where; fromTo[k*2] is a 0-based index of the input channel in src, fromTo[k*2+1] is an index of the output channel in dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to src[0].channels()-1, the second input image channels are indexed from src[0].channels() to src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image channels; as a special case, when fromTo[k*2] is negative, the corresponding output channel is filled with zero . Return dst : [Evision.Mat] . output array or vector of matrices; all the matrices must be allocated ; their size and depth must be the same as in src[0]. Has overloading in C++ Python prototype (for reference): mixChannels(src, dst, fromTo) -&gt; dst","ref":"Evision.html#mixChannels/3","title":"Evision.mixChannels/3","type":"function"},{"doc":"Raising version of moments/1 .","ref":"Evision.html#moments!/1","title":"Evision.moments!/1","type":"function"},{"doc":"Raising version of moments/2 .","ref":"Evision.html#moments!/2","title":"Evision.moments!/2","type":"function"},{"doc":"Calculates all of the moments up to the third order of a polygon or rasterized shape. Positional Arguments array : Evision.Mat . Raster image (single-channel, 8-bit or floating-point 2D array) or an array ( \\f$1 \\times N\\f$ or \\f$N \\times 1\\f$ ) of 2D points (Point or Point2f ). Keyword Arguments binaryImage : bool . If it is true, all non-zero image pixels are treated as 1's. The parameter is used for images only. The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The results are returned in the structure cv::Moments. @returns moments. Note : Only applicable to contour moments calculations from Python bindings: Note that the numpy type for the input array should be either np.int32 or np.float32. @sa contourArea, arcLength Python prototype (for reference): moments(array[, binaryImage]) -&gt; retval","ref":"Evision.html#moments/1","title":"Evision.moments/1","type":"function"},{"doc":"Calculates all of the moments up to the third order of a polygon or rasterized shape. Positional Arguments array : Evision.Mat . Raster image (single-channel, 8-bit or floating-point 2D array) or an array ( \\f$1 \\times N\\f$ or \\f$N \\times 1\\f$ ) of 2D points (Point or Point2f ). Keyword Arguments binaryImage : bool . If it is true, all non-zero image pixels are treated as 1's. The parameter is used for images only. The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The results are returned in the structure cv::Moments. @returns moments. Note : Only applicable to contour moments calculations from Python bindings: Note that the numpy type for the input array should be either np.int32 or np.float32. @sa contourArea, arcLength Python prototype (for reference): moments(array[, binaryImage]) -&gt; retval","ref":"Evision.html#moments/2","title":"Evision.moments/2","type":"function"},{"doc":"Raising version of morphologyEx/3 .","ref":"Evision.html#morphologyEx!/3","title":"Evision.morphologyEx!/3","type":"function"},{"doc":"Raising version of morphologyEx/4 .","ref":"Evision.html#morphologyEx!/4","title":"Evision.morphologyEx!/4","type":"function"},{"doc":"Performs advanced morphological transformations. Positional Arguments src : Evision.Mat . Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. op : int . Type of a morphological operation, see #MorphTypes kernel : Evision.Mat . Structuring element. It can be created using #getStructuringElement. Keyword Arguments anchor : Point . Anchor position with the kernel. Negative values mean that the anchor is at the kernel center. iterations : int . Number of times erosion and dilation are applied. borderType : int . Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. borderValue : Scalar . Border value in case of a constant border. The default value has a special meaning. Return dst : Evision.Mat . Destination image of the same size and type as source image. The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations. Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently. @sa dilate, erode, getStructuringElement Note : The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). Python prototype (for reference): morphologyEx(src, op, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -&gt; dst","ref":"Evision.html#morphologyEx/3","title":"Evision.morphologyEx/3","type":"function"},{"doc":"Performs advanced morphological transformations. Positional Arguments src : Evision.Mat . Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. op : int . Type of a morphological operation, see #MorphTypes kernel : Evision.Mat . Structuring element. It can be created using #getStructuringElement. Keyword Arguments anchor : Point . Anchor position with the kernel. Negative values mean that the anchor is at the kernel center. iterations : int . Number of times erosion and dilation are applied. borderType : int . Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. borderValue : Scalar . Border value in case of a constant border. The default value has a special meaning. Return dst : Evision.Mat . Destination image of the same size and type as source image. The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations. Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently. @sa dilate, erode, getStructuringElement Note : The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). Python prototype (for reference): morphologyEx(src, op, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -&gt; dst","ref":"Evision.html#morphologyEx/4","title":"Evision.morphologyEx/4","type":"function"},{"doc":"Raising version of moveWindow/3 .","ref":"Evision.html#moveWindow!/3","title":"Evision.moveWindow!/3","type":"function"},{"doc":"Moves the window to the specified position Positional Arguments winname : String . Name of the window. x : int . The new x-coordinate of the window. y : int . The new y-coordinate of the window. Python prototype (for reference): moveWindow(winname, x, y) -&gt; None","ref":"Evision.html#moveWindow/3","title":"Evision.moveWindow/3","type":"function"},{"doc":"Raising version of mulSpectrums/3 .","ref":"Evision.html#mulSpectrums!/3","title":"Evision.mulSpectrums!/3","type":"function"},{"doc":"Raising version of mulSpectrums/4 .","ref":"Evision.html#mulSpectrums!/4","title":"Evision.mulSpectrums!/4","type":"function"},{"doc":"Performs the per-element multiplication of two Fourier spectrums. Positional Arguments a : Evision.Mat . first input array. b : Evision.Mat . second input array of the same size and type as src1 . flags : int . operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a 0 as value. Keyword Arguments conjB : bool . optional flag that conjugates the second input array before the multiplication (true) or not (false). Return c : Evision.Mat . output array of the same size and type as src1 . The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex matrices that are results of a real or complex Fourier transform. The function, together with dft and idft , may be used to calculate convolution (pass conjB=false ) or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-array elements. When the arrays are real, they are assumed to be CCS-packed (see dft for details). Python prototype (for reference): mulSpectrums(a, b, flags[, c[, conjB]]) -&gt; c","ref":"Evision.html#mulSpectrums/3","title":"Evision.mulSpectrums/3","type":"function"},{"doc":"Performs the per-element multiplication of two Fourier spectrums. Positional Arguments a : Evision.Mat . first input array. b : Evision.Mat . second input array of the same size and type as src1 . flags : int . operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a 0 as value. Keyword Arguments conjB : bool . optional flag that conjugates the second input array before the multiplication (true) or not (false). Return c : Evision.Mat . output array of the same size and type as src1 . The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex matrices that are results of a real or complex Fourier transform. The function, together with dft and idft , may be used to calculate convolution (pass conjB=false ) or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-array elements. When the arrays are real, they are assumed to be CCS-packed (see dft for details). Python prototype (for reference): mulSpectrums(a, b, flags[, c[, conjB]]) -&gt; c","ref":"Evision.html#mulSpectrums/4","title":"Evision.mulSpectrums/4","type":"function"},{"doc":"Raising version of mulTransposed/2 .","ref":"Evision.html#mulTransposed!/2","title":"Evision.mulTransposed!/2","type":"function"},{"doc":"Raising version of mulTransposed/3 .","ref":"Evision.html#mulTransposed!/3","title":"Evision.mulTransposed!/3","type":"function"},{"doc":"Calculates the product of a matrix and its transposition. Positional Arguments src : Evision.Mat . input single-channel matrix. Note that unlike gemm, the function can multiply not only floating-point matrices. aTa : bool . Flag specifying the multiplication ordering. See the description below. Keyword Arguments delta : Evision.Mat . Optional delta matrix subtracted from src before the multiplication. When the matrix is empty ( delta=noArray() ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as src , it is simply subtracted. Otherwise, it is &quot;repeated&quot; (see repeat ) to cover the full src and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the dtype parameter description below. scale : double . Optional scale factor for the matrix product. dtype : int . Optional type of the output matrix. When it is negative, the output matrix will have the same type as src . Otherwise, it will be type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F . Return dst : Evision.Mat . output square matrix. The function cv::mulTransposed calculates the product of src and its transposition: \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} )^T ( \\texttt{src} - \\texttt{delta} )\\f] if aTa=true , and \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} ) ( \\texttt{src} - \\texttt{delta} )^T\\f] otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product A*B when B=A' @sa calcCovarMatrix, gemm, repeat, reduce Python prototype (for reference): mulTransposed(src, aTa[, dst[, delta[, scale[, dtype]]]]) -&gt; dst","ref":"Evision.html#mulTransposed/2","title":"Evision.mulTransposed/2","type":"function"},{"doc":"Calculates the product of a matrix and its transposition. Positional Arguments src : Evision.Mat . input single-channel matrix. Note that unlike gemm, the function can multiply not only floating-point matrices. aTa : bool . Flag specifying the multiplication ordering. See the description below. Keyword Arguments delta : Evision.Mat . Optional delta matrix subtracted from src before the multiplication. When the matrix is empty ( delta=noArray() ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as src , it is simply subtracted. Otherwise, it is &quot;repeated&quot; (see repeat ) to cover the full src and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the dtype parameter description below. scale : double . Optional scale factor for the matrix product. dtype : int . Optional type of the output matrix. When it is negative, the output matrix will have the same type as src . Otherwise, it will be type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F . Return dst : Evision.Mat . output square matrix. The function cv::mulTransposed calculates the product of src and its transposition: \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} )^T ( \\texttt{src} - \\texttt{delta} )\\f] if aTa=true , and \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} ) ( \\texttt{src} - \\texttt{delta} )^T\\f] otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product A*B when B=A' @sa calcCovarMatrix, gemm, repeat, reduce Python prototype (for reference): mulTransposed(src, aTa[, dst[, delta[, scale[, dtype]]]]) -&gt; dst","ref":"Evision.html#mulTransposed/3","title":"Evision.mulTransposed/3","type":"function"},{"doc":"Raising version of multiply/2 .","ref":"Evision.html#multiply!/2","title":"Evision.multiply!/2","type":"function"},{"doc":"Raising version of multiply/3 .","ref":"Evision.html#multiply!/3","title":"Evision.multiply!/3","type":"function"},{"doc":"Calculates the per-element scaled product of two arrays. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and the same type as src1. Keyword Arguments scale : double . optional scale factor. dtype : int . optional depth of the output array Return dst : Evision.Mat . output array of the same size and type as src1. The function multiply calculates the per-element product of two arrays: \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{scale} \\cdot \\texttt{src1} (I) \\cdot \\texttt{src2} (I))\\f] There is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul . For a not-per-element matrix product, see gemm . Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare, Mat::convertTo Python prototype (for reference): multiply(src1, src2[, dst[, scale[, dtype]]]) -&gt; dst","ref":"Evision.html#multiply/2","title":"Evision.multiply/2","type":"function"},{"doc":"Calculates the per-element scaled product of two arrays. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and the same type as src1. Keyword Arguments scale : double . optional scale factor. dtype : int . optional depth of the output array Return dst : Evision.Mat . output array of the same size and type as src1. The function multiply calculates the per-element product of two arrays: \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{scale} \\cdot \\texttt{src1} (I) \\cdot \\texttt{src2} (I))\\f] There is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul . For a not-per-element matrix product, see gemm . Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare, Mat::convertTo Python prototype (for reference): multiply(src1, src2[, dst[, scale[, dtype]]]) -&gt; dst","ref":"Evision.html#multiply/3","title":"Evision.multiply/3","type":"function"},{"doc":"Raising version of namedWindow/1 .","ref":"Evision.html#namedWindow!/1","title":"Evision.namedWindow!/1","type":"function"},{"doc":"Raising version of namedWindow/2 .","ref":"Evision.html#namedWindow!/2","title":"Evision.namedWindow!/2","type":"function"},{"doc":"Creates a window. Positional Arguments winname : String . Name of the window in the window caption that may be used as a window identifier. Keyword Arguments flags : int . Flags of the window. The supported flags are: (cv::WindowFlags) The function namedWindow creates a window that can be used as a placeholder for images and trackbars. Created windows are referred to by their names. If a window with the same name already exists, the function does nothing. You can call cv::destroyWindow or cv::destroyAllWindows to close the window and de-allocate any associated memory usage. For a simple program, you do not really have to call these functions because all the resources and windows of the application are closed automatically by the operating system upon exit. Note : Qt backend supports additional flags: WINDOW_NORMAL or WINDOW_AUTOSIZE: WINDOW_NORMAL enables you to resize the window, whereas WINDOW_AUTOSIZE adjusts automatically the window size to fit the displayed image (see imshow ), and you cannot change the window size manually. WINDOW_FREERATIO or WINDOW_KEEPRATIO: WINDOW_FREERATIO adjusts the image with no respect to its ratio, whereas WINDOW_KEEPRATIO keeps the image ratio. WINDOW_GUI_NORMAL or WINDOW_GUI_EXPANDED: WINDOW_GUI_NORMAL is the old way to draw the window without statusbar and toolbar, whereas WINDOW_GUI_EXPANDED is a new enhanced GUI. By default, flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDED Python prototype (for reference): namedWindow(winname[, flags]) -&gt; None","ref":"Evision.html#namedWindow/1","title":"Evision.namedWindow/1","type":"function"},{"doc":"Creates a window. Positional Arguments winname : String . Name of the window in the window caption that may be used as a window identifier. Keyword Arguments flags : int . Flags of the window. The supported flags are: (cv::WindowFlags) The function namedWindow creates a window that can be used as a placeholder for images and trackbars. Created windows are referred to by their names. If a window with the same name already exists, the function does nothing. You can call cv::destroyWindow or cv::destroyAllWindows to close the window and de-allocate any associated memory usage. For a simple program, you do not really have to call these functions because all the resources and windows of the application are closed automatically by the operating system upon exit. Note : Qt backend supports additional flags: WINDOW_NORMAL or WINDOW_AUTOSIZE: WINDOW_NORMAL enables you to resize the window, whereas WINDOW_AUTOSIZE adjusts automatically the window size to fit the displayed image (see imshow ), and you cannot change the window size manually. WINDOW_FREERATIO or WINDOW_KEEPRATIO: WINDOW_FREERATIO adjusts the image with no respect to its ratio, whereas WINDOW_KEEPRATIO keeps the image ratio. WINDOW_GUI_NORMAL or WINDOW_GUI_EXPANDED: WINDOW_GUI_NORMAL is the old way to draw the window without statusbar and toolbar, whereas WINDOW_GUI_EXPANDED is a new enhanced GUI. By default, flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDED Python prototype (for reference): namedWindow(winname[, flags]) -&gt; None","ref":"Evision.html#namedWindow/2","title":"Evision.namedWindow/2","type":"function"},{"doc":"Raising version of norm/1 .","ref":"Evision.html#norm!/1","title":"Evision.norm!/1","type":"function"},{"doc":"Raising version of norm/2 .","ref":"Evision.html#norm!/2","title":"Evision.norm!/2","type":"function"},{"doc":"Raising version of norm/3 .","ref":"Evision.html#norm!/3","title":"Evision.norm!/3","type":"function"},{"doc":"Calculates the absolute norm of an array. Positional Arguments src1 : Evision.Mat . first input array. Keyword Arguments normType : int . type of the norm (see #NormTypes). mask : Evision.Mat . optional operation mask; it must have the same size as src1 and CV_8UC1 type. This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes. As example for one array consider the function \\f$r(x)= \\begin{pmatrix} x \\\\ 1-x \\end{pmatrix}, x \\in [-1;1]\\f$. The \\f$ L_{1}, L_{2} \\f$ and \\f$ L_{\\infty} \\f$ norm for the sample value \\f$r(-1) = \\begin{pmatrix} -1 \\\\ 2 \\end{pmatrix}\\f$ is calculated as follows \\f{align } \\| r(-1) \\| {L_1} &amp;= |-1| + |2| = 3 \\\\ \\| r(-1) \\| {L 2} &amp;= \\sqrt{(-1)^{2} + (2)^{2}} = \\sqrt{5} \\\\ \\| r(-1) \\| {L_\\infty} &amp;= \\max(|-1|,|2|) = 2 \\f} and for \\f$r(0.5) = \\begin{pmatrix} 0.5 \\\\ 0.5 \\end{pmatrix}\\f$ the calculation is \\f{align } \\| r(0.5) \\| {L_1} &amp;= |0.5| + |0.5| = 1 \\\\ \\| r(0.5) \\| {L 2} &amp;= \\sqrt{(0.5)^{2} + (0.5)^{2}} = \\sqrt{0.5} \\\\ \\| r(0.5) \\| {L \\infty} &amp;= \\max(|0.5|,|0.5|) = 0.5. \\f} The following graphic shows all values for the three norm functions \\f$\\| r(x) \\|\\ {L_1}, \\| r(x) \\|_{L_2}\\f$ and \\f$\\| r(x) \\|_{L_\\infty}\\f$. It is notable that the \\f$ L_{1} \\f$ norm forms the upper and the \\f$ L_{\\infty} \\f$ norm forms the lower border for the example function \\f$ r(x) \\f$. When the mask parameter is specified and it is not empty, the norm is If normType is not specified, #NORM_L2 is used. calculated only over the region specified by the mask. Multi-channel input arrays are treated as single-channel arrays, that is, the results for all channels are combined. Hamming norms can only be calculated with CV_8U depth arrays. Python prototype (for reference): norm(src1[, normType[, mask]]) -&gt; retval","ref":"Evision.html#norm/1","title":"Evision.norm/1","type":"function"},{"doc":"Variant 1: Calculates an absolute difference norm or a relative difference norm. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and the same type as src1. Keyword Arguments normType : int . type of the norm (see #NormTypes). mask : Evision.Mat . optional operation mask; it must have the same size as src1 and CV_8UC1 type. This version of cv::norm calculates the absolute difference norm or the relative difference norm of arrays src1 and src2. The type of norm to calculate is specified using #NormTypes. Python prototype (for reference): norm(src1, src2[, normType[, mask]]) -&gt; retval Variant 2: Calculates the absolute norm of an array. Positional Arguments src1 : Evision.Mat . first input array. Keyword Arguments normType : int . type of the norm (see #NormTypes). mask : Evision.Mat . optional operation mask; it must have the same size as src1 and CV_8UC1 type. This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes. As example for one array consider the function \\f$r(x)= \\begin{pmatrix} x \\\\ 1-x \\end{pmatrix}, x \\in [-1;1]\\f$. The \\f$ L_{1}, L_{2} \\f$ and \\f$ L_{\\infty} \\f$ norm for the sample value \\f$r(-1) = \\begin{pmatrix} -1 \\\\ 2 \\end{pmatrix}\\f$ is calculated as follows \\f{align } \\| r(-1) \\| {L_1} &amp;= |-1| + |2| = 3 \\\\ \\| r(-1) \\| {L 2} &amp;= \\sqrt{(-1)^{2} + (2)^{2}} = \\sqrt{5} \\\\ \\| r(-1) \\| {L_\\infty} &amp;= \\max(|-1|,|2|) = 2 \\f} and for \\f$r(0.5) = \\begin{pmatrix} 0.5 \\\\ 0.5 \\end{pmatrix}\\f$ the calculation is \\f{align } \\| r(0.5) \\| {L_1} &amp;= |0.5| + |0.5| = 1 \\\\ \\| r(0.5) \\| {L 2} &amp;= \\sqrt{(0.5)^{2} + (0.5)^{2}} = \\sqrt{0.5} \\\\ \\| r(0.5) \\| {L \\infty} &amp;= \\max(|0.5|,|0.5|) = 0.5. \\f} The following graphic shows all values for the three norm functions \\f$\\| r(x) \\|\\ {L_1}, \\| r(x) \\|_{L_2}\\f$ and \\f$\\| r(x) \\|_{L_\\infty}\\f$. It is notable that the \\f$ L_{1} \\f$ norm forms the upper and the \\f$ L_{\\infty} \\f$ norm forms the lower border for the example function \\f$ r(x) \\f$. When the mask parameter is specified and it is not empty, the norm is If normType is not specified, #NORM_L2 is used. calculated only over the region specified by the mask. Multi-channel input arrays are treated as single-channel arrays, that is, the results for all channels are combined. Hamming norms can only be calculated with CV_8U depth arrays. Python prototype (for reference): norm(src1[, normType[, mask]]) -&gt; retval","ref":"Evision.html#norm/2","title":"Evision.norm/2","type":"function"},{"doc":"Calculates an absolute difference norm or a relative difference norm. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size and the same type as src1. Keyword Arguments normType : int . type of the norm (see #NormTypes). mask : Evision.Mat . optional operation mask; it must have the same size as src1 and CV_8UC1 type. This version of cv::norm calculates the absolute difference norm or the relative difference norm of arrays src1 and src2. The type of norm to calculate is specified using #NormTypes. Python prototype (for reference): norm(src1, src2[, normType[, mask]]) -&gt; retval","ref":"Evision.html#norm/3","title":"Evision.norm/3","type":"function"},{"doc":"Raising version of normalize/2 .","ref":"Evision.html#normalize!/2","title":"Evision.normalize!/2","type":"function"},{"doc":"Raising version of normalize/3 .","ref":"Evision.html#normalize!/3","title":"Evision.normalize!/3","type":"function"},{"doc":"Normalizes the norm or value range of an array. Positional Arguments src : Evision.Mat . input array. Keyword Arguments alpha : double . norm value to normalize to or the lower range boundary in case of the range normalization. beta : double . upper range boundary in case of the range normalization; it is not used for the norm normalization. norm_type : int . normalization type (see cv::NormTypes). dtype : int . when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth =CV_MAT_DEPTH(dtype). mask : Evision.Mat . optional operation mask. Return dst : Evision.Mat . output array of the same size as src . The function cv::normalize normalizes scale and shift the input array elements so that \\f[\\| \\texttt{dst} \\| _{L_p}= \\texttt{alpha}\\f] (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that \\f[\\min _I \\texttt{dst} (I)= \\texttt{alpha} , \\, \\, \\max _I \\texttt{dst} (I)= \\texttt{beta}\\f] when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and Mat::convertTo. In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level. Possible usage with some positive example data: vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax; // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1); // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2); // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF); // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); @sa norm, Mat::convertTo, SparseMat::convertTo Python prototype (for reference): normalize(src, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]) -&gt; dst","ref":"Evision.html#normalize/2","title":"Evision.normalize/2","type":"function"},{"doc":"Normalizes the norm or value range of an array. Positional Arguments src : Evision.Mat . input array. Keyword Arguments alpha : double . norm value to normalize to or the lower range boundary in case of the range normalization. beta : double . upper range boundary in case of the range normalization; it is not used for the norm normalization. norm_type : int . normalization type (see cv::NormTypes). dtype : int . when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth =CV_MAT_DEPTH(dtype). mask : Evision.Mat . optional operation mask. Return dst : Evision.Mat . output array of the same size as src . The function cv::normalize normalizes scale and shift the input array elements so that \\f[\\| \\texttt{dst} \\| _{L_p}= \\texttt{alpha}\\f] (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that \\f[\\min _I \\texttt{dst} (I)= \\texttt{alpha} , \\, \\, \\max _I \\texttt{dst} (I)= \\texttt{beta}\\f] when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and Mat::convertTo. In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level. Possible usage with some positive example data: vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax; // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1); // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2); // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF); // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); @sa norm, Mat::convertTo, SparseMat::convertTo Python prototype (for reference): normalize(src, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]) -&gt; dst","ref":"Evision.html#normalize/3","title":"Evision.normalize/3","type":"function"},{"doc":"Raising version of patchNaNs/1 .","ref":"Evision.html#patchNaNs!/1","title":"Evision.patchNaNs!/1","type":"function"},{"doc":"Raising version of patchNaNs/2 .","ref":"Evision.html#patchNaNs!/2","title":"Evision.patchNaNs!/2","type":"function"},{"doc":"converts NaNs to the given number Keyword Arguments val : double . value to convert the NaNs Return a : Evision.Mat . input/output matrix (CV_32F type). Python prototype (for reference): patchNaNs(a[, val]) -&gt; a","ref":"Evision.html#patchNaNs/1","title":"Evision.patchNaNs/1","type":"function"},{"doc":"converts NaNs to the given number Keyword Arguments val : double . value to convert the NaNs Return a : Evision.Mat . input/output matrix (CV_32F type). Python prototype (for reference): patchNaNs(a[, val]) -&gt; a","ref":"Evision.html#patchNaNs/2","title":"Evision.patchNaNs/2","type":"function"},{"doc":"Raising version of pcaBackProject/3 .","ref":"Evision.html#pcaBackProject!/3","title":"Evision.pcaBackProject!/3","type":"function"},{"doc":"Raising version of pcaBackProject/4 .","ref":"Evision.html#pcaBackProject!/4","title":"Evision.pcaBackProject!/4","type":"function"},{"doc":"Positional Arguments data : Evision.Mat mean : Evision.Mat eigenvectors : Evision.Mat Return result : Evision.Mat . wrap PCA::backProject Python prototype (for reference): PCABackProject(data, mean, eigenvectors[, result]) -&gt; result","ref":"Evision.html#pcaBackProject/3","title":"Evision.pcaBackProject/3","type":"function"},{"doc":"Positional Arguments data : Evision.Mat mean : Evision.Mat eigenvectors : Evision.Mat Return result : Evision.Mat . wrap PCA::backProject Python prototype (for reference): PCABackProject(data, mean, eigenvectors[, result]) -&gt; result","ref":"Evision.html#pcaBackProject/4","title":"Evision.pcaBackProject/4","type":"function"},{"doc":"Raising version of pcaCompute2/2 .","ref":"Evision.html#pcaCompute2!/2","title":"Evision.pcaCompute2!/2","type":"function"},{"doc":"Raising version of pcaCompute2/3 .","ref":"Evision.html#pcaCompute2!/3","title":"Evision.pcaCompute2!/3","type":"function"},{"doc":"Raising version of pcaCompute2/4 .","ref":"Evision.html#pcaCompute2!/4","title":"Evision.pcaCompute2!/4","type":"function"},{"doc":"Positional Arguments data : Evision.Mat Keyword Arguments maxComponents : int . Return mean : Evision.Mat eigenvectors : Evision.Mat . eigenvalues : Evision.Mat . wrap PCA::operator() and add eigenvalues output parameter Python prototype (for reference): PCACompute2(data, mean[, eigenvectors[, eigenvalues[, maxComponents]]]) -&gt; mean, eigenvectors, eigenvalues","ref":"Evision.html#pcaCompute2/2","title":"Evision.pcaCompute2/2","type":"function"},{"doc":"Variant 1: Positional Arguments data : Evision.Mat retainedVariance : double Return mean : Evision.Mat eigenvectors : Evision.Mat . eigenvalues : Evision.Mat . wrap PCA::operator() and add eigenvalues output parameter Python prototype (for reference): PCACompute2(data, mean, retainedVariance[, eigenvectors[, eigenvalues]]) -&gt; mean, eigenvectors, eigenvalues Variant 2: Positional Arguments data : Evision.Mat Keyword Arguments maxComponents : int . Return mean : Evision.Mat eigenvectors : Evision.Mat . eigenvalues : Evision.Mat . wrap PCA::operator() and add eigenvalues output parameter Python prototype (for reference): PCACompute2(data, mean[, eigenvectors[, eigenvalues[, maxComponents]]]) -&gt; mean, eigenvectors, eigenvalues","ref":"Evision.html#pcaCompute2/3","title":"Evision.pcaCompute2/3","type":"function"},{"doc":"Positional Arguments data : Evision.Mat retainedVariance : double Return mean : Evision.Mat eigenvectors : Evision.Mat . eigenvalues : Evision.Mat . wrap PCA::operator() and add eigenvalues output parameter Python prototype (for reference): PCACompute2(data, mean, retainedVariance[, eigenvectors[, eigenvalues]]) -&gt; mean, eigenvectors, eigenvalues","ref":"Evision.html#pcaCompute2/4","title":"Evision.pcaCompute2/4","type":"function"},{"doc":"Raising version of pcaCompute/2 .","ref":"Evision.html#pcaCompute!/2","title":"Evision.pcaCompute!/2","type":"function"},{"doc":"Raising version of pcaCompute/3 .","ref":"Evision.html#pcaCompute!/3","title":"Evision.pcaCompute!/3","type":"function"},{"doc":"Raising version of pcaCompute/4 .","ref":"Evision.html#pcaCompute!/4","title":"Evision.pcaCompute!/4","type":"function"},{"doc":"Positional Arguments data : Evision.Mat Keyword Arguments maxComponents : int . Return mean : Evision.Mat eigenvectors : Evision.Mat . wrap PCA::operator() Python prototype (for reference): PCACompute(data, mean[, eigenvectors[, maxComponents]]) -&gt; mean, eigenvectors","ref":"Evision.html#pcaCompute/2","title":"Evision.pcaCompute/2","type":"function"},{"doc":"Variant 1: Positional Arguments data : Evision.Mat retainedVariance : double Return mean : Evision.Mat eigenvectors : Evision.Mat . wrap PCA::operator() Python prototype (for reference): PCACompute(data, mean, retainedVariance[, eigenvectors]) -&gt; mean, eigenvectors Variant 2: Positional Arguments data : Evision.Mat Keyword Arguments maxComponents : int . Return mean : Evision.Mat eigenvectors : Evision.Mat . wrap PCA::operator() Python prototype (for reference): PCACompute(data, mean[, eigenvectors[, maxComponents]]) -&gt; mean, eigenvectors","ref":"Evision.html#pcaCompute/3","title":"Evision.pcaCompute/3","type":"function"},{"doc":"Positional Arguments data : Evision.Mat retainedVariance : double Return mean : Evision.Mat eigenvectors : Evision.Mat . wrap PCA::operator() Python prototype (for reference): PCACompute(data, mean, retainedVariance[, eigenvectors]) -&gt; mean, eigenvectors","ref":"Evision.html#pcaCompute/4","title":"Evision.pcaCompute/4","type":"function"},{"doc":"Raising version of pcaProject/3 .","ref":"Evision.html#pcaProject!/3","title":"Evision.pcaProject!/3","type":"function"},{"doc":"Raising version of pcaProject/4 .","ref":"Evision.html#pcaProject!/4","title":"Evision.pcaProject!/4","type":"function"},{"doc":"Positional Arguments data : Evision.Mat mean : Evision.Mat eigenvectors : Evision.Mat Return result : Evision.Mat . wrap PCA::project Python prototype (for reference): PCAProject(data, mean, eigenvectors[, result]) -&gt; result","ref":"Evision.html#pcaProject/3","title":"Evision.pcaProject/3","type":"function"},{"doc":"Positional Arguments data : Evision.Mat mean : Evision.Mat eigenvectors : Evision.Mat Return result : Evision.Mat . wrap PCA::project Python prototype (for reference): PCAProject(data, mean, eigenvectors[, result]) -&gt; result","ref":"Evision.html#pcaProject/4","title":"Evision.pcaProject/4","type":"function"},{"doc":"Raising version of pencilSketch/1 .","ref":"Evision.html#pencilSketch!/1","title":"Evision.pencilSketch!/1","type":"function"},{"doc":"Raising version of pencilSketch/2 .","ref":"Evision.html#pencilSketch!/2","title":"Evision.pencilSketch!/2","type":"function"},{"doc":"Pencil-like non-photorealistic line drawing Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. shade_factor : float . %Range between 0 to 0.1. Return dst1 : Evision.Mat . Output 8-bit 1-channel image. dst2 : Evision.Mat . Output image with the same size and type as src. Python prototype (for reference): pencilSketch(src[, dst1[, dst2[, sigma_s[, sigma_r[, shade_factor]]]]]) -&gt; dst1, dst2","ref":"Evision.html#pencilSketch/1","title":"Evision.pencilSketch/1","type":"function"},{"doc":"Pencil-like non-photorealistic line drawing Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. shade_factor : float . %Range between 0 to 0.1. Return dst1 : Evision.Mat . Output 8-bit 1-channel image. dst2 : Evision.Mat . Output image with the same size and type as src. Python prototype (for reference): pencilSketch(src[, dst1[, dst2[, sigma_s[, sigma_r[, shade_factor]]]]]) -&gt; dst1, dst2","ref":"Evision.html#pencilSketch/2","title":"Evision.pencilSketch/2","type":"function"},{"doc":"Raising version of perspectiveTransform/2 .","ref":"Evision.html#perspectiveTransform!/2","title":"Evision.perspectiveTransform!/2","type":"function"},{"doc":"Raising version of perspectiveTransform/3 .","ref":"Evision.html#perspectiveTransform!/3","title":"Evision.perspectiveTransform!/3","type":"function"},{"doc":"Performs the perspective matrix transformation of vectors. Positional Arguments src : Evision.Mat . input two-channel or three-channel floating-point array; each element is a 2D/3D vector to be transformed. m : Evision.Mat . 3x3 or 4x4 floating-point transformation matrix. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::perspectiveTransform transforms every element of src by treating it as a 2D or 3D vector, in the following way: \\f[(x, y, z) \\rightarrow (x'/w, y'/w, z'/w)\\f] where \\f[(x', y', z', w') = \\texttt{mat} \\cdot \\begin{bmatrix} x &amp; y &amp; z &amp; 1 \\end{bmatrix}\\f] and \\f[w = \\fork{w'}{if (w' \\ne 0)}{\\infty}{otherwise}\\f] Here a 3D vector transformation is shown. In case of a 2D vector transformation, the z component is omitted. Note : The function transforms a sparse set of 2D or 3D vectors. If you want to transform an image using perspective transformation, use warpPerspective . If you have an inverse problem, that is, you want to compute the most probable perspective transformation out of several pairs of corresponding points, you can use getPerspectiveTransform or findHomography . @sa transform, warpPerspective, getPerspectiveTransform, findHomography Python prototype (for reference): perspectiveTransform(src, m[, dst]) -&gt; dst","ref":"Evision.html#perspectiveTransform/2","title":"Evision.perspectiveTransform/2","type":"function"},{"doc":"Performs the perspective matrix transformation of vectors. Positional Arguments src : Evision.Mat . input two-channel or three-channel floating-point array; each element is a 2D/3D vector to be transformed. m : Evision.Mat . 3x3 or 4x4 floating-point transformation matrix. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::perspectiveTransform transforms every element of src by treating it as a 2D or 3D vector, in the following way: \\f[(x, y, z) \\rightarrow (x'/w, y'/w, z'/w)\\f] where \\f[(x', y', z', w') = \\texttt{mat} \\cdot \\begin{bmatrix} x &amp; y &amp; z &amp; 1 \\end{bmatrix}\\f] and \\f[w = \\fork{w'}{if (w' \\ne 0)}{\\infty}{otherwise}\\f] Here a 3D vector transformation is shown. In case of a 2D vector transformation, the z component is omitted. Note : The function transforms a sparse set of 2D or 3D vectors. If you want to transform an image using perspective transformation, use warpPerspective . If you have an inverse problem, that is, you want to compute the most probable perspective transformation out of several pairs of corresponding points, you can use getPerspectiveTransform or findHomography . @sa transform, warpPerspective, getPerspectiveTransform, findHomography Python prototype (for reference): perspectiveTransform(src, m[, dst]) -&gt; dst","ref":"Evision.html#perspectiveTransform/3","title":"Evision.perspectiveTransform/3","type":"function"},{"doc":"Raising version of phase/2 .","ref":"Evision.html#phase!/2","title":"Evision.phase!/2","type":"function"},{"doc":"Raising version of phase/3 .","ref":"Evision.html#phase!/3","title":"Evision.phase!/3","type":"function"},{"doc":"Calculates the rotation angle of 2D vectors. Positional Arguments x : Evision.Mat . input floating-point array of x-coordinates of 2D vectors. y : Evision.Mat . input array of y-coordinates of 2D vectors; it must have the same size and the same type as x. Keyword Arguments angleInDegrees : bool . when true, the function calculates the angle in degrees, otherwise, they are measured in radians. Return angle : Evision.Mat . output array of vector angles; it has the same size and same type as x . The function cv::phase calculates the rotation angle of each 2D vector that is formed from the corresponding elements of x and y : \\f[\\texttt{angle} (I) = \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\f] The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 , the corresponding angle(I) is set to 0. Python prototype (for reference): phase(x, y[, angle[, angleInDegrees]]) -&gt; angle","ref":"Evision.html#phase/2","title":"Evision.phase/2","type":"function"},{"doc":"Calculates the rotation angle of 2D vectors. Positional Arguments x : Evision.Mat . input floating-point array of x-coordinates of 2D vectors. y : Evision.Mat . input array of y-coordinates of 2D vectors; it must have the same size and the same type as x. Keyword Arguments angleInDegrees : bool . when true, the function calculates the angle in degrees, otherwise, they are measured in radians. Return angle : Evision.Mat . output array of vector angles; it has the same size and same type as x . The function cv::phase calculates the rotation angle of each 2D vector that is formed from the corresponding elements of x and y : \\f[\\texttt{angle} (I) = \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\f] The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 , the corresponding angle(I) is set to 0. Python prototype (for reference): phase(x, y[, angle[, angleInDegrees]]) -&gt; angle","ref":"Evision.html#phase/3","title":"Evision.phase/3","type":"function"},{"doc":"Raising version of phaseCorrelate/2 .","ref":"Evision.html#phaseCorrelate!/2","title":"Evision.phaseCorrelate!/2","type":"function"},{"doc":"Raising version of phaseCorrelate/3 .","ref":"Evision.html#phaseCorrelate!/3","title":"Evision.phaseCorrelate!/3","type":"function"},{"doc":"The function is used to detect translational shifts that occur between two images. Positional Arguments src1 : Evision.Mat . Source floating point array (CV_32FC1 or CV_64FC1) src2 : Evision.Mat . Source floating point array (CV_32FC1 or CV_64FC1) Keyword Arguments window : Evision.Mat . Floating point array with windowing coefficients to reduce edge effects (optional). Return response : double* . Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional). The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. For more information please see http://en.wikipedia.org/wiki/Phase_correlation Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed with getOptimalDFTSize. The function performs the following equations: First it applies a Hanning window (see http://en.wikipedia.org/wiki/Hann_function ) to each image to remove possible edge effects. This window is cached until the array size changes to speed up processing time. Next it computes the forward DFTs of each source array: \\f[\\mathbf{G}_a = \\mathcal{F}\\{src_1\\}, \\; \\mathbf{G}_b = \\mathcal{F}\\{src_2\\}\\f] where \\f$\\mathcal{F}\\f$ is the forward DFT. It then computes the cross-power spectrum of each frequency domain array: \\f[R = \\frac{ \\mathbf{G}_a \\mathbf{G}_b^*}{|\\mathbf{G}_a \\mathbf{G}_b^*|}\\f] Next the cross-correlation is converted back into the time domain via the inverse DFT: \\f[r = \\mathcal{F}^{-1}\\{R\\}\\f] Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to achieve sub-pixel accuracy. \\f[(\\Delta x, \\Delta y) = \\texttt{weightedCentroid} \\{\\arg \\max_{(x, y)}\\{r\\}\\}\\f] If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks. @returns detected phase shift (sub-pixel) between the two arrays. @sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow Python prototype (for reference): phaseCorrelate(src1, src2[, window]) -&gt; retval, response","ref":"Evision.html#phaseCorrelate/2","title":"Evision.phaseCorrelate/2","type":"function"},{"doc":"The function is used to detect translational shifts that occur between two images. Positional Arguments src1 : Evision.Mat . Source floating point array (CV_32FC1 or CV_64FC1) src2 : Evision.Mat . Source floating point array (CV_32FC1 or CV_64FC1) Keyword Arguments window : Evision.Mat . Floating point array with windowing coefficients to reduce edge effects (optional). Return response : double* . Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional). The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. For more information please see http://en.wikipedia.org/wiki/Phase_correlation Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed with getOptimalDFTSize. The function performs the following equations: First it applies a Hanning window (see http://en.wikipedia.org/wiki/Hann_function ) to each image to remove possible edge effects. This window is cached until the array size changes to speed up processing time. Next it computes the forward DFTs of each source array: \\f[\\mathbf{G}_a = \\mathcal{F}\\{src_1\\}, \\; \\mathbf{G}_b = \\mathcal{F}\\{src_2\\}\\f] where \\f$\\mathcal{F}\\f$ is the forward DFT. It then computes the cross-power spectrum of each frequency domain array: \\f[R = \\frac{ \\mathbf{G}_a \\mathbf{G}_b^*}{|\\mathbf{G}_a \\mathbf{G}_b^*|}\\f] Next the cross-correlation is converted back into the time domain via the inverse DFT: \\f[r = \\mathcal{F}^{-1}\\{R\\}\\f] Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to achieve sub-pixel accuracy. \\f[(\\Delta x, \\Delta y) = \\texttt{weightedCentroid} \\{\\arg \\max_{(x, y)}\\{r\\}\\}\\f] If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks. @returns detected phase shift (sub-pixel) between the two arrays. @sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow Python prototype (for reference): phaseCorrelate(src1, src2[, window]) -&gt; retval, response","ref":"Evision.html#phaseCorrelate/3","title":"Evision.phaseCorrelate/3","type":"function"},{"doc":"Raising version of pointPolygonTest/3 .","ref":"Evision.html#pointPolygonTest!/3","title":"Evision.pointPolygonTest!/3","type":"function"},{"doc":"Performs a point-in-contour test. Positional Arguments contour : Evision.Mat . Input contour. pt : Point2f . Point tested against the contour. measureDist : bool . If true, the function estimates the signed distance from the point to the nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not. The function determines whether the point is inside a contour, outside, or lies on an edge (or coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge) value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively. Otherwise, the return value is a signed distance between the point and the nearest contour edge. See below a sample output of the function where each image pixel is tested against the contour: Python prototype (for reference): pointPolygonTest(contour, pt, measureDist) -&gt; retval","ref":"Evision.html#pointPolygonTest/3","title":"Evision.pointPolygonTest/3","type":"function"},{"doc":"Raising version of polarToCart/2 .","ref":"Evision.html#polarToCart!/2","title":"Evision.polarToCart!/2","type":"function"},{"doc":"Raising version of polarToCart/3 .","ref":"Evision.html#polarToCart!/3","title":"Evision.polarToCart!/3","type":"function"},{"doc":"Calculates x and y coordinates of 2D vectors from their magnitude and angle. Positional Arguments magnitude : Evision.Mat . input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle. angle : Evision.Mat . input floating-point array of angles of 2D vectors. Keyword Arguments angleInDegrees : bool . when true, the input angles are measured in degrees, otherwise, they are measured in radians. Return x : Evision.Mat . output array of x-coordinates of 2D vectors; it has the same size and type as angle. y : Evision.Mat . output array of y-coordinates of 2D vectors; it has the same size and type as angle. The function cv::polarToCart calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of magnitude and angle: \\f[\\begin{array}{l} \\texttt{x} (I) = \\texttt{magnitude} (I) \\cos ( \\texttt{angle} (I)) \\\\ \\texttt{y} (I) = \\texttt{magnitude} (I) \\sin ( \\texttt{angle} (I)) \\\\ \\end{array}\\f] The relative accuracy of the estimated coordinates is about 1e-6. @sa cartToPolar, magnitude, phase, exp, log, pow, sqrt Python prototype (for reference): polarToCart(magnitude, angle[, x[, y[, angleInDegrees]]]) -&gt; x, y","ref":"Evision.html#polarToCart/2","title":"Evision.polarToCart/2","type":"function"},{"doc":"Calculates x and y coordinates of 2D vectors from their magnitude and angle. Positional Arguments magnitude : Evision.Mat . input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle. angle : Evision.Mat . input floating-point array of angles of 2D vectors. Keyword Arguments angleInDegrees : bool . when true, the input angles are measured in degrees, otherwise, they are measured in radians. Return x : Evision.Mat . output array of x-coordinates of 2D vectors; it has the same size and type as angle. y : Evision.Mat . output array of y-coordinates of 2D vectors; it has the same size and type as angle. The function cv::polarToCart calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of magnitude and angle: \\f[\\begin{array}{l} \\texttt{x} (I) = \\texttt{magnitude} (I) \\cos ( \\texttt{angle} (I)) \\\\ \\texttt{y} (I) = \\texttt{magnitude} (I) \\sin ( \\texttt{angle} (I)) \\\\ \\end{array}\\f] The relative accuracy of the estimated coordinates is about 1e-6. @sa cartToPolar, magnitude, phase, exp, log, pow, sqrt Python prototype (for reference): polarToCart(magnitude, angle[, x[, y[, angleInDegrees]]]) -&gt; x, y","ref":"Evision.html#polarToCart/3","title":"Evision.polarToCart/3","type":"function"},{"doc":"Raising version of pollKey/0 .","ref":"Evision.html#pollKey!/0","title":"Evision.pollKey!/0","type":"function"},{"doc":"Polls for a pressed key. The function pollKey polls for a key event without waiting. It returns the code of the pressed key or -1 if no key was pressed since the last invocation. To wait until a key was pressed, use #waitKey. Note : The functions #waitKey and #pollKey are the only methods in HighGUI that can fetch and handle GUI events, so one of them needs to be called periodically for normal event processing unless HighGUI is used within an environment that takes care of event processing. Note : The function only works if there is at least one HighGUI window created and the window is active. If there are several HighGUI windows, any of them can be active. Python prototype (for reference): pollKey() -&gt; retval","ref":"Evision.html#pollKey/0","title":"Evision.pollKey/0","type":"function"},{"doc":"Raising version of polylines/4 .","ref":"Evision.html#polylines!/4","title":"Evision.polylines!/4","type":"function"},{"doc":"Raising version of polylines/5 .","ref":"Evision.html#polylines!/5","title":"Evision.polylines!/5","type":"function"},{"doc":"Draws several polygonal curves. Positional Arguments pts : [Evision.Mat] . Array of polygonal curves. isClosed : bool . Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. color : Scalar . Polyline color. Keyword Arguments thickness : int . Thickness of the polyline edges. lineType : int . Type of the line segments. See #LineTypes shift : int . Number of fractional bits in the vertex coordinates. Return img : Evision.Mat . Image. The function cv::polylines draws one or more polygonal curves. Python prototype (for reference): polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#polylines/4","title":"Evision.polylines/4","type":"function"},{"doc":"Draws several polygonal curves. Positional Arguments pts : [Evision.Mat] . Array of polygonal curves. isClosed : bool . Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. color : Scalar . Polyline color. Keyword Arguments thickness : int . Thickness of the polyline edges. lineType : int . Type of the line segments. See #LineTypes shift : int . Number of fractional bits in the vertex coordinates. Return img : Evision.Mat . Image. The function cv::polylines draws one or more polygonal curves. Python prototype (for reference): polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#polylines/5","title":"Evision.polylines/5","type":"function"},{"doc":"Raising version of pow/2 .","ref":"Evision.html#pow!/2","title":"Evision.pow!/2","type":"function"},{"doc":"Raising version of pow/3 .","ref":"Evision.html#pow!/3","title":"Evision.pow!/3","type":"function"},{"doc":"Raises every array element to a power. Positional Arguments src : Evision.Mat . input array. power : double . exponent of power. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::pow raises every element of the input array to power : \\f[\\texttt{dst} (I) = \\fork{\\texttt{src}(I)^{power}}{if (\\texttt{power}) is integer}{|\\texttt{src}(I)|^{power}}{otherwise}\\f] So, for a non-integer power exponent, the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations. In the example below, computing the 5th root of array src shows: Mat mask = src &lt; 0; pow(src, 1./5, dst); subtract(Scalar::all(0), dst, dst, mask); For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used. Special values (NaN, Inf) are not handled. @sa sqrt, exp, log, cartToPolar, polarToCart Python prototype (for reference): pow(src, power[, dst]) -&gt; dst","ref":"Evision.html#pow/2","title":"Evision.pow/2","type":"function"},{"doc":"Raises every array element to a power. Positional Arguments src : Evision.Mat . input array. power : double . exponent of power. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::pow raises every element of the input array to power : \\f[\\texttt{dst} (I) = \\fork{\\texttt{src}(I)^{power}}{if (\\texttt{power}) is integer}{|\\texttt{src}(I)|^{power}}{otherwise}\\f] So, for a non-integer power exponent, the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations. In the example below, computing the 5th root of array src shows: Mat mask = src &lt; 0; pow(src, 1./5, dst); subtract(Scalar::all(0), dst, dst, mask); For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used. Special values (NaN, Inf) are not handled. @sa sqrt, exp, log, cartToPolar, polarToCart Python prototype (for reference): pow(src, power[, dst]) -&gt; dst","ref":"Evision.html#pow/3","title":"Evision.pow/3","type":"function"},{"doc":"Raising version of preCornerDetect/2 .","ref":"Evision.html#preCornerDetect!/2","title":"Evision.preCornerDetect!/2","type":"function"},{"doc":"Raising version of preCornerDetect/3 .","ref":"Evision.html#preCornerDetect!/3","title":"Evision.preCornerDetect!/3","type":"function"},{"doc":"Calculates a feature map for corner detection. Positional Arguments src : Evision.Mat . Source single-channel 8-bit of floating-point image. ksize : int . %Aperture size of the Sobel . Keyword Arguments borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Output image that has the type CV_32F and the same size as src . The function calculates the complex spatial derivative-based function of the source image \\f[\\texttt{dst} = (D_x \\texttt{src} )^2 \\cdot D_{yy} \\texttt{src} + (D_y \\texttt{src} )^2 \\cdot D_{xx} \\texttt{src} - 2 D_x \\texttt{src} \\cdot D_y \\texttt{src} \\cdot D_{xy} \\texttt{src}\\f] where \\f$D_x\\f$,\\f$D_y\\f$ are the first image derivatives, \\f$D_{xx}\\f$,\\f$D_{yy}\\f$ are the second image derivatives, and \\f$D_{xy}\\f$ is the mixed derivative. The corners can be found as local maximums of the functions, as shown below: Mat corners , dilated_corners ; preCornerDetect ( image , corners , 3 ) ; // dilation with 3 x3 rectangular structuring element dilate ( corners , dilated_corners , Mat ( ) , 1 ) ; Mat corner_mask = corners == dilated_corners ; Python prototype (for reference): preCornerDetect(src, ksize[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#preCornerDetect/2","title":"Evision.preCornerDetect/2","type":"function"},{"doc":"Calculates a feature map for corner detection. Positional Arguments src : Evision.Mat . Source single-channel 8-bit of floating-point image. ksize : int . %Aperture size of the Sobel . Keyword Arguments borderType : int . Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Output image that has the type CV_32F and the same size as src . The function calculates the complex spatial derivative-based function of the source image \\f[\\texttt{dst} = (D_x \\texttt{src} )^2 \\cdot D_{yy} \\texttt{src} + (D_y \\texttt{src} )^2 \\cdot D_{xx} \\texttt{src} - 2 D_x \\texttt{src} \\cdot D_y \\texttt{src} \\cdot D_{xy} \\texttt{src}\\f] where \\f$D_x\\f$,\\f$D_y\\f$ are the first image derivatives, \\f$D_{xx}\\f$,\\f$D_{yy}\\f$ are the second image derivatives, and \\f$D_{xy}\\f$ is the mixed derivative. The corners can be found as local maximums of the functions, as shown below: Mat corners , dilated_corners ; preCornerDetect ( image , corners , 3 ) ; // dilation with 3 x3 rectangular structuring element dilate ( corners , dilated_corners , Mat ( ) , 1 ) ; Mat corner_mask = corners == dilated_corners ; Python prototype (for reference): preCornerDetect(src, ksize[, dst[, borderType]]) -&gt; dst","ref":"Evision.html#preCornerDetect/3","title":"Evision.preCornerDetect/3","type":"function"},{"doc":"Raising version of projectPoints/5 .","ref":"Evision.html#projectPoints!/5","title":"Evision.projectPoints!/5","type":"function"},{"doc":"Raising version of projectPoints/6 .","ref":"Evision.html#projectPoints!/6","title":"Evision.projectPoints!/6","type":"function"},{"doc":"Projects 3D points to an image plane. Positional Arguments objectPoints : Evision.Mat . Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3 1-channel or 1xN/Nx1 3-channel (or vector\\&lt;Point3f&gt; ), where N is the number of points in the view. rvec : Evision.Mat . The rotation vector (@ref Rodrigues) that, together with tvec, performs a change of basis from world to camera coordinate system, see @ref calibrateCamera for details. tvec : Evision.Mat . The translation vector, see parameter description above. cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$ . If the vector is empty, the zero distortion coefficients are assumed. Keyword Arguments aspectRatio : double . Optional &quot;fixed aspect ratio&quot; parameter. If the parameter is not 0, the function assumes that the aspect ratio (\\f$f_x / f_y\\f$) is fixed and correspondingly adjusts the jacobian matrix. Return imagePoints : Evision.Mat . Output array of image points, 1xN/Nx1 2-channel, or vector\\&lt;Point2f&gt; . jacobian : Evision.Mat . Optional output 2Nx(10+\\&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters. The function computes the 2D projections of 3D points to the image plane, given intrinsic and extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial derivatives of image points coordinates (as functions of all the input parameters) with respect to the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global optimization in @ref calibrateCamera, @ref solvePnP, and @ref stereoCalibrate. The function itself can also be used to compute a re-projection error, given the current intrinsic and extrinsic parameters. Note : By setting rvec = tvec = \\f$[0, 0, 0]\\f$, or by setting cameraMatrix to a 3x3 identity matrix, or by passing zero distortion coefficients, one can get various useful partial cases of the function. This means, one can compute the distorted coordinates for a sparse set of points or apply a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup. Python prototype (for reference): projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs[, imagePoints[, jacobian[, aspectRatio]]]) -&gt; imagePoints, jacobian","ref":"Evision.html#projectPoints/5","title":"Evision.projectPoints/5","type":"function"},{"doc":"Projects 3D points to an image plane. Positional Arguments objectPoints : Evision.Mat . Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3 1-channel or 1xN/Nx1 3-channel (or vector\\&lt;Point3f&gt; ), where N is the number of points in the view. rvec : Evision.Mat . The rotation vector (@ref Rodrigues) that, together with tvec, performs a change of basis from world to camera coordinate system, see @ref calibrateCamera for details. tvec : Evision.Mat . The translation vector, see parameter description above. cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$ . If the vector is empty, the zero distortion coefficients are assumed. Keyword Arguments aspectRatio : double . Optional &quot;fixed aspect ratio&quot; parameter. If the parameter is not 0, the function assumes that the aspect ratio (\\f$f_x / f_y\\f$) is fixed and correspondingly adjusts the jacobian matrix. Return imagePoints : Evision.Mat . Output array of image points, 1xN/Nx1 2-channel, or vector\\&lt;Point2f&gt; . jacobian : Evision.Mat . Optional output 2Nx(10+\\&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters. The function computes the 2D projections of 3D points to the image plane, given intrinsic and extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial derivatives of image points coordinates (as functions of all the input parameters) with respect to the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global optimization in @ref calibrateCamera, @ref solvePnP, and @ref stereoCalibrate. The function itself can also be used to compute a re-projection error, given the current intrinsic and extrinsic parameters. Note : By setting rvec = tvec = \\f$[0, 0, 0]\\f$, or by setting cameraMatrix to a 3x3 identity matrix, or by passing zero distortion coefficients, one can get various useful partial cases of the function. This means, one can compute the distorted coordinates for a sparse set of points or apply a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup. Python prototype (for reference): projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs[, imagePoints[, jacobian[, aspectRatio]]]) -&gt; imagePoints, jacobian","ref":"Evision.html#projectPoints/6","title":"Evision.projectPoints/6","type":"function"},{"doc":"Raising version of psnr/2 .","ref":"Evision.html#psnr!/2","title":"Evision.psnr!/2","type":"function"},{"doc":"Raising version of psnr/3 .","ref":"Evision.html#psnr!/3","title":"Evision.psnr!/3","type":"function"},{"doc":"Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size as src1. Keyword Arguments r : double . the maximum pixel value (255 by default) This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB), between two input arrays src1 and src2. The arrays must have the same type. The PSNR is calculated as follows: \\f[ \\texttt{PSNR} = 10 \\cdot \\log_{10}{\\left( \\frac{R^2}{MSE} \\right) } \\f] where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data) and MSE is the mean squared error between the two arrays. Python prototype (for reference): PSNR(src1, src2[, R]) -&gt; retval","ref":"Evision.html#psnr/2","title":"Evision.psnr/2","type":"function"},{"doc":"Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric. Positional Arguments src1 : Evision.Mat . first input array. src2 : Evision.Mat . second input array of the same size as src1. Keyword Arguments r : double . the maximum pixel value (255 by default) This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB), between two input arrays src1 and src2. The arrays must have the same type. The PSNR is calculated as follows: \\f[ \\texttt{PSNR} = 10 \\cdot \\log_{10}{\\left( \\frac{R^2}{MSE} \\right) } \\f] where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data) and MSE is the mean squared error between the two arrays. Python prototype (for reference): PSNR(src1, src2[, R]) -&gt; retval","ref":"Evision.html#psnr/3","title":"Evision.psnr/3","type":"function"},{"doc":"Raising version of putText/6 .","ref":"Evision.html#putText!/6","title":"Evision.putText!/6","type":"function"},{"doc":"Raising version of putText/7 .","ref":"Evision.html#putText!/7","title":"Evision.putText!/7","type":"function"},{"doc":"Draws a text string. Positional Arguments text : String . Text string to be drawn. org : Point . Bottom-left corner of the text string in the image. fontFace : int . Font type, see #HersheyFonts. fontScale : double . Font scale factor that is multiplied by the font-specific base size. color : Scalar . Text color. Keyword Arguments thickness : int . Thickness of the lines used to draw a text. lineType : int . Line type. See #LineTypes bottomLeftOrigin : bool . When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner. Return img : Evision.Mat . Image. The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See #getTextSize for a text rendering code example. Python prototype (for reference): putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) -&gt; img","ref":"Evision.html#putText/6","title":"Evision.putText/6","type":"function"},{"doc":"Draws a text string. Positional Arguments text : String . Text string to be drawn. org : Point . Bottom-left corner of the text string in the image. fontFace : int . Font type, see #HersheyFonts. fontScale : double . Font scale factor that is multiplied by the font-specific base size. color : Scalar . Text color. Keyword Arguments thickness : int . Thickness of the lines used to draw a text. lineType : int . Line type. See #LineTypes bottomLeftOrigin : bool . When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner. Return img : Evision.Mat . Image. The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See #getTextSize for a text rendering code example. Python prototype (for reference): putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) -&gt; img","ref":"Evision.html#putText/7","title":"Evision.putText/7","type":"function"},{"doc":"Raising version of pyrDown/1 .","ref":"Evision.html#pyrDown!/1","title":"Evision.pyrDown!/1","type":"function"},{"doc":"Raising version of pyrDown/2 .","ref":"Evision.html#pyrDown!/2","title":"Evision.pyrDown!/2","type":"function"},{"doc":"Blurs an image and downsamples it. Positional Arguments src : Evision.Mat . input image. Keyword Arguments dstsize : Size . size of the output image. borderType : int . Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported) Return dst : Evision.Mat . output image; it has the specified size and the same type as src. By default, size of the output image is computed as Size((src.cols+1)/2, (src.rows+1)/2) , but in any case, the following conditions should be satisfied: \\f[\\begin{array}{l} | \\texttt{dstsize.width} *2-src.cols| \\leq 2 \\\\ | \\texttt{dstsize.height} *2-src.rows| \\leq 2 \\end{array}\\f] The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel: \\f[\\frac{1}{256} \\begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \\\\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\\\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \\\\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\\\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \\end{bmatrix}\\f] Then, it downsamples the image by rejecting even rows and columns. Python prototype (for reference): pyrDown(src[, dst[, dstsize[, borderType]]]) -&gt; dst","ref":"Evision.html#pyrDown/1","title":"Evision.pyrDown/1","type":"function"},{"doc":"Blurs an image and downsamples it. Positional Arguments src : Evision.Mat . input image. Keyword Arguments dstsize : Size . size of the output image. borderType : int . Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported) Return dst : Evision.Mat . output image; it has the specified size and the same type as src. By default, size of the output image is computed as Size((src.cols+1)/2, (src.rows+1)/2) , but in any case, the following conditions should be satisfied: \\f[\\begin{array}{l} | \\texttt{dstsize.width} *2-src.cols| \\leq 2 \\\\ | \\texttt{dstsize.height} *2-src.rows| \\leq 2 \\end{array}\\f] The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel: \\f[\\frac{1}{256} \\begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \\\\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\\\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \\\\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\\\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \\end{bmatrix}\\f] Then, it downsamples the image by rejecting even rows and columns. Python prototype (for reference): pyrDown(src[, dst[, dstsize[, borderType]]]) -&gt; dst","ref":"Evision.html#pyrDown/2","title":"Evision.pyrDown/2","type":"function"},{"doc":"Raising version of pyrMeanShiftFiltering/3 .","ref":"Evision.html#pyrMeanShiftFiltering!/3","title":"Evision.pyrMeanShiftFiltering!/3","type":"function"},{"doc":"Raising version of pyrMeanShiftFiltering/4 .","ref":"Evision.html#pyrMeanShiftFiltering!/4","title":"Evision.pyrMeanShiftFiltering!/4","type":"function"},{"doc":"Performs initial step of meanshift segmentation of an image. Positional Arguments src : Evision.Mat . The source 8-bit, 3-channel image. sp : double . The spatial window radius. sr : double . The color window radius. Keyword Arguments maxLevel : int . Maximum level of the pyramid for the segmentation. termcrit : TermCriteria . Termination criteria: when to stop meanshift iterations. Return dst : Evision.Mat . The destination image of the same format and the same size as the source. The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered &quot;posterized&quot; image with color gradients and fine-grain texture flattened. At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is considered: \\f[(x,y): X- \\texttt{sp} \\le x \\le X+ \\texttt{sp} , Y- \\texttt{sp} \\le y \\le Y+ \\texttt{sp} , ||(R,G,B)-(r,g,b)|| \\le \\texttt{sr}\\f] where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively (though, the algorithm does not depend on the color space used, so any 3-component color space can be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector (R',G',B') are found and they act as the neighborhood center on the next iteration: \\f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\\f] After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration): \\f[I(X,Y) &lt;- (R*,G*,B*)\\f] When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than sr from the lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.e. when maxLevel==0). Python prototype (for reference): pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]]) -&gt; dst","ref":"Evision.html#pyrMeanShiftFiltering/3","title":"Evision.pyrMeanShiftFiltering/3","type":"function"},{"doc":"Performs initial step of meanshift segmentation of an image. Positional Arguments src : Evision.Mat . The source 8-bit, 3-channel image. sp : double . The spatial window radius. sr : double . The color window radius. Keyword Arguments maxLevel : int . Maximum level of the pyramid for the segmentation. termcrit : TermCriteria . Termination criteria: when to stop meanshift iterations. Return dst : Evision.Mat . The destination image of the same format and the same size as the source. The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered &quot;posterized&quot; image with color gradients and fine-grain texture flattened. At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is considered: \\f[(x,y): X- \\texttt{sp} \\le x \\le X+ \\texttt{sp} , Y- \\texttt{sp} \\le y \\le Y+ \\texttt{sp} , ||(R,G,B)-(r,g,b)|| \\le \\texttt{sr}\\f] where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively (though, the algorithm does not depend on the color space used, so any 3-component color space can be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector (R',G',B') are found and they act as the neighborhood center on the next iteration: \\f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\\f] After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration): \\f[I(X,Y) &lt;- (R*,G*,B*)\\f] When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than sr from the lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.e. when maxLevel==0). Python prototype (for reference): pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]]) -&gt; dst","ref":"Evision.html#pyrMeanShiftFiltering/4","title":"Evision.pyrMeanShiftFiltering/4","type":"function"},{"doc":"Raising version of pyrUp/1 .","ref":"Evision.html#pyrUp!/1","title":"Evision.pyrUp!/1","type":"function"},{"doc":"Raising version of pyrUp/2 .","ref":"Evision.html#pyrUp!/2","title":"Evision.pyrUp!/2","type":"function"},{"doc":"Upsamples an image and then blurs it. Positional Arguments src : Evision.Mat . input image. Keyword Arguments dstsize : Size . size of the output image. borderType : int . Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported) Return dst : Evision.Mat . output image. It has the specified size and the same type as src . By default, size of the output image is computed as Size(src.cols\\*2, (src.rows\\*2) , but in any case, the following conditions should be satisfied: \\f[\\begin{array}{l} | \\texttt{dstsize.width} -src.cols*2| \\leq ( \\texttt{dstsize.width} \\mod 2) \\\\ | \\texttt{dstsize.height} -src.rows*2| \\leq ( \\texttt{dstsize.height} \\mod 2) \\end{array}\\f] The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in pyrDown multiplied by 4. Python prototype (for reference): pyrUp(src[, dst[, dstsize[, borderType]]]) -&gt; dst","ref":"Evision.html#pyrUp/1","title":"Evision.pyrUp/1","type":"function"},{"doc":"Upsamples an image and then blurs it. Positional Arguments src : Evision.Mat . input image. Keyword Arguments dstsize : Size . size of the output image. borderType : int . Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported) Return dst : Evision.Mat . output image. It has the specified size and the same type as src . By default, size of the output image is computed as Size(src.cols\\*2, (src.rows\\*2) , but in any case, the following conditions should be satisfied: \\f[\\begin{array}{l} | \\texttt{dstsize.width} -src.cols*2| \\leq ( \\texttt{dstsize.width} \\mod 2) \\\\ | \\texttt{dstsize.height} -src.rows*2| \\leq ( \\texttt{dstsize.height} \\mod 2) \\end{array}\\f] The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in pyrDown multiplied by 4. Python prototype (for reference): pyrUp(src[, dst[, dstsize[, borderType]]]) -&gt; dst","ref":"Evision.html#pyrUp/2","title":"Evision.pyrUp/2","type":"function"},{"doc":"Raising version of randn/3 .","ref":"Evision.html#randn!/3","title":"Evision.randn!/3","type":"function"},{"doc":"Fills the array with normally distributed random numbers. Positional Arguments mean : Evision.Mat . mean value (expectation) of the generated random numbers. stddev : Evision.Mat . standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix. Return dst : Evision.Mat . output array of random numbers; the array must be pre-allocated and have 1 to 4 channels. The function cv::randn fills the matrix dst with normally distributed random numbers with the specified mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the value range of the output array data type. @sa RNG, randu Python prototype (for reference): randn(dst, mean, stddev) -&gt; dst","ref":"Evision.html#randn/3","title":"Evision.randn/3","type":"function"},{"doc":"Raising version of randShuffle/1 .","ref":"Evision.html#randShuffle!/1","title":"Evision.randShuffle!/1","type":"function"},{"doc":"Raising version of randShuffle/2 .","ref":"Evision.html#randShuffle!/2","title":"Evision.randShuffle!/2","type":"function"},{"doc":"Shuffles the array elements randomly. Keyword Arguments iterFactor : double . scale factor that determines the number of random swap operations (see the details below). Return dst : Evision.Mat . input/output numerical 1D array. The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and swapping them. The number of such swap operations will be dst.rows*dst.cols*iterFactor . @sa RNG, sort Python prototype (for reference): randShuffle(dst[, iterFactor]) -&gt; dst","ref":"Evision.html#randShuffle/1","title":"Evision.randShuffle/1","type":"function"},{"doc":"Shuffles the array elements randomly. Keyword Arguments iterFactor : double . scale factor that determines the number of random swap operations (see the details below). Return dst : Evision.Mat . input/output numerical 1D array. The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and swapping them. The number of such swap operations will be dst.rows*dst.cols*iterFactor . @sa RNG, sort Python prototype (for reference): randShuffle(dst[, iterFactor]) -&gt; dst","ref":"Evision.html#randShuffle/2","title":"Evision.randShuffle/2","type":"function"},{"doc":"Raising version of randu/3 .","ref":"Evision.html#randu!/3","title":"Evision.randu!/3","type":"function"},{"doc":"Generates a single uniformly-distributed random number or an array of random numbers. Positional Arguments low : Evision.Mat . inclusive lower boundary of the generated random numbers. high : Evision.Mat . exclusive upper boundary of the generated random numbers. Return dst : Evision.Mat . output array of random numbers; the array must be pre-allocated. Non-template variant of the function fills the matrix dst with uniformly-distributed random numbers from the specified range: \\f[\\texttt{low} _c \\leq \\texttt{dst} (I)_c &lt; \\texttt{high} _c\\f] @sa RNG, randn, theRNG Python prototype (for reference): randu(dst, low, high) -&gt; dst","ref":"Evision.html#randu/3","title":"Evision.randu/3","type":"function"},{"doc":"Raising version of readOpticalFlow/1 .","ref":"Evision.html#readOpticalFlow!/1","title":"Evision.readOpticalFlow!/1","type":"function"},{"doc":"Read a .flo file Positional Arguments path : String . Path to the file to be loaded The function readOpticalFlow loads a flow field from a file and returns it as a single matrix. Resulting Mat has a type CV_32FC2 - floating-point, 2-channel. First channel corresponds to the flow in the horizontal direction (u), second - vertical (v). Python prototype (for reference): readOpticalFlow(path) -&gt; retval","ref":"Evision.html#readOpticalFlow/1","title":"Evision.readOpticalFlow/1","type":"function"},{"doc":"Raising version of recoverPose/3 .","ref":"Evision.html#recoverPose!/3","title":"Evision.recoverPose!/3","type":"function"},{"doc":"Raising version of recoverPose/4 .","ref":"Evision.html#recoverPose!/4","title":"Evision.recoverPose!/4","type":"function"},{"doc":"Raising version of recoverPose/5 .","ref":"Evision.html#recoverPose!/5","title":"Evision.recoverPose!/5","type":"function"},{"doc":"Raising version of recoverPose/6 .","ref":"Evision.html#recoverPose!/6","title":"Evision.recoverPose!/6","type":"function"},{"doc":"Raising version of recoverPose/7 .","ref":"Evision.html#recoverPose!/7","title":"Evision.recoverPose!/7","type":"function"},{"doc":"Positional Arguments e : Evision.Mat . The input essential matrix. points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . Keyword Arguments focal : double . Focal length of the camera. Note that this function assumes that points1 and points2 are feature points from cameras with same focal length and principal point. pp : Point2d . principal point of the camera. Return r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter description below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. Has overloading in C++ This function differs from the one above that it computes camera intrinsic matrix from focal length and principal point: \\f[A = \\begin{bmatrix} f &amp; 0 &amp; x_{pp} \\\\ 0 &amp; f &amp; y_{pp} \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\f] Python prototype (for reference): recoverPose(E, points1, points2[, R[, t[, focal[, pp[, mask]]]]]) -&gt; retval, R, t, mask","ref":"Evision.html#recoverPose/3","title":"Evision.recoverPose/3","type":"function"},{"doc":"Variant 1: Recovers the relative camera rotation and the translation from an estimated essential matrix and the corresponding points in two images, using cheirality check. Returns the number of inliers that pass the check. Positional Arguments e : Evision.Mat . The input essential matrix. points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera intrinsic matrix. Return r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter described below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies possible pose hypotheses by doing cheirality check. The cheirality check means that the triangulated 3D points should have positive depth. Some details can be found in @cite Nister03. This function can be used to process the output E and mask from @ref findEssentialMat. In this scenario, points1 and points2 are the same input for #findEssentialMat : // Example . Estimation of fundamental matrix using the RANSAC algorithm int point_count = 100 ; vector &lt; Point2f &gt; points1 ( point_count ) ; vector &lt; Point2f &gt; points2 ( point_count ) ; // initialize the points here ... for ( int i = 0 ; i &lt; point_count ; i ++ ) { points1 [ i ] = ... ; points2 [ i ] = ... ; } // cametra matrix with both focal lengths = 1 , and principal point = ( 0 , 0 ) Mat cameraMatrix = Mat :: eye ( 3 , 3 , CV_64F ) ; Mat E , R , t , mask ; E = findEssentialMat ( points1 , points2 , cameraMatrix , RANSAC , 0.999 , 1.0 , mask ) ; recoverPose ( E , points1 , points2 , cameraMatrix , R , t , mask ) ; Python prototype (for reference): recoverPose(E, points1, points2, cameraMatrix[, R[, t[, mask]]]) -&gt; retval, R, t, mask Variant 2: Positional Arguments e : Evision.Mat . The input essential matrix. points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . Keyword Arguments focal : double . Focal length of the camera. Note that this function assumes that points1 and points2 are feature points from cameras with same focal length and principal point. pp : Point2d . principal point of the camera. Return r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter description below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. Has overloading in C++ This function differs from the one above that it computes camera intrinsic matrix from focal length and principal point: \\f[A = \\begin{bmatrix} f &amp; 0 &amp; x_{pp} \\\\ 0 &amp; f &amp; y_{pp} \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\f] Python prototype (for reference): recoverPose(E, points1, points2[, R[, t[, focal[, pp[, mask]]]]]) -&gt; retval, R, t, mask","ref":"Evision.html#recoverPose/4","title":"Evision.recoverPose/4","type":"function"},{"doc":"Variant 1: Positional Arguments e : Evision.Mat . The input essential matrix. points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1. cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera intrinsic matrix. distanceThresh : double . threshold distance which is used to filter out far away points (i.e. infinite points). Return r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter description below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. triangulatedPoints : Evision.Mat . 3D points which were reconstructed by triangulation. Has overloading in C++ This function differs from the one above that it outputs the triangulated 3D point that are used for the cheirality check. Python prototype (for reference): recoverPose(E, points1, points2, cameraMatrix, distanceThresh[, R[, t[, mask[, triangulatedPoints]]]]) -&gt; retval, R, t, mask, triangulatedPoints Variant 2: Recovers the relative camera rotation and the translation from an estimated essential matrix and the corresponding points in two images, using cheirality check. Returns the number of inliers that pass the check. Positional Arguments e : Evision.Mat . The input essential matrix. points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera intrinsic matrix. Return r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter described below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies possible pose hypotheses by doing cheirality check. The cheirality check means that the triangulated 3D points should have positive depth. Some details can be found in @cite Nister03. This function can be used to process the output E and mask from @ref findEssentialMat. In this scenario, points1 and points2 are the same input for #findEssentialMat : // Example . Estimation of fundamental matrix using the RANSAC algorithm int point_count = 100 ; vector &lt; Point2f &gt; points1 ( point_count ) ; vector &lt; Point2f &gt; points2 ( point_count ) ; // initialize the points here ... for ( int i = 0 ; i &lt; point_count ; i ++ ) { points1 [ i ] = ... ; points2 [ i ] = ... ; } // cametra matrix with both focal lengths = 1 , and principal point = ( 0 , 0 ) Mat cameraMatrix = Mat :: eye ( 3 , 3 , CV_64F ) ; Mat E , R , t , mask ; E = findEssentialMat ( points1 , points2 , cameraMatrix , RANSAC , 0.999 , 1.0 , mask ) ; recoverPose ( E , points1 , points2 , cameraMatrix , R , t , mask ) ; Python prototype (for reference): recoverPose(E, points1, points2, cameraMatrix[, R[, t[, mask]]]) -&gt; retval, R, t, mask","ref":"Evision.html#recoverPose/5","title":"Evision.recoverPose/5","type":"function"},{"doc":"Variant 1: Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using cheirality check. Returns the number of inliers that pass the check. Positional Arguments points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix1 : Evision.Mat . Input/output camera matrix for the first camera, the same as in distCoeffs1 : Evision.Mat . Input/output vector of distortion coefficients, the same as in cameraMatrix2 : Evision.Mat . Input/output camera matrix for the first camera, the same as in distCoeffs2 : Evision.Mat . Input/output vector of distortion coefficients, the same as in Keyword Arguments method : int . Method for computing an essential matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. Return e : Evision.Mat . The output essential matrix. r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter described below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below. @ref calibrateCamera. @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below. @ref calibrateCamera. This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies possible pose hypotheses by doing cheirality check. The cheirality check means that the triangulated 3D points should have positive depth. Some details can be found in @cite Nister03. This function can be used to process the output E and mask from @ref findEssentialMat. In this scenario, points1 and points2 are the same input for findEssentialMat.: // Example . Estimation of fundamental matrix using the RANSAC algorithm int point_count = 100 ; vector &lt; Point2f &gt; points1 ( point_count ) ; vector &lt; Point2f &gt; points2 ( point_count ) ; // initialize the points here ... for ( int i = 0 ; i &lt; point_count ; i ++ ) { points1 [ i ] = ... ; points2 [ i ] = ... ; } // Input : camera calibration of both cameras , for example using intrinsic chessboard calibration . Mat cameraMatrix1 , distCoeffs1 , cameraMatrix2 , distCoeffs2 ; // Output : Essential matrix , relative rotation and relative translation . Mat E , R , t , mask ; recoverPose ( points1 , points2 , cameraMatrix1 , distCoeffs1 , cameraMatrix2 , distCoeffs2 , E , R , t , mask ) ; Python prototype (for reference): recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, E[, R[, t[, method[, prob[, threshold[, mask]]]]]]]) -&gt; retval, E, R, t, mask Variant 2: Positional Arguments e : Evision.Mat . The input essential matrix. points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1. cameraMatrix : Evision.Mat . Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera intrinsic matrix. distanceThresh : double . threshold distance which is used to filter out far away points (i.e. infinite points). Return r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter description below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. triangulatedPoints : Evision.Mat . 3D points which were reconstructed by triangulation. Has overloading in C++ This function differs from the one above that it outputs the triangulated 3D point that are used for the cheirality check. Python prototype (for reference): recoverPose(E, points1, points2, cameraMatrix, distanceThresh[, R[, t[, mask[, triangulatedPoints]]]]) -&gt; retval, R, t, mask, triangulatedPoints","ref":"Evision.html#recoverPose/6","title":"Evision.recoverPose/6","type":"function"},{"doc":"Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using cheirality check. Returns the number of inliers that pass the check. Positional Arguments points1 : Evision.Mat . Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision). points2 : Evision.Mat . Array of the second image points of the same size and format as points1 . cameraMatrix1 : Evision.Mat . Input/output camera matrix for the first camera, the same as in distCoeffs1 : Evision.Mat . Input/output vector of distortion coefficients, the same as in cameraMatrix2 : Evision.Mat . Input/output camera matrix for the first camera, the same as in distCoeffs2 : Evision.Mat . Input/output vector of distortion coefficients, the same as in Keyword Arguments method : int . Method for computing an essential matrix. @ref RANSAC for the RANSAC algorithm. @ref LMEDS for the LMedS algorithm. prob : double . Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. threshold : double . Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise. Return e : Evision.Mat . The output essential matrix. r : Evision.Mat . Output rotation matrix. Together with the translation vector, this matrix makes up a tuple that performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Note that, in general, t can not be used for this tuple, see the parameter described below. t : Evision.Mat . Output translation vector. This vector is obtained by @ref decomposeEssentialMat and therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit length. mask : Evision.Mat . Input/output mask for inliers in points1 and points2. If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check. @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below. @ref calibrateCamera. @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below. @ref calibrateCamera. This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies possible pose hypotheses by doing cheirality check. The cheirality check means that the triangulated 3D points should have positive depth. Some details can be found in @cite Nister03. This function can be used to process the output E and mask from @ref findEssentialMat. In this scenario, points1 and points2 are the same input for findEssentialMat.: // Example . Estimation of fundamental matrix using the RANSAC algorithm int point_count = 100 ; vector &lt; Point2f &gt; points1 ( point_count ) ; vector &lt; Point2f &gt; points2 ( point_count ) ; // initialize the points here ... for ( int i = 0 ; i &lt; point_count ; i ++ ) { points1 [ i ] = ... ; points2 [ i ] = ... ; } // Input : camera calibration of both cameras , for example using intrinsic chessboard calibration . Mat cameraMatrix1 , distCoeffs1 , cameraMatrix2 , distCoeffs2 ; // Output : Essential matrix , relative rotation and relative translation . Mat E , R , t , mask ; recoverPose ( points1 , points2 , cameraMatrix1 , distCoeffs1 , cameraMatrix2 , distCoeffs2 , E , R , t , mask ) ; Python prototype (for reference): recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, E[, R[, t[, method[, prob[, threshold[, mask]]]]]]]) -&gt; retval, E, R, t, mask","ref":"Evision.html#recoverPose/7","title":"Evision.recoverPose/7","type":"function"},{"doc":"Raising version of rectangle/3 .","ref":"Evision.html#rectangle!/3","title":"Evision.rectangle!/3","type":"function"},{"doc":"Raising version of rectangle/4 .","ref":"Evision.html#rectangle!/4","title":"Evision.rectangle!/4","type":"function"},{"doc":"Raising version of rectangle/5 .","ref":"Evision.html#rectangle!/5","title":"Evision.rectangle!/5","type":"function"},{"doc":"Positional Arguments rec : Rect color : Scalar Keyword Arguments thickness : int . lineType : int . shift : int . Return img : Evision.Mat Has overloading in C++ use rec parameter as alternative specification of the drawn rectangle: r.tl() and r.br()-Point(1,1) are opposite corners Python prototype (for reference): rectangle(img, rec, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#rectangle/3","title":"Evision.rectangle/3","type":"function"},{"doc":"Variant 1: Draws a simple, thick, or filled up-right rectangle. Positional Arguments pt1 : Point . Vertex of the rectangle. pt2 : Point . Vertex of the rectangle opposite to pt1 . color : Scalar . Rectangle color or brightness (grayscale image). Keyword Arguments thickness : int . Thickness of lines that make up the rectangle. Negative values, like #FILLED, mean that the function has to draw a filled rectangle. lineType : int . Type of the line. See #LineTypes shift : int . Number of fractional bits in the point coordinates. Return img : Evision.Mat . Image. The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners are pt1 and pt2. Python prototype (for reference): rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -&gt; img Variant 2: Positional Arguments rec : Rect color : Scalar Keyword Arguments thickness : int . lineType : int . shift : int . Return img : Evision.Mat Has overloading in C++ use rec parameter as alternative specification of the drawn rectangle: r.tl() and r.br()-Point(1,1) are opposite corners Python prototype (for reference): rectangle(img, rec, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#rectangle/4","title":"Evision.rectangle/4","type":"function"},{"doc":"Draws a simple, thick, or filled up-right rectangle. Positional Arguments pt1 : Point . Vertex of the rectangle. pt2 : Point . Vertex of the rectangle opposite to pt1 . color : Scalar . Rectangle color or brightness (grayscale image). Keyword Arguments thickness : int . Thickness of lines that make up the rectangle. Negative values, like #FILLED, mean that the function has to draw a filled rectangle. lineType : int . Type of the line. See #LineTypes shift : int . Number of fractional bits in the point coordinates. Return img : Evision.Mat . Image. The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners are pt1 and pt2. Python prototype (for reference): rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -&gt; img","ref":"Evision.html#rectangle/5","title":"Evision.rectangle/5","type":"function"},{"doc":"Raising version of rectify3Collinear/16 .","ref":"Evision.html#rectify3Collinear!/16","title":"Evision.rectify3Collinear!/16","type":"function"},{"doc":"Raising version of rectify3Collinear/17 .","ref":"Evision.html#rectify3Collinear!/17","title":"Evision.rectify3Collinear!/17","type":"function"},{"doc":"Positional Arguments cameraMatrix1 : Evision.Mat distCoeffs1 : Evision.Mat cameraMatrix2 : Evision.Mat distCoeffs2 : Evision.Mat cameraMatrix3 : Evision.Mat distCoeffs3 : Evision.Mat imgpt1 : [Evision.Mat] imgpt3 : [Evision.Mat] imageSize : Size r12 : Evision.Mat t12 : Evision.Mat r13 : Evision.Mat t13 : Evision.Mat alpha : double newImgSize : Size flags : int Return r1 : Evision.Mat . r2 : Evision.Mat . r3 : Evision.Mat . p1 : Evision.Mat . p2 : Evision.Mat . p3 : Evision.Mat . q : Evision.Mat . roi1 : Rect* roi2 : Rect* Python prototype (for reference): rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, alpha, newImgSize, flags[, R1[, R2[, R3[, P1[, P2[, P3[, Q]]]]]]]) -&gt; retval, R1, R2, R3, P1, P2, P3, Q, roi1, roi2","ref":"Evision.html#rectify3Collinear/16","title":"Evision.rectify3Collinear/16","type":"function"},{"doc":"Positional Arguments cameraMatrix1 : Evision.Mat distCoeffs1 : Evision.Mat cameraMatrix2 : Evision.Mat distCoeffs2 : Evision.Mat cameraMatrix3 : Evision.Mat distCoeffs3 : Evision.Mat imgpt1 : [Evision.Mat] imgpt3 : [Evision.Mat] imageSize : Size r12 : Evision.Mat t12 : Evision.Mat r13 : Evision.Mat t13 : Evision.Mat alpha : double newImgSize : Size flags : int Return r1 : Evision.Mat . r2 : Evision.Mat . r3 : Evision.Mat . p1 : Evision.Mat . p2 : Evision.Mat . p3 : Evision.Mat . q : Evision.Mat . roi1 : Rect* roi2 : Rect* Python prototype (for reference): rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, alpha, newImgSize, flags[, R1[, R2[, R3[, P1[, P2[, P3[, Q]]]]]]]) -&gt; retval, R1, R2, R3, P1, P2, P3, Q, roi1, roi2","ref":"Evision.html#rectify3Collinear/17","title":"Evision.rectify3Collinear/17","type":"function"},{"doc":"Raising version of reduce/3 .","ref":"Evision.html#reduce!/3","title":"Evision.reduce!/3","type":"function"},{"doc":"Raising version of reduce/4 .","ref":"Evision.html#reduce!/4","title":"Evision.reduce!/4","type":"function"},{"doc":"Reduces a matrix to a vector. Positional Arguments src : Evision.Mat . input 2D matrix. dim : int . dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column. rtype : int . reduction operation that could be one of #ReduceTypes Keyword Arguments dtype : int . when negative, the output vector will have the same type as the input matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()). Return dst : Evision.Mat . output vector. Its size and type is defined by dim and dtype parameters. The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of #REDUCE_MAX and #REDUCE_MIN , the output image should have the same type as the source one. In case of #REDUCE_SUM and #REDUCE_AVG , the output may have a larger element bit-depth to preserve accuracy. And multi-channel arrays are also supported in these two reduction modes. The following code demonstrates its usage for a single channel matrix. @snippet snippets/core_reduce.cpp example And the following code demonstrates its usage for a two-channel matrix. @snippet snippets/core_reduce.cpp example2 @sa repeat, reduceArgMin, reduceArgMax Python prototype (for reference): reduce(src, dim, rtype[, dst[, dtype]]) -&gt; dst","ref":"Evision.html#reduce/3","title":"Evision.reduce/3","type":"function"},{"doc":"Reduces a matrix to a vector. Positional Arguments src : Evision.Mat . input 2D matrix. dim : int . dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column. rtype : int . reduction operation that could be one of #ReduceTypes Keyword Arguments dtype : int . when negative, the output vector will have the same type as the input matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()). Return dst : Evision.Mat . output vector. Its size and type is defined by dim and dtype parameters. The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of #REDUCE_MAX and #REDUCE_MIN , the output image should have the same type as the source one. In case of #REDUCE_SUM and #REDUCE_AVG , the output may have a larger element bit-depth to preserve accuracy. And multi-channel arrays are also supported in these two reduction modes. The following code demonstrates its usage for a single channel matrix. @snippet snippets/core_reduce.cpp example And the following code demonstrates its usage for a two-channel matrix. @snippet snippets/core_reduce.cpp example2 @sa repeat, reduceArgMin, reduceArgMax Python prototype (for reference): reduce(src, dim, rtype[, dst[, dtype]]) -&gt; dst","ref":"Evision.html#reduce/4","title":"Evision.reduce/4","type":"function"},{"doc":"Raising version of reduceArgMax/2 .","ref":"Evision.html#reduceArgMax!/2","title":"Evision.reduceArgMax!/2","type":"function"},{"doc":"Raising version of reduceArgMax/3 .","ref":"Evision.html#reduceArgMax!/3","title":"Evision.reduceArgMax!/3","type":"function"},{"doc":"Finds indices of max elements along provided axis Positional Arguments src : Evision.Mat . input single-channel array. axis : int . axis to reduce along. Keyword Arguments lastIndex : bool . whether to get the index of first or last occurrence of max. Return dst : Evision.Mat . output array of type CV_32SC1 with the same dimensionality as src, except for axis being reduced - it should be set to 1. Note : If input or output array is not continuous, this function will create an internal copy. NaN handling is left unspecified, see patchNaNs(). The returned index is always in bounds of input matrix. @sa reduceArgMin, minMaxLoc, min, max, compare, reduce Python prototype (for reference): reduceArgMax(src, axis[, dst[, lastIndex]]) -&gt; dst","ref":"Evision.html#reduceArgMax/2","title":"Evision.reduceArgMax/2","type":"function"},{"doc":"Finds indices of max elements along provided axis Positional Arguments src : Evision.Mat . input single-channel array. axis : int . axis to reduce along. Keyword Arguments lastIndex : bool . whether to get the index of first or last occurrence of max. Return dst : Evision.Mat . output array of type CV_32SC1 with the same dimensionality as src, except for axis being reduced - it should be set to 1. Note : If input or output array is not continuous, this function will create an internal copy. NaN handling is left unspecified, see patchNaNs(). The returned index is always in bounds of input matrix. @sa reduceArgMin, minMaxLoc, min, max, compare, reduce Python prototype (for reference): reduceArgMax(src, axis[, dst[, lastIndex]]) -&gt; dst","ref":"Evision.html#reduceArgMax/3","title":"Evision.reduceArgMax/3","type":"function"},{"doc":"Raising version of reduceArgMin/2 .","ref":"Evision.html#reduceArgMin!/2","title":"Evision.reduceArgMin!/2","type":"function"},{"doc":"Raising version of reduceArgMin/3 .","ref":"Evision.html#reduceArgMin!/3","title":"Evision.reduceArgMin!/3","type":"function"},{"doc":"Finds indices of min elements along provided axis Positional Arguments src : Evision.Mat . input single-channel array. axis : int . axis to reduce along. Keyword Arguments lastIndex : bool . whether to get the index of first or last occurrence of min. Return dst : Evision.Mat . output array of type CV_32SC1 with the same dimensionality as src, except for axis being reduced - it should be set to 1. Note : If input or output array is not continuous, this function will create an internal copy. NaN handling is left unspecified, see patchNaNs(). The returned index is always in bounds of input matrix. @sa reduceArgMax, minMaxLoc, min, max, compare, reduce Python prototype (for reference): reduceArgMin(src, axis[, dst[, lastIndex]]) -&gt; dst","ref":"Evision.html#reduceArgMin/2","title":"Evision.reduceArgMin/2","type":"function"},{"doc":"Finds indices of min elements along provided axis Positional Arguments src : Evision.Mat . input single-channel array. axis : int . axis to reduce along. Keyword Arguments lastIndex : bool . whether to get the index of first or last occurrence of min. Return dst : Evision.Mat . output array of type CV_32SC1 with the same dimensionality as src, except for axis being reduced - it should be set to 1. Note : If input or output array is not continuous, this function will create an internal copy. NaN handling is left unspecified, see patchNaNs(). The returned index is always in bounds of input matrix. @sa reduceArgMax, minMaxLoc, min, max, compare, reduce Python prototype (for reference): reduceArgMin(src, axis[, dst[, lastIndex]]) -&gt; dst","ref":"Evision.html#reduceArgMin/3","title":"Evision.reduceArgMin/3","type":"function"},{"doc":"Raising version of remap/4 .","ref":"Evision.html#remap!/4","title":"Evision.remap!/4","type":"function"},{"doc":"Raising version of remap/5 .","ref":"Evision.html#remap!/5","title":"Evision.remap!/5","type":"function"},{"doc":"Applies a generic geometrical transformation to an image. Positional Arguments src : Evision.Mat . Source image. map1 : Evision.Mat . The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1, or CV_32FC2. See #convertMaps for details on converting a floating point representation to fixed-point for speed. map2 : Evision.Mat . The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively. interpolation : int . Interpolation method (see #InterpolationFlags). The methods #INTER_AREA and #INTER_LINEAR_EXACT are not supported by this function. Keyword Arguments borderMode : int . Pixel extrapolation method (see #BorderTypes). When borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that corresponds to the &quot;outliers&quot; in the source image are not modified by the function. borderValue : Scalar . Value used in case of a constant border. By default, it is 0. Return dst : Evision.Mat . Destination image. It has the same size as map1 and the same type as src . The function remap transforms the source image using the specified map: \\f[\\texttt{dst} (x,y) = \\texttt{src} (map_x(x,y),map_y(x,y))\\f] where values of pixels with non-integer coordinates are computed using one of available interpolation methods. \\f$map_x\\f$ and \\f$map_y\\f$ can be encoded as separate floating-point maps in \\f$map_1\\f$ and \\f$map_2\\f$ respectively, or interleaved floating-point maps of \\f$(x,y)\\f$ in \\f$map_1\\f$, or fixed-point maps created by using #convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (\\~2x) remapping operations. In the converted case, \\f$map_1\\f$ contains pairs (cvFloor(x), cvFloor(y)) and \\f$map_2\\f$ contains indices in a table of interpolation coefficients. This function cannot operate in-place. Note : Due to current implementation limitations the size of an input and output images should be less than 32767x32767. Python prototype (for reference): remap(src, map1, map2, interpolation[, dst[, borderMode[, borderValue]]]) -&gt; dst","ref":"Evision.html#remap/4","title":"Evision.remap/4","type":"function"},{"doc":"Applies a generic geometrical transformation to an image. Positional Arguments src : Evision.Mat . Source image. map1 : Evision.Mat . The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1, or CV_32FC2. See #convertMaps for details on converting a floating point representation to fixed-point for speed. map2 : Evision.Mat . The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively. interpolation : int . Interpolation method (see #InterpolationFlags). The methods #INTER_AREA and #INTER_LINEAR_EXACT are not supported by this function. Keyword Arguments borderMode : int . Pixel extrapolation method (see #BorderTypes). When borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that corresponds to the &quot;outliers&quot; in the source image are not modified by the function. borderValue : Scalar . Value used in case of a constant border. By default, it is 0. Return dst : Evision.Mat . Destination image. It has the same size as map1 and the same type as src . The function remap transforms the source image using the specified map: \\f[\\texttt{dst} (x,y) = \\texttt{src} (map_x(x,y),map_y(x,y))\\f] where values of pixels with non-integer coordinates are computed using one of available interpolation methods. \\f$map_x\\f$ and \\f$map_y\\f$ can be encoded as separate floating-point maps in \\f$map_1\\f$ and \\f$map_2\\f$ respectively, or interleaved floating-point maps of \\f$(x,y)\\f$ in \\f$map_1\\f$, or fixed-point maps created by using #convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (\\~2x) remapping operations. In the converted case, \\f$map_1\\f$ contains pairs (cvFloor(x), cvFloor(y)) and \\f$map_2\\f$ contains indices in a table of interpolation coefficients. This function cannot operate in-place. Note : Due to current implementation limitations the size of an input and output images should be less than 32767x32767. Python prototype (for reference): remap(src, map1, map2, interpolation[, dst[, borderMode[, borderValue]]]) -&gt; dst","ref":"Evision.html#remap/5","title":"Evision.remap/5","type":"function"},{"doc":"Raising version of repeat/3 .","ref":"Evision.html#repeat!/3","title":"Evision.repeat!/3","type":"function"},{"doc":"Raising version of repeat/4 .","ref":"Evision.html#repeat!/4","title":"Evision.repeat!/4","type":"function"},{"doc":"Fills the output array with repeated copies of the input array. Positional Arguments src : Evision.Mat . input array to replicate. ny : int . Flag to specify how many times the src is repeated along the vertical axis. nx : int . Flag to specify how many times the src is repeated along the horizontal axis. Return dst : Evision.Mat . output array of the same type as src . The function cv::repeat duplicates the input array one or more times along each of the two axes: \\f[\\texttt{dst} _{ij}= \\texttt{src} _{i\\mod src.rows, \\; j\\mod src.cols }\\f] The second variant of the function is more convenient to use with @ref MatrixExpressions. @sa cv::reduce Python prototype (for reference): repeat(src, ny, nx[, dst]) -&gt; dst","ref":"Evision.html#repeat/3","title":"Evision.repeat/3","type":"function"},{"doc":"Fills the output array with repeated copies of the input array. Positional Arguments src : Evision.Mat . input array to replicate. ny : int . Flag to specify how many times the src is repeated along the vertical axis. nx : int . Flag to specify how many times the src is repeated along the horizontal axis. Return dst : Evision.Mat . output array of the same type as src . The function cv::repeat duplicates the input array one or more times along each of the two axes: \\f[\\texttt{dst} _{ij}= \\texttt{src} _{i\\mod src.rows, \\; j\\mod src.cols }\\f] The second variant of the function is more convenient to use with @ref MatrixExpressions. @sa cv::reduce Python prototype (for reference): repeat(src, ny, nx[, dst]) -&gt; dst","ref":"Evision.html#repeat/4","title":"Evision.repeat/4","type":"function"},{"doc":"Raising version of reprojectImageTo3D/2 .","ref":"Evision.html#reprojectImageTo3D!/2","title":"Evision.reprojectImageTo3D!/2","type":"function"},{"doc":"Raising version of reprojectImageTo3D/3 .","ref":"Evision.html#reprojectImageTo3D!/3","title":"Evision.reprojectImageTo3D!/3","type":"function"},{"doc":"Reprojects a disparity image to 3D space. Positional Arguments disparity : Evision.Mat . Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit floating-point disparity image. The values of 8-bit / 16-bit signed formats are assumed to have no fractional bits. If the disparity is 16-bit signed format, as computed by @ref StereoBM or q : Evision.Mat . \\f$4 \\times 4\\f$ perspective transformation matrix that can be obtained with Keyword Arguments handleMissingValues : bool . Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). If handleMissingValues=true, then pixels with the minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed to 3D points with a very large Z value (currently set to 10000). ddepth : int . The optional output array depth. If it is -1, the output image will have CV_32F depth. ddepth can also be set to CV_16S, CV_32S or CV_32F. Return 3dImage : Evision.Mat . Output 3-channel floating-point image of the same size as disparity. Each element of _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map. If one uses Q obtained by @ref stereoRectify, then the returned points are represented in the first camera's rectified coordinate system. @ref StereoSGBM and maybe other algorithms, it should be divided by 16 (and scaled to float) before being used here. @ref stereoRectify. The function transforms a single-channel disparity map to a 3-channel image representing a 3D surface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it computes: \\f[\\begin{bmatrix} X \\\\ Y \\\\ Z \\\\ W \\end{bmatrix} = Q \\begin{bmatrix} x \\\\ y \\\\ \\texttt{disparity} (x,y) \\\\ z \\end{bmatrix}.\\f] @sa To reproject a sparse set of points {(x,y,d),...} to 3D space, use perspectiveTransform. Python prototype (for reference): reprojectImageTo3D(disparity, Q[, _3dImage[, handleMissingValues[, ddepth]]]) -&gt; _3dImage","ref":"Evision.html#reprojectImageTo3D/2","title":"Evision.reprojectImageTo3D/2","type":"function"},{"doc":"Reprojects a disparity image to 3D space. Positional Arguments disparity : Evision.Mat . Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit floating-point disparity image. The values of 8-bit / 16-bit signed formats are assumed to have no fractional bits. If the disparity is 16-bit signed format, as computed by @ref StereoBM or q : Evision.Mat . \\f$4 \\times 4\\f$ perspective transformation matrix that can be obtained with Keyword Arguments handleMissingValues : bool . Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). If handleMissingValues=true, then pixels with the minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed to 3D points with a very large Z value (currently set to 10000). ddepth : int . The optional output array depth. If it is -1, the output image will have CV_32F depth. ddepth can also be set to CV_16S, CV_32S or CV_32F. Return 3dImage : Evision.Mat . Output 3-channel floating-point image of the same size as disparity. Each element of _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map. If one uses Q obtained by @ref stereoRectify, then the returned points are represented in the first camera's rectified coordinate system. @ref StereoSGBM and maybe other algorithms, it should be divided by 16 (and scaled to float) before being used here. @ref stereoRectify. The function transforms a single-channel disparity map to a 3-channel image representing a 3D surface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it computes: \\f[\\begin{bmatrix} X \\\\ Y \\\\ Z \\\\ W \\end{bmatrix} = Q \\begin{bmatrix} x \\\\ y \\\\ \\texttt{disparity} (x,y) \\\\ z \\end{bmatrix}.\\f] @sa To reproject a sparse set of points {(x,y,d),...} to 3D space, use perspectiveTransform. Python prototype (for reference): reprojectImageTo3D(disparity, Q[, _3dImage[, handleMissingValues[, ddepth]]]) -&gt; _3dImage","ref":"Evision.html#reprojectImageTo3D/3","title":"Evision.reprojectImageTo3D/3","type":"function"},{"doc":"Raising version of resize/2 .","ref":"Evision.html#resize!/2","title":"Evision.resize!/2","type":"function"},{"doc":"Raising version of resize/3 .","ref":"Evision.html#resize!/3","title":"Evision.resize!/3","type":"function"},{"doc":"Resizes an image. Positional Arguments src : Evision.Mat . input image. dsize : Size . output image size; if it equals zero ( None in Python), it is computed as: \\f[\\texttt{dsize = Size(round(fx src.cols), round(fy src.rows))}\\f] Either dsize or both fx and fy must be non-zero. Keyword Arguments fx : double . scale factor along the horizontal axis; when it equals 0, it is computed as \\f[\\texttt{(double)dsize.width/src.cols}\\f] fy : double . scale factor along the vertical axis; when it equals 0, it is computed as \\f[\\texttt{(double)dsize.height/src.rows}\\f] interpolation : int . interpolation method, see #InterpolationFlags Return dst : Evision.Mat . output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src. The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the src , dsize , fx , and fy . If you want to resize src so that it fits the pre-created dst, you may call the function as follows: // explicitly specify dsize = dst . size ( ) ; fx and fy will be computed from that . resize ( src , dst , dst . size ( ) , 0 , 0 , interpolation ) ; If you want to decimate the image by factor of 2 in each direction, you can call the function this way: // specify fx and fy and let the function compute the destination image size . resize ( src , dst , Size ( ) , 0.5 , 0.5 , interpolation ) ; To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR (faster but still looks OK). @sa warpAffine, warpPerspective, remap Python prototype (for reference): resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) -&gt; dst","ref":"Evision.html#resize/2","title":"Evision.resize/2","type":"function"},{"doc":"Resizes an image. Positional Arguments src : Evision.Mat . input image. dsize : Size . output image size; if it equals zero ( None in Python), it is computed as: \\f[\\texttt{dsize = Size(round(fx src.cols), round(fy src.rows))}\\f] Either dsize or both fx and fy must be non-zero. Keyword Arguments fx : double . scale factor along the horizontal axis; when it equals 0, it is computed as \\f[\\texttt{(double)dsize.width/src.cols}\\f] fy : double . scale factor along the vertical axis; when it equals 0, it is computed as \\f[\\texttt{(double)dsize.height/src.rows}\\f] interpolation : int . interpolation method, see #InterpolationFlags Return dst : Evision.Mat . output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src. The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the src , dsize , fx , and fy . If you want to resize src so that it fits the pre-created dst, you may call the function as follows: // explicitly specify dsize = dst . size ( ) ; fx and fy will be computed from that . resize ( src , dst , dst . size ( ) , 0 , 0 , interpolation ) ; If you want to decimate the image by factor of 2 in each direction, you can call the function this way: // specify fx and fy and let the function compute the destination image size . resize ( src , dst , Size ( ) , 0.5 , 0.5 , interpolation ) ; To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR (faster but still looks OK). @sa warpAffine, warpPerspective, remap Python prototype (for reference): resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) -&gt; dst","ref":"Evision.html#resize/3","title":"Evision.resize/3","type":"function"},{"doc":"Raising version of resizeWindow/2 .","ref":"Evision.html#resizeWindow!/2","title":"Evision.resizeWindow!/2","type":"function"},{"doc":"Raising version of resizeWindow/3 .","ref":"Evision.html#resizeWindow!/3","title":"Evision.resizeWindow!/3","type":"function"},{"doc":"Positional Arguments winname : String . Window name. size : Size . The new window size. Has overloading in C++ Python prototype (for reference): resizeWindow(winname, size) -&gt; None","ref":"Evision.html#resizeWindow/2","title":"Evision.resizeWindow/2","type":"function"},{"doc":"Resizes the window to the specified size Positional Arguments winname : String . Window name. width : int . The new window width. height : int . The new window height. Note : The specified window size is for the image area. Toolbars are not counted. Only windows created without cv::WINDOW_AUTOSIZE flag can be resized. Python prototype (for reference): resizeWindow(winname, width, height) -&gt; None","ref":"Evision.html#resizeWindow/3","title":"Evision.resizeWindow/3","type":"function"},{"doc":"Raising version of rodrigues/1 .","ref":"Evision.html#rodrigues!/1","title":"Evision.rodrigues!/1","type":"function"},{"doc":"Raising version of rodrigues/2 .","ref":"Evision.html#rodrigues!/2","title":"Evision.rodrigues!/2","type":"function"},{"doc":"Converts a rotation matrix to a rotation vector or vice versa. Positional Arguments src : Evision.Mat . Input rotation vector (3x1 or 1x3) or rotation matrix (3x3). Return dst : Evision.Mat . Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively. jacobian : Evision.Mat . Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial derivatives of the output array components with respect to the input array components. \\f[\\begin{array}{l} \\theta \\leftarrow norm(r) \\\\ r \\leftarrow r/ \\theta \\\\ R = \\cos(\\theta) I + (1- \\cos{\\theta} ) r r^T + \\sin(\\theta) \\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \\end{array}\\f] Inverse transformation can be also done easily, since \\f[\\sin ( \\theta ) \\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \\frac{R - R^T}{2}\\f] A rotation vector is a convenient and most compact representation of a rotation matrix (since any rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry optimization procedures like @ref calibrateCamera, @ref stereoCalibrate, or @ref solvePnP . Note : More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate can be found in: A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi @cite Gallego2014ACF Note : Useful information on SE(3) and Lie Groups can be found in: A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco @cite blanco2010tutorial Lie Groups for 2D and 3D Transformation, Ethan Eade @cite Eade17 A micro Lie theory for state estimation in robotics, Joan Sol, Jrmie Deray, Dinesh Atchuthan @cite Sol2018AML Python prototype (for reference): Rodrigues(src[, dst[, jacobian]]) -&gt; dst, jacobian","ref":"Evision.html#rodrigues/1","title":"Evision.rodrigues/1","type":"function"},{"doc":"Converts a rotation matrix to a rotation vector or vice versa. Positional Arguments src : Evision.Mat . Input rotation vector (3x1 or 1x3) or rotation matrix (3x3). Return dst : Evision.Mat . Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively. jacobian : Evision.Mat . Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial derivatives of the output array components with respect to the input array components. \\f[\\begin{array}{l} \\theta \\leftarrow norm(r) \\\\ r \\leftarrow r/ \\theta \\\\ R = \\cos(\\theta) I + (1- \\cos{\\theta} ) r r^T + \\sin(\\theta) \\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \\end{array}\\f] Inverse transformation can be also done easily, since \\f[\\sin ( \\theta ) \\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \\frac{R - R^T}{2}\\f] A rotation vector is a convenient and most compact representation of a rotation matrix (since any rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry optimization procedures like @ref calibrateCamera, @ref stereoCalibrate, or @ref solvePnP . Note : More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate can be found in: A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi @cite Gallego2014ACF Note : Useful information on SE(3) and Lie Groups can be found in: A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco @cite blanco2010tutorial Lie Groups for 2D and 3D Transformation, Ethan Eade @cite Eade17 A micro Lie theory for state estimation in robotics, Joan Sol, Jrmie Deray, Dinesh Atchuthan @cite Sol2018AML Python prototype (for reference): Rodrigues(src[, dst[, jacobian]]) -&gt; dst, jacobian","ref":"Evision.html#rodrigues/2","title":"Evision.rodrigues/2","type":"function"},{"doc":"Raising version of rotate/2 .","ref":"Evision.html#rotate!/2","title":"Evision.rotate!/2","type":"function"},{"doc":"Raising version of rotate/3 .","ref":"Evision.html#rotate!/3","title":"Evision.rotate!/3","type":"function"},{"doc":"Rotates a 2D array in multiples of 90 degrees. The function cv::rotate rotates the array in one of three different ways: Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE). Rotate by 180 degrees clockwise (rotateCode = ROTATE_180). Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE). Positional Arguments src : Evision.Mat . input array. rotateCode : int . an enum to specify how to rotate the array; see the enum #RotateFlags Return dst : Evision.Mat . output array of the same type as src. The size is the same with ROTATE_180, and the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE. @sa transpose , repeat , completeSymm, flip, RotateFlags Python prototype (for reference): rotate(src, rotateCode[, dst]) -&gt; dst","ref":"Evision.html#rotate/2","title":"Evision.rotate/2","type":"function"},{"doc":"Rotates a 2D array in multiples of 90 degrees. The function cv::rotate rotates the array in one of three different ways: Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE). Rotate by 180 degrees clockwise (rotateCode = ROTATE_180). Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE). Positional Arguments src : Evision.Mat . input array. rotateCode : int . an enum to specify how to rotate the array; see the enum #RotateFlags Return dst : Evision.Mat . output array of the same type as src. The size is the same with ROTATE_180, and the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE. @sa transpose , repeat , completeSymm, flip, RotateFlags Python prototype (for reference): rotate(src, rotateCode[, dst]) -&gt; dst","ref":"Evision.html#rotate/3","title":"Evision.rotate/3","type":"function"},{"doc":"Raising version of rotatedRectangleIntersection/2 .","ref":"Evision.html#rotatedRectangleIntersection!/2","title":"Evision.rotatedRectangleIntersection!/2","type":"function"},{"doc":"Raising version of rotatedRectangleIntersection/3 .","ref":"Evision.html#rotatedRectangleIntersection!/3","title":"Evision.rotatedRectangleIntersection!/3","type":"function"},{"doc":"Finds out if there is any intersection between two rotated rectangles. Positional Arguments rect1 : {centre={x, y}, size={s1, s2}, angle} . First rectangle rect2 : {centre={x, y}, size={s1, s2}, angle} . Second rectangle Return intersectingRegion : Evision.Mat . The output array of the vertices of the intersecting region. It returns at most 8 vertices. Stored as std::vector\\&lt;cv::Point2f&gt; or cv::Mat as Mx1 of type CV_32FC2. If there is then the vertices of the intersecting region are returned as well. Below are some examples of intersection configurations. The hatched pattern indicates the intersecting region and the red vertices are returned by the function. @returns One of #RectanglesIntersectTypes Python prototype (for reference): rotatedRectangleIntersection(rect1, rect2[, intersectingRegion]) -&gt; retval, intersectingRegion","ref":"Evision.html#rotatedRectangleIntersection/2","title":"Evision.rotatedRectangleIntersection/2","type":"function"},{"doc":"Finds out if there is any intersection between two rotated rectangles. Positional Arguments rect1 : {centre={x, y}, size={s1, s2}, angle} . First rectangle rect2 : {centre={x, y}, size={s1, s2}, angle} . Second rectangle Return intersectingRegion : Evision.Mat . The output array of the vertices of the intersecting region. It returns at most 8 vertices. Stored as std::vector\\&lt;cv::Point2f&gt; or cv::Mat as Mx1 of type CV_32FC2. If there is then the vertices of the intersecting region are returned as well. Below are some examples of intersection configurations. The hatched pattern indicates the intersecting region and the red vertices are returned by the function. @returns One of #RectanglesIntersectTypes Python prototype (for reference): rotatedRectangleIntersection(rect1, rect2[, intersectingRegion]) -&gt; retval, intersectingRegion","ref":"Evision.html#rotatedRectangleIntersection/3","title":"Evision.rotatedRectangleIntersection/3","type":"function"},{"doc":"Raising version of rqDecomp3x3/1 .","ref":"Evision.html#rqDecomp3x3!/1","title":"Evision.rqDecomp3x3!/1","type":"function"},{"doc":"Raising version of rqDecomp3x3/2 .","ref":"Evision.html#rqDecomp3x3!/2","title":"Evision.rqDecomp3x3!/2","type":"function"},{"doc":"Computes an RQ decomposition of 3x3 matrices. Positional Arguments src : Evision.Mat . 3x3 input matrix. Return mtxR : Evision.Mat . Output 3x3 upper-triangular matrix. mtxQ : Evision.Mat . Output 3x3 orthogonal matrix. qx : Evision.Mat . Optional output 3x3 rotation matrix around x-axis. qy : Evision.Mat . Optional output 3x3 rotation matrix around y-axis. qz : Evision.Mat . Optional output 3x3 rotation matrix around z-axis. The function computes a RQ decomposition using the given rotations. This function is used in #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera and a rotation matrix. It optionally returns three rotation matrices, one for each axis, and the three Euler angles in degrees (as the return value) that could be used in OpenGL. Note, there is always more than one sequence of rotations about the three principal axes that results in the same orientation of an object, e.g. see @cite Slabaugh . Returned tree rotation matrices and corresponding three Euler angles are only one of the possible solutions. Python prototype (for reference): RQDecomp3x3(src[, mtxR[, mtxQ[, Qx[, Qy[, Qz]]]]]) -&gt; retval, mtxR, mtxQ, Qx, Qy, Qz","ref":"Evision.html#rqDecomp3x3/1","title":"Evision.rqDecomp3x3/1","type":"function"},{"doc":"Computes an RQ decomposition of 3x3 matrices. Positional Arguments src : Evision.Mat . 3x3 input matrix. Return mtxR : Evision.Mat . Output 3x3 upper-triangular matrix. mtxQ : Evision.Mat . Output 3x3 orthogonal matrix. qx : Evision.Mat . Optional output 3x3 rotation matrix around x-axis. qy : Evision.Mat . Optional output 3x3 rotation matrix around y-axis. qz : Evision.Mat . Optional output 3x3 rotation matrix around z-axis. The function computes a RQ decomposition using the given rotations. This function is used in #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera and a rotation matrix. It optionally returns three rotation matrices, one for each axis, and the three Euler angles in degrees (as the return value) that could be used in OpenGL. Note, there is always more than one sequence of rotations about the three principal axes that results in the same orientation of an object, e.g. see @cite Slabaugh . Returned tree rotation matrices and corresponding three Euler angles are only one of the possible solutions. Python prototype (for reference): RQDecomp3x3(src[, mtxR[, mtxQ[, Qx[, Qy[, Qz]]]]]) -&gt; retval, mtxR, mtxQ, Qx, Qy, Qz","ref":"Evision.html#rqDecomp3x3/2","title":"Evision.rqDecomp3x3/2","type":"function"},{"doc":"Raising version of sampsonDistance/3 .","ref":"Evision.html#sampsonDistance!/3","title":"Evision.sampsonDistance!/3","type":"function"},{"doc":"Calculates the Sampson Distance between two points. Positional Arguments pt1 : Evision.Mat . first homogeneous 2d point pt2 : Evision.Mat . second homogeneous 2d point f : Evision.Mat . fundamental matrix The function cv::sampsonDistance calculates and returns the first order approximation of the geometric error as: \\f[ sd( \\texttt{pt1} , \\texttt{pt2} )= \\frac{(\\texttt{pt2}^t \\cdot \\texttt{F} \\cdot \\texttt{pt1})^2} {((\\texttt{F} \\cdot \\texttt{pt1})(0))^2 + ((\\texttt{F} \\cdot \\texttt{pt1})(1))^2 + ((\\texttt{F}^t \\cdot \\texttt{pt2})(0))^2 + ((\\texttt{F}^t \\cdot \\texttt{pt2})(1))^2} \\f] The fundamental matrix may be calculated using the #findFundamentalMat function. See @cite HartleyZ00 11.4.3 for details. @return The computed Sampson distance. Python prototype (for reference): sampsonDistance(pt1, pt2, F) -&gt; retval","ref":"Evision.html#sampsonDistance/3","title":"Evision.sampsonDistance/3","type":"function"},{"doc":"Raising version of scaleAdd/3 .","ref":"Evision.html#scaleAdd!/3","title":"Evision.scaleAdd!/3","type":"function"},{"doc":"Raising version of scaleAdd/4 .","ref":"Evision.html#scaleAdd!/4","title":"Evision.scaleAdd!/4","type":"function"},{"doc":"Calculates the sum of a scaled array and another array. Positional Arguments src1 : Evision.Mat . first input array. alpha : double . scale factor for the first array. src2 : Evision.Mat . second input array of the same size and type as src1. Return dst : Evision.Mat . output array of the same size and type as src1. The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY or SAXPY in BLAS . It calculates the sum of a scaled array and another array: \\f[\\texttt{dst} (I)= \\texttt{scale} \\cdot \\texttt{src1} (I) + \\texttt{src2} (I)\\f] The function can also be emulated with a matrix expression, for example: Mat A(3, 3, CV_64F); ... A.row(0) = A.row(1)*2 + A.row(2); @sa add, addWeighted, subtract, Mat::dot, Mat::convertTo Python prototype (for reference): scaleAdd(src1, alpha, src2[, dst]) -&gt; dst","ref":"Evision.html#scaleAdd/3","title":"Evision.scaleAdd/3","type":"function"},{"doc":"Calculates the sum of a scaled array and another array. Positional Arguments src1 : Evision.Mat . first input array. alpha : double . scale factor for the first array. src2 : Evision.Mat . second input array of the same size and type as src1. Return dst : Evision.Mat . output array of the same size and type as src1. The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY or SAXPY in BLAS . It calculates the sum of a scaled array and another array: \\f[\\texttt{dst} (I)= \\texttt{scale} \\cdot \\texttt{src1} (I) + \\texttt{src2} (I)\\f] The function can also be emulated with a matrix expression, for example: Mat A(3, 3, CV_64F); ... A.row(0) = A.row(1)*2 + A.row(2); @sa add, addWeighted, subtract, Mat::dot, Mat::convertTo Python prototype (for reference): scaleAdd(src1, alpha, src2[, dst]) -&gt; dst","ref":"Evision.html#scaleAdd/4","title":"Evision.scaleAdd/4","type":"function"},{"doc":"Raising version of scharr/4 .","ref":"Evision.html#scharr!/4","title":"Evision.scharr!/4","type":"function"},{"doc":"Raising version of scharr/5 .","ref":"Evision.html#scharr!/5","title":"Evision.scharr!/5","type":"function"},{"doc":"Calculates the first x- or y- image derivative using Scharr operator. Positional Arguments src : Evision.Mat . input image. ddepth : int . output image depth, see @ref filter_depths &quot;combinations&quot; dx : int . order of the derivative x. dy : int . order of the derivative y. Keyword Arguments scale : double . optional scale factor for the computed derivative values; by default, no scaling is applied (see #getDerivKernels for details). delta : double . optional delta value that is added to the results prior to storing them in dst. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and the same number of channels as src. The function computes the first x- or y- spatial image derivative using the Scharr operator. The call \\f[\\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\\f] is equivalent to \\f[\\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\\f] @sa cartToPolar Python prototype (for reference): Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, borderType]]]]) -&gt; dst","ref":"Evision.html#scharr/4","title":"Evision.scharr/4","type":"function"},{"doc":"Calculates the first x- or y- image derivative using Scharr operator. Positional Arguments src : Evision.Mat . input image. ddepth : int . output image depth, see @ref filter_depths &quot;combinations&quot; dx : int . order of the derivative x. dy : int . order of the derivative y. Keyword Arguments scale : double . optional scale factor for the computed derivative values; by default, no scaling is applied (see #getDerivKernels for details). delta : double . optional delta value that is added to the results prior to storing them in dst. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and the same number of channels as src. The function computes the first x- or y- spatial image derivative using the Scharr operator. The call \\f[\\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\\f] is equivalent to \\f[\\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\\f] @sa cartToPolar Python prototype (for reference): Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, borderType]]]]) -&gt; dst","ref":"Evision.html#scharr/5","title":"Evision.scharr/5","type":"function"},{"doc":"Raising version of seamlessClone/5 .","ref":"Evision.html#seamlessClone!/5","title":"Evision.seamlessClone!/5","type":"function"},{"doc":"Raising version of seamlessClone/6 .","ref":"Evision.html#seamlessClone!/6","title":"Evision.seamlessClone!/6","type":"function"},{"doc":"Image editing tasks concern either global changes (color/intensity corrections, filters, deformations) or local changes concerned to a selection. Here we are interested in achieving local changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless manner. The extent of the changes ranges from slight distortions to complete replacement by novel content @cite PM03 . Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. dst : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. p : Point . Point in dst image where object is placed. flags : int . Cloning method that could be cv::NORMAL_CLONE, cv::MIXED_CLONE or cv::MONOCHROME_TRANSFER Return blend : Evision.Mat . Output image with the same size and type as dst. Python prototype (for reference): seamlessClone(src, dst, mask, p, flags[, blend]) -&gt; blend","ref":"Evision.html#seamlessClone/5","title":"Evision.seamlessClone/5","type":"function"},{"doc":"Image editing tasks concern either global changes (color/intensity corrections, filters, deformations) or local changes concerned to a selection. Here we are interested in achieving local changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless manner. The extent of the changes ranges from slight distortions to complete replacement by novel content @cite PM03 . Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. dst : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. p : Point . Point in dst image where object is placed. flags : int . Cloning method that could be cv::NORMAL_CLONE, cv::MIXED_CLONE or cv::MONOCHROME_TRANSFER Return blend : Evision.Mat . Output image with the same size and type as dst. Python prototype (for reference): seamlessClone(src, dst, mask, p, flags[, blend]) -&gt; blend","ref":"Evision.html#seamlessClone/6","title":"Evision.seamlessClone/6","type":"function"},{"doc":"Raising version of selectROI/1 .","ref":"Evision.html#selectROI!/1","title":"Evision.selectROI!/1","type":"function"},{"doc":"Raising version of selectROI/2 .","ref":"Evision.html#selectROI!/2","title":"Evision.selectROI!/2","type":"function"},{"doc":"Raising version of selectROI/3 .","ref":"Evision.html#selectROI!/3","title":"Evision.selectROI!/3","type":"function"},{"doc":"Positional Arguments img : Evision.Mat Keyword Arguments showCrosshair : bool . fromCenter : bool . Has overloading in C++ Python prototype (for reference): selectROI(img[, showCrosshair[, fromCenter]]) -&gt; retval","ref":"Evision.html#selectROI/1","title":"Evision.selectROI/1","type":"function"},{"doc":"Variant 1: Allows users to select a ROI on the given image. Positional Arguments windowName : String . name of the window where selection process will be shown. img : Evision.Mat . image to select a ROI. Keyword Arguments showCrosshair : bool . if true crosshair of selection rectangle will be shown. fromCenter : bool . if true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position. The function creates a window and allows users to select a ROI using the mouse. Controls: use space or enter to finish selection, use key c to cancel selection (function will return the zero cv::Rect). @return selected ROI or empty rect if selection canceled. Note : The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...). After finish of work an empty callback will be set for the used window. Python prototype (for reference): selectROI(windowName, img[, showCrosshair[, fromCenter]]) -&gt; retval Variant 2: Positional Arguments img : Evision.Mat Keyword Arguments showCrosshair : bool . fromCenter : bool . Has overloading in C++ Python prototype (for reference): selectROI(img[, showCrosshair[, fromCenter]]) -&gt; retval","ref":"Evision.html#selectROI/2","title":"Evision.selectROI/2","type":"function"},{"doc":"Allows users to select a ROI on the given image. Positional Arguments windowName : String . name of the window where selection process will be shown. img : Evision.Mat . image to select a ROI. Keyword Arguments showCrosshair : bool . if true crosshair of selection rectangle will be shown. fromCenter : bool . if true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position. The function creates a window and allows users to select a ROI using the mouse. Controls: use space or enter to finish selection, use key c to cancel selection (function will return the zero cv::Rect). @return selected ROI or empty rect if selection canceled. Note : The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...). After finish of work an empty callback will be set for the used window. Python prototype (for reference): selectROI(windowName, img[, showCrosshair[, fromCenter]]) -&gt; retval","ref":"Evision.html#selectROI/3","title":"Evision.selectROI/3","type":"function"},{"doc":"Raising version of selectROIs/2 .","ref":"Evision.html#selectROIs!/2","title":"Evision.selectROIs!/2","type":"function"},{"doc":"Raising version of selectROIs/3 .","ref":"Evision.html#selectROIs!/3","title":"Evision.selectROIs!/3","type":"function"},{"doc":"Allows users to select multiple ROIs on the given image. Positional Arguments windowName : String . name of the window where selection process will be shown. img : Evision.Mat . image to select a ROI. Keyword Arguments showCrosshair : bool . if true crosshair of selection rectangle will be shown. fromCenter : bool . if true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position. Return boundingBoxes : [Rect] . selected ROIs. The function creates a window and allows users to select multiple ROIs using the mouse. Controls: use space or enter to finish current selection and start a new one, use esc to terminate multiple ROI selection process. Note : The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...). After finish of work an empty callback will be set for the used window. Python prototype (for reference): selectROIs(windowName, img[, showCrosshair[, fromCenter]]) -&gt; boundingBoxes","ref":"Evision.html#selectROIs/2","title":"Evision.selectROIs/2","type":"function"},{"doc":"Allows users to select multiple ROIs on the given image. Positional Arguments windowName : String . name of the window where selection process will be shown. img : Evision.Mat . image to select a ROI. Keyword Arguments showCrosshair : bool . if true crosshair of selection rectangle will be shown. fromCenter : bool . if true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position. Return boundingBoxes : [Rect] . selected ROIs. The function creates a window and allows users to select multiple ROIs using the mouse. Controls: use space or enter to finish current selection and start a new one, use esc to terminate multiple ROI selection process. Note : The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...). After finish of work an empty callback will be set for the used window. Python prototype (for reference): selectROIs(windowName, img[, showCrosshair[, fromCenter]]) -&gt; boundingBoxes","ref":"Evision.html#selectROIs/3","title":"Evision.selectROIs/3","type":"function"},{"doc":"Raising version of sepFilter2D/4 .","ref":"Evision.html#sepFilter2D!/4","title":"Evision.sepFilter2D!/4","type":"function"},{"doc":"Raising version of sepFilter2D/5 .","ref":"Evision.html#sepFilter2D!/5","title":"Evision.sepFilter2D!/5","type":"function"},{"doc":"Applies a separable linear filter to an image. Positional Arguments src : Evision.Mat . Source image. ddepth : int . Destination image depth, see @ref filter_depths &quot;combinations&quot; kernelX : Evision.Mat . Coefficients for filtering each row. kernelY : Evision.Mat . Coefficients for filtering each column. Keyword Arguments anchor : Point . Anchor position within the kernel. The default value \\f$(-1,-1)\\f$ means that the anchor is at the kernel center. delta : double . Value added to the filtered results before storing them. borderType : int . Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Destination image of the same size and the same number of channels as src . The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst . @sa filter2D, Sobel, GaussianBlur, boxFilter, blur Python prototype (for reference): sepFilter2D(src, ddepth, kernelX, kernelY[, dst[, anchor[, delta[, borderType]]]]) -&gt; dst","ref":"Evision.html#sepFilter2D/4","title":"Evision.sepFilter2D/4","type":"function"},{"doc":"Applies a separable linear filter to an image. Positional Arguments src : Evision.Mat . Source image. ddepth : int . Destination image depth, see @ref filter_depths &quot;combinations&quot; kernelX : Evision.Mat . Coefficients for filtering each row. kernelY : Evision.Mat . Coefficients for filtering each column. Keyword Arguments anchor : Point . Anchor position within the kernel. The default value \\f$(-1,-1)\\f$ means that the anchor is at the kernel center. delta : double . Value added to the filtered results before storing them. borderType : int . Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . Destination image of the same size and the same number of channels as src . The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst . @sa filter2D, Sobel, GaussianBlur, boxFilter, blur Python prototype (for reference): sepFilter2D(src, ddepth, kernelX, kernelY[, dst[, anchor[, delta[, borderType]]]]) -&gt; dst","ref":"Evision.html#sepFilter2D/5","title":"Evision.sepFilter2D/5","type":"function"},{"doc":"Raising version of setIdentity/1 .","ref":"Evision.html#setIdentity!/1","title":"Evision.setIdentity!/1","type":"function"},{"doc":"Raising version of setIdentity/2 .","ref":"Evision.html#setIdentity!/2","title":"Evision.setIdentity!/2","type":"function"},{"doc":"Initializes a scaled identity matrix. Keyword Arguments s : Scalar . value to assign to diagonal elements. Return mtx : Evision.Mat . matrix to initialize (not necessarily square). The function cv::setIdentity initializes a scaled identity matrix: \\f[\\texttt{mtx} (i,j)= \\fork{\\texttt{value}}{ if (i=j)}{0}{otherwise}\\f] The function can also be emulated using the matrix initializers and the matrix expressions: Mat A = Mat :: eye ( 4 , 3 , CV_32F ) * 5 ; // A will be set to [ [ 5 , 0 , 0 ] , [ 0 , 5 , 0 ] , [ 0 , 0 , 5 ] , [ 0 , 0 , 0 ] ] @sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator= Python prototype (for reference): setIdentity(mtx[, s]) -&gt; mtx","ref":"Evision.html#setIdentity/1","title":"Evision.setIdentity/1","type":"function"},{"doc":"Initializes a scaled identity matrix. Keyword Arguments s : Scalar . value to assign to diagonal elements. Return mtx : Evision.Mat . matrix to initialize (not necessarily square). The function cv::setIdentity initializes a scaled identity matrix: \\f[\\texttt{mtx} (i,j)= \\fork{\\texttt{value}}{ if (i=j)}{0}{otherwise}\\f] The function can also be emulated using the matrix initializers and the matrix expressions: Mat A = Mat :: eye ( 4 , 3 , CV_32F ) * 5 ; // A will be set to [ [ 5 , 0 , 0 ] , [ 0 , 5 , 0 ] , [ 0 , 0 , 5 ] , [ 0 , 0 , 0 ] ] @sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator= Python prototype (for reference): setIdentity(mtx[, s]) -&gt; mtx","ref":"Evision.html#setIdentity/2","title":"Evision.setIdentity/2","type":"function"},{"doc":"Raising version of setLogLevel/1 .","ref":"Evision.html#setLogLevel!/1","title":"Evision.setLogLevel!/1","type":"function"},{"doc":"Positional Arguments level : int Python prototype (for reference): setLogLevel(level) -&gt; retval","ref":"Evision.html#setLogLevel/1","title":"Evision.setLogLevel/1","type":"function"},{"doc":"Raising version of setNumThreads/1 .","ref":"Evision.html#setNumThreads!/1","title":"Evision.setNumThreads!/1","type":"function"},{"doc":"OpenCV will try to set the number of threads for the next parallel region. Positional Arguments nthreads : int . Number of threads used by OpenCV. If threads == 0, OpenCV will disable threading optimizations and run all it's functions sequentially. Passing threads \\&lt; 0 will reset threads number to system default. This function must be called outside of parallel region. OpenCV will try to run its functions with specified threads number, but some behaviour differs from framework: TBB - User-defined parallel constructions will run with the same threads number, if another is not specified. If later on user creates his own scheduler, OpenCV will use it. OpenMP - No special defined behaviour. Concurrency - If threads == 1, OpenCV will disable threading optimizations and run its functions sequentially. GCD - Supports only values \\&lt;= 0. C= - No special defined behaviour. @sa getNumThreads, getThreadNum Python prototype (for reference): setNumThreads(nthreads) -&gt; None","ref":"Evision.html#setNumThreads/1","title":"Evision.setNumThreads/1","type":"function"},{"doc":"Raising version of setRNGSeed/1 .","ref":"Evision.html#setRNGSeed!/1","title":"Evision.setRNGSeed!/1","type":"function"},{"doc":"Sets state of default random number generator. Positional Arguments seed : int . new state for default random number generator The function cv::setRNGSeed sets state of default random number generator to custom value. @sa RNG, randu, randn Python prototype (for reference): setRNGSeed(seed) -&gt; None","ref":"Evision.html#setRNGSeed/1","title":"Evision.setRNGSeed/1","type":"function"},{"doc":"Raising version of setTrackbarMax/3 .","ref":"Evision.html#setTrackbarMax!/3","title":"Evision.setTrackbarMax!/3","type":"function"},{"doc":"Sets the trackbar maximum position. Positional Arguments trackbarname : String . Name of the trackbar. winname : String . Name of the window that is the parent of trackbar. maxval : int . New maximum position. The function sets the maximum position of the specified trackbar in the specified window. Note : [ Qt Backend Only ] winname can be empty if the trackbar is attached to the control panel. Python prototype (for reference): setTrackbarMax(trackbarname, winname, maxval) -&gt; None","ref":"Evision.html#setTrackbarMax/3","title":"Evision.setTrackbarMax/3","type":"function"},{"doc":"Raising version of setTrackbarMin/3 .","ref":"Evision.html#setTrackbarMin!/3","title":"Evision.setTrackbarMin!/3","type":"function"},{"doc":"Sets the trackbar minimum position. Positional Arguments trackbarname : String . Name of the trackbar. winname : String . Name of the window that is the parent of trackbar. minval : int . New minimum position. The function sets the minimum position of the specified trackbar in the specified window. Note : [ Qt Backend Only ] winname can be empty if the trackbar is attached to the control panel. Python prototype (for reference): setTrackbarMin(trackbarname, winname, minval) -&gt; None","ref":"Evision.html#setTrackbarMin/3","title":"Evision.setTrackbarMin/3","type":"function"},{"doc":"Raising version of setTrackbarPos/3 .","ref":"Evision.html#setTrackbarPos!/3","title":"Evision.setTrackbarPos!/3","type":"function"},{"doc":"Sets the trackbar position. Positional Arguments trackbarname : String . Name of the trackbar. winname : String . Name of the window that is the parent of trackbar. pos : int . New position. The function sets the position of the specified trackbar in the specified window. Note : [ Qt Backend Only ] winname can be empty if the trackbar is attached to the control panel. Python prototype (for reference): setTrackbarPos(trackbarname, winname, pos) -&gt; None","ref":"Evision.html#setTrackbarPos/3","title":"Evision.setTrackbarPos/3","type":"function"},{"doc":"Raising version of setUseOpenVX/1 .","ref":"Evision.html#setUseOpenVX!/1","title":"Evision.setUseOpenVX!/1","type":"function"},{"doc":"Positional Arguments flag : bool Python prototype (for reference): setUseOpenVX(flag) -&gt; None","ref":"Evision.html#setUseOpenVX/1","title":"Evision.setUseOpenVX/1","type":"function"},{"doc":"Raising version of setUseOptimized/1 .","ref":"Evision.html#setUseOptimized!/1","title":"Evision.setUseOptimized!/1","type":"function"},{"doc":"Enables or disables the optimized code. Positional Arguments onoff : bool . The boolean flag specifying whether the optimized code should be used (onoff=true) or not (onoff=false). The function can be used to dynamically turn on and off optimized dispatched code (code that uses SSE4.2, AVX/AVX2, and other instructions on the platforms that support it). It sets a global flag that is further checked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only safe to call the function on the very top level in your application where you can be sure that no other OpenCV function is currently executed. By default, the optimized code is enabled unless you disable it in CMake. The current status can be retrieved using useOptimized. Python prototype (for reference): setUseOptimized(onoff) -&gt; None","ref":"Evision.html#setUseOptimized/1","title":"Evision.setUseOptimized/1","type":"function"},{"doc":"Raising version of setWindowProperty/3 .","ref":"Evision.html#setWindowProperty!/3","title":"Evision.setWindowProperty!/3","type":"function"},{"doc":"Changes parameters of a window dynamically. Positional Arguments winname : String . Name of the window. prop_id : int . Window property to edit. The supported operation flags are: (cv::WindowPropertyFlags) prop_value : double . New value of the window property. The supported flags are: (cv::WindowFlags) The function setWindowProperty enables changing properties of a window. Python prototype (for reference): setWindowProperty(winname, prop_id, prop_value) -&gt; None","ref":"Evision.html#setWindowProperty/3","title":"Evision.setWindowProperty/3","type":"function"},{"doc":"Raising version of setWindowTitle/2 .","ref":"Evision.html#setWindowTitle!/2","title":"Evision.setWindowTitle!/2","type":"function"},{"doc":"Updates window title Positional Arguments winname : String . Name of the window. title : String . New title. Python prototype (for reference): setWindowTitle(winname, title) -&gt; None","ref":"Evision.html#setWindowTitle/2","title":"Evision.setWindowTitle/2","type":"function"},{"doc":"Raising version of sobel/4 .","ref":"Evision.html#sobel!/4","title":"Evision.sobel!/4","type":"function"},{"doc":"Raising version of sobel/5 .","ref":"Evision.html#sobel!/5","title":"Evision.sobel!/5","type":"function"},{"doc":"Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator. Positional Arguments src : Evision.Mat . input image. ddepth : int . output image depth, see @ref filter_depths &quot;combinations&quot;; in the case of 8-bit input images it will result in truncated derivatives. dx : int . order of the derivative x. dy : int . order of the derivative y. Keyword Arguments ksize : int . size of the extended Sobel kernel; it must be 1, 3, 5, or 7. scale : double . optional scale factor for the computed derivative values; by default, no scaling is applied (see #getDerivKernels for details). delta : double . optional delta value that is added to the results prior to storing them in dst. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and the same number of channels as src . In all cases except one, the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ separable kernel is used to calculate the derivative. When \\f$\\texttt{ksize = 1}\\f$, the \\f$3 \\times 1\\f$ or \\f$1 \\times 3\\f$ kernel is used (that is, no Gaussian smoothing is done). ksize = 1 can only be used for the first or the second x- or y- derivatives. There is also the special value ksize = #FILTER_SCHARR (-1) that corresponds to the \\f$3\\times3\\f$ Scharr filter that may give more accurate results than the \\f$3\\times3\\f$ Sobel. The Scharr aperture is \\f[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\f] for the x-derivative, or transposed for the y-derivative. The function calculates an image derivative by convolving the image with the appropriate kernel: \\f[\\texttt{dst} = \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\f] The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of: \\f[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\f] The second case corresponds to a kernel of: \\f[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\f] @sa Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar Python prototype (for reference): Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]]) -&gt; dst","ref":"Evision.html#sobel/4","title":"Evision.sobel/4","type":"function"},{"doc":"Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator. Positional Arguments src : Evision.Mat . input image. ddepth : int . output image depth, see @ref filter_depths &quot;combinations&quot;; in the case of 8-bit input images it will result in truncated derivatives. dx : int . order of the derivative x. dy : int . order of the derivative y. Keyword Arguments ksize : int . size of the extended Sobel kernel; it must be 1, 3, 5, or 7. scale : double . optional scale factor for the computed derivative values; by default, no scaling is applied (see #getDerivKernels for details). delta : double . optional delta value that is added to the results prior to storing them in dst. borderType : int . pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and the same number of channels as src . In all cases except one, the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ separable kernel is used to calculate the derivative. When \\f$\\texttt{ksize = 1}\\f$, the \\f$3 \\times 1\\f$ or \\f$1 \\times 3\\f$ kernel is used (that is, no Gaussian smoothing is done). ksize = 1 can only be used for the first or the second x- or y- derivatives. There is also the special value ksize = #FILTER_SCHARR (-1) that corresponds to the \\f$3\\times3\\f$ Scharr filter that may give more accurate results than the \\f$3\\times3\\f$ Sobel. The Scharr aperture is \\f[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\f] for the x-derivative, or transposed for the y-derivative. The function calculates an image derivative by convolving the image with the appropriate kernel: \\f[\\texttt{dst} = \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\f] The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of: \\f[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\f] The second case corresponds to a kernel of: \\f[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\f] @sa Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar Python prototype (for reference): Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]]) -&gt; dst","ref":"Evision.html#sobel/5","title":"Evision.sobel/5","type":"function"},{"doc":"Raising version of solve/2 .","ref":"Evision.html#solve!/2","title":"Evision.solve!/2","type":"function"},{"doc":"Raising version of solve/3 .","ref":"Evision.html#solve!/3","title":"Evision.solve!/3","type":"function"},{"doc":"Solves one or more linear systems or least-squares problems. Positional Arguments src1 : Evision.Mat . input matrix on the left-hand side of the system. src2 : Evision.Mat . input matrix on the right-hand side of the system. Keyword Arguments flags : int . solution (matrix inversion) method (#DecompTypes) Return dst : Evision.Mat . output solution. The function cv::solve solves a linear system or least-squares problem (the latter is possible with SVD or QR methods, or by specifying the flag #DECOMP_NORMAL ): \\f[\\texttt{dst} = \\arg \\min _X \\| \\texttt{src1} \\cdot \\texttt{X} - \\texttt{src2} \\|\\f] If #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1 if src1 (or \\f$\\texttt{src1}^T\\texttt{src1}\\f$ ) is non-singular. Otherwise, it returns 0. In the latter case, dst is not valid. Other methods find a pseudo-solution in case of a singular left-hand side part. Note : If you want to find a unity-norm solution of an under-defined singular system \\f$\\texttt{src1}\\cdot\\texttt{dst}=0\\f$ , the function solve will not do the work. Use SVD::solveZ instead. @sa invert, SVD, eigen Python prototype (for reference): solve(src1, src2[, dst[, flags]]) -&gt; retval, dst","ref":"Evision.html#solve/2","title":"Evision.solve/2","type":"function"},{"doc":"Solves one or more linear systems or least-squares problems. Positional Arguments src1 : Evision.Mat . input matrix on the left-hand side of the system. src2 : Evision.Mat . input matrix on the right-hand side of the system. Keyword Arguments flags : int . solution (matrix inversion) method (#DecompTypes) Return dst : Evision.Mat . output solution. The function cv::solve solves a linear system or least-squares problem (the latter is possible with SVD or QR methods, or by specifying the flag #DECOMP_NORMAL ): \\f[\\texttt{dst} = \\arg \\min _X \\| \\texttt{src1} \\cdot \\texttt{X} - \\texttt{src2} \\|\\f] If #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1 if src1 (or \\f$\\texttt{src1}^T\\texttt{src1}\\f$ ) is non-singular. Otherwise, it returns 0. In the latter case, dst is not valid. Other methods find a pseudo-solution in case of a singular left-hand side part. Note : If you want to find a unity-norm solution of an under-defined singular system \\f$\\texttt{src1}\\cdot\\texttt{dst}=0\\f$ , the function solve will not do the work. Use SVD::solveZ instead. @sa invert, SVD, eigen Python prototype (for reference): solve(src1, src2[, dst[, flags]]) -&gt; retval, dst","ref":"Evision.html#solve/3","title":"Evision.solve/3","type":"function"},{"doc":"Raising version of solveCubic/1 .","ref":"Evision.html#solveCubic!/1","title":"Evision.solveCubic!/1","type":"function"},{"doc":"Raising version of solveCubic/2 .","ref":"Evision.html#solveCubic!/2","title":"Evision.solveCubic!/2","type":"function"},{"doc":"Finds the real roots of a cubic equation. Positional Arguments coeffs : Evision.Mat . equation coefficients, an array of 3 or 4 elements. Return roots : Evision.Mat . output array of real roots that has 1 or 3 elements. The function solveCubic finds the real roots of a cubic equation: if coeffs is a 4-element vector: \\f[\\texttt{coeffs} [0] x^3 + \\texttt{coeffs} [1] x^2 + \\texttt{coeffs} [2] x + \\texttt{coeffs} [3] = 0\\f] if coeffs is a 3-element vector: \\f[x^3 + \\texttt{coeffs} [0] x^2 + \\texttt{coeffs} [1] x + \\texttt{coeffs} [2] = 0\\f] The roots are stored in the roots array. @return number of real roots. It can be 0, 1 or 2. Python prototype (for reference): solveCubic(coeffs[, roots]) -&gt; retval, roots","ref":"Evision.html#solveCubic/1","title":"Evision.solveCubic/1","type":"function"},{"doc":"Finds the real roots of a cubic equation. Positional Arguments coeffs : Evision.Mat . equation coefficients, an array of 3 or 4 elements. Return roots : Evision.Mat . output array of real roots that has 1 or 3 elements. The function solveCubic finds the real roots of a cubic equation: if coeffs is a 4-element vector: \\f[\\texttt{coeffs} [0] x^3 + \\texttt{coeffs} [1] x^2 + \\texttt{coeffs} [2] x + \\texttt{coeffs} [3] = 0\\f] if coeffs is a 3-element vector: \\f[x^3 + \\texttt{coeffs} [0] x^2 + \\texttt{coeffs} [1] x + \\texttt{coeffs} [2] = 0\\f] The roots are stored in the roots array. @return number of real roots. It can be 0, 1 or 2. Python prototype (for reference): solveCubic(coeffs[, roots]) -&gt; retval, roots","ref":"Evision.html#solveCubic/2","title":"Evision.solveCubic/2","type":"function"},{"doc":"Raising version of solveLP/2 .","ref":"Evision.html#solveLP!/2","title":"Evision.solveLP!/2","type":"function"},{"doc":"Raising version of solveLP/3 .","ref":"Evision.html#solveLP!/3","title":"Evision.solveLP!/3","type":"function"},{"doc":"Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method). Positional Arguments func : Evision.Mat . This row-vector corresponds to \\f$c\\f$ in the LP problem formulation (see above). It should contain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted, in the latter case it is understood to correspond to \\f$c^T\\f$. constr : Evision.Mat . m -by- n+1 matrix, whose rightmost column corresponds to \\f$b\\f$ in formulation above and the remaining to \\f$A\\f$. It should contain 32- or 64-bit floating point numbers. Return z : Evision.Mat . The solution will be returned here as a column-vector - it corresponds to \\f$c\\f$ in the formulation above. It will contain 64-bit floating point numbers. What we mean here by &quot;linear programming problem&quot; (or LP problem, for short) can be formulated as: \\f[\\mbox{Maximize } c\\cdot x\\\\ \\mbox{Subject to:}\\\\ Ax\\leq b\\\\ x\\geq 0\\f] Where \\f$c\\f$ is fixed 1 -by- n row-vector, \\f$A\\f$ is fixed m -by- n matrix, \\f$b\\f$ is fixed m -by- 1 column vector and \\f$x\\f$ is an arbitrary n -by- 1 column vector, which satisfies the constraints. Simplex algorithm is one of many algorithms that are designed to handle this sort of problems efficiently. Although it is not optimal in theoretical sense (there exist algorithms that can solve any problem written as above in polynomial time, while simplex method degenerates to exponential time for some special cases), it is well-studied, easy to implement and is shown to work well for real-life purposes. The particular implementation is taken almost verbatim from Introduction to Algorithms, third edition by T. H. Cormen, C. E. Leiserson, R. L. Rivest and Clifford Stein. In particular, the Bland's rule http://en.wikipedia.org/wiki/Bland%27s_rule is used to prevent cycling. @return One of cv::SolveLPResult Python prototype (for reference): solveLP(Func, Constr[, z]) -&gt; retval, z","ref":"Evision.html#solveLP/2","title":"Evision.solveLP/2","type":"function"},{"doc":"Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method). Positional Arguments func : Evision.Mat . This row-vector corresponds to \\f$c\\f$ in the LP problem formulation (see above). It should contain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted, in the latter case it is understood to correspond to \\f$c^T\\f$. constr : Evision.Mat . m -by- n+1 matrix, whose rightmost column corresponds to \\f$b\\f$ in formulation above and the remaining to \\f$A\\f$. It should contain 32- or 64-bit floating point numbers. Return z : Evision.Mat . The solution will be returned here as a column-vector - it corresponds to \\f$c\\f$ in the formulation above. It will contain 64-bit floating point numbers. What we mean here by &quot;linear programming problem&quot; (or LP problem, for short) can be formulated as: \\f[\\mbox{Maximize } c\\cdot x\\\\ \\mbox{Subject to:}\\\\ Ax\\leq b\\\\ x\\geq 0\\f] Where \\f$c\\f$ is fixed 1 -by- n row-vector, \\f$A\\f$ is fixed m -by- n matrix, \\f$b\\f$ is fixed m -by- 1 column vector and \\f$x\\f$ is an arbitrary n -by- 1 column vector, which satisfies the constraints. Simplex algorithm is one of many algorithms that are designed to handle this sort of problems efficiently. Although it is not optimal in theoretical sense (there exist algorithms that can solve any problem written as above in polynomial time, while simplex method degenerates to exponential time for some special cases), it is well-studied, easy to implement and is shown to work well for real-life purposes. The particular implementation is taken almost verbatim from Introduction to Algorithms, third edition by T. H. Cormen, C. E. Leiserson, R. L. Rivest and Clifford Stein. In particular, the Bland's rule http://en.wikipedia.org/wiki/Bland%27s_rule is used to prevent cycling. @return One of cv::SolveLPResult Python prototype (for reference): solveLP(Func, Constr[, z]) -&gt; retval, z","ref":"Evision.html#solveLP/3","title":"Evision.solveLP/3","type":"function"},{"doc":"Raising version of solveP3P/5 .","ref":"Evision.html#solveP3P!/5","title":"Evision.solveP3P!/5","type":"function"},{"doc":"Raising version of solveP3P/6 .","ref":"Evision.html#solveP3P!/6","title":"Evision.solveP3P!/6","type":"function"},{"doc":"Finds an object pose from 3 3D-2D point correspondences. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, 3x3 1-channel or 1x3/3x1 3-channel. vector\\&lt;Point3f&gt; can be also passed here. imagePoints : Evision.Mat . Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel. vector\\&lt;Point2f&gt; can be also passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. flags : int . Method for solving a P3P problem: @ref SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang &quot;Complete Solution Classification for the Perspective-Three-Point Problem&quot; (@cite gao2003complete). @ref SOLVEPNP_AP3P Method is based on the paper of T. Ke and S. Roumeliotis. &quot;An Efficient Algebraic Solution to the Perspective-Three-Point Problem&quot; (@cite Ke17). Return rvecs : [Evision.Mat] . Output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from the model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions. tvecs : [Evision.Mat] . Output translation vectors. @see @ref calib3d_solvePnP The function estimates the object pose given 3 object points, their corresponding image projections, as well as the camera intrinsic matrix and the distortion coefficients. Note : The solutions are sorted by reprojection errors (lowest to highest). Python prototype (for reference): solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, flags[, rvecs[, tvecs]]) -&gt; retval, rvecs, tvecs","ref":"Evision.html#solveP3P/5","title":"Evision.solveP3P/5","type":"function"},{"doc":"Finds an object pose from 3 3D-2D point correspondences. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, 3x3 1-channel or 1x3/3x1 3-channel. vector\\&lt;Point3f&gt; can be also passed here. imagePoints : Evision.Mat . Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel. vector\\&lt;Point2f&gt; can be also passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. flags : int . Method for solving a P3P problem: @ref SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang &quot;Complete Solution Classification for the Perspective-Three-Point Problem&quot; (@cite gao2003complete). @ref SOLVEPNP_AP3P Method is based on the paper of T. Ke and S. Roumeliotis. &quot;An Efficient Algebraic Solution to the Perspective-Three-Point Problem&quot; (@cite Ke17). Return rvecs : [Evision.Mat] . Output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from the model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions. tvecs : [Evision.Mat] . Output translation vectors. @see @ref calib3d_solvePnP The function estimates the object pose given 3 object points, their corresponding image projections, as well as the camera intrinsic matrix and the distortion coefficients. Note : The solutions are sorted by reprojection errors (lowest to highest). Python prototype (for reference): solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, flags[, rvecs[, tvecs]]) -&gt; retval, rvecs, tvecs","ref":"Evision.html#solveP3P/6","title":"Evision.solveP3P/6","type":"function"},{"doc":"Raising version of solvePnP/4 .","ref":"Evision.html#solvePnP!/4","title":"Evision.solvePnP!/4","type":"function"},{"doc":"Raising version of solvePnP/5 .","ref":"Evision.html#solvePnP!/5","title":"Evision.solvePnP!/5","type":"function"},{"doc":"Finds an object pose from 3D-2D point correspondences. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can be also passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can be also passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments useExtrinsicGuess : bool . Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them. flags : int . Method for solving a PnP problem: see @ref calib3d_solvePnP_flags Return rvec : Evision.Mat . Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. tvec : Evision.Mat . Output translation vector. @see @ref calib3d_solvePnP This function returns the rotation and the translation vectors that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame, using different methods: P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): need 4 input points to return a unique solution. @ref SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation. Number of input points must be 4. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration. More information about Perspective-n-Points is described in @ref calib3d_solvePnP Note : An example of how to use solvePnP for planar augmented reality can be found at opencv_source_code/samples/python/plane_ar.py If you are using Python: Numpy array slices won't work as input because solvePnP requires contiguous arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of modules/calib3d/src/solvepnp.cpp version 2.4.9) The P3P algorithm requires image points to be in an array of shape (N,1,2) due to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9) which requires 2-channel information. Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints = np.ascontiguousarray(D[:,:2]).reshape((N,1,2)) The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are unstable and sometimes give completely wrong results. If you pass one of these two flags, @ref SOLVEPNP_EPNP method will be used instead. The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error). With @ref SOLVEPNP_ITERATIVE method and useExtrinsicGuess=true , the minimum number of points is 3 (3 points are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the global solution to converge. With @ref SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar. With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation. Number of input points must be 4. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] With @ref SOLVEPNP_SQPNP input points must be &gt;= 3 Python prototype (for reference): solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, useExtrinsicGuess[, flags]]]]) -&gt; retval, rvec, tvec","ref":"Evision.html#solvePnP/4","title":"Evision.solvePnP/4","type":"function"},{"doc":"Finds an object pose from 3D-2D point correspondences. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can be also passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can be also passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments useExtrinsicGuess : bool . Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them. flags : int . Method for solving a PnP problem: see @ref calib3d_solvePnP_flags Return rvec : Evision.Mat . Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. tvec : Evision.Mat . Output translation vector. @see @ref calib3d_solvePnP This function returns the rotation and the translation vectors that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame, using different methods: P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): need 4 input points to return a unique solution. @ref SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation. Number of input points must be 4. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration. More information about Perspective-n-Points is described in @ref calib3d_solvePnP Note : An example of how to use solvePnP for planar augmented reality can be found at opencv_source_code/samples/python/plane_ar.py If you are using Python: Numpy array slices won't work as input because solvePnP requires contiguous arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of modules/calib3d/src/solvepnp.cpp version 2.4.9) The P3P algorithm requires image points to be in an array of shape (N,1,2) due to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9) which requires 2-channel information. Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints = np.ascontiguousarray(D[:,:2]).reshape((N,1,2)) The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are unstable and sometimes give completely wrong results. If you pass one of these two flags, @ref SOLVEPNP_EPNP method will be used instead. The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error). With @ref SOLVEPNP_ITERATIVE method and useExtrinsicGuess=true , the minimum number of points is 3 (3 points are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the global solution to converge. With @ref SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar. With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation. Number of input points must be 4. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] With @ref SOLVEPNP_SQPNP input points must be &gt;= 3 Python prototype (for reference): solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, useExtrinsicGuess[, flags]]]]) -&gt; retval, rvec, tvec","ref":"Evision.html#solvePnP/5","title":"Evision.solvePnP/5","type":"function"},{"doc":"Raising version of solvePnPGeneric/4 .","ref":"Evision.html#solvePnPGeneric!/4","title":"Evision.solvePnPGeneric!/4","type":"function"},{"doc":"Raising version of solvePnPGeneric/5 .","ref":"Evision.html#solvePnPGeneric!/5","title":"Evision.solvePnPGeneric!/5","type":"function"},{"doc":"Finds an object pose from 3D-2D point correspondences. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can be also passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can be also passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments useExtrinsicGuess : bool . Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them. flags : SolvePnPMethod . Method for solving a PnP problem: see @ref calib3d_solvePnP_flags rvec : Evision.Mat . Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE and useExtrinsicGuess is set to true. tvec : Evision.Mat . Translation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE and useExtrinsicGuess is set to true. Return rvecs : [Evision.Mat] . Vector of output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from the model coordinate system to the camera coordinate system. tvecs : [Evision.Mat] . Vector of output translation vectors. reprojectionError : Evision.Mat . Optional vector of reprojection error, that is the RMS error (\\f$ \\text{RMSE} = \\sqrt{\\frac{\\sum_{i}^{N} \\left ( \\hat{y_i} - y_i \\right )^2}{N}} \\f$) between the input image points and the 3D object points projected with the estimated pose. @see @ref calib3d_solvePnP This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt; couple), depending on the number of input points and the chosen method: P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points. @ref SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions. @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation. Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration. Only 1 solution is returned. More information is described in @ref calib3d_solvePnP Note : An example of how to use solvePnP for planar augmented reality can be found at opencv_source_code/samples/python/plane_ar.py If you are using Python: Numpy array slices won't work as input because solvePnP requires contiguous arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of modules/calib3d/src/solvepnp.cpp version 2.4.9) The P3P algorithm requires image points to be in an array of shape (N,1,2) due to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9) which requires 2-channel information. Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints = np.ascontiguousarray(D[:,:2]).reshape((N,1,2)) The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are unstable and sometimes give completely wrong results. If you pass one of these two flags, @ref SOLVEPNP_EPNP method will be used instead. The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error). With @ref SOLVEPNP_ITERATIVE method and useExtrinsicGuess=true , the minimum number of points is 3 (3 points are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the global solution to converge. With @ref SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar. With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation. Number of input points must be 4. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] Python prototype (for reference): solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvecs[, tvecs[, useExtrinsicGuess[, flags[, rvec[, tvec[, reprojectionError]]]]]]]) -&gt; retval, rvecs, tvecs, reprojectionError","ref":"Evision.html#solvePnPGeneric/4","title":"Evision.solvePnPGeneric/4","type":"function"},{"doc":"Finds an object pose from 3D-2D point correspondences. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can be also passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can be also passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments useExtrinsicGuess : bool . Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them. flags : SolvePnPMethod . Method for solving a PnP problem: see @ref calib3d_solvePnP_flags rvec : Evision.Mat . Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE and useExtrinsicGuess is set to true. tvec : Evision.Mat . Translation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE and useExtrinsicGuess is set to true. Return rvecs : [Evision.Mat] . Vector of output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from the model coordinate system to the camera coordinate system. tvecs : [Evision.Mat] . Vector of output translation vectors. reprojectionError : Evision.Mat . Optional vector of reprojection error, that is the RMS error (\\f$ \\text{RMSE} = \\sqrt{\\frac{\\sum_{i}^{N} \\left ( \\hat{y_i} - y_i \\right )^2}{N}} \\f$) between the input image points and the 3D object points projected with the estimated pose. @see @ref calib3d_solvePnP This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt; couple), depending on the number of input points and the chosen method: P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points. @ref SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions. @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation. Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration. Only 1 solution is returned. More information is described in @ref calib3d_solvePnP Note : An example of how to use solvePnP for planar augmented reality can be found at opencv_source_code/samples/python/plane_ar.py If you are using Python: Numpy array slices won't work as input because solvePnP requires contiguous arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of modules/calib3d/src/solvepnp.cpp version 2.4.9) The P3P algorithm requires image points to be in an array of shape (N,1,2) due to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9) which requires 2-channel information. Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints = np.ascontiguousarray(D[:,:2]).reshape((N,1,2)) The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are unstable and sometimes give completely wrong results. If you pass one of these two flags, @ref SOLVEPNP_EPNP method will be used instead. The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error). With @ref SOLVEPNP_ITERATIVE method and useExtrinsicGuess=true , the minimum number of points is 3 (3 points are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the global solution to converge. With @ref SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar. With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation. Number of input points must be 4. Object points must be defined in the following order: point 0: [-squareLength / 2, squareLength / 2, 0] point 1: [ squareLength / 2, squareLength / 2, 0] point 2: [ squareLength / 2, -squareLength / 2, 0] point 3: [-squareLength / 2, -squareLength / 2, 0] Python prototype (for reference): solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvecs[, tvecs[, useExtrinsicGuess[, flags[, rvec[, tvec[, reprojectionError]]]]]]]) -&gt; retval, rvecs, tvecs, reprojectionError","ref":"Evision.html#solvePnPGeneric/5","title":"Evision.solvePnPGeneric/5","type":"function"},{"doc":"Raising version of solvePnPRansac/4 .","ref":"Evision.html#solvePnPRansac!/4","title":"Evision.solvePnPRansac!/4","type":"function"},{"doc":"Raising version of solvePnPRansac/5 .","ref":"Evision.html#solvePnPRansac!/5","title":"Evision.solvePnPRansac!/5","type":"function"},{"doc":"Positional Arguments objectPoints : Evision.Mat imagePoints : Evision.Mat distCoeffs : Evision.Mat Keyword Arguments params : UsacParams . Return cameraMatrix : Evision.Mat rvec : Evision.Mat . tvec : Evision.Mat . inliers : Evision.Mat . Python prototype (for reference): solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, inliers[, params]]]]) -&gt; retval, cameraMatrix, rvec, tvec, inliers","ref":"Evision.html#solvePnPRansac/4","title":"Evision.solvePnPRansac/4","type":"function"},{"doc":"Positional Arguments objectPoints : Evision.Mat imagePoints : Evision.Mat distCoeffs : Evision.Mat Keyword Arguments params : UsacParams . Return cameraMatrix : Evision.Mat rvec : Evision.Mat . tvec : Evision.Mat . inliers : Evision.Mat . Python prototype (for reference): solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, inliers[, params]]]]) -&gt; retval, cameraMatrix, rvec, tvec, inliers","ref":"Evision.html#solvePnPRansac/5","title":"Evision.solvePnPRansac/5","type":"function"},{"doc":"Raising version of solvePnPRefineLM/6 .","ref":"Evision.html#solvePnPRefineLM!/6","title":"Evision.solvePnPRefineLM!/6","type":"function"},{"doc":"Raising version of solvePnPRefineLM/7 .","ref":"Evision.html#solvePnPRefineLM!/7","title":"Evision.solvePnPRefineLM!/7","type":"function"},{"doc":"Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can also be passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can also be passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments criteria : TermCriteria . Criteria when to stop the Levenberg-Marquard iterative algorithm. Return rvec : Evision.Mat . Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. Input values are used as an initial solution. tvec : Evision.Mat . Input/Output translation vector. Input values are used as an initial solution. @see @ref calib3d_solvePnP The function refines the object pose given at least 3 object points, their corresponding image projections, an initial solution for the rotation and translation vector, as well as the camera intrinsic matrix and the distortion coefficients. The function minimizes the projection error with respect to the rotation and the translation vectors, according to a Levenberg-Marquardt iterative minimization @cite Madsen04 @cite Eade13 process. Python prototype (for reference): solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria]) -&gt; rvec, tvec","ref":"Evision.html#solvePnPRefineLM/6","title":"Evision.solvePnPRefineLM/6","type":"function"},{"doc":"Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can also be passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can also be passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments criteria : TermCriteria . Criteria when to stop the Levenberg-Marquard iterative algorithm. Return rvec : Evision.Mat . Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. Input values are used as an initial solution. tvec : Evision.Mat . Input/Output translation vector. Input values are used as an initial solution. @see @ref calib3d_solvePnP The function refines the object pose given at least 3 object points, their corresponding image projections, an initial solution for the rotation and translation vector, as well as the camera intrinsic matrix and the distortion coefficients. The function minimizes the projection error with respect to the rotation and the translation vectors, according to a Levenberg-Marquardt iterative minimization @cite Madsen04 @cite Eade13 process. Python prototype (for reference): solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria]) -&gt; rvec, tvec","ref":"Evision.html#solvePnPRefineLM/7","title":"Evision.solvePnPRefineLM/7","type":"function"},{"doc":"Raising version of solvePnPRefineVVS/6 .","ref":"Evision.html#solvePnPRefineVVS!/6","title":"Evision.solvePnPRefineVVS!/6","type":"function"},{"doc":"Raising version of solvePnPRefineVVS/7 .","ref":"Evision.html#solvePnPRefineVVS!/7","title":"Evision.solvePnPRefineVVS!/7","type":"function"},{"doc":"Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can also be passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can also be passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments criteria : TermCriteria . Criteria when to stop the Levenberg-Marquard iterative algorithm. vVSlambda : double . Gain for the virtual visual servoing control law, equivalent to the \\f$\\alpha\\f$ gain in the Damped Gauss-Newton formulation. Return rvec : Evision.Mat . Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. Input values are used as an initial solution. tvec : Evision.Mat . Input/Output translation vector. Input values are used as an initial solution. @see @ref calib3d_solvePnP The function refines the object pose given at least 3 object points, their corresponding image projections, an initial solution for the rotation and translation vector, as well as the camera intrinsic matrix and the distortion coefficients. The function minimizes the projection error with respect to the rotation and the translation vectors, using a virtual visual servoing (VVS) @cite Chaumette06 @cite Marchand16 scheme. Python prototype (for reference): solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria[, VVSlambda]]) -&gt; rvec, tvec","ref":"Evision.html#solvePnPRefineVVS/6","title":"Evision.solvePnPRefineVVS/6","type":"function"},{"doc":"Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution. Positional Arguments objectPoints : Evision.Mat . Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. vector\\&lt;Point3d&gt; can also be passed here. imagePoints : Evision.Mat . Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. vector\\&lt;Point2d&gt; can also be passed here. cameraMatrix : Evision.Mat . Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments criteria : TermCriteria . Criteria when to stop the Levenberg-Marquard iterative algorithm. vVSlambda : double . Gain for the virtual visual servoing control law, equivalent to the \\f$\\alpha\\f$ gain in the Damped Gauss-Newton formulation. Return rvec : Evision.Mat . Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. Input values are used as an initial solution. tvec : Evision.Mat . Input/Output translation vector. Input values are used as an initial solution. @see @ref calib3d_solvePnP The function refines the object pose given at least 3 object points, their corresponding image projections, an initial solution for the rotation and translation vector, as well as the camera intrinsic matrix and the distortion coefficients. The function minimizes the projection error with respect to the rotation and the translation vectors, using a virtual visual servoing (VVS) @cite Chaumette06 @cite Marchand16 scheme. Python prototype (for reference): solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria[, VVSlambda]]) -&gt; rvec, tvec","ref":"Evision.html#solvePnPRefineVVS/7","title":"Evision.solvePnPRefineVVS/7","type":"function"},{"doc":"Raising version of solvePoly/1 .","ref":"Evision.html#solvePoly!/1","title":"Evision.solvePoly!/1","type":"function"},{"doc":"Raising version of solvePoly/2 .","ref":"Evision.html#solvePoly!/2","title":"Evision.solvePoly!/2","type":"function"},{"doc":"Finds the real or complex roots of a polynomial equation. Positional Arguments coeffs : Evision.Mat . array of polynomial coefficients. Keyword Arguments maxIters : int . maximum number of iterations the algorithm does. Return roots : Evision.Mat . output (complex) array of roots. The function cv::solvePoly finds real and complex roots of a polynomial equation: \\f[\\texttt{coeffs} [n] x^{n} + \\texttt{coeffs} [n-1] x^{n-1} + ... + \\texttt{coeffs} [1] x + \\texttt{coeffs} [0] = 0\\f] Python prototype (for reference): solvePoly(coeffs[, roots[, maxIters]]) -&gt; retval, roots","ref":"Evision.html#solvePoly/1","title":"Evision.solvePoly/1","type":"function"},{"doc":"Finds the real or complex roots of a polynomial equation. Positional Arguments coeffs : Evision.Mat . array of polynomial coefficients. Keyword Arguments maxIters : int . maximum number of iterations the algorithm does. Return roots : Evision.Mat . output (complex) array of roots. The function cv::solvePoly finds real and complex roots of a polynomial equation: \\f[\\texttt{coeffs} [n] x^{n} + \\texttt{coeffs} [n-1] x^{n-1} + ... + \\texttt{coeffs} [1] x + \\texttt{coeffs} [0] = 0\\f] Python prototype (for reference): solvePoly(coeffs[, roots[, maxIters]]) -&gt; retval, roots","ref":"Evision.html#solvePoly/2","title":"Evision.solvePoly/2","type":"function"},{"doc":"Raising version of sort/2 .","ref":"Evision.html#sort!/2","title":"Evision.sort!/2","type":"function"},{"doc":"Raising version of sort/3 .","ref":"Evision.html#sort!/3","title":"Evision.sort!/3","type":"function"},{"doc":"Sorts each row or each column of a matrix. Positional Arguments src : Evision.Mat . input single-channel array. flags : int . operation flags, a combination of #SortFlags Return dst : Evision.Mat . output array of the same size and type as src. The function cv::sort sorts each matrix row or each matrix column in ascending or descending order. So you should pass two operation flags to get desired behaviour. If you want to sort matrix rows or columns lexicographically, you can use STL std::sort generic function with the proper comparison predicate. @sa sortIdx, randShuffle Python prototype (for reference): sort(src, flags[, dst]) -&gt; dst","ref":"Evision.html#sort/2","title":"Evision.sort/2","type":"function"},{"doc":"Sorts each row or each column of a matrix. Positional Arguments src : Evision.Mat . input single-channel array. flags : int . operation flags, a combination of #SortFlags Return dst : Evision.Mat . output array of the same size and type as src. The function cv::sort sorts each matrix row or each matrix column in ascending or descending order. So you should pass two operation flags to get desired behaviour. If you want to sort matrix rows or columns lexicographically, you can use STL std::sort generic function with the proper comparison predicate. @sa sortIdx, randShuffle Python prototype (for reference): sort(src, flags[, dst]) -&gt; dst","ref":"Evision.html#sort/3","title":"Evision.sort/3","type":"function"},{"doc":"Raising version of sortIdx/2 .","ref":"Evision.html#sortIdx!/2","title":"Evision.sortIdx!/2","type":"function"},{"doc":"Raising version of sortIdx/3 .","ref":"Evision.html#sortIdx!/3","title":"Evision.sortIdx!/3","type":"function"},{"doc":"Sorts each row or each column of a matrix. Positional Arguments src : Evision.Mat . input single-channel array. flags : int . operation flags that could be a combination of cv::SortFlags Return dst : Evision.Mat . output integer array of the same size as src. The function cv::sortIdx sorts each matrix row or each matrix column in the ascending or descending order. So you should pass two operation flags to get desired behaviour. Instead of reordering the elements themselves, it stores the indices of sorted elements in the output array. For example: Mat A = Mat :: eye ( 3 , 3 , CV_32F ) , B ; sortIdx ( A , B , SORT_EVERY_ROW + SORT_ASCENDING ) ; // B will probably contain // ( because of equal elements in A some permutations are possible ) : // [ [ 1 , 2 , 0 ] , [ 0 , 2 , 1 ] , [ 0 , 1 , 2 ] ] @sa sort, randShuffle Python prototype (for reference): sortIdx(src, flags[, dst]) -&gt; dst","ref":"Evision.html#sortIdx/2","title":"Evision.sortIdx/2","type":"function"},{"doc":"Sorts each row or each column of a matrix. Positional Arguments src : Evision.Mat . input single-channel array. flags : int . operation flags that could be a combination of cv::SortFlags Return dst : Evision.Mat . output integer array of the same size as src. The function cv::sortIdx sorts each matrix row or each matrix column in the ascending or descending order. So you should pass two operation flags to get desired behaviour. Instead of reordering the elements themselves, it stores the indices of sorted elements in the output array. For example: Mat A = Mat :: eye ( 3 , 3 , CV_32F ) , B ; sortIdx ( A , B , SORT_EVERY_ROW + SORT_ASCENDING ) ; // B will probably contain // ( because of equal elements in A some permutations are possible ) : // [ [ 1 , 2 , 0 ] , [ 0 , 2 , 1 ] , [ 0 , 1 , 2 ] ] @sa sort, randShuffle Python prototype (for reference): sortIdx(src, flags[, dst]) -&gt; dst","ref":"Evision.html#sortIdx/3","title":"Evision.sortIdx/3","type":"function"},{"doc":"Raising version of spatialGradient/1 .","ref":"Evision.html#spatialGradient!/1","title":"Evision.spatialGradient!/1","type":"function"},{"doc":"Raising version of spatialGradient/2 .","ref":"Evision.html#spatialGradient!/2","title":"Evision.spatialGradient!/2","type":"function"},{"doc":"Calculates the first order image derivative in both x and y using a Sobel operator Positional Arguments src : Evision.Mat . input image. Keyword Arguments ksize : int . size of Sobel kernel. It must be 3. borderType : int . pixel extrapolation method, see #BorderTypes. Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported. Return dx : Evision.Mat . output image with first-order derivative in x. dy : Evision.Mat . output image with first-order derivative in y. Equivalent to calling: Sobel ( src , dx , CV_16SC1 , 1 , 0 , 3 ) ; Sobel ( src , dy , CV_16SC1 , 0 , 1 , 3 ) ; @sa Sobel Python prototype (for reference): spatialGradient(src[, dx[, dy[, ksize[, borderType]]]]) -&gt; dx, dy","ref":"Evision.html#spatialGradient/1","title":"Evision.spatialGradient/1","type":"function"},{"doc":"Calculates the first order image derivative in both x and y using a Sobel operator Positional Arguments src : Evision.Mat . input image. Keyword Arguments ksize : int . size of Sobel kernel. It must be 3. borderType : int . pixel extrapolation method, see #BorderTypes. Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported. Return dx : Evision.Mat . output image with first-order derivative in x. dy : Evision.Mat . output image with first-order derivative in y. Equivalent to calling: Sobel ( src , dx , CV_16SC1 , 1 , 0 , 3 ) ; Sobel ( src , dy , CV_16SC1 , 0 , 1 , 3 ) ; @sa Sobel Python prototype (for reference): spatialGradient(src[, dx[, dy[, ksize[, borderType]]]]) -&gt; dx, dy","ref":"Evision.html#spatialGradient/2","title":"Evision.spatialGradient/2","type":"function"},{"doc":"Raising version of split/1 .","ref":"Evision.html#split!/1","title":"Evision.split!/1","type":"function"},{"doc":"Raising version of split/2 .","ref":"Evision.html#split!/2","title":"Evision.split!/2","type":"function"},{"doc":"Positional Arguments m : Evision.Mat . input multi-channel array. Return mv : [Evision.Mat] . output vector of arrays; the arrays themselves are reallocated, if needed. Has overloading in C++ Python prototype (for reference): split(m[, mv]) -&gt; mv","ref":"Evision.html#split/1","title":"Evision.split/1","type":"function"},{"doc":"Positional Arguments m : Evision.Mat . input multi-channel array. Return mv : [Evision.Mat] . output vector of arrays; the arrays themselves are reallocated, if needed. Has overloading in C++ Python prototype (for reference): split(m[, mv]) -&gt; mv","ref":"Evision.html#split/2","title":"Evision.split/2","type":"function"},{"doc":"Raising version of sqrBoxFilter/3 .","ref":"Evision.html#sqrBoxFilter!/3","title":"Evision.sqrBoxFilter!/3","type":"function"},{"doc":"Raising version of sqrBoxFilter/4 .","ref":"Evision.html#sqrBoxFilter!/4","title":"Evision.sqrBoxFilter!/4","type":"function"},{"doc":"Calculates the normalized sum of squares of the pixel values overlapping the filter. Positional Arguments src : Evision.Mat . input image ddepth : int . the output image depth (-1 to use src.depth()) ksize : Size . kernel size Keyword Arguments anchor : Point . kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel center. normalize : bool . flag, specifying whether the kernel is to be normalized by it's area or not. borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src For every pixel \\f$ (x, y) \\f$ in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel \\f$ (x, y) \\f$. The unnormalized square box filter can be useful in computing local image statistics such as the local variance and standard deviation around the neighborhood of a pixel. @sa boxFilter Python prototype (for reference): sqrBoxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -&gt; dst","ref":"Evision.html#sqrBoxFilter/3","title":"Evision.sqrBoxFilter/3","type":"function"},{"doc":"Calculates the normalized sum of squares of the pixel values overlapping the filter. Positional Arguments src : Evision.Mat . input image ddepth : int . the output image depth (-1 to use src.depth()) ksize : Size . kernel size Keyword Arguments anchor : Point . kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel center. normalize : bool . flag, specifying whether the kernel is to be normalized by it's area or not. borderType : int . border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. Return dst : Evision.Mat . output image of the same size and type as src For every pixel \\f$ (x, y) \\f$ in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel \\f$ (x, y) \\f$. The unnormalized square box filter can be useful in computing local image statistics such as the local variance and standard deviation around the neighborhood of a pixel. @sa boxFilter Python prototype (for reference): sqrBoxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -&gt; dst","ref":"Evision.html#sqrBoxFilter/4","title":"Evision.sqrBoxFilter/4","type":"function"},{"doc":"Raising version of sqrt/1 .","ref":"Evision.html#sqrt!/1","title":"Evision.sqrt!/1","type":"function"},{"doc":"Raising version of sqrt/2 .","ref":"Evision.html#sqrt!/2","title":"Evision.sqrt!/2","type":"function"},{"doc":"Calculates a square root of array elements. Positional Arguments src : Evision.Mat . input floating-point array. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::sqrt calculates a square root of each input array element. In case of multi-channel arrays, each channel is processed independently. The accuracy is approximately the same as of the built-in std::sqrt . Python prototype (for reference): sqrt(src[, dst]) -&gt; dst","ref":"Evision.html#sqrt/1","title":"Evision.sqrt/1","type":"function"},{"doc":"Calculates a square root of array elements. Positional Arguments src : Evision.Mat . input floating-point array. Return dst : Evision.Mat . output array of the same size and type as src. The function cv::sqrt calculates a square root of each input array element. In case of multi-channel arrays, each channel is processed independently. The accuracy is approximately the same as of the built-in std::sqrt . Python prototype (for reference): sqrt(src[, dst]) -&gt; dst","ref":"Evision.html#sqrt/2","title":"Evision.sqrt/2","type":"function"},{"doc":"Raising version of startWindowThread/0 .","ref":"Evision.html#startWindowThread!/0","title":"Evision.startWindowThread!/0","type":"function"},{"doc":"Python prototype (for reference): startWindowThread() -&gt; retval","ref":"Evision.html#startWindowThread/0","title":"Evision.startWindowThread/0","type":"function"},{"doc":"Raising version of stereoCalibrate/8 .","ref":"Evision.html#stereoCalibrate!/8","title":"Evision.stereoCalibrate!/8","type":"function"},{"doc":"Raising version of stereoCalibrate/9 .","ref":"Evision.html#stereoCalibrate!/9","title":"Evision.stereoCalibrate!/9","type":"function"},{"doc":"Positional Arguments objectPoints : [Evision.Mat] imagePoints1 : [Evision.Mat] imagePoints2 : [Evision.Mat] imageSize : Size Keyword Arguments flags : int . criteria : TermCriteria . Return cameraMatrix1 : Evision.Mat distCoeffs1 : Evision.Mat cameraMatrix2 : Evision.Mat distCoeffs2 : Evision.Mat r : Evision.Mat . t : Evision.Mat . e : Evision.Mat . f : Evision.Mat . Python prototype (for reference): stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize[, R[, T[, E[, F[, flags[, criteria]]]]]]) -&gt; retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F","ref":"Evision.html#stereoCalibrate/8","title":"Evision.stereoCalibrate/8","type":"function"},{"doc":"Positional Arguments objectPoints : [Evision.Mat] imagePoints1 : [Evision.Mat] imagePoints2 : [Evision.Mat] imageSize : Size Keyword Arguments flags : int . criteria : TermCriteria . Return cameraMatrix1 : Evision.Mat distCoeffs1 : Evision.Mat cameraMatrix2 : Evision.Mat distCoeffs2 : Evision.Mat r : Evision.Mat . t : Evision.Mat . e : Evision.Mat . f : Evision.Mat . Python prototype (for reference): stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize[, R[, T[, E[, F[, flags[, criteria]]]]]]) -&gt; retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F","ref":"Evision.html#stereoCalibrate/9","title":"Evision.stereoCalibrate/9","type":"function"},{"doc":"Raising version of stereoCalibrateExtended/10 .","ref":"Evision.html#stereoCalibrateExtended!/10","title":"Evision.stereoCalibrateExtended!/10","type":"function"},{"doc":"Raising version of stereoCalibrateExtended/11 .","ref":"Evision.html#stereoCalibrateExtended!/11","title":"Evision.stereoCalibrateExtended!/11","type":"function"},{"doc":"Calibrates a stereo camera set up. This function finds the intrinsic parameters for each of the two cameras and the extrinsic parameters between the two cameras. Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of the calibration pattern points. The same structure as in @ref calibrateCamera. For each pattern view, both cameras need to see the same object points. Therefore, objectPoints.size(), imagePoints1.size(), and imagePoints2.size() need to be equal as well as objectPoints[i].size(), imagePoints1[i].size(), and imagePoints2[i].size() need to be equal for each i. imagePoints1 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the first camera. The same structure as in @ref calibrateCamera. imagePoints2 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the second camera. The same structure as in @ref calibrateCamera. imageSize : Size . Size of the image used only to initialize the camera intrinsic matrices. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref CALIB_FIX_INTRINSIC Fix cameraMatrix? and distCoeffs? so that only R, T, E, and F matrices are estimated. @ref CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic parameters according to the specified flags. Initial values are provided by the user. @ref CALIB_USE_EXTRINSIC_GUESS R and T contain valid initial values that are optimized further. Otherwise R and T are initialized to the median value of the pattern views (each dimension separately). @ref CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the optimization. @ref CALIB_FIX_FOCAL_LENGTH Fix \\f$f^{(j)}_x\\f$ and \\f$f^{(j)}_y\\f$ . @ref CALIB_FIX_ASPECT_RATIO Optimize \\f$f^{(j)}_y\\f$ . Fix the ratio \\f$f^{(j)}_x/f^{(j)}_y\\f$ . @ref CALIB_SAME_FOCAL_LENGTH Enforce \\f$f^{(0)}_x=f^{(1)}_x\\f$ and \\f$f^{(0)}_y=f^{(1)}_y\\f$ . @ref CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for each camera to zeros and fix there. @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 Do not change the corresponding radial distortion coefficient during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the thin prism model and return 12 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the tilted sensor model and return 14 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return cameraMatrix1 : Evision.Mat . Input/output camera intrinsic matrix for the first camera, the same as in distCoeffs1 : Evision.Mat . Input/output vector of distortion coefficients, the same as in cameraMatrix2 : Evision.Mat . Input/output second camera intrinsic matrix for the second camera. See description for cameraMatrix1. distCoeffs2 : Evision.Mat . Input/output lens distortion coefficients for the second camera. See description for distCoeffs1. r : Evision.Mat . Output rotation matrix. Together with the translation vector T, this matrix brings points given in the first camera's coordinate system to points in the second camera's coordinate system. In more technical terms, the tuple of R and T performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Due to its duality, this tuple is equivalent to the position of the first camera with respect to the second camera coordinate system. t : Evision.Mat . Output translation vector, see description above. e : Evision.Mat . Output essential matrix. f : Evision.Mat . Output fundamental matrix. perViewErrors : Evision.Mat . Output vector of the RMS re-projection error estimated for each pattern view. @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below. @ref calibrateCamera. The function estimates the transformation between two cameras making a stereo pair. If one computes the poses of an object relative to the first camera and to the second camera, ( \\f$R_1\\f$,\\f$T_1\\f$ ) and (\\f$R_2\\f$,\\f$T_2\\f$), respectively, for a stereo camera where the relative position and orientation between the two cameras are fixed, then those poses definitely relate to each other. This means, if the relative position and orientation (\\f$R\\f$,\\f$T\\f$) of the two cameras is known, it is possible to compute (\\f$R_2\\f$,\\f$T_2\\f$) when (\\f$R_1\\f$,\\f$T_1\\f$) is given. This is what the described function does. It computes (\\f$R\\f$,\\f$T\\f$) such that: \\f[R_2=R R_1\\f] \\f[T_2=R T_1 + T.\\f] Therefore, one can compute the coordinate representation of a 3D point for the second camera's coordinate system when given the point's coordinate representation in the first camera's coordinate system: \\f[\\begin{bmatrix} X_2 \\\\ Y_2 \\\\ Z_2 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} R &amp; T \\\\ 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_1 \\\\ Y_1 \\\\ Z_1 \\\\ 1 \\end{bmatrix}.\\f] Optionally, it computes the essential matrix E: \\f[E= \\vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} R\\f] where \\f$T_i\\f$ are components of the translation vector \\f$T\\f$ : \\f$T=[T_0, T_1, T_2]^T\\f$ . And the function can also compute the fundamental matrix F: \\f[F = cameraMatrix2^{-T}\\cdot E \\cdot cameraMatrix1^{-1}\\f] Besides the stereo-related information, the function can also perform a full calibration of each of the two cameras. However, due to the high dimensionality of the parameter space and noise in the input data, the function can diverge from the correct solution. If the intrinsic parameters can be estimated with high accuracy for each of the cameras individually (for example, using #calibrateCamera ), you are recommended to do so and then pass @ref CALIB_FIX_INTRINSIC flag to the function along with the computed intrinsic parameters. Otherwise, if all the parameters are estimated at once, it makes sense to restrict some parameters, for example, pass @ref CALIB_SAME_FOCAL_LENGTH and @ref CALIB_ZERO_TANGENT_DIST flags, which is usually a reasonable assumption. Similarly to #calibrateCamera, the function minimizes the total re-projection error for all the points in all the available views from both cameras. The function returns the final value of the re-projection error. Python prototype (for reference): stereoCalibrateExtended(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, E[, F[, perViewErrors[, flags[, criteria]]]]]) -&gt; retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F, perViewErrors","ref":"Evision.html#stereoCalibrateExtended/10","title":"Evision.stereoCalibrateExtended/10","type":"function"},{"doc":"Calibrates a stereo camera set up. This function finds the intrinsic parameters for each of the two cameras and the extrinsic parameters between the two cameras. Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of the calibration pattern points. The same structure as in @ref calibrateCamera. For each pattern view, both cameras need to see the same object points. Therefore, objectPoints.size(), imagePoints1.size(), and imagePoints2.size() need to be equal as well as objectPoints[i].size(), imagePoints1[i].size(), and imagePoints2[i].size() need to be equal for each i. imagePoints1 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the first camera. The same structure as in @ref calibrateCamera. imagePoints2 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the second camera. The same structure as in @ref calibrateCamera. imageSize : Size . Size of the image used only to initialize the camera intrinsic matrices. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref CALIB_FIX_INTRINSIC Fix cameraMatrix? and distCoeffs? so that only R, T, E, and F matrices are estimated. @ref CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic parameters according to the specified flags. Initial values are provided by the user. @ref CALIB_USE_EXTRINSIC_GUESS R and T contain valid initial values that are optimized further. Otherwise R and T are initialized to the median value of the pattern views (each dimension separately). @ref CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the optimization. @ref CALIB_FIX_FOCAL_LENGTH Fix \\f$f^{(j)}_x\\f$ and \\f$f^{(j)}_y\\f$ . @ref CALIB_FIX_ASPECT_RATIO Optimize \\f$f^{(j)}_y\\f$ . Fix the ratio \\f$f^{(j)}_x/f^{(j)}_y\\f$ . @ref CALIB_SAME_FOCAL_LENGTH Enforce \\f$f^{(0)}_x=f^{(1)}_x\\f$ and \\f$f^{(0)}_y=f^{(1)}_y\\f$ . @ref CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for each camera to zeros and fix there. @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 Do not change the corresponding radial distortion coefficient during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the thin prism model and return 12 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the tilted sensor model and return 14 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return cameraMatrix1 : Evision.Mat . Input/output camera intrinsic matrix for the first camera, the same as in distCoeffs1 : Evision.Mat . Input/output vector of distortion coefficients, the same as in cameraMatrix2 : Evision.Mat . Input/output second camera intrinsic matrix for the second camera. See description for cameraMatrix1. distCoeffs2 : Evision.Mat . Input/output lens distortion coefficients for the second camera. See description for distCoeffs1. r : Evision.Mat . Output rotation matrix. Together with the translation vector T, this matrix brings points given in the first camera's coordinate system to points in the second camera's coordinate system. In more technical terms, the tuple of R and T performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Due to its duality, this tuple is equivalent to the position of the first camera with respect to the second camera coordinate system. t : Evision.Mat . Output translation vector, see description above. e : Evision.Mat . Output essential matrix. f : Evision.Mat . Output fundamental matrix. perViewErrors : Evision.Mat . Output vector of the RMS re-projection error estimated for each pattern view. @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below. @ref calibrateCamera. The function estimates the transformation between two cameras making a stereo pair. If one computes the poses of an object relative to the first camera and to the second camera, ( \\f$R_1\\f$,\\f$T_1\\f$ ) and (\\f$R_2\\f$,\\f$T_2\\f$), respectively, for a stereo camera where the relative position and orientation between the two cameras are fixed, then those poses definitely relate to each other. This means, if the relative position and orientation (\\f$R\\f$,\\f$T\\f$) of the two cameras is known, it is possible to compute (\\f$R_2\\f$,\\f$T_2\\f$) when (\\f$R_1\\f$,\\f$T_1\\f$) is given. This is what the described function does. It computes (\\f$R\\f$,\\f$T\\f$) such that: \\f[R_2=R R_1\\f] \\f[T_2=R T_1 + T.\\f] Therefore, one can compute the coordinate representation of a 3D point for the second camera's coordinate system when given the point's coordinate representation in the first camera's coordinate system: \\f[\\begin{bmatrix} X_2 \\\\ Y_2 \\\\ Z_2 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} R &amp; T \\\\ 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} X_1 \\\\ Y_1 \\\\ Z_1 \\\\ 1 \\end{bmatrix}.\\f] Optionally, it computes the essential matrix E: \\f[E= \\vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} R\\f] where \\f$T_i\\f$ are components of the translation vector \\f$T\\f$ : \\f$T=[T_0, T_1, T_2]^T\\f$ . And the function can also compute the fundamental matrix F: \\f[F = cameraMatrix2^{-T}\\cdot E \\cdot cameraMatrix1^{-1}\\f] Besides the stereo-related information, the function can also perform a full calibration of each of the two cameras. However, due to the high dimensionality of the parameter space and noise in the input data, the function can diverge from the correct solution. If the intrinsic parameters can be estimated with high accuracy for each of the cameras individually (for example, using #calibrateCamera ), you are recommended to do so and then pass @ref CALIB_FIX_INTRINSIC flag to the function along with the computed intrinsic parameters. Otherwise, if all the parameters are estimated at once, it makes sense to restrict some parameters, for example, pass @ref CALIB_SAME_FOCAL_LENGTH and @ref CALIB_ZERO_TANGENT_DIST flags, which is usually a reasonable assumption. Similarly to #calibrateCamera, the function minimizes the total re-projection error for all the points in all the available views from both cameras. The function returns the final value of the re-projection error. Python prototype (for reference): stereoCalibrateExtended(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, E[, F[, perViewErrors[, flags[, criteria]]]]]) -&gt; retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F, perViewErrors","ref":"Evision.html#stereoCalibrateExtended/11","title":"Evision.stereoCalibrateExtended/11","type":"function"},{"doc":"Raising version of stereoRectify/7 .","ref":"Evision.html#stereoRectify!/7","title":"Evision.stereoRectify!/7","type":"function"},{"doc":"Raising version of stereoRectify/8 .","ref":"Evision.html#stereoRectify!/8","title":"Evision.stereoRectify!/8","type":"function"},{"doc":"Computes rectification transforms for each head of a calibrated stereo camera. Positional Arguments cameraMatrix1 : Evision.Mat . First camera intrinsic matrix. distCoeffs1 : Evision.Mat . First camera distortion parameters. cameraMatrix2 : Evision.Mat . Second camera intrinsic matrix. distCoeffs2 : Evision.Mat . Second camera distortion parameters. imageSize : Size . Size of the image used for stereo calibration. r : Evision.Mat . Rotation matrix from the coordinate system of the first camera to the second camera, see @ref stereoCalibrate. t : Evision.Mat . Translation vector from the coordinate system of the first camera to the second camera, see @ref stereoCalibrate. Keyword Arguments flags : int . Operation flags that may be zero or @ref CALIB_ZERO_DISPARITY . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area. alpha : double . Free scaling parameter. If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained in the rectified images (no source image pixels are lost). Any intermediate value yields an intermediate result between those two extreme cases. newImageSize : Size . New image resolution after rectification. The same size should be passed to #initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0) is passed (default), it is set to the original imageSize . Setting it to a larger value can help you preserve details in the original image, especially when there is a big radial distortion. Return r1 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix brings points given in the unrectified first camera's coordinate system to points in the rectified first camera's coordinate system. In more technical terms, it performs a change of basis from the unrectified first camera's coordinate system to the rectified first camera's coordinate system. r2 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix brings points given in the unrectified second camera's coordinate system to points in the rectified second camera's coordinate system. In more technical terms, it performs a change of basis from the unrectified second camera's coordinate system to the rectified second camera's coordinate system. p1 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera, i.e. it projects points given in the rectified first camera coordinate system into the rectified first camera's image. p2 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera, i.e. it projects points given in the rectified first camera coordinate system into the rectified second camera's image. q : Evision.Mat . Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see @ref reprojectImageTo3D). validPixROI1 : Rect* . Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below). validPixROI2 : Rect* . Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below). The function computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. The function takes the matrices computed by #stereoCalibrate as input. As output, it provides two rotation matrices and also two projection matrices in the new coordinates. The function distinguishes the following two cases: Horizontal stereo : the first and the second camera views are shifted relative to each other mainly along the x-axis (with possible small vertical shift). In the rectified images, the corresponding epipolar lines in the left and right cameras are horizontal and have the same y-coordinate. P1 and P2 look like: \\f[\\texttt{P1} = \\begin{bmatrix} f &amp; 0 &amp; cx_1 &amp; 0 \\\\ 0 &amp; f &amp; cy &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}\\f] \\f[\\texttt{P2} = \\begin{bmatrix} f &amp; 0 &amp; cx_2 &amp; T_x*f \\\\ 0 &amp; f &amp; cy &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix} ,\\f] where \\f$T_x\\f$ is a horizontal shift between the cameras and \\f$cx_1=cx_2\\f$ if @ref CALIB_ZERO_DISPARITY is set. Vertical stereo : the first and the second camera views are shifted relative to each other mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like: \\f[\\texttt{P1} = \\begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\\\ 0 &amp; f &amp; cy_1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}\\f] \\f[\\texttt{P2} = \\begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\\\ 0 &amp; f &amp; cy_2 &amp; T_y*f \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix},\\f] where \\f$T_y\\f$ is a vertical shift between the cameras and \\f$cy_1=cy_2\\f$ if @ref CALIB_ZERO_DISPARITY is set. As you can see, the first three columns of P1 and P2 will effectively be the new &quot;rectified&quot; camera matrices. The matrices, together with R1 and R2 , can then be passed to #initUndistortRectifyMap to initialize the rectification map for each camera. See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through the corresponding image regions. This means that the images are well rectified, which is what most stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that their interiors are all valid pixels. Python prototype (for reference): stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, R1[, R2[, P1[, P2[, Q[, flags[, alpha[, newImageSize]]]]]]]]) -&gt; R1, R2, P1, P2, Q, validPixROI1, validPixROI2","ref":"Evision.html#stereoRectify/7","title":"Evision.stereoRectify/7","type":"function"},{"doc":"Computes rectification transforms for each head of a calibrated stereo camera. Positional Arguments cameraMatrix1 : Evision.Mat . First camera intrinsic matrix. distCoeffs1 : Evision.Mat . First camera distortion parameters. cameraMatrix2 : Evision.Mat . Second camera intrinsic matrix. distCoeffs2 : Evision.Mat . Second camera distortion parameters. imageSize : Size . Size of the image used for stereo calibration. r : Evision.Mat . Rotation matrix from the coordinate system of the first camera to the second camera, see @ref stereoCalibrate. t : Evision.Mat . Translation vector from the coordinate system of the first camera to the second camera, see @ref stereoCalibrate. Keyword Arguments flags : int . Operation flags that may be zero or @ref CALIB_ZERO_DISPARITY . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area. alpha : double . Free scaling parameter. If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained in the rectified images (no source image pixels are lost). Any intermediate value yields an intermediate result between those two extreme cases. newImageSize : Size . New image resolution after rectification. The same size should be passed to #initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0) is passed (default), it is set to the original imageSize . Setting it to a larger value can help you preserve details in the original image, especially when there is a big radial distortion. Return r1 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix brings points given in the unrectified first camera's coordinate system to points in the rectified first camera's coordinate system. In more technical terms, it performs a change of basis from the unrectified first camera's coordinate system to the rectified first camera's coordinate system. r2 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix brings points given in the unrectified second camera's coordinate system to points in the rectified second camera's coordinate system. In more technical terms, it performs a change of basis from the unrectified second camera's coordinate system to the rectified second camera's coordinate system. p1 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera, i.e. it projects points given in the rectified first camera coordinate system into the rectified first camera's image. p2 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera, i.e. it projects points given in the rectified first camera coordinate system into the rectified second camera's image. q : Evision.Mat . Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see @ref reprojectImageTo3D). validPixROI1 : Rect* . Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below). validPixROI2 : Rect* . Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below). The function computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. The function takes the matrices computed by #stereoCalibrate as input. As output, it provides two rotation matrices and also two projection matrices in the new coordinates. The function distinguishes the following two cases: Horizontal stereo : the first and the second camera views are shifted relative to each other mainly along the x-axis (with possible small vertical shift). In the rectified images, the corresponding epipolar lines in the left and right cameras are horizontal and have the same y-coordinate. P1 and P2 look like: \\f[\\texttt{P1} = \\begin{bmatrix} f &amp; 0 &amp; cx_1 &amp; 0 \\\\ 0 &amp; f &amp; cy &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}\\f] \\f[\\texttt{P2} = \\begin{bmatrix} f &amp; 0 &amp; cx_2 &amp; T_x*f \\\\ 0 &amp; f &amp; cy &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix} ,\\f] where \\f$T_x\\f$ is a horizontal shift between the cameras and \\f$cx_1=cx_2\\f$ if @ref CALIB_ZERO_DISPARITY is set. Vertical stereo : the first and the second camera views are shifted relative to each other mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like: \\f[\\texttt{P1} = \\begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\\\ 0 &amp; f &amp; cy_1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}\\f] \\f[\\texttt{P2} = \\begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\\\ 0 &amp; f &amp; cy_2 &amp; T_y*f \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix},\\f] where \\f$T_y\\f$ is a vertical shift between the cameras and \\f$cy_1=cy_2\\f$ if @ref CALIB_ZERO_DISPARITY is set. As you can see, the first three columns of P1 and P2 will effectively be the new &quot;rectified&quot; camera matrices. The matrices, together with R1 and R2 , can then be passed to #initUndistortRectifyMap to initialize the rectification map for each camera. See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through the corresponding image regions. This means that the images are well rectified, which is what most stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that their interiors are all valid pixels. Python prototype (for reference): stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, R1[, R2[, P1[, P2[, Q[, flags[, alpha[, newImageSize]]]]]]]]) -&gt; R1, R2, P1, P2, Q, validPixROI1, validPixROI2","ref":"Evision.html#stereoRectify/8","title":"Evision.stereoRectify/8","type":"function"},{"doc":"Raising version of stereoRectifyUncalibrated/4 .","ref":"Evision.html#stereoRectifyUncalibrated!/4","title":"Evision.stereoRectifyUncalibrated!/4","type":"function"},{"doc":"Raising version of stereoRectifyUncalibrated/5 .","ref":"Evision.html#stereoRectifyUncalibrated!/5","title":"Evision.stereoRectifyUncalibrated!/5","type":"function"},{"doc":"Computes a rectification transform for an uncalibrated stereo camera. Positional Arguments points1 : Evision.Mat . Array of feature points in the first image. points2 : Evision.Mat . The corresponding points in the second image. The same formats as in #findFundamentalMat are supported. f : Evision.Mat . Input fundamental matrix. It can be computed from the same set of point pairs using #findFundamentalMat . imgSize : Size . Size of the image. Keyword Arguments threshold : double . Optional threshold used to filter out the outliers. If the parameter is greater than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points for which \\f$|\\texttt{points2[i]}^T \\texttt{F} \\texttt{points1[i]}|&gt;\\texttt{threshold}\\f$ ) are rejected prior to computing the homographies. Otherwise, all the points are considered inliers. Return h1 : Evision.Mat . Output rectification homography matrix for the first image. h2 : Evision.Mat . Output rectification homography matrix for the second image. The function computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in the space, which explains the suffix &quot;uncalibrated&quot;. Another related difference from #stereoRectify is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations encoded by the homography matrices H1 and H2 . The function implements the algorithm @cite Hartley99 . Note : While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion, it would be better to correct it before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using #calibrateCamera . Then, the images can be corrected using #undistort , or just the point coordinates can be corrected with #undistortPoints . Python prototype (for reference): stereoRectifyUncalibrated(points1, points2, F, imgSize[, H1[, H2[, threshold]]]) -&gt; retval, H1, H2","ref":"Evision.html#stereoRectifyUncalibrated/4","title":"Evision.stereoRectifyUncalibrated/4","type":"function"},{"doc":"Computes a rectification transform for an uncalibrated stereo camera. Positional Arguments points1 : Evision.Mat . Array of feature points in the first image. points2 : Evision.Mat . The corresponding points in the second image. The same formats as in #findFundamentalMat are supported. f : Evision.Mat . Input fundamental matrix. It can be computed from the same set of point pairs using #findFundamentalMat . imgSize : Size . Size of the image. Keyword Arguments threshold : double . Optional threshold used to filter out the outliers. If the parameter is greater than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points for which \\f$|\\texttt{points2[i]}^T \\texttt{F} \\texttt{points1[i]}|&gt;\\texttt{threshold}\\f$ ) are rejected prior to computing the homographies. Otherwise, all the points are considered inliers. Return h1 : Evision.Mat . Output rectification homography matrix for the first image. h2 : Evision.Mat . Output rectification homography matrix for the second image. The function computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in the space, which explains the suffix &quot;uncalibrated&quot;. Another related difference from #stereoRectify is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations encoded by the homography matrices H1 and H2 . The function implements the algorithm @cite Hartley99 . Note : While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion, it would be better to correct it before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using #calibrateCamera . Then, the images can be corrected using #undistort , or just the point coordinates can be corrected with #undistortPoints . Python prototype (for reference): stereoRectifyUncalibrated(points1, points2, F, imgSize[, H1[, H2[, threshold]]]) -&gt; retval, H1, H2","ref":"Evision.html#stereoRectifyUncalibrated/5","title":"Evision.stereoRectifyUncalibrated/5","type":"function"},{"doc":"Raising version of stylization/1 .","ref":"Evision.html#stylization!/1","title":"Evision.stylization!/1","type":"function"},{"doc":"Raising version of stylization/2 .","ref":"Evision.html#stylization!/2","title":"Evision.stylization!/2","type":"function"},{"doc":"Stylization aims to produce digital imagery with a wide variety of effects not focused on photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low contrast while preserving, or enhancing, high-contrast features. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. Return dst : Evision.Mat . Output image with the same size and type as src. Python prototype (for reference): stylization(src[, dst[, sigma_s[, sigma_r]]]) -&gt; dst","ref":"Evision.html#stylization/1","title":"Evision.stylization/1","type":"function"},{"doc":"Stylization aims to produce digital imagery with a wide variety of effects not focused on photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low contrast while preserving, or enhancing, high-contrast features. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. Keyword Arguments sigma_s : float . %Range between 0 to 200. sigma_r : float . %Range between 0 to 1. Return dst : Evision.Mat . Output image with the same size and type as src. Python prototype (for reference): stylization(src[, dst[, sigma_s[, sigma_r]]]) -&gt; dst","ref":"Evision.html#stylization/2","title":"Evision.stylization/2","type":"function"},{"doc":"Raising version of subtract/2 .","ref":"Evision.html#subtract!/2","title":"Evision.subtract!/2","type":"function"},{"doc":"Raising version of subtract/3 .","ref":"Evision.html#subtract!/3","title":"Evision.subtract!/3","type":"function"},{"doc":"Calculates the per-element difference between two arrays or array and a scalar. Positional Arguments src1 : Evision.Mat . first input array or a scalar. src2 : Evision.Mat . second input array or a scalar. Keyword Arguments mask : Evision.Mat . optional operation mask; this is an 8-bit single channel array that specifies elements of the output array to be changed. dtype : int . optional depth of the output array Return dst : Evision.Mat . output array of the same size and the same number of channels as the input array. The function subtract calculates: Difference between two arrays, when both input arrays have the same size and the same number of channels: \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) - \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f] Difference between an array and a scalar, when src2 is constructed from Scalar or has the same number of elements as src1.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) - \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f] Difference between a scalar and an array, when src1 is constructed from Scalar or has the same number of elements as src2.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1} - \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f] The reverse difference between a scalar and an array in the case of SubRS : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src2} - \\texttt{src1}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions: dst = src1 - src2; dst -= src1; // equivalent to subtract(dst, src1, dst); The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of the output array is determined by dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case the output array will have the same depth as the input array, be it src1, src2 or both. Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa add, addWeighted, scaleAdd, Mat::convertTo Python prototype (for reference): subtract(src1, src2[, dst[, mask[, dtype]]]) -&gt; dst","ref":"Evision.html#subtract/2","title":"Evision.subtract/2","type":"function"},{"doc":"Calculates the per-element difference between two arrays or array and a scalar. Positional Arguments src1 : Evision.Mat . first input array or a scalar. src2 : Evision.Mat . second input array or a scalar. Keyword Arguments mask : Evision.Mat . optional operation mask; this is an 8-bit single channel array that specifies elements of the output array to be changed. dtype : int . optional depth of the output array Return dst : Evision.Mat . output array of the same size and the same number of channels as the input array. The function subtract calculates: Difference between two arrays, when both input arrays have the same size and the same number of channels: \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) - \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f] Difference between an array and a scalar, when src2 is constructed from Scalar or has the same number of elements as src1.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1}(I) - \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f] Difference between a scalar and an array, when src1 is constructed from Scalar or has the same number of elements as src2.channels() : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src1} - \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f] The reverse difference between a scalar and an array in the case of SubRS : \\f[\\texttt{dst}(I) = \\texttt{saturate} ( \\texttt{src2} - \\texttt{src1}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f] where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions: dst = src1 - src2; dst -= src1; // equivalent to subtract(dst, src1, dst); The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of the output array is determined by dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case the output array will have the same depth as the input array, be it src1, src2 or both. Note : Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. @sa add, addWeighted, scaleAdd, Mat::convertTo Python prototype (for reference): subtract(src1, src2[, dst[, mask[, dtype]]]) -&gt; dst","ref":"Evision.html#subtract/3","title":"Evision.subtract/3","type":"function"},{"doc":"Raising version of sumElems/1 .","ref":"Evision.html#sumElems!/1","title":"Evision.sumElems!/1","type":"function"},{"doc":"Calculates the sum of array elements. Positional Arguments src : Evision.Mat . input array that must have from 1 to 4 channels. The function cv::sum calculates and returns the sum of array elements, independently for each channel. @sa countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce Python prototype (for reference): sumElems(src) -&gt; retval","ref":"Evision.html#sumElems/1","title":"Evision.sumElems/1","type":"function"},{"doc":"Raising version of svBackSubst/4 .","ref":"Evision.html#svBackSubst!/4","title":"Evision.svBackSubst!/4","type":"function"},{"doc":"Raising version of svBackSubst/5 .","ref":"Evision.html#svBackSubst!/5","title":"Evision.svBackSubst!/5","type":"function"},{"doc":"Positional Arguments w : Evision.Mat u : Evision.Mat vt : Evision.Mat rhs : Evision.Mat Return dst : Evision.Mat . wrap SVD::backSubst Python prototype (for reference): SVBackSubst(w, u, vt, rhs[, dst]) -&gt; dst","ref":"Evision.html#svBackSubst/4","title":"Evision.svBackSubst/4","type":"function"},{"doc":"Positional Arguments w : Evision.Mat u : Evision.Mat vt : Evision.Mat rhs : Evision.Mat Return dst : Evision.Mat . wrap SVD::backSubst Python prototype (for reference): SVBackSubst(w, u, vt, rhs[, dst]) -&gt; dst","ref":"Evision.html#svBackSubst/5","title":"Evision.svBackSubst/5","type":"function"},{"doc":"Raising version of svdDecomp/1 .","ref":"Evision.html#svdDecomp!/1","title":"Evision.svdDecomp!/1","type":"function"},{"doc":"Raising version of svdDecomp/2 .","ref":"Evision.html#svdDecomp!/2","title":"Evision.svdDecomp!/2","type":"function"},{"doc":"Positional Arguments src : Evision.Mat Keyword Arguments flags : int . Return w : Evision.Mat . u : Evision.Mat . vt : Evision.Mat . wrap SVD::compute Python prototype (for reference): SVDecomp(src[, w[, u[, vt[, flags]]]]) -&gt; w, u, vt","ref":"Evision.html#svdDecomp/1","title":"Evision.svdDecomp/1","type":"function"},{"doc":"Positional Arguments src : Evision.Mat Keyword Arguments flags : int . Return w : Evision.Mat . u : Evision.Mat . vt : Evision.Mat . wrap SVD::compute Python prototype (for reference): SVDecomp(src[, w[, u[, vt[, flags]]]]) -&gt; w, u, vt","ref":"Evision.html#svdDecomp/2","title":"Evision.svdDecomp/2","type":"function"},{"doc":"Raising version of textureFlattening/2 .","ref":"Evision.html#textureFlattening!/2","title":"Evision.textureFlattening!/2","type":"function"},{"doc":"Raising version of textureFlattening/3 .","ref":"Evision.html#textureFlattening!/3","title":"Evision.textureFlattening!/3","type":"function"},{"doc":"By retaining only the gradients at edge locations, before integrating with the Poisson solver, one washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge %Detector is used. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. Keyword Arguments low_threshold : float . %Range from 0 to 100. high_threshold : float . Value &gt; 100. kernel_size : int . The size of the Sobel kernel to be used. Return dst : Evision.Mat . Output image with the same size and type as src. Note : The algorithm assumes that the color of the source image is close to that of the destination. This assumption means that when the colors don't match, the source image color gets tinted toward the color of the destination image. Python prototype (for reference): textureFlattening(src, mask[, dst[, low_threshold[, high_threshold[, kernel_size]]]]) -&gt; dst","ref":"Evision.html#textureFlattening/2","title":"Evision.textureFlattening/2","type":"function"},{"doc":"By retaining only the gradients at edge locations, before integrating with the Poisson solver, one washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge %Detector is used. Positional Arguments src : Evision.Mat . Input 8-bit 3-channel image. mask : Evision.Mat . Input 8-bit 1 or 3-channel image. Keyword Arguments low_threshold : float . %Range from 0 to 100. high_threshold : float . Value &gt; 100. kernel_size : int . The size of the Sobel kernel to be used. Return dst : Evision.Mat . Output image with the same size and type as src. Note : The algorithm assumes that the color of the source image is close to that of the destination. This assumption means that when the colors don't match, the source image color gets tinted toward the color of the destination image. Python prototype (for reference): textureFlattening(src, mask[, dst[, low_threshold[, high_threshold[, kernel_size]]]]) -&gt; dst","ref":"Evision.html#textureFlattening/3","title":"Evision.textureFlattening/3","type":"function"},{"doc":"Raising version of threshold/4 .","ref":"Evision.html#threshold!/4","title":"Evision.threshold!/4","type":"function"},{"doc":"Raising version of threshold/5 .","ref":"Evision.html#threshold!/5","title":"Evision.threshold!/5","type":"function"},{"doc":"Applies a fixed-level threshold to each array element. Positional Arguments src : Evision.Mat . input array (multiple-channel, 8-bit or 32-bit floating point). thresh : double . threshold value. maxval : double . maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding types. type : int . thresholding type (see #ThresholdTypes). Return dst : Evision.Mat . output array of the same size and type and the same number of channels as src. The function applies fixed-level thresholding to a multiple-channel array. The function is typically used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for this purpose) or for removing a noise, that is, filtering out pixels with too small or too large values. There are several types of thresholding supported by the function. They are determined by type parameter. Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the above values. In these cases, the function determines the optimal threshold value using the Otsu's or Triangle algorithm and uses it instead of the specified thresh. Note : Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images. @return the computed threshold value if Otsu's or Triangle methods used. @sa adaptiveThreshold, findContours, compare, min, max Python prototype (for reference): threshold(src, thresh, maxval, type[, dst]) -&gt; retval, dst","ref":"Evision.html#threshold/4","title":"Evision.threshold/4","type":"function"},{"doc":"Applies a fixed-level threshold to each array element. Positional Arguments src : Evision.Mat . input array (multiple-channel, 8-bit or 32-bit floating point). thresh : double . threshold value. maxval : double . maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding types. type : int . thresholding type (see #ThresholdTypes). Return dst : Evision.Mat . output array of the same size and type and the same number of channels as src. The function applies fixed-level thresholding to a multiple-channel array. The function is typically used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for this purpose) or for removing a noise, that is, filtering out pixels with too small or too large values. There are several types of thresholding supported by the function. They are determined by type parameter. Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the above values. In these cases, the function determines the optimal threshold value using the Otsu's or Triangle algorithm and uses it instead of the specified thresh. Note : Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images. @return the computed threshold value if Otsu's or Triangle methods used. @sa adaptiveThreshold, findContours, compare, min, max Python prototype (for reference): threshold(src, thresh, maxval, type[, dst]) -&gt; retval, dst","ref":"Evision.html#threshold/5","title":"Evision.threshold/5","type":"function"},{"doc":"Raising version of trace/1 .","ref":"Evision.html#trace!/1","title":"Evision.trace!/1","type":"function"},{"doc":"Returns the trace of a matrix. Positional Arguments mtx : Evision.Mat . input matrix. The function cv::trace returns the sum of the diagonal elements of the matrix mtx . \\f[\\mathrm{tr} ( \\texttt{mtx} ) = \\sum _i \\texttt{mtx} (i,i)\\f] Python prototype (for reference): trace(mtx) -&gt; retval","ref":"Evision.html#trace/1","title":"Evision.trace/1","type":"function"},{"doc":"Raising version of transform/2 .","ref":"Evision.html#transform!/2","title":"Evision.transform!/2","type":"function"},{"doc":"Raising version of transform/3 .","ref":"Evision.html#transform!/3","title":"Evision.transform!/3","type":"function"},{"doc":"Performs the matrix transformation of every array element. Positional Arguments src : Evision.Mat . input array that must have as many channels (1 to 4) as m.cols or m.cols-1. m : Evision.Mat . transformation 2x2 or 2x3 floating-point matrix. Return dst : Evision.Mat . output array of the same size and depth as src; it has as many channels as m.rows. The function cv::transform performs the matrix transformation of every element of the array src and stores the results in dst : \\f[\\texttt{dst} (I) = \\texttt{m} \\cdot \\texttt{src} (I)\\f] (when m.cols=src.channels() ), or \\f[\\texttt{dst} (I) = \\texttt{m} \\cdot [ \\texttt{src} (I); 1]\\f] (when m.cols=src.channels()+1 ) Every element of the N -channel array src is interpreted as N -element vector that is transformed using the M x N or M x (N+1) matrix m to M-element vector - the corresponding element of the output array dst . The function may be used for geometrical transformation of N -dimensional points, arbitrary linear color space transformation (such as various kinds of RGB to YUV transforms), shuffling the image channels, and so forth. @sa perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective Python prototype (for reference): transform(src, m[, dst]) -&gt; dst","ref":"Evision.html#transform/2","title":"Evision.transform/2","type":"function"},{"doc":"Performs the matrix transformation of every array element. Positional Arguments src : Evision.Mat . input array that must have as many channels (1 to 4) as m.cols or m.cols-1. m : Evision.Mat . transformation 2x2 or 2x3 floating-point matrix. Return dst : Evision.Mat . output array of the same size and depth as src; it has as many channels as m.rows. The function cv::transform performs the matrix transformation of every element of the array src and stores the results in dst : \\f[\\texttt{dst} (I) = \\texttt{m} \\cdot \\texttt{src} (I)\\f] (when m.cols=src.channels() ), or \\f[\\texttt{dst} (I) = \\texttt{m} \\cdot [ \\texttt{src} (I); 1]\\f] (when m.cols=src.channels()+1 ) Every element of the N -channel array src is interpreted as N -element vector that is transformed using the M x N or M x (N+1) matrix m to M-element vector - the corresponding element of the output array dst . The function may be used for geometrical transformation of N -dimensional points, arbitrary linear color space transformation (such as various kinds of RGB to YUV transforms), shuffling the image channels, and so forth. @sa perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective Python prototype (for reference): transform(src, m[, dst]) -&gt; dst","ref":"Evision.html#transform/3","title":"Evision.transform/3","type":"function"},{"doc":"Raising version of transpose/1 .","ref":"Evision.html#transpose!/1","title":"Evision.transpose!/1","type":"function"},{"doc":"Raising version of transpose/2 .","ref":"Evision.html#transpose!/2","title":"Evision.transpose!/2","type":"function"},{"doc":"Transposes a matrix. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array of the same type as src. The function cv::transpose transposes the matrix src : \\f[\\texttt{dst} (i,j) = \\texttt{src} (j,i)\\f] Note : No complex conjugation is done in case of a complex matrix. It should be done separately if needed. Python prototype (for reference): transpose(src[, dst]) -&gt; dst","ref":"Evision.html#transpose/1","title":"Evision.transpose/1","type":"function"},{"doc":"Transposes a matrix. Positional Arguments src : Evision.Mat . input array. Return dst : Evision.Mat . output array of the same type as src. The function cv::transpose transposes the matrix src : \\f[\\texttt{dst} (i,j) = \\texttt{src} (j,i)\\f] Note : No complex conjugation is done in case of a complex matrix. It should be done separately if needed. Python prototype (for reference): transpose(src[, dst]) -&gt; dst","ref":"Evision.html#transpose/2","title":"Evision.transpose/2","type":"function"},{"doc":"Raising version of transposeND/2 .","ref":"Evision.html#transposeND!/2","title":"Evision.transposeND!/2","type":"function"},{"doc":"Raising version of transposeND/3 .","ref":"Evision.html#transposeND!/3","title":"Evision.transposeND!/3","type":"function"},{"doc":"Transpose for n-dimensional matrices. Positional Arguments src : Evision.Mat . input array. order : [int] . a permutation of [0,1,..,N-1] where N is the number of axes of src. The ith axis of dst will correspond to the axis numbered order[i] of the input. Return dst : Evision.Mat . output array of the same type as src. Note : Input should be continuous single-channel matrix. Python prototype (for reference): transposeND(src, order[, dst]) -&gt; dst","ref":"Evision.html#transposeND/2","title":"Evision.transposeND/2","type":"function"},{"doc":"Transpose for n-dimensional matrices. Positional Arguments src : Evision.Mat . input array. order : [int] . a permutation of [0,1,..,N-1] where N is the number of axes of src. The ith axis of dst will correspond to the axis numbered order[i] of the input. Return dst : Evision.Mat . output array of the same type as src. Note : Input should be continuous single-channel matrix. Python prototype (for reference): transposeND(src, order[, dst]) -&gt; dst","ref":"Evision.html#transposeND/3","title":"Evision.transposeND/3","type":"function"},{"doc":"Raising version of triangulatePoints/4 .","ref":"Evision.html#triangulatePoints!/4","title":"Evision.triangulatePoints!/4","type":"function"},{"doc":"Raising version of triangulatePoints/5 .","ref":"Evision.html#triangulatePoints!/5","title":"Evision.triangulatePoints!/5","type":"function"},{"doc":"This function reconstructs 3-dimensional points (in homogeneous coordinates) by using their observations with a stereo camera. Positional Arguments projMatr1 : Evision.Mat . 3x4 projection matrix of the first camera, i.e. this matrix projects 3D points given in the world's coordinate system into the first image. projMatr2 : Evision.Mat . 3x4 projection matrix of the second camera, i.e. this matrix projects 3D points given in the world's coordinate system into the second image. projPoints1 : Evision.Mat . 2xN array of feature points in the first image. In the case of the c++ version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1. projPoints2 : Evision.Mat . 2xN array of corresponding points in the second image. In the case of the c++ version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1. Return points4D : Evision.Mat . 4xN array of reconstructed points in homogeneous coordinates. These points are returned in the world's coordinate system. Note : Keep in mind that all input data should be of float type in order for this function to work. Note : If the projection matrices from @ref stereoRectify are used, then the returned points are represented in the first camera's rectified coordinate system. @sa reprojectImageTo3D Python prototype (for reference): triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2[, points4D]) -&gt; points4D","ref":"Evision.html#triangulatePoints/4","title":"Evision.triangulatePoints/4","type":"function"},{"doc":"This function reconstructs 3-dimensional points (in homogeneous coordinates) by using their observations with a stereo camera. Positional Arguments projMatr1 : Evision.Mat . 3x4 projection matrix of the first camera, i.e. this matrix projects 3D points given in the world's coordinate system into the first image. projMatr2 : Evision.Mat . 3x4 projection matrix of the second camera, i.e. this matrix projects 3D points given in the world's coordinate system into the second image. projPoints1 : Evision.Mat . 2xN array of feature points in the first image. In the case of the c++ version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1. projPoints2 : Evision.Mat . 2xN array of corresponding points in the second image. In the case of the c++ version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1. Return points4D : Evision.Mat . 4xN array of reconstructed points in homogeneous coordinates. These points are returned in the world's coordinate system. Note : Keep in mind that all input data should be of float type in order for this function to work. Note : If the projection matrices from @ref stereoRectify are used, then the returned points are represented in the first camera's rectified coordinate system. @sa reprojectImageTo3D Python prototype (for reference): triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2[, points4D]) -&gt; points4D","ref":"Evision.html#triangulatePoints/5","title":"Evision.triangulatePoints/5","type":"function"},{"doc":"Raising version of undistort/3 .","ref":"Evision.html#undistort!/3","title":"Evision.undistort!/3","type":"function"},{"doc":"Raising version of undistort/4 .","ref":"Evision.html#undistort!/4","title":"Evision.undistort!/4","type":"function"},{"doc":"Transforms an image to compensate for lens distortion. Positional Arguments src : Evision.Mat . Input (distorted) image. cameraMatrix : Evision.Mat . Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments newCameraMatrix : Evision.Mat . Camera matrix of the distorted image. By default, it is the same as cameraMatrix but you may additionally scale and shift the result by using a different matrix. Return dst : Evision.Mat . Output (corrected) image that has the same size and type as src . The function transforms an image to compensate radial and tangential lens distortion. The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap (with bilinear interpolation). See the former function for details of the transformation being performed. Those pixels in the destination image, for which there is no correspondent pixels in the source image, are filled with zeros (black color). A particular subset of the source image that will be visible in the corrected image can be regulated by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate newCameraMatrix depending on your requirements. The camera matrix and the distortion parameters can be determined using #calibrateCamera. If the resolution of images is different from the resolution used at the calibration stage, \\f$f_x, f_y, c_x\\f$ and \\f$c_y\\f$ need to be scaled accordingly, while the distortion coefficients remain the same. Python prototype (for reference): undistort(src, cameraMatrix, distCoeffs[, dst[, newCameraMatrix]]) -&gt; dst","ref":"Evision.html#undistort/3","title":"Evision.undistort/3","type":"function"},{"doc":"Transforms an image to compensate for lens distortion. Positional Arguments src : Evision.Mat . Input (distorted) image. cameraMatrix : Evision.Mat . Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments newCameraMatrix : Evision.Mat . Camera matrix of the distorted image. By default, it is the same as cameraMatrix but you may additionally scale and shift the result by using a different matrix. Return dst : Evision.Mat . Output (corrected) image that has the same size and type as src . The function transforms an image to compensate radial and tangential lens distortion. The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap (with bilinear interpolation). See the former function for details of the transformation being performed. Those pixels in the destination image, for which there is no correspondent pixels in the source image, are filled with zeros (black color). A particular subset of the source image that will be visible in the corrected image can be regulated by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate newCameraMatrix depending on your requirements. The camera matrix and the distortion parameters can be determined using #calibrateCamera. If the resolution of images is different from the resolution used at the calibration stage, \\f$f_x, f_y, c_x\\f$ and \\f$c_y\\f$ need to be scaled accordingly, while the distortion coefficients remain the same. Python prototype (for reference): undistort(src, cameraMatrix, distCoeffs[, dst[, newCameraMatrix]]) -&gt; dst","ref":"Evision.html#undistort/4","title":"Evision.undistort/4","type":"function"},{"doc":"Raising version of undistortImagePoints/3 .","ref":"Evision.html#undistortImagePoints!/3","title":"Evision.undistortImagePoints!/3","type":"function"},{"doc":"Raising version of undistortImagePoints/4 .","ref":"Evision.html#undistortImagePoints!/4","title":"Evision.undistortImagePoints!/4","type":"function"},{"doc":"Compute undistorted image points position Positional Arguments src : Evision.Mat . Observed points position, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or vector\\&lt;Point2f&gt; ). cameraMatrix : Evision.Mat . Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Distortion coefficients Keyword Arguments arg1 : TermCriteria . Return dst : Evision.Mat . Output undistorted points position (1xN/Nx1 2-channel or vector\\&lt;Point2f&gt; ). Python prototype (for reference): undistortImagePoints(src, cameraMatrix, distCoeffs[, dst[, arg1]]) -&gt; dst","ref":"Evision.html#undistortImagePoints/3","title":"Evision.undistortImagePoints/3","type":"function"},{"doc":"Compute undistorted image points position Positional Arguments src : Evision.Mat . Observed points position, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or vector\\&lt;Point2f&gt; ). cameraMatrix : Evision.Mat . Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Distortion coefficients Keyword Arguments arg1 : TermCriteria . Return dst : Evision.Mat . Output undistorted points position (1xN/Nx1 2-channel or vector\\&lt;Point2f&gt; ). Python prototype (for reference): undistortImagePoints(src, cameraMatrix, distCoeffs[, dst[, arg1]]) -&gt; dst","ref":"Evision.html#undistortImagePoints/4","title":"Evision.undistortImagePoints/4","type":"function"},{"doc":"Raising version of undistortPoints/3 .","ref":"Evision.html#undistortPoints!/3","title":"Evision.undistortPoints!/3","type":"function"},{"doc":"Raising version of undistortPoints/4 .","ref":"Evision.html#undistortPoints!/4","title":"Evision.undistortPoints!/4","type":"function"},{"doc":"Computes the ideal point coordinates from the observed point coordinates. Positional Arguments src : Evision.Mat . Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or vector\\&lt;Point2f&gt; ). cameraMatrix : Evision.Mat . Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments r : Evision.Mat . Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used. p : Evision.Mat . New camera matrix (3x3) or new projection matrix (3x4) \\f$\\begin{bmatrix} {f'}_x &amp; 0 &amp; {c'}_x &amp; t_x \\\\ 0 &amp; {f'}_y &amp; {c'}_y &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\end{bmatrix}\\f$. P1 or P2 computed by #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used. Return dst : Evision.Mat . Output ideal point coordinates (1xN/Nx1 2-channel or vector\\&lt;Point2f&gt; ) after undistortion and reverse perspective transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates. The function is similar to #undistort and #initUndistortRectifyMap but it operates on a sparse set of points instead of a raster image. Also the function performs a reverse transformation to #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a planar object, it does, up to a translation vector, if the proper R is specified. For each observed point coordinate \\f$(u, v)\\f$ the function computes: \\f[ \\begin{array}{l} x^{&quot;} \\leftarrow (u - c_x)/f_x \\\\ y^{&quot;} \\leftarrow (v - c_y)/f_y \\\\ (x',y') = undistort(x^{&quot;},y^{&quot;}, \\texttt{distCoeffs}) \\\\ {[X\\,Y\\,W]} ^T \\leftarrow R*[x' \\, y' \\, 1]^T \\\\ x \\leftarrow X/W \\\\ y \\leftarrow Y/W \\\\ \\text{only performed if P is specified:} \\\\ u' \\leftarrow x {f'}_x + {c'}_x \\\\ v' \\leftarrow y {f'}_y + {c'}_y \\end{array} \\f] where undistort is an approximate iterative algorithm that estimates the normalized original point coordinates out of the normalized distorted point coordinates (&quot;normalized&quot; means that the coordinates do not depend on the camera matrix). The function can be used for both a stereo camera head or a monocular camera (when R is empty). Python prototype (for reference): undistortPoints(src, cameraMatrix, distCoeffs[, dst[, R[, P]]]) -&gt; dst","ref":"Evision.html#undistortPoints/3","title":"Evision.undistortPoints/3","type":"function"},{"doc":"Computes the ideal point coordinates from the observed point coordinates. Positional Arguments src : Evision.Mat . Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or vector\\&lt;Point2f&gt; ). cameraMatrix : Evision.Mat . Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . distCoeffs : Evision.Mat . Input vector of distortion coefficients \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed. Keyword Arguments r : Evision.Mat . Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used. p : Evision.Mat . New camera matrix (3x3) or new projection matrix (3x4) \\f$\\begin{bmatrix} {f'}_x &amp; 0 &amp; {c'}_x &amp; t_x \\\\ 0 &amp; {f'}_y &amp; {c'}_y &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\end{bmatrix}\\f$. P1 or P2 computed by #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used. Return dst : Evision.Mat . Output ideal point coordinates (1xN/Nx1 2-channel or vector\\&lt;Point2f&gt; ) after undistortion and reverse perspective transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates. The function is similar to #undistort and #initUndistortRectifyMap but it operates on a sparse set of points instead of a raster image. Also the function performs a reverse transformation to #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a planar object, it does, up to a translation vector, if the proper R is specified. For each observed point coordinate \\f$(u, v)\\f$ the function computes: \\f[ \\begin{array}{l} x^{&quot;} \\leftarrow (u - c_x)/f_x \\\\ y^{&quot;} \\leftarrow (v - c_y)/f_y \\\\ (x',y') = undistort(x^{&quot;},y^{&quot;}, \\texttt{distCoeffs}) \\\\ {[X\\,Y\\,W]} ^T \\leftarrow R*[x' \\, y' \\, 1]^T \\\\ x \\leftarrow X/W \\\\ y \\leftarrow Y/W \\\\ \\text{only performed if P is specified:} \\\\ u' \\leftarrow x {f'}_x + {c'}_x \\\\ v' \\leftarrow y {f'}_y + {c'}_y \\end{array} \\f] where undistort is an approximate iterative algorithm that estimates the normalized original point coordinates out of the normalized distorted point coordinates (&quot;normalized&quot; means that the coordinates do not depend on the camera matrix). The function can be used for both a stereo camera head or a monocular camera (when R is empty). Python prototype (for reference): undistortPoints(src, cameraMatrix, distCoeffs[, dst[, R[, P]]]) -&gt; dst","ref":"Evision.html#undistortPoints/4","title":"Evision.undistortPoints/4","type":"function"},{"doc":"Raising version of undistortPointsIter/6 .","ref":"Evision.html#undistortPointsIter!/6","title":"Evision.undistortPointsIter!/6","type":"function"},{"doc":"Raising version of undistortPointsIter/7 .","ref":"Evision.html#undistortPointsIter!/7","title":"Evision.undistortPointsIter!/7","type":"function"},{"doc":"Positional Arguments src : Evision.Mat cameraMatrix : Evision.Mat distCoeffs : Evision.Mat r : Evision.Mat p : Evision.Mat criteria : TermCriteria Return dst : Evision.Mat . Has overloading in C++ Note : Default version of #undistortPoints does 5 iterations to compute undistorted points. Python prototype (for reference): undistortPointsIter(src, cameraMatrix, distCoeffs, R, P, criteria[, dst]) -&gt; dst","ref":"Evision.html#undistortPointsIter/6","title":"Evision.undistortPointsIter/6","type":"function"},{"doc":"Positional Arguments src : Evision.Mat cameraMatrix : Evision.Mat distCoeffs : Evision.Mat r : Evision.Mat p : Evision.Mat criteria : TermCriteria Return dst : Evision.Mat . Has overloading in C++ Note : Default version of #undistortPoints does 5 iterations to compute undistorted points. Python prototype (for reference): undistortPointsIter(src, cameraMatrix, distCoeffs, R, P, criteria[, dst]) -&gt; dst","ref":"Evision.html#undistortPointsIter/7","title":"Evision.undistortPointsIter/7","type":"function"},{"doc":"Raising version of useOpenVX/0 .","ref":"Evision.html#useOpenVX!/0","title":"Evision.useOpenVX!/0","type":"function"},{"doc":"Python prototype (for reference): useOpenVX() -&gt; retval","ref":"Evision.html#useOpenVX/0","title":"Evision.useOpenVX/0","type":"function"},{"doc":"Raising version of useOptimized/0 .","ref":"Evision.html#useOptimized!/0","title":"Evision.useOptimized!/0","type":"function"},{"doc":"Returns the status of optimized code usage. The function returns true if the optimized code is enabled. Otherwise, it returns false. Python prototype (for reference): useOptimized() -&gt; retval","ref":"Evision.html#useOptimized/0","title":"Evision.useOptimized/0","type":"function"},{"doc":"Raising version of validateDisparity/4 .","ref":"Evision.html#validateDisparity!/4","title":"Evision.validateDisparity!/4","type":"function"},{"doc":"Raising version of validateDisparity/5 .","ref":"Evision.html#validateDisparity!/5","title":"Evision.validateDisparity!/5","type":"function"},{"doc":"Positional Arguments cost : Evision.Mat minDisparity : int numberOfDisparities : int Keyword Arguments disp12MaxDisp : int . Return disparity : Evision.Mat Python prototype (for reference): validateDisparity(disparity, cost, minDisparity, numberOfDisparities[, disp12MaxDisp]) -&gt; disparity","ref":"Evision.html#validateDisparity/4","title":"Evision.validateDisparity/4","type":"function"},{"doc":"Positional Arguments cost : Evision.Mat minDisparity : int numberOfDisparities : int Keyword Arguments disp12MaxDisp : int . Return disparity : Evision.Mat Python prototype (for reference): validateDisparity(disparity, cost, minDisparity, numberOfDisparities[, disp12MaxDisp]) -&gt; disparity","ref":"Evision.html#validateDisparity/5","title":"Evision.validateDisparity/5","type":"function"},{"doc":"Raising version of vconcat/1 .","ref":"Evision.html#vconcat!/1","title":"Evision.vconcat!/1","type":"function"},{"doc":"Raising version of vconcat/2 .","ref":"Evision.html#vconcat!/2","title":"Evision.vconcat!/2","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] . input array or vector of matrices. all of the matrices must have the same number of cols and the same depth Return dst : Evision.Mat . output array. It has the same number of cols and depth as the src, and the sum of rows of the src. same depth. Has overloading in C++ std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),}; cv::Mat out; cv::vconcat( matrices, out ); //out: //[1, 1, 1, 1; // 2, 2, 2, 2; // 3, 3, 3, 3] Python prototype (for reference): vconcat(src[, dst]) -&gt; dst","ref":"Evision.html#vconcat/1","title":"Evision.vconcat/1","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] . input array or vector of matrices. all of the matrices must have the same number of cols and the same depth Return dst : Evision.Mat . output array. It has the same number of cols and depth as the src, and the sum of rows of the src. same depth. Has overloading in C++ std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),}; cv::Mat out; cv::vconcat( matrices, out ); //out: //[1, 1, 1, 1; // 2, 2, 2, 2; // 3, 3, 3, 3] Python prototype (for reference): vconcat(src[, dst]) -&gt; dst","ref":"Evision.html#vconcat/2","title":"Evision.vconcat/2","type":"function"},{"doc":"Raising version of waitKeyEx/0 .","ref":"Evision.html#waitKeyEx!/0","title":"Evision.waitKeyEx!/0","type":"function"},{"doc":"Raising version of waitKeyEx/1 .","ref":"Evision.html#waitKeyEx!/1","title":"Evision.waitKeyEx!/1","type":"function"},{"doc":"Similar to #waitKey, but returns full key code. Keyword Arguments delay : int . Note : Key code is implementation specific and depends on used backend: QT/GTK/Win32/etc Python prototype (for reference): waitKeyEx([, delay]) -&gt; retval","ref":"Evision.html#waitKeyEx/0","title":"Evision.waitKeyEx/0","type":"function"},{"doc":"Similar to #waitKey, but returns full key code. Keyword Arguments delay : int . Note : Key code is implementation specific and depends on used backend: QT/GTK/Win32/etc Python prototype (for reference): waitKeyEx([, delay]) -&gt; retval","ref":"Evision.html#waitKeyEx/1","title":"Evision.waitKeyEx/1","type":"function"},{"doc":"Raising version of warpAffine/3 .","ref":"Evision.html#warpAffine!/3","title":"Evision.warpAffine!/3","type":"function"},{"doc":"Raising version of warpAffine/4 .","ref":"Evision.html#warpAffine!/4","title":"Evision.warpAffine!/4","type":"function"},{"doc":"Applies an affine transformation to an image. Positional Arguments src : Evision.Mat . input image. m : Evision.Mat . \\f$2\\times 3\\f$ transformation matrix. dsize : Size . size of the output image. Keyword Arguments flags : int . combination of interpolation methods (see #InterpolationFlags) and the optional flag #WARP_INVERSE_MAP that means that M is the inverse transformation ( \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ). borderMode : int . pixel extrapolation method (see #BorderTypes); when borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the &quot;outliers&quot; in the source image are not modified by the function. borderValue : Scalar . value used in case of a constant border; by default, it is 0. Return dst : Evision.Mat . output image that has the size dsize and the same type as src . The function warpAffine transforms the source image using the specified matrix: \\f[\\texttt{dst} (x,y) = \\texttt{src} ( \\texttt{M} _{11} x + \\texttt{M} _{12} y + \\texttt{M} _{13}, \\texttt{M} _{21} x + \\texttt{M} _{22} y + \\texttt{M} _{23})\\f] when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with #invertAffineTransform and then put in the formula above instead of M. The function cannot operate in-place. @sa warpPerspective, resize, remap, getRectSubPix, transform Python prototype (for reference): warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -&gt; dst","ref":"Evision.html#warpAffine/3","title":"Evision.warpAffine/3","type":"function"},{"doc":"Applies an affine transformation to an image. Positional Arguments src : Evision.Mat . input image. m : Evision.Mat . \\f$2\\times 3\\f$ transformation matrix. dsize : Size . size of the output image. Keyword Arguments flags : int . combination of interpolation methods (see #InterpolationFlags) and the optional flag #WARP_INVERSE_MAP that means that M is the inverse transformation ( \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ). borderMode : int . pixel extrapolation method (see #BorderTypes); when borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the &quot;outliers&quot; in the source image are not modified by the function. borderValue : Scalar . value used in case of a constant border; by default, it is 0. Return dst : Evision.Mat . output image that has the size dsize and the same type as src . The function warpAffine transforms the source image using the specified matrix: \\f[\\texttt{dst} (x,y) = \\texttt{src} ( \\texttt{M} _{11} x + \\texttt{M} _{12} y + \\texttt{M} _{13}, \\texttt{M} _{21} x + \\texttt{M} _{22} y + \\texttt{M} _{23})\\f] when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with #invertAffineTransform and then put in the formula above instead of M. The function cannot operate in-place. @sa warpPerspective, resize, remap, getRectSubPix, transform Python prototype (for reference): warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -&gt; dst","ref":"Evision.html#warpAffine/4","title":"Evision.warpAffine/4","type":"function"},{"doc":"Raising version of warpPerspective/3 .","ref":"Evision.html#warpPerspective!/3","title":"Evision.warpPerspective!/3","type":"function"},{"doc":"Raising version of warpPerspective/4 .","ref":"Evision.html#warpPerspective!/4","title":"Evision.warpPerspective!/4","type":"function"},{"doc":"Applies a perspective transformation to an image. Positional Arguments src : Evision.Mat . input image. m : Evision.Mat . \\f$3\\times 3\\f$ transformation matrix. dsize : Size . size of the output image. Keyword Arguments flags : int . combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation ( \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ). borderMode : int . pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE). borderValue : Scalar . value used in case of a constant border; by default, it equals 0. Return dst : Evision.Mat . output image that has the size dsize and the same type as src . The function warpPerspective transforms the source image using the specified matrix: \\f[\\texttt{dst} (x,y) = \\texttt{src} \\left ( \\frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \\right )\\f] when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place. @sa warpAffine, resize, remap, getRectSubPix, perspectiveTransform Python prototype (for reference): warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -&gt; dst","ref":"Evision.html#warpPerspective/3","title":"Evision.warpPerspective/3","type":"function"},{"doc":"Applies a perspective transformation to an image. Positional Arguments src : Evision.Mat . input image. m : Evision.Mat . \\f$3\\times 3\\f$ transformation matrix. dsize : Size . size of the output image. Keyword Arguments flags : int . combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation ( \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ). borderMode : int . pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE). borderValue : Scalar . value used in case of a constant border; by default, it equals 0. Return dst : Evision.Mat . output image that has the size dsize and the same type as src . The function warpPerspective transforms the source image using the specified matrix: \\f[\\texttt{dst} (x,y) = \\texttt{src} \\left ( \\frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \\right )\\f] when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place. @sa warpAffine, resize, remap, getRectSubPix, perspectiveTransform Python prototype (for reference): warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -&gt; dst","ref":"Evision.html#warpPerspective/4","title":"Evision.warpPerspective/4","type":"function"},{"doc":"Raising version of warpPolar/5 .","ref":"Evision.html#warpPolar!/5","title":"Evision.warpPolar!/5","type":"function"},{"doc":"Raising version of warpPolar/6 .","ref":"Evision.html#warpPolar!/6","title":"Evision.warpPolar!/6","type":"function"},{"doc":"Positional Arguments src : Evision.Mat . Source image. dsize : Size . The destination image size (see description for valid options). center : Point2f . The transformation center. maxRadius : double . The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too. flags : int . A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode. Add #WARP_POLAR_LINEAR to select linear polar mapping (default) Add #WARP_POLAR_LOG to select semilog polar mapping Add #WARP_INVERSE_MAP for reverse mapping. Return dst : Evision.Mat . Destination image. It will have same type as src. \\brief Remaps an image to polar or semilog-polar coordinates space @anchor polar_remaps_reference_image Transform the source image using the following transformation: \\f[ dst(\\rho , \\phi ) = src(x,y) \\f] where \\f[ \\begin{array}{l} \\vec{I} = (x - center.x, \\;y - center.y) \\\\ \\phi = Kangle \\cdot \\texttt{angle} (\\vec{I}) \\\\ \\rho = \\left\\{\\begin{matrix} Klin \\cdot \\texttt{magnitude} (\\vec{I}) &amp; default \\\\ Klog \\cdot log_e(\\texttt{magnitude} (\\vec{I})) &amp; if \\; semilog \\\\ \\end{matrix}\\right. \\end{array} \\f] and \\f[ \\begin{array}{l} Kangle = dsize.height / 2\\Pi \\\\ Klin = dsize.width / maxRadius \\\\ Klog = dsize.width / log_e(maxRadius) \\\\ \\end{array} \\f] \\par Linear vs semilog mapping Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to flags to specify the polar mapping mode. Linear is the default mode. The semilog mapping emulates the human &quot;foveal&quot; vision that permit very high acuity on the line of sight (central vision) in contrast to peripheral vision where acuity is minor. \\par Option on dsize : if both values in dsize &lt;=0 (default), the destination image will have (almost) same area of source bounding circle: \\f[\\begin{array}{l} dsize.area \\leftarrow (maxRadius^2 \\cdot \\Pi) \\\\ dsize.width = \\texttt{cvRound}(maxRadius) \\\\ dsize.height = \\texttt{cvRound}(maxRadius \\cdot \\Pi) \\\\ \\end{array}\\f] if only dsize.height &lt;= 0 , the destination image area will be proportional to the bounding circle area but scaled by Kx * Kx : \\f[\\begin{array}{l} dsize.height = \\texttt{cvRound}(dsize.width \\cdot \\Pi) \\\\ \\end{array} \\f] if both values in dsize &gt; 0 , the destination image will have the given size therefore the area of the bounding circle will be scaled to dsize . \\par Reverse mapping You can get reverse mapping adding #WARP_INVERSE_MAP to flags \\snippet polar_transforms.cpp InverseMap In addiction, to calculate the original coordinate from a polar mapped coordinate \\f$(rho, phi)-&gt;(x, y)\\f$: \\snippet polar_transforms.cpp InverseCoordinate Note : The function can not operate in-place. To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees. This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767. @sa cv::remap Python prototype (for reference): warpPolar(src, dsize, center, maxRadius, flags[, dst]) -&gt; dst","ref":"Evision.html#warpPolar/5","title":"Evision.warpPolar/5","type":"function"},{"doc":"Positional Arguments src : Evision.Mat . Source image. dsize : Size . The destination image size (see description for valid options). center : Point2f . The transformation center. maxRadius : double . The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too. flags : int . A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode. Add #WARP_POLAR_LINEAR to select linear polar mapping (default) Add #WARP_POLAR_LOG to select semilog polar mapping Add #WARP_INVERSE_MAP for reverse mapping. Return dst : Evision.Mat . Destination image. It will have same type as src. \\brief Remaps an image to polar or semilog-polar coordinates space @anchor polar_remaps_reference_image Transform the source image using the following transformation: \\f[ dst(\\rho , \\phi ) = src(x,y) \\f] where \\f[ \\begin{array}{l} \\vec{I} = (x - center.x, \\;y - center.y) \\\\ \\phi = Kangle \\cdot \\texttt{angle} (\\vec{I}) \\\\ \\rho = \\left\\{\\begin{matrix} Klin \\cdot \\texttt{magnitude} (\\vec{I}) &amp; default \\\\ Klog \\cdot log_e(\\texttt{magnitude} (\\vec{I})) &amp; if \\; semilog \\\\ \\end{matrix}\\right. \\end{array} \\f] and \\f[ \\begin{array}{l} Kangle = dsize.height / 2\\Pi \\\\ Klin = dsize.width / maxRadius \\\\ Klog = dsize.width / log_e(maxRadius) \\\\ \\end{array} \\f] \\par Linear vs semilog mapping Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to flags to specify the polar mapping mode. Linear is the default mode. The semilog mapping emulates the human &quot;foveal&quot; vision that permit very high acuity on the line of sight (central vision) in contrast to peripheral vision where acuity is minor. \\par Option on dsize : if both values in dsize &lt;=0 (default), the destination image will have (almost) same area of source bounding circle: \\f[\\begin{array}{l} dsize.area \\leftarrow (maxRadius^2 \\cdot \\Pi) \\\\ dsize.width = \\texttt{cvRound}(maxRadius) \\\\ dsize.height = \\texttt{cvRound}(maxRadius \\cdot \\Pi) \\\\ \\end{array}\\f] if only dsize.height &lt;= 0 , the destination image area will be proportional to the bounding circle area but scaled by Kx * Kx : \\f[\\begin{array}{l} dsize.height = \\texttt{cvRound}(dsize.width \\cdot \\Pi) \\\\ \\end{array} \\f] if both values in dsize &gt; 0 , the destination image will have the given size therefore the area of the bounding circle will be scaled to dsize . \\par Reverse mapping You can get reverse mapping adding #WARP_INVERSE_MAP to flags \\snippet polar_transforms.cpp InverseMap In addiction, to calculate the original coordinate from a polar mapped coordinate \\f$(rho, phi)-&gt;(x, y)\\f$: \\snippet polar_transforms.cpp InverseCoordinate Note : The function can not operate in-place. To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees. This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767. @sa cv::remap Python prototype (for reference): warpPolar(src, dsize, center, maxRadius, flags[, dst]) -&gt; dst","ref":"Evision.html#warpPolar/6","title":"Evision.warpPolar/6","type":"function"},{"doc":"Raising version of watershed/2 .","ref":"Evision.html#watershed!/2","title":"Evision.watershed!/2","type":"function"},{"doc":"Performs a marker-based image segmentation using the watershed algorithm. Positional Arguments image : Evision.Mat . Input 8-bit 3-channel image. Return markers : Evision.Mat . Input/output 32-bit single-channel image (map) of markers. It should have the same size as image . The function implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in @cite Meyer92 . Before passing the image to the function, you have to roughly outline the desired regions in the image markers with positive (&gt;0) indices. So, every region is represented as one or more connected components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary mask using #findContours and #drawContours (see the watershed.cpp demo). The markers are &quot;seeds&quot; of the future image regions. All the other pixels in markers , whose relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. In the function output, each pixel in markers is set to a value of the &quot;seed&quot; components or to -1 at boundaries between the regions. Note : Any two neighbor connected components are not necessarily separated by a watershed boundary (-1's pixels); for example, they can touch each other in the initial marker image passed to the function. @sa findContours Python prototype (for reference): watershed(image, markers) -&gt; markers","ref":"Evision.html#watershed/2","title":"Evision.watershed/2","type":"function"},{"doc":"Raising version of writeOpticalFlow/2 .","ref":"Evision.html#writeOpticalFlow!/2","title":"Evision.writeOpticalFlow!/2","type":"function"},{"doc":"Write a .flo to disk Positional Arguments path : String . Path to the file to be written flow : Evision.Mat . Flow field to be stored The function stores a flow field in a file, returns true on success, false otherwise. The flow field must be a 2-channel, floating-point matrix (CV_32FC2). First channel corresponds to the flow in the horizontal direction (u), second - vertical (v). Python prototype (for reference): writeOpticalFlow(path, flow) -&gt; retval","ref":"Evision.html#writeOpticalFlow/2","title":"Evision.writeOpticalFlow/2","type":"function"},{"doc":"","ref":"Evision.AKAZE.html","title":"Evision.AKAZE","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.AKAZE.html#compute!/3","title":"Evision.AKAZE.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.AKAZE.html#compute!/4","title":"Evision.AKAZE.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.AKAZE.html#compute/3","title":"Evision.AKAZE.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.AKAZE.html#compute/4","title":"Evision.AKAZE.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.AKAZE.html#create!/0","title":"Evision.AKAZE.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.AKAZE.html#create!/1","title":"Evision.AKAZE.create!/1","type":"function"},{"doc":"The AKAZE constructor Keyword Arguments descriptor_type : AKAZE_DescriptorType . Type of the extracted descriptor: DESCRIPTOR_KAZE, DESCRIPTOR_KAZE_UPRIGHT, DESCRIPTOR_MLDB or DESCRIPTOR_MLDB_UPRIGHT. descriptor_size : int . Size of the descriptor in bits. 0 -&gt; Full size descriptor_channels : int . Number of channels in the descriptor (1, 2, 3) threshold : float . Detector response threshold to accept point nOctaves : int . Maximum octave evolution of the image nOctaveLayers : int . Default number of sublevels per scale level diffusivity : KAZE_DiffusivityType . Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or DIFF_CHARBONNIER Python prototype (for reference): create([, descriptor_type[, descriptor_size[, descriptor_channels[, threshold[, nOctaves[, nOctaveLayers[, diffusivity]]]]]]]) -&gt; retval","ref":"Evision.AKAZE.html#create/0","title":"Evision.AKAZE.create/0","type":"function"},{"doc":"The AKAZE constructor Keyword Arguments descriptor_type : AKAZE_DescriptorType . Type of the extracted descriptor: DESCRIPTOR_KAZE, DESCRIPTOR_KAZE_UPRIGHT, DESCRIPTOR_MLDB or DESCRIPTOR_MLDB_UPRIGHT. descriptor_size : int . Size of the descriptor in bits. 0 -&gt; Full size descriptor_channels : int . Number of channels in the descriptor (1, 2, 3) threshold : float . Detector response threshold to accept point nOctaves : int . Maximum octave evolution of the image nOctaveLayers : int . Default number of sublevels per scale level diffusivity : KAZE_DiffusivityType . Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or DIFF_CHARBONNIER Python prototype (for reference): create([, descriptor_type[, descriptor_size[, descriptor_channels[, threshold[, nOctaves[, nOctaveLayers[, diffusivity]]]]]]]) -&gt; retval","ref":"Evision.AKAZE.html#create/1","title":"Evision.AKAZE.create/1","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.AKAZE.html#defaultNorm!/1","title":"Evision.AKAZE.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.AKAZE.html#defaultNorm/1","title":"Evision.AKAZE.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.AKAZE.html#descriptorSize!/1","title":"Evision.AKAZE.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.AKAZE.html#descriptorSize/1","title":"Evision.AKAZE.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.AKAZE.html#descriptorType!/1","title":"Evision.AKAZE.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.AKAZE.html#descriptorType/1","title":"Evision.AKAZE.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.AKAZE.html#detect!/2","title":"Evision.AKAZE.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.AKAZE.html#detect!/3","title":"Evision.AKAZE.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.AKAZE.html#detect/2","title":"Evision.AKAZE.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.AKAZE.html#detect/3","title":"Evision.AKAZE.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.AKAZE.html#detectAndCompute!/3","title":"Evision.AKAZE.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.AKAZE.html#detectAndCompute!/4","title":"Evision.AKAZE.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.AKAZE.html#detectAndCompute/3","title":"Evision.AKAZE.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.AKAZE.html#detectAndCompute/4","title":"Evision.AKAZE.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.AKAZE.html#empty!/1","title":"Evision.AKAZE.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.AKAZE.html#empty/1","title":"Evision.AKAZE.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.AKAZE.html#getDefaultName!/1","title":"Evision.AKAZE.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.AKAZE.html#getDefaultName/1","title":"Evision.AKAZE.getDefaultName/1","type":"function"},{"doc":"Raising version of getDescriptorChannels/1 .","ref":"Evision.AKAZE.html#getDescriptorChannels!/1","title":"Evision.AKAZE.getDescriptorChannels!/1","type":"function"},{"doc":"Python prototype (for reference): getDescriptorChannels() -&gt; retval","ref":"Evision.AKAZE.html#getDescriptorChannels/1","title":"Evision.AKAZE.getDescriptorChannels/1","type":"function"},{"doc":"Raising version of getDescriptorSize/1 .","ref":"Evision.AKAZE.html#getDescriptorSize!/1","title":"Evision.AKAZE.getDescriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): getDescriptorSize() -&gt; retval","ref":"Evision.AKAZE.html#getDescriptorSize/1","title":"Evision.AKAZE.getDescriptorSize/1","type":"function"},{"doc":"Raising version of getDescriptorType/1 .","ref":"Evision.AKAZE.html#getDescriptorType!/1","title":"Evision.AKAZE.getDescriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): getDescriptorType() -&gt; retval","ref":"Evision.AKAZE.html#getDescriptorType/1","title":"Evision.AKAZE.getDescriptorType/1","type":"function"},{"doc":"Raising version of getDiffusivity/1 .","ref":"Evision.AKAZE.html#getDiffusivity!/1","title":"Evision.AKAZE.getDiffusivity!/1","type":"function"},{"doc":"Python prototype (for reference): getDiffusivity() -&gt; retval","ref":"Evision.AKAZE.html#getDiffusivity/1","title":"Evision.AKAZE.getDiffusivity/1","type":"function"},{"doc":"Raising version of getNOctaveLayers/1 .","ref":"Evision.AKAZE.html#getNOctaveLayers!/1","title":"Evision.AKAZE.getNOctaveLayers!/1","type":"function"},{"doc":"Python prototype (for reference): getNOctaveLayers() -&gt; retval","ref":"Evision.AKAZE.html#getNOctaveLayers/1","title":"Evision.AKAZE.getNOctaveLayers/1","type":"function"},{"doc":"Raising version of getNOctaves/1 .","ref":"Evision.AKAZE.html#getNOctaves!/1","title":"Evision.AKAZE.getNOctaves!/1","type":"function"},{"doc":"Python prototype (for reference): getNOctaves() -&gt; retval","ref":"Evision.AKAZE.html#getNOctaves/1","title":"Evision.AKAZE.getNOctaves/1","type":"function"},{"doc":"Raising version of getThreshold/1 .","ref":"Evision.AKAZE.html#getThreshold!/1","title":"Evision.AKAZE.getThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getThreshold() -&gt; retval","ref":"Evision.AKAZE.html#getThreshold/1","title":"Evision.AKAZE.getThreshold/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.AKAZE.html#read!/2","title":"Evision.AKAZE.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.AKAZE.html#read/2","title":"Evision.AKAZE.read/2","type":"function"},{"doc":"Raising version of setDescriptorChannels/2 .","ref":"Evision.AKAZE.html#setDescriptorChannels!/2","title":"Evision.AKAZE.setDescriptorChannels!/2","type":"function"},{"doc":"Positional Arguments dch : int Python prototype (for reference): setDescriptorChannels(dch) -&gt; None","ref":"Evision.AKAZE.html#setDescriptorChannels/2","title":"Evision.AKAZE.setDescriptorChannels/2","type":"function"},{"doc":"Raising version of setDescriptorSize/2 .","ref":"Evision.AKAZE.html#setDescriptorSize!/2","title":"Evision.AKAZE.setDescriptorSize!/2","type":"function"},{"doc":"Positional Arguments dsize : int Python prototype (for reference): setDescriptorSize(dsize) -&gt; None","ref":"Evision.AKAZE.html#setDescriptorSize/2","title":"Evision.AKAZE.setDescriptorSize/2","type":"function"},{"doc":"Raising version of setDescriptorType/2 .","ref":"Evision.AKAZE.html#setDescriptorType!/2","title":"Evision.AKAZE.setDescriptorType!/2","type":"function"},{"doc":"Positional Arguments dtype : AKAZE_DescriptorType Python prototype (for reference): setDescriptorType(dtype) -&gt; None","ref":"Evision.AKAZE.html#setDescriptorType/2","title":"Evision.AKAZE.setDescriptorType/2","type":"function"},{"doc":"Raising version of setDiffusivity/2 .","ref":"Evision.AKAZE.html#setDiffusivity!/2","title":"Evision.AKAZE.setDiffusivity!/2","type":"function"},{"doc":"Positional Arguments diff : KAZE_DiffusivityType Python prototype (for reference): setDiffusivity(diff) -&gt; None","ref":"Evision.AKAZE.html#setDiffusivity/2","title":"Evision.AKAZE.setDiffusivity/2","type":"function"},{"doc":"Raising version of setNOctaveLayers/2 .","ref":"Evision.AKAZE.html#setNOctaveLayers!/2","title":"Evision.AKAZE.setNOctaveLayers!/2","type":"function"},{"doc":"Positional Arguments octaveLayers : int Python prototype (for reference): setNOctaveLayers(octaveLayers) -&gt; None","ref":"Evision.AKAZE.html#setNOctaveLayers/2","title":"Evision.AKAZE.setNOctaveLayers/2","type":"function"},{"doc":"Raising version of setNOctaves/2 .","ref":"Evision.AKAZE.html#setNOctaves!/2","title":"Evision.AKAZE.setNOctaves!/2","type":"function"},{"doc":"Positional Arguments octaves : int Python prototype (for reference): setNOctaves(octaves) -&gt; None","ref":"Evision.AKAZE.html#setNOctaves/2","title":"Evision.AKAZE.setNOctaves/2","type":"function"},{"doc":"Raising version of setThreshold/2 .","ref":"Evision.AKAZE.html#setThreshold!/2","title":"Evision.AKAZE.setThreshold!/2","type":"function"},{"doc":"Positional Arguments threshold : double Python prototype (for reference): setThreshold(threshold) -&gt; None","ref":"Evision.AKAZE.html#setThreshold/2","title":"Evision.AKAZE.setThreshold/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.AKAZE.html#write!/2","title":"Evision.AKAZE.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.AKAZE.html#write!/3","title":"Evision.AKAZE.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.AKAZE.html#write/2","title":"Evision.AKAZE.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.AKAZE.html#write/3","title":"Evision.AKAZE.write/3","type":"function"},{"doc":"","ref":"Evision.AffineFeature.html","title":"Evision.AffineFeature","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.AffineFeature.html#compute!/3","title":"Evision.AffineFeature.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.AffineFeature.html#compute!/4","title":"Evision.AffineFeature.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.AffineFeature.html#compute/3","title":"Evision.AffineFeature.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.AffineFeature.html#compute/4","title":"Evision.AffineFeature.compute/4","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.AffineFeature.html#create!/1","title":"Evision.AffineFeature.create!/1","type":"function"},{"doc":"Raising version of create/2 .","ref":"Evision.AffineFeature.html#create!/2","title":"Evision.AffineFeature.create!/2","type":"function"},{"doc":"Positional Arguments backend : Ptr&lt;Feature2D&gt; . The detector/extractor you want to use as backend. Keyword Arguments maxTilt : int . The highest power index of tilt factor. 5 is used in the paper as tilt sampling range n. minTilt : int . The lowest power index of tilt factor. 0 is used in the paper. tiltStep : float . Tilt sampling step \\f$\\delta_t\\f$ in Algorithm 1 in the paper. rotateStepBase : float . Rotation sampling step factor b in Algorithm 1 in the paper. Python prototype (for reference): create(backend[, maxTilt[, minTilt[, tiltStep[, rotateStepBase]]]]) -&gt; retval","ref":"Evision.AffineFeature.html#create/1","title":"Evision.AffineFeature.create/1","type":"function"},{"doc":"Positional Arguments backend : Ptr&lt;Feature2D&gt; . The detector/extractor you want to use as backend. Keyword Arguments maxTilt : int . The highest power index of tilt factor. 5 is used in the paper as tilt sampling range n. minTilt : int . The lowest power index of tilt factor. 0 is used in the paper. tiltStep : float . Tilt sampling step \\f$\\delta_t\\f$ in Algorithm 1 in the paper. rotateStepBase : float . Rotation sampling step factor b in Algorithm 1 in the paper. Python prototype (for reference): create(backend[, maxTilt[, minTilt[, tiltStep[, rotateStepBase]]]]) -&gt; retval","ref":"Evision.AffineFeature.html#create/2","title":"Evision.AffineFeature.create/2","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.AffineFeature.html#defaultNorm!/1","title":"Evision.AffineFeature.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.AffineFeature.html#defaultNorm/1","title":"Evision.AffineFeature.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.AffineFeature.html#descriptorSize!/1","title":"Evision.AffineFeature.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.AffineFeature.html#descriptorSize/1","title":"Evision.AffineFeature.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.AffineFeature.html#descriptorType!/1","title":"Evision.AffineFeature.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.AffineFeature.html#descriptorType/1","title":"Evision.AffineFeature.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.AffineFeature.html#detect!/2","title":"Evision.AffineFeature.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.AffineFeature.html#detect!/3","title":"Evision.AffineFeature.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.AffineFeature.html#detect/2","title":"Evision.AffineFeature.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.AffineFeature.html#detect/3","title":"Evision.AffineFeature.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.AffineFeature.html#detectAndCompute!/3","title":"Evision.AffineFeature.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.AffineFeature.html#detectAndCompute!/4","title":"Evision.AffineFeature.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.AffineFeature.html#detectAndCompute/3","title":"Evision.AffineFeature.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.AffineFeature.html#detectAndCompute/4","title":"Evision.AffineFeature.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.AffineFeature.html#empty!/1","title":"Evision.AffineFeature.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.AffineFeature.html#empty/1","title":"Evision.AffineFeature.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.AffineFeature.html#getDefaultName!/1","title":"Evision.AffineFeature.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.AffineFeature.html#getDefaultName/1","title":"Evision.AffineFeature.getDefaultName/1","type":"function"},{"doc":"Raising version of getViewParams/3 .","ref":"Evision.AffineFeature.html#getViewParams!/3","title":"Evision.AffineFeature.getViewParams!/3","type":"function"},{"doc":"Positional Arguments tilts : [float] rolls : [float] Python prototype (for reference): getViewParams(tilts, rolls) -&gt; None","ref":"Evision.AffineFeature.html#getViewParams/3","title":"Evision.AffineFeature.getViewParams/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.AffineFeature.html#read!/2","title":"Evision.AffineFeature.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.AffineFeature.html#read/2","title":"Evision.AffineFeature.read/2","type":"function"},{"doc":"Raising version of setViewParams/3 .","ref":"Evision.AffineFeature.html#setViewParams!/3","title":"Evision.AffineFeature.setViewParams!/3","type":"function"},{"doc":"Positional Arguments tilts : [float] rolls : [float] Python prototype (for reference): setViewParams(tilts, rolls) -&gt; None","ref":"Evision.AffineFeature.html#setViewParams/3","title":"Evision.AffineFeature.setViewParams/3","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.AffineFeature.html#write!/2","title":"Evision.AffineFeature.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.AffineFeature.html#write!/3","title":"Evision.AffineFeature.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.AffineFeature.html#write/2","title":"Evision.AffineFeature.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.AffineFeature.html#write/3","title":"Evision.AffineFeature.write/3","type":"function"},{"doc":"","ref":"Evision.AgastFeatureDetector.html","title":"Evision.AgastFeatureDetector","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.AgastFeatureDetector.html#compute!/3","title":"Evision.AgastFeatureDetector.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.AgastFeatureDetector.html#compute!/4","title":"Evision.AgastFeatureDetector.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.AgastFeatureDetector.html#compute/3","title":"Evision.AgastFeatureDetector.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.AgastFeatureDetector.html#compute/4","title":"Evision.AgastFeatureDetector.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.AgastFeatureDetector.html#create!/0","title":"Evision.AgastFeatureDetector.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.AgastFeatureDetector.html#create!/1","title":"Evision.AgastFeatureDetector.create!/1","type":"function"},{"doc":"##### Keyword Arguments threshold : int . nonmaxSuppression : bool . type : AgastFeatureDetector_DetectorType . Python prototype (for reference): create([, threshold[, nonmaxSuppression[, type]]]) -&gt; retval","ref":"Evision.AgastFeatureDetector.html#create/0","title":"Evision.AgastFeatureDetector.create/0","type":"function"},{"doc":"##### Keyword Arguments threshold : int . nonmaxSuppression : bool . type : AgastFeatureDetector_DetectorType . Python prototype (for reference): create([, threshold[, nonmaxSuppression[, type]]]) -&gt; retval","ref":"Evision.AgastFeatureDetector.html#create/1","title":"Evision.AgastFeatureDetector.create/1","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.AgastFeatureDetector.html#defaultNorm!/1","title":"Evision.AgastFeatureDetector.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#defaultNorm/1","title":"Evision.AgastFeatureDetector.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.AgastFeatureDetector.html#descriptorSize!/1","title":"Evision.AgastFeatureDetector.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#descriptorSize/1","title":"Evision.AgastFeatureDetector.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.AgastFeatureDetector.html#descriptorType!/1","title":"Evision.AgastFeatureDetector.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#descriptorType/1","title":"Evision.AgastFeatureDetector.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.AgastFeatureDetector.html#detect!/2","title":"Evision.AgastFeatureDetector.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.AgastFeatureDetector.html#detect!/3","title":"Evision.AgastFeatureDetector.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.AgastFeatureDetector.html#detect/2","title":"Evision.AgastFeatureDetector.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.AgastFeatureDetector.html#detect/3","title":"Evision.AgastFeatureDetector.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.AgastFeatureDetector.html#detectAndCompute!/3","title":"Evision.AgastFeatureDetector.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.AgastFeatureDetector.html#detectAndCompute!/4","title":"Evision.AgastFeatureDetector.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.AgastFeatureDetector.html#detectAndCompute/3","title":"Evision.AgastFeatureDetector.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.AgastFeatureDetector.html#detectAndCompute/4","title":"Evision.AgastFeatureDetector.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.AgastFeatureDetector.html#empty!/1","title":"Evision.AgastFeatureDetector.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#empty/1","title":"Evision.AgastFeatureDetector.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.AgastFeatureDetector.html#getDefaultName!/1","title":"Evision.AgastFeatureDetector.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#getDefaultName/1","title":"Evision.AgastFeatureDetector.getDefaultName/1","type":"function"},{"doc":"Raising version of getNonmaxSuppression/1 .","ref":"Evision.AgastFeatureDetector.html#getNonmaxSuppression!/1","title":"Evision.AgastFeatureDetector.getNonmaxSuppression!/1","type":"function"},{"doc":"Python prototype (for reference): getNonmaxSuppression() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#getNonmaxSuppression/1","title":"Evision.AgastFeatureDetector.getNonmaxSuppression/1","type":"function"},{"doc":"Raising version of getThreshold/1 .","ref":"Evision.AgastFeatureDetector.html#getThreshold!/1","title":"Evision.AgastFeatureDetector.getThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getThreshold() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#getThreshold/1","title":"Evision.AgastFeatureDetector.getThreshold/1","type":"function"},{"doc":"Raising version of getType/1 .","ref":"Evision.AgastFeatureDetector.html#getType!/1","title":"Evision.AgastFeatureDetector.getType!/1","type":"function"},{"doc":"Python prototype (for reference): getType() -&gt; retval","ref":"Evision.AgastFeatureDetector.html#getType/1","title":"Evision.AgastFeatureDetector.getType/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.AgastFeatureDetector.html#read!/2","title":"Evision.AgastFeatureDetector.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.AgastFeatureDetector.html#read/2","title":"Evision.AgastFeatureDetector.read/2","type":"function"},{"doc":"Raising version of setNonmaxSuppression/2 .","ref":"Evision.AgastFeatureDetector.html#setNonmaxSuppression!/2","title":"Evision.AgastFeatureDetector.setNonmaxSuppression!/2","type":"function"},{"doc":"Positional Arguments f : bool Python prototype (for reference): setNonmaxSuppression(f) -&gt; None","ref":"Evision.AgastFeatureDetector.html#setNonmaxSuppression/2","title":"Evision.AgastFeatureDetector.setNonmaxSuppression/2","type":"function"},{"doc":"Raising version of setThreshold/2 .","ref":"Evision.AgastFeatureDetector.html#setThreshold!/2","title":"Evision.AgastFeatureDetector.setThreshold!/2","type":"function"},{"doc":"Positional Arguments threshold : int Python prototype (for reference): setThreshold(threshold) -&gt; None","ref":"Evision.AgastFeatureDetector.html#setThreshold/2","title":"Evision.AgastFeatureDetector.setThreshold/2","type":"function"},{"doc":"Raising version of setType/2 .","ref":"Evision.AgastFeatureDetector.html#setType!/2","title":"Evision.AgastFeatureDetector.setType!/2","type":"function"},{"doc":"Positional Arguments type : AgastFeatureDetector_DetectorType Python prototype (for reference): setType(type) -&gt; None","ref":"Evision.AgastFeatureDetector.html#setType/2","title":"Evision.AgastFeatureDetector.setType/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.AgastFeatureDetector.html#write!/2","title":"Evision.AgastFeatureDetector.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.AgastFeatureDetector.html#write!/3","title":"Evision.AgastFeatureDetector.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.AgastFeatureDetector.html#write/2","title":"Evision.AgastFeatureDetector.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.AgastFeatureDetector.html#write/3","title":"Evision.AgastFeatureDetector.write/3","type":"function"},{"doc":"","ref":"Evision.Algorithm.html","title":"Evision.Algorithm","type":"module"},{"doc":"Raising version of clear/1 .","ref":"Evision.Algorithm.html#clear!/1","title":"Evision.Algorithm.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.Algorithm.html#clear/1","title":"Evision.Algorithm.clear/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.Algorithm.html#empty!/1","title":"Evision.Algorithm.empty!/1","type":"function"},{"doc":"Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read Python prototype (for reference): empty() -&gt; retval","ref":"Evision.Algorithm.html#empty/1","title":"Evision.Algorithm.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.Algorithm.html#getDefaultName!/1","title":"Evision.Algorithm.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.Algorithm.html#getDefaultName/1","title":"Evision.Algorithm.getDefaultName/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.Algorithm.html#read!/2","title":"Evision.Algorithm.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.Algorithm.html#read/2","title":"Evision.Algorithm.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.Algorithm.html#save!/2","title":"Evision.Algorithm.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.Algorithm.html#save/2","title":"Evision.Algorithm.save/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.Algorithm.html#write!/2","title":"Evision.Algorithm.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.Algorithm.html#write!/3","title":"Evision.Algorithm.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.Algorithm.html#write/2","title":"Evision.Algorithm.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.Algorithm.html#write/3","title":"Evision.Algorithm.write/3","type":"function"},{"doc":"","ref":"Evision.AlignExposures.html","title":"Evision.AlignExposures","type":"module"},{"doc":"Raising version of process/5 .","ref":"Evision.AlignExposures.html#process!/5","title":"Evision.AlignExposures.process!/5","type":"function"},{"doc":"Aligns images Positional Arguments src : [Evision.Mat] . vector of input images dst : [Evision.Mat] . vector of aligned images times : Evision.Mat . vector of exposure time values for each image response : Evision.Mat . 256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images. Python prototype (for reference): process(src, dst, times, response) -&gt; None","ref":"Evision.AlignExposures.html#process/5","title":"Evision.AlignExposures.process/5","type":"function"},{"doc":"","ref":"Evision.AlignMTB.html","title":"Evision.AlignMTB","type":"module"},{"doc":"Raising version of calculateShift/3 .","ref":"Evision.AlignMTB.html#calculateShift!/3","title":"Evision.AlignMTB.calculateShift!/3","type":"function"},{"doc":"Calculates shift between two images, i. e. how to shift the second image to correspond it with the first. Positional Arguments img0 : Evision.Mat . first image img1 : Evision.Mat . second image Python prototype (for reference): calculateShift(img0, img1) -&gt; retval","ref":"Evision.AlignMTB.html#calculateShift/3","title":"Evision.AlignMTB.calculateShift/3","type":"function"},{"doc":"Raising version of computeBitmaps/2 .","ref":"Evision.AlignMTB.html#computeBitmaps!/2","title":"Evision.AlignMTB.computeBitmaps!/2","type":"function"},{"doc":"Raising version of computeBitmaps/3 .","ref":"Evision.AlignMTB.html#computeBitmaps!/3","title":"Evision.AlignMTB.computeBitmaps!/3","type":"function"},{"doc":"Computes median threshold and exclude bitmaps of given image. Positional Arguments img : Evision.Mat . input image Return tb : Evision.Mat . median threshold bitmap eb : Evision.Mat . exclude bitmap Python prototype (for reference): computeBitmaps(img[, tb[, eb]]) -&gt; tb, eb","ref":"Evision.AlignMTB.html#computeBitmaps/2","title":"Evision.AlignMTB.computeBitmaps/2","type":"function"},{"doc":"Computes median threshold and exclude bitmaps of given image. Positional Arguments img : Evision.Mat . input image Return tb : Evision.Mat . median threshold bitmap eb : Evision.Mat . exclude bitmap Python prototype (for reference): computeBitmaps(img[, tb[, eb]]) -&gt; tb, eb","ref":"Evision.AlignMTB.html#computeBitmaps/3","title":"Evision.AlignMTB.computeBitmaps/3","type":"function"},{"doc":"Raising version of getCut/1 .","ref":"Evision.AlignMTB.html#getCut!/1","title":"Evision.AlignMTB.getCut!/1","type":"function"},{"doc":"Python prototype (for reference): getCut() -&gt; retval","ref":"Evision.AlignMTB.html#getCut/1","title":"Evision.AlignMTB.getCut/1","type":"function"},{"doc":"Raising version of getExcludeRange/1 .","ref":"Evision.AlignMTB.html#getExcludeRange!/1","title":"Evision.AlignMTB.getExcludeRange!/1","type":"function"},{"doc":"Python prototype (for reference): getExcludeRange() -&gt; retval","ref":"Evision.AlignMTB.html#getExcludeRange/1","title":"Evision.AlignMTB.getExcludeRange/1","type":"function"},{"doc":"Raising version of getMaxBits/1 .","ref":"Evision.AlignMTB.html#getMaxBits!/1","title":"Evision.AlignMTB.getMaxBits!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxBits() -&gt; retval","ref":"Evision.AlignMTB.html#getMaxBits/1","title":"Evision.AlignMTB.getMaxBits/1","type":"function"},{"doc":"Raising version of process/3 .","ref":"Evision.AlignMTB.html#process!/3","title":"Evision.AlignMTB.process!/3","type":"function"},{"doc":"Raising version of process/5 .","ref":"Evision.AlignMTB.html#process!/5","title":"Evision.AlignMTB.process!/5","type":"function"},{"doc":"Short version of process, that doesn't take extra arguments. Positional Arguments src : [Evision.Mat] . vector of input images dst : [Evision.Mat] . vector of aligned images Python prototype (for reference): process(src, dst) -&gt; None","ref":"Evision.AlignMTB.html#process/3","title":"Evision.AlignMTB.process/3","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] dst : [Evision.Mat] times : Evision.Mat response : Evision.Mat Python prototype (for reference): process(src, dst, times, response) -&gt; None","ref":"Evision.AlignMTB.html#process/5","title":"Evision.AlignMTB.process/5","type":"function"},{"doc":"Raising version of setCut/2 .","ref":"Evision.AlignMTB.html#setCut!/2","title":"Evision.AlignMTB.setCut!/2","type":"function"},{"doc":"Positional Arguments value : bool Python prototype (for reference): setCut(value) -&gt; None","ref":"Evision.AlignMTB.html#setCut/2","title":"Evision.AlignMTB.setCut/2","type":"function"},{"doc":"Raising version of setExcludeRange/2 .","ref":"Evision.AlignMTB.html#setExcludeRange!/2","title":"Evision.AlignMTB.setExcludeRange!/2","type":"function"},{"doc":"Positional Arguments exclude_range : int Python prototype (for reference): setExcludeRange(exclude_range) -&gt; None","ref":"Evision.AlignMTB.html#setExcludeRange/2","title":"Evision.AlignMTB.setExcludeRange/2","type":"function"},{"doc":"Raising version of setMaxBits/2 .","ref":"Evision.AlignMTB.html#setMaxBits!/2","title":"Evision.AlignMTB.setMaxBits!/2","type":"function"},{"doc":"Positional Arguments max_bits : int Python prototype (for reference): setMaxBits(max_bits) -&gt; None","ref":"Evision.AlignMTB.html#setMaxBits/2","title":"Evision.AlignMTB.setMaxBits/2","type":"function"},{"doc":"Raising version of shiftMat/3 .","ref":"Evision.AlignMTB.html#shiftMat!/3","title":"Evision.AlignMTB.shiftMat!/3","type":"function"},{"doc":"Raising version of shiftMat/4 .","ref":"Evision.AlignMTB.html#shiftMat!/4","title":"Evision.AlignMTB.shiftMat!/4","type":"function"},{"doc":"Helper function, that shift Mat filling new regions with zeros. Positional Arguments src : Evision.Mat . input image shift : Point . shift value Return dst : Evision.Mat . result image Python prototype (for reference): shiftMat(src, shift[, dst]) -&gt; dst","ref":"Evision.AlignMTB.html#shiftMat/3","title":"Evision.AlignMTB.shiftMat/3","type":"function"},{"doc":"Helper function, that shift Mat filling new regions with zeros. Positional Arguments src : Evision.Mat . input image shift : Point . shift value Return dst : Evision.Mat . result image Python prototype (for reference): shiftMat(src, shift[, dst]) -&gt; dst","ref":"Evision.AlignMTB.html#shiftMat/4","title":"Evision.AlignMTB.shiftMat/4","type":"function"},{"doc":"","ref":"Evision.AsyncArray.html","title":"Evision.AsyncArray","type":"module"},{"doc":"Raising version of asyncArray/0 .","ref":"Evision.AsyncArray.html#asyncArray!/0","title":"Evision.AsyncArray.asyncArray!/0","type":"function"},{"doc":"Python prototype (for reference): AsyncArray() -&gt; &lt;AsyncArray object&gt;","ref":"Evision.AsyncArray.html#asyncArray/0","title":"Evision.AsyncArray.asyncArray/0","type":"function"},{"doc":"Raising version of get/1 .","ref":"Evision.AsyncArray.html#get!/1","title":"Evision.AsyncArray.get!/1","type":"function"},{"doc":"Raising version of get/2 .","ref":"Evision.AsyncArray.html#get!/2","title":"Evision.AsyncArray.get!/2","type":"function"},{"doc":"Raising version of get/3 .","ref":"Evision.AsyncArray.html#get!/3","title":"Evision.AsyncArray.get!/3","type":"function"},{"doc":"##### Return dst : Evision.Mat . destination array Fetch the result. Waits for result until container has valid result. Throws exception if exception was stored as a result. Throws exception on invalid container state. Note : Result or stored exception can be fetched only once. Python prototype (for reference): get([, dst]) -&gt; dst","ref":"Evision.AsyncArray.html#get/1","title":"Evision.AsyncArray.get/1","type":"function"},{"doc":"Positional Arguments timeoutNs : double . timeout in nanoseconds, -1 for infinite wait Return dst : Evision.Mat . destination array Retrieving the result with timeout @returns true if result is ready, false if the timeout has expired Note : Result or stored exception can be fetched only once. Python prototype (for reference): get(timeoutNs[, dst]) -&gt; retval, dst","ref":"Evision.AsyncArray.html#get/2","title":"Evision.AsyncArray.get/2","type":"function"},{"doc":"Positional Arguments timeoutNs : double . timeout in nanoseconds, -1 for infinite wait Return dst : Evision.Mat . destination array Retrieving the result with timeout @returns true if result is ready, false if the timeout has expired Note : Result or stored exception can be fetched only once. Python prototype (for reference): get(timeoutNs[, dst]) -&gt; retval, dst","ref":"Evision.AsyncArray.html#get/3","title":"Evision.AsyncArray.get/3","type":"function"},{"doc":"Raising version of release/1 .","ref":"Evision.AsyncArray.html#release!/1","title":"Evision.AsyncArray.release!/1","type":"function"},{"doc":"Python prototype (for reference): release() -&gt; None","ref":"Evision.AsyncArray.html#release/1","title":"Evision.AsyncArray.release/1","type":"function"},{"doc":"Raising version of valid/1 .","ref":"Evision.AsyncArray.html#valid!/1","title":"Evision.AsyncArray.valid!/1","type":"function"},{"doc":"Python prototype (for reference): valid() -&gt; retval","ref":"Evision.AsyncArray.html#valid/1","title":"Evision.AsyncArray.valid/1","type":"function"},{"doc":"Raising version of wait_for/2 .","ref":"Evision.AsyncArray.html#wait_for!/2","title":"Evision.AsyncArray.wait_for!/2","type":"function"},{"doc":"Positional Arguments timeoutNs : double Python prototype (for reference): wait_for(timeoutNs) -&gt; retval","ref":"Evision.AsyncArray.html#wait_for/2","title":"Evision.AsyncArray.wait_for/2","type":"function"},{"doc":"","ref":"Evision.BFMatcher.html","title":"Evision.BFMatcher","type":"module"},{"doc":"Raising version of add/2 .","ref":"Evision.BFMatcher.html#add!/2","title":"Evision.BFMatcher.add!/2","type":"function"},{"doc":"Adds descriptors to train a CPU(trainDescCollectionis) or GPU(utrainDescCollectionis) descriptor collection. Positional Arguments descriptors : [Evision.Mat] . Descriptors to add. Each descriptors[i] is a set of descriptors from the same train image. If the collection is not empty, the new descriptors are added to existing train descriptors. Python prototype (for reference): add(descriptors) -&gt; None","ref":"Evision.BFMatcher.html#add/2","title":"Evision.BFMatcher.add/2","type":"function"},{"doc":"Raising version of bfMatcher/0 .","ref":"Evision.BFMatcher.html#bfMatcher!/0","title":"Evision.BFMatcher.bfMatcher!/0","type":"function"},{"doc":"Raising version of bfMatcher/1 .","ref":"Evision.BFMatcher.html#bfMatcher!/1","title":"Evision.BFMatcher.bfMatcher!/1","type":"function"},{"doc":"Brute-force matcher constructor (obsolete). Please use BFMatcher.create() Keyword Arguments normType : int . crossCheck : bool . Python prototype (for reference): BFMatcher([, normType[, crossCheck]]) -&gt; &lt;BFMatcher object&gt;","ref":"Evision.BFMatcher.html#bfMatcher/0","title":"Evision.BFMatcher.bfMatcher/0","type":"function"},{"doc":"Brute-force matcher constructor (obsolete). Please use BFMatcher.create() Keyword Arguments normType : int . crossCheck : bool . Python prototype (for reference): BFMatcher([, normType[, crossCheck]]) -&gt; &lt;BFMatcher object&gt;","ref":"Evision.BFMatcher.html#bfMatcher/1","title":"Evision.BFMatcher.bfMatcher/1","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.BFMatcher.html#clear!/1","title":"Evision.BFMatcher.clear!/1","type":"function"},{"doc":"Clears the train descriptor collections. Python prototype (for reference): clear() -&gt; None","ref":"Evision.BFMatcher.html#clear/1","title":"Evision.BFMatcher.clear/1","type":"function"},{"doc":"Raising version of clone/1 .","ref":"Evision.BFMatcher.html#clone!/1","title":"Evision.BFMatcher.clone!/1","type":"function"},{"doc":"Clones the matcher. Keyword Arguments emptyTrainData : bool . If emptyTrainData is false, the method creates a deep copy of the object, that is, copies both parameters and train data. If emptyTrainData is true, the method creates an object copy with the current parameters but with empty train data. Python prototype (for reference): clone([, emptyTrainData]) -&gt; retval","ref":"Evision.BFMatcher.html#clone/1","title":"Evision.BFMatcher.clone/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.BFMatcher.html#create!/0","title":"Evision.BFMatcher.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.BFMatcher.html#create!/1","title":"Evision.BFMatcher.create!/1","type":"function"},{"doc":"Brute-force matcher create method. Keyword Arguments normType : int . One of NORM_L1, NORM_L2, NORM_HAMMING, NORM_HAMMING2. L1 and L2 norms are preferable choices for SIFT and SURF descriptors, NORM_HAMMING should be used with ORB, BRISK and BRIEF, NORM_HAMMING2 should be used with ORB when WTA_K==3 or 4 (see ORB::ORB constructor description). crossCheck : bool . If it is false, this is will be default BFMatcher behaviour when it finds the k nearest neighbors for each query descriptor. If crossCheck==true, then the knnMatch() method with k=1 will only return pairs (i,j) such that for i-th query descriptor the j-th descriptor in the matcher's collection is the nearest and vice versa, i.e. the BFMatcher will only return consistent pairs. Such technique usually produces best results with minimal number of outliers when there are enough matches. This is alternative to the ratio test, used by D. Lowe in SIFT paper. Python prototype (for reference): create([, normType[, crossCheck]]) -&gt; retval","ref":"Evision.BFMatcher.html#create/0","title":"Evision.BFMatcher.create/0","type":"function"},{"doc":"Brute-force matcher create method. Keyword Arguments normType : int . One of NORM_L1, NORM_L2, NORM_HAMMING, NORM_HAMMING2. L1 and L2 norms are preferable choices for SIFT and SURF descriptors, NORM_HAMMING should be used with ORB, BRISK and BRIEF, NORM_HAMMING2 should be used with ORB when WTA_K==3 or 4 (see ORB::ORB constructor description). crossCheck : bool . If it is false, this is will be default BFMatcher behaviour when it finds the k nearest neighbors for each query descriptor. If crossCheck==true, then the knnMatch() method with k=1 will only return pairs (i,j) such that for i-th query descriptor the j-th descriptor in the matcher's collection is the nearest and vice versa, i.e. the BFMatcher will only return consistent pairs. Such technique usually produces best results with minimal number of outliers when there are enough matches. This is alternative to the ratio test, used by D. Lowe in SIFT paper. Python prototype (for reference): create([, normType[, crossCheck]]) -&gt; retval","ref":"Evision.BFMatcher.html#create/1","title":"Evision.BFMatcher.create/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.BFMatcher.html#empty!/1","title":"Evision.BFMatcher.empty!/1","type":"function"},{"doc":"Returns true if there are no train descriptors in the both collections. Python prototype (for reference): empty() -&gt; retval","ref":"Evision.BFMatcher.html#empty/1","title":"Evision.BFMatcher.empty/1","type":"function"},{"doc":"Raising version of getTrainDescriptors/1 .","ref":"Evision.BFMatcher.html#getTrainDescriptors!/1","title":"Evision.BFMatcher.getTrainDescriptors!/1","type":"function"},{"doc":"Returns a constant link to the train descriptor collection trainDescCollection . Python prototype (for reference): getTrainDescriptors() -&gt; retval","ref":"Evision.BFMatcher.html#getTrainDescriptors/1","title":"Evision.BFMatcher.getTrainDescriptors/1","type":"function"},{"doc":"Raising version of isMaskSupported/1 .","ref":"Evision.BFMatcher.html#isMaskSupported!/1","title":"Evision.BFMatcher.isMaskSupported!/1","type":"function"},{"doc":"Returns true if the descriptor matcher supports masking permissible matches. Python prototype (for reference): isMaskSupported() -&gt; retval","ref":"Evision.BFMatcher.html#isMaskSupported/1","title":"Evision.BFMatcher.isMaskSupported/1","type":"function"},{"doc":"Raising version of knnMatch/3 .","ref":"Evision.BFMatcher.html#knnMatch!/3","title":"Evision.BFMatcher.knnMatch!/3","type":"function"},{"doc":"Raising version of knnMatch/4 .","ref":"Evision.BFMatcher.html#knnMatch!/4","title":"Evision.BFMatcher.knnMatch!/4","type":"function"},{"doc":"Raising version of knnMatch/5 .","ref":"Evision.BFMatcher.html#knnMatch!/5","title":"Evision.BFMatcher.knnMatch!/5","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. Has overloading in C++ Python prototype (for reference): knnMatch(queryDescriptors, k[, masks[, compactResult]]) -&gt; matches","ref":"Evision.BFMatcher.html#knnMatch/3","title":"Evision.BFMatcher.knnMatch/3","type":"function"},{"doc":"Variant 1: Finds the k best matches for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. These extended variants of DescriptorMatcher::match methods find several best matches for each query descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match for the details about query and train descriptors. Python prototype (for reference): knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. Has overloading in C++ Python prototype (for reference): knnMatch(queryDescriptors, k[, masks[, compactResult]]) -&gt; matches","ref":"Evision.BFMatcher.html#knnMatch/4","title":"Evision.BFMatcher.knnMatch/4","type":"function"},{"doc":"Finds the k best matches for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. These extended variants of DescriptorMatcher::match methods find several best matches for each query descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match for the details about query and train descriptors. Python prototype (for reference): knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -&gt; matches","ref":"Evision.BFMatcher.html#knnMatch/5","title":"Evision.BFMatcher.knnMatch/5","type":"function"},{"doc":"Raising version of match/2 .","ref":"Evision.BFMatcher.html#match!/2","title":"Evision.BFMatcher.match!/2","type":"function"},{"doc":"Raising version of match/3 .","ref":"Evision.BFMatcher.html#match!/3","title":"Evision.BFMatcher.match!/3","type":"function"},{"doc":"Raising version of match/4 .","ref":"Evision.BFMatcher.html#match!/4","title":"Evision.BFMatcher.match!/4","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. Has overloading in C++ Python prototype (for reference): match(queryDescriptors[, masks]) -&gt; matches","ref":"Evision.BFMatcher.html#match/2","title":"Evision.BFMatcher.match/2","type":"function"},{"doc":"Variant 1: Finds the best match for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. In the first variant of this method, the train descriptors are passed as an input argument. In the second variant of the method, train descriptors collection that was set by DescriptorMatcher::add is used. Optional mask (or masks) can be passed to specify which query and training descriptors can be matched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if mask.at\\&lt;uchar&gt;(i,j) is non-zero. Python prototype (for reference): match(queryDescriptors, trainDescriptors[, mask]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. Has overloading in C++ Python prototype (for reference): match(queryDescriptors[, masks]) -&gt; matches","ref":"Evision.BFMatcher.html#match/3","title":"Evision.BFMatcher.match/3","type":"function"},{"doc":"Finds the best match for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. In the first variant of this method, the train descriptors are passed as an input argument. In the second variant of the method, train descriptors collection that was set by DescriptorMatcher::add is used. Optional mask (or masks) can be passed to specify which query and training descriptors can be matched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if mask.at\\&lt;uchar&gt;(i,j) is non-zero. Python prototype (for reference): match(queryDescriptors, trainDescriptors[, mask]) -&gt; matches","ref":"Evision.BFMatcher.html#match/4","title":"Evision.BFMatcher.match/4","type":"function"},{"doc":"Raising version of radiusMatch/3 .","ref":"Evision.BFMatcher.html#radiusMatch!/3","title":"Evision.BFMatcher.radiusMatch!/3","type":"function"},{"doc":"Raising version of radiusMatch/4 .","ref":"Evision.BFMatcher.html#radiusMatch!/4","title":"Evision.BFMatcher.radiusMatch!/4","type":"function"},{"doc":"Raising version of radiusMatch/5 .","ref":"Evision.BFMatcher.html#radiusMatch!/5","title":"Evision.BFMatcher.radiusMatch!/5","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. Has overloading in C++ Python prototype (for reference): radiusMatch(queryDescriptors, maxDistance[, masks[, compactResult]]) -&gt; matches","ref":"Evision.BFMatcher.html#radiusMatch/3","title":"Evision.BFMatcher.radiusMatch/3","type":"function"},{"doc":"Variant 1: For each query descriptor, finds the training descriptors not farther than the specified distance. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. For each query descriptor, the methods find such training descriptors that the distance between the query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are returned in the distance increasing order. Python prototype (for reference): radiusMatch(queryDescriptors, trainDescriptors, maxDistance[, mask[, compactResult]]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. Has overloading in C++ Python prototype (for reference): radiusMatch(queryDescriptors, maxDistance[, masks[, compactResult]]) -&gt; matches","ref":"Evision.BFMatcher.html#radiusMatch/4","title":"Evision.BFMatcher.radiusMatch/4","type":"function"},{"doc":"For each query descriptor, finds the training descriptors not farther than the specified distance. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. For each query descriptor, the methods find such training descriptors that the distance between the query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are returned in the distance increasing order. Python prototype (for reference): radiusMatch(queryDescriptors, trainDescriptors, maxDistance[, mask[, compactResult]]) -&gt; matches","ref":"Evision.BFMatcher.html#radiusMatch/5","title":"Evision.BFMatcher.radiusMatch/5","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.BFMatcher.html#read!/2","title":"Evision.BFMatcher.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.BFMatcher.html#read/2","title":"Evision.BFMatcher.read/2","type":"function"},{"doc":"Raising version of train/1 .","ref":"Evision.BFMatcher.html#train!/1","title":"Evision.BFMatcher.train!/1","type":"function"},{"doc":"Trains a descriptor matcher Trains a descriptor matcher (for example, the flann index). In all methods to match, the method train() is run every time before matching. Some descriptor matchers (for example, BruteForceMatcher) have an empty implementation of this method. Other matchers really train their inner structures (for example, FlannBasedMatcher trains flann::Index ). Python prototype (for reference): train() -&gt; None","ref":"Evision.BFMatcher.html#train/1","title":"Evision.BFMatcher.train/1","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.BFMatcher.html#write!/2","title":"Evision.BFMatcher.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.BFMatcher.html#write!/3","title":"Evision.BFMatcher.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.BFMatcher.html#write/2","title":"Evision.BFMatcher.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.BFMatcher.html#write/3","title":"Evision.BFMatcher.write/3","type":"function"},{"doc":"","ref":"Evision.BOWImgDescriptorExtractor.html","title":"Evision.BOWImgDescriptorExtractor","type":"module"},{"doc":"Raising version of bowImgDescriptorExtractor/2 .","ref":"Evision.BOWImgDescriptorExtractor.html#bowImgDescriptorExtractor!/2","title":"Evision.BOWImgDescriptorExtractor.bowImgDescriptorExtractor!/2","type":"function"},{"doc":"The constructor. Positional Arguments dextractor : Ptr&lt;DescriptorExtractor&gt; . Descriptor extractor that is used to compute descriptors for an input image and its keypoints. dmatcher : Ptr&lt;DescriptorMatcher&gt; . Descriptor matcher that is used to find the nearest word of the trained vocabulary for each keypoint descriptor of the image. Python prototype (for reference): BOWImgDescriptorExtractor(dextractor, dmatcher) -&gt; &lt;BOWImgDescriptorExtractor object&gt;","ref":"Evision.BOWImgDescriptorExtractor.html#bowImgDescriptorExtractor/2","title":"Evision.BOWImgDescriptorExtractor.bowImgDescriptorExtractor/2","type":"function"},{"doc":"Raising version of compute/3 .","ref":"Evision.BOWImgDescriptorExtractor.html#compute!/3","title":"Evision.BOWImgDescriptorExtractor.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.BOWImgDescriptorExtractor.html#compute!/4","title":"Evision.BOWImgDescriptorExtractor.compute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat keypoints : [KeyPoint] Return imgDescriptor : Evision.Mat . Computed output image descriptor. Has overloading in C++ Python prototype (for reference): compute(image, keypoints[, imgDescriptor]) -&gt; imgDescriptor","ref":"Evision.BOWImgDescriptorExtractor.html#compute/3","title":"Evision.BOWImgDescriptorExtractor.compute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat keypoints : [KeyPoint] Return imgDescriptor : Evision.Mat . Computed output image descriptor. Has overloading in C++ Python prototype (for reference): compute(image, keypoints[, imgDescriptor]) -&gt; imgDescriptor","ref":"Evision.BOWImgDescriptorExtractor.html#compute/4","title":"Evision.BOWImgDescriptorExtractor.compute/4","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.BOWImgDescriptorExtractor.html#descriptorSize!/1","title":"Evision.BOWImgDescriptorExtractor.descriptorSize!/1","type":"function"},{"doc":"Returns an image descriptor size if the vocabulary is set. Otherwise, it returns 0. Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.BOWImgDescriptorExtractor.html#descriptorSize/1","title":"Evision.BOWImgDescriptorExtractor.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.BOWImgDescriptorExtractor.html#descriptorType!/1","title":"Evision.BOWImgDescriptorExtractor.descriptorType!/1","type":"function"},{"doc":"Returns an image descriptor type. Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.BOWImgDescriptorExtractor.html#descriptorType/1","title":"Evision.BOWImgDescriptorExtractor.descriptorType/1","type":"function"},{"doc":"Raising version of getVocabulary/1 .","ref":"Evision.BOWImgDescriptorExtractor.html#getVocabulary!/1","title":"Evision.BOWImgDescriptorExtractor.getVocabulary!/1","type":"function"},{"doc":"Returns the set vocabulary. Python prototype (for reference): getVocabulary() -&gt; retval","ref":"Evision.BOWImgDescriptorExtractor.html#getVocabulary/1","title":"Evision.BOWImgDescriptorExtractor.getVocabulary/1","type":"function"},{"doc":"Raising version of setVocabulary/2 .","ref":"Evision.BOWImgDescriptorExtractor.html#setVocabulary!/2","title":"Evision.BOWImgDescriptorExtractor.setVocabulary!/2","type":"function"},{"doc":"Sets a visual vocabulary. Positional Arguments vocabulary : Evision.Mat . Vocabulary (can be trained using the inheritor of BOWTrainer ). Each row of the vocabulary is a visual word (cluster center). Python prototype (for reference): setVocabulary(vocabulary) -&gt; None","ref":"Evision.BOWImgDescriptorExtractor.html#setVocabulary/2","title":"Evision.BOWImgDescriptorExtractor.setVocabulary/2","type":"function"},{"doc":"","ref":"Evision.BOWKMeansTrainer.html","title":"Evision.BOWKMeansTrainer","type":"module"},{"doc":"Raising version of bowKMeansTrainer/1 .","ref":"Evision.BOWKMeansTrainer.html#bowKMeansTrainer!/1","title":"Evision.BOWKMeansTrainer.bowKMeansTrainer!/1","type":"function"},{"doc":"Raising version of bowKMeansTrainer/2 .","ref":"Evision.BOWKMeansTrainer.html#bowKMeansTrainer!/2","title":"Evision.BOWKMeansTrainer.bowKMeansTrainer!/2","type":"function"},{"doc":"The constructor. Positional Arguments clusterCount : int Keyword Arguments termcrit : TermCriteria . attempts : int . flags : int . @see cv::kmeans Python prototype (for reference): BOWKMeansTrainer(clusterCount[, termcrit[, attempts[, flags]]]) -&gt; &lt;BOWKMeansTrainer object&gt;","ref":"Evision.BOWKMeansTrainer.html#bowKMeansTrainer/1","title":"Evision.BOWKMeansTrainer.bowKMeansTrainer/1","type":"function"},{"doc":"The constructor. Positional Arguments clusterCount : int Keyword Arguments termcrit : TermCriteria . attempts : int . flags : int . @see cv::kmeans Python prototype (for reference): BOWKMeansTrainer(clusterCount[, termcrit[, attempts[, flags]]]) -&gt; &lt;BOWKMeansTrainer object&gt;","ref":"Evision.BOWKMeansTrainer.html#bowKMeansTrainer/2","title":"Evision.BOWKMeansTrainer.bowKMeansTrainer/2","type":"function"},{"doc":"Raising version of cluster/1 .","ref":"Evision.BOWKMeansTrainer.html#cluster!/1","title":"Evision.BOWKMeansTrainer.cluster!/1","type":"function"},{"doc":"Raising version of cluster/2 .","ref":"Evision.BOWKMeansTrainer.html#cluster!/2","title":"Evision.BOWKMeansTrainer.cluster!/2","type":"function"},{"doc":"Python prototype (for reference): cluster() -&gt; retval","ref":"Evision.BOWKMeansTrainer.html#cluster/1","title":"Evision.BOWKMeansTrainer.cluster/1","type":"function"},{"doc":"Positional Arguments descriptors : Evision.Mat Python prototype (for reference): cluster(descriptors) -&gt; retval","ref":"Evision.BOWKMeansTrainer.html#cluster/2","title":"Evision.BOWKMeansTrainer.cluster/2","type":"function"},{"doc":"","ref":"Evision.BOWTrainer.html","title":"Evision.BOWTrainer","type":"module"},{"doc":"Raising version of add/2 .","ref":"Evision.BOWTrainer.html#add!/2","title":"Evision.BOWTrainer.add!/2","type":"function"},{"doc":"Adds descriptors to a training set. Positional Arguments descriptors : Evision.Mat . Descriptors to add to a training set. Each row of the descriptors matrix is a descriptor. The training set is clustered using clustermethod to construct the vocabulary. Python prototype (for reference): add(descriptors) -&gt; None","ref":"Evision.BOWTrainer.html#add/2","title":"Evision.BOWTrainer.add/2","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.BOWTrainer.html#clear!/1","title":"Evision.BOWTrainer.clear!/1","type":"function"},{"doc":"Python prototype (for reference): clear() -&gt; None","ref":"Evision.BOWTrainer.html#clear/1","title":"Evision.BOWTrainer.clear/1","type":"function"},{"doc":"Raising version of cluster/1 .","ref":"Evision.BOWTrainer.html#cluster!/1","title":"Evision.BOWTrainer.cluster!/1","type":"function"},{"doc":"Raising version of cluster/2 .","ref":"Evision.BOWTrainer.html#cluster!/2","title":"Evision.BOWTrainer.cluster!/2","type":"function"},{"doc":"Has overloading in C++ Python prototype (for reference): cluster() -&gt; retval","ref":"Evision.BOWTrainer.html#cluster/1","title":"Evision.BOWTrainer.cluster/1","type":"function"},{"doc":"Clusters train descriptors. Positional Arguments descriptors : Evision.Mat . Descriptors to cluster. Each row of the descriptors matrix is a descriptor. Descriptors are not added to the inner train descriptor set. The vocabulary consists of cluster centers. So, this method returns the vocabulary. In the first variant of the method, train descriptors stored in the object are clustered. In the second variant, input descriptors are clustered. Python prototype (for reference): cluster(descriptors) -&gt; retval","ref":"Evision.BOWTrainer.html#cluster/2","title":"Evision.BOWTrainer.cluster/2","type":"function"},{"doc":"Raising version of descriptorsCount/1 .","ref":"Evision.BOWTrainer.html#descriptorsCount!/1","title":"Evision.BOWTrainer.descriptorsCount!/1","type":"function"},{"doc":"Returns the count of all descriptors stored in the training set. Python prototype (for reference): descriptorsCount() -&gt; retval","ref":"Evision.BOWTrainer.html#descriptorsCount/1","title":"Evision.BOWTrainer.descriptorsCount/1","type":"function"},{"doc":"Raising version of getDescriptors/1 .","ref":"Evision.BOWTrainer.html#getDescriptors!/1","title":"Evision.BOWTrainer.getDescriptors!/1","type":"function"},{"doc":"Returns a training set of descriptors. Python prototype (for reference): getDescriptors() -&gt; retval","ref":"Evision.BOWTrainer.html#getDescriptors/1","title":"Evision.BOWTrainer.getDescriptors/1","type":"function"},{"doc":"","ref":"Evision.BRISK.html","title":"Evision.BRISK","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.BRISK.html#compute!/3","title":"Evision.BRISK.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.BRISK.html#compute!/4","title":"Evision.BRISK.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.BRISK.html#compute/3","title":"Evision.BRISK.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.BRISK.html#compute/4","title":"Evision.BRISK.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.BRISK.html#create!/0","title":"Evision.BRISK.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.BRISK.html#create!/1","title":"Evision.BRISK.create!/1","type":"function"},{"doc":"Raising version of create/2 .","ref":"Evision.BRISK.html#create!/2","title":"Evision.BRISK.create!/2","type":"function"},{"doc":"Raising version of create/3 .","ref":"Evision.BRISK.html#create!/3","title":"Evision.BRISK.create!/3","type":"function"},{"doc":"Raising version of create/4 .","ref":"Evision.BRISK.html#create!/4","title":"Evision.BRISK.create!/4","type":"function"},{"doc":"Raising version of create/5 .","ref":"Evision.BRISK.html#create!/5","title":"Evision.BRISK.create!/5","type":"function"},{"doc":"The BRISK constructor Keyword Arguments thresh : int . AGAST detection threshold score. octaves : int . detection octaves. Use 0 to do single scale. patternScale : float . apply this scale to the pattern used for sampling the neighbourhood of a keypoint. Python prototype (for reference): create([, thresh[, octaves[, patternScale]]]) -&gt; retval","ref":"Evision.BRISK.html#create/0","title":"Evision.BRISK.create/0","type":"function"},{"doc":"The BRISK constructor Keyword Arguments thresh : int . AGAST detection threshold score. octaves : int . detection octaves. Use 0 to do single scale. patternScale : float . apply this scale to the pattern used for sampling the neighbourhood of a keypoint. Python prototype (for reference): create([, thresh[, octaves[, patternScale]]]) -&gt; retval","ref":"Evision.BRISK.html#create/1","title":"Evision.BRISK.create/1","type":"function"},{"doc":"The BRISK constructor for a custom pattern Positional Arguments radiusList : [float] . defines the radii (in pixels) where the samples around a keypoint are taken (for keypoint scale 1). numberList : [int] . defines the number of sampling points on the sampling circle. Must be the same size as radiusList.. Keyword Arguments dMax : float . threshold for the short pairings used for descriptor formation (in pixels for keypoint scale 1). dMin : float . threshold for the long pairings used for orientation determination (in pixels for keypoint scale 1). indexChange : [int] . index remapping of the bits. Python prototype (for reference): create(radiusList, numberList[, dMax[, dMin[, indexChange]]]) -&gt; retval","ref":"Evision.BRISK.html#create/2","title":"Evision.BRISK.create/2","type":"function"},{"doc":"The BRISK constructor for a custom pattern Positional Arguments radiusList : [float] . defines the radii (in pixels) where the samples around a keypoint are taken (for keypoint scale 1). numberList : [int] . defines the number of sampling points on the sampling circle. Must be the same size as radiusList.. Keyword Arguments dMax : float . threshold for the short pairings used for descriptor formation (in pixels for keypoint scale 1). dMin : float . threshold for the long pairings used for orientation determination (in pixels for keypoint scale 1). indexChange : [int] . index remapping of the bits. Python prototype (for reference): create(radiusList, numberList[, dMax[, dMin[, indexChange]]]) -&gt; retval","ref":"Evision.BRISK.html#create/3","title":"Evision.BRISK.create/3","type":"function"},{"doc":"The BRISK constructor for a custom pattern, detection threshold and octaves Positional Arguments thresh : int . AGAST detection threshold score. octaves : int . detection octaves. Use 0 to do single scale. radiusList : [float] . defines the radii (in pixels) where the samples around a keypoint are taken (for keypoint scale 1). numberList : [int] . defines the number of sampling points on the sampling circle. Must be the same size as radiusList.. Keyword Arguments dMax : float . threshold for the short pairings used for descriptor formation (in pixels for keypoint scale 1). dMin : float . threshold for the long pairings used for orientation determination (in pixels for keypoint scale 1). indexChange : [int] . index remapping of the bits. Python prototype (for reference): create(thresh, octaves, radiusList, numberList[, dMax[, dMin[, indexChange]]]) -&gt; retval","ref":"Evision.BRISK.html#create/4","title":"Evision.BRISK.create/4","type":"function"},{"doc":"The BRISK constructor for a custom pattern, detection threshold and octaves Positional Arguments thresh : int . AGAST detection threshold score. octaves : int . detection octaves. Use 0 to do single scale. radiusList : [float] . defines the radii (in pixels) where the samples around a keypoint are taken (for keypoint scale 1). numberList : [int] . defines the number of sampling points on the sampling circle. Must be the same size as radiusList.. Keyword Arguments dMax : float . threshold for the short pairings used for descriptor formation (in pixels for keypoint scale 1). dMin : float . threshold for the long pairings used for orientation determination (in pixels for keypoint scale 1). indexChange : [int] . index remapping of the bits. Python prototype (for reference): create(thresh, octaves, radiusList, numberList[, dMax[, dMin[, indexChange]]]) -&gt; retval","ref":"Evision.BRISK.html#create/5","title":"Evision.BRISK.create/5","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.BRISK.html#defaultNorm!/1","title":"Evision.BRISK.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.BRISK.html#defaultNorm/1","title":"Evision.BRISK.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.BRISK.html#descriptorSize!/1","title":"Evision.BRISK.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.BRISK.html#descriptorSize/1","title":"Evision.BRISK.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.BRISK.html#descriptorType!/1","title":"Evision.BRISK.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.BRISK.html#descriptorType/1","title":"Evision.BRISK.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.BRISK.html#detect!/2","title":"Evision.BRISK.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.BRISK.html#detect!/3","title":"Evision.BRISK.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.BRISK.html#detect/2","title":"Evision.BRISK.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.BRISK.html#detect/3","title":"Evision.BRISK.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.BRISK.html#detectAndCompute!/3","title":"Evision.BRISK.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.BRISK.html#detectAndCompute!/4","title":"Evision.BRISK.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.BRISK.html#detectAndCompute/3","title":"Evision.BRISK.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.BRISK.html#detectAndCompute/4","title":"Evision.BRISK.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.BRISK.html#empty!/1","title":"Evision.BRISK.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.BRISK.html#empty/1","title":"Evision.BRISK.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.BRISK.html#getDefaultName!/1","title":"Evision.BRISK.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.BRISK.html#getDefaultName/1","title":"Evision.BRISK.getDefaultName/1","type":"function"},{"doc":"Raising version of getOctaves/1 .","ref":"Evision.BRISK.html#getOctaves!/1","title":"Evision.BRISK.getOctaves!/1","type":"function"},{"doc":"Python prototype (for reference): getOctaves() -&gt; retval","ref":"Evision.BRISK.html#getOctaves/1","title":"Evision.BRISK.getOctaves/1","type":"function"},{"doc":"Raising version of getThreshold/1 .","ref":"Evision.BRISK.html#getThreshold!/1","title":"Evision.BRISK.getThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getThreshold() -&gt; retval","ref":"Evision.BRISK.html#getThreshold/1","title":"Evision.BRISK.getThreshold/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.BRISK.html#read!/2","title":"Evision.BRISK.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.BRISK.html#read/2","title":"Evision.BRISK.read/2","type":"function"},{"doc":"Raising version of setOctaves/2 .","ref":"Evision.BRISK.html#setOctaves!/2","title":"Evision.BRISK.setOctaves!/2","type":"function"},{"doc":"Set detection octaves. Positional Arguments octaves : int . detection octaves. Use 0 to do single scale. Python prototype (for reference): setOctaves(octaves) -&gt; None","ref":"Evision.BRISK.html#setOctaves/2","title":"Evision.BRISK.setOctaves/2","type":"function"},{"doc":"Raising version of setThreshold/2 .","ref":"Evision.BRISK.html#setThreshold!/2","title":"Evision.BRISK.setThreshold!/2","type":"function"},{"doc":"Set detection threshold. Positional Arguments threshold : int . AGAST detection threshold score. Python prototype (for reference): setThreshold(threshold) -&gt; None","ref":"Evision.BRISK.html#setThreshold/2","title":"Evision.BRISK.setThreshold/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.BRISK.html#write!/2","title":"Evision.BRISK.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.BRISK.html#write!/3","title":"Evision.BRISK.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.BRISK.html#write/2","title":"Evision.BRISK.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.BRISK.html#write/3","title":"Evision.BRISK.write/3","type":"function"},{"doc":"","ref":"Evision.Backend.html","title":"Evision.Backend","type":"module"},{"doc":"Tensor with constant values. Example Nx . tensor ( 1.0 , backend : Evision.Backend ) # Nx.Tensor &lt; f32 Evision.Backend 1.0 &gt;","ref":"Evision.Backend.html#constant/3","title":"Evision.Backend.constant/3","type":"function"},{"doc":"","ref":"Evision.BackgroundSubtractor.html","title":"Evision.BackgroundSubtractor","type":"module"},{"doc":"Raising version of apply/2 .","ref":"Evision.BackgroundSubtractor.html#apply!/2","title":"Evision.BackgroundSubtractor.apply!/2","type":"function"},{"doc":"Raising version of apply/3 .","ref":"Evision.BackgroundSubtractor.html#apply!/3","title":"Evision.BackgroundSubtractor.apply!/3","type":"function"},{"doc":"Computes a foreground mask. Positional Arguments image : Evision.Mat . Next video frame. Keyword Arguments learningRate : double . The value between 0 and 1 that indicates how fast the background model is learnt. Negative parameter value makes the algorithm to use some automatically chosen learning rate. 0 means that the background model is not updated at all, 1 means that the background model is completely reinitialized from the last frame. Return fgmask : Evision.Mat . The output foreground mask as an 8-bit binary image. Python prototype (for reference): apply(image[, fgmask[, learningRate]]) -&gt; fgmask","ref":"Evision.BackgroundSubtractor.html#apply/2","title":"Evision.BackgroundSubtractor.apply/2","type":"function"},{"doc":"Computes a foreground mask. Positional Arguments image : Evision.Mat . Next video frame. Keyword Arguments learningRate : double . The value between 0 and 1 that indicates how fast the background model is learnt. Negative parameter value makes the algorithm to use some automatically chosen learning rate. 0 means that the background model is not updated at all, 1 means that the background model is completely reinitialized from the last frame. Return fgmask : Evision.Mat . The output foreground mask as an 8-bit binary image. Python prototype (for reference): apply(image[, fgmask[, learningRate]]) -&gt; fgmask","ref":"Evision.BackgroundSubtractor.html#apply/3","title":"Evision.BackgroundSubtractor.apply/3","type":"function"},{"doc":"Raising version of getBackgroundImage/1 .","ref":"Evision.BackgroundSubtractor.html#getBackgroundImage!/1","title":"Evision.BackgroundSubtractor.getBackgroundImage!/1","type":"function"},{"doc":"Computes a background image. Return backgroundImage : Evision.Mat . The output background image. Note : Sometimes the background image can be very blurry, as it contain the average background statistics. Python prototype (for reference): getBackgroundImage([, backgroundImage]) -&gt; backgroundImage","ref":"Evision.BackgroundSubtractor.html#getBackgroundImage/1","title":"Evision.BackgroundSubtractor.getBackgroundImage/1","type":"function"},{"doc":"","ref":"Evision.BackgroundSubtractorKNN.html","title":"Evision.BackgroundSubtractorKNN","type":"module"},{"doc":"Raising version of getDetectShadows/1 .","ref":"Evision.BackgroundSubtractorKNN.html#getDetectShadows!/1","title":"Evision.BackgroundSubtractorKNN.getDetectShadows!/1","type":"function"},{"doc":"Returns the shadow detection flag If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for details. Python prototype (for reference): getDetectShadows() -&gt; retval","ref":"Evision.BackgroundSubtractorKNN.html#getDetectShadows/1","title":"Evision.BackgroundSubtractorKNN.getDetectShadows/1","type":"function"},{"doc":"Raising version of getDist2Threshold/1 .","ref":"Evision.BackgroundSubtractorKNN.html#getDist2Threshold!/1","title":"Evision.BackgroundSubtractorKNN.getDist2Threshold!/1","type":"function"},{"doc":"Returns the threshold on the squared distance between the pixel and the sample The threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to a data sample. Python prototype (for reference): getDist2Threshold() -&gt; retval","ref":"Evision.BackgroundSubtractorKNN.html#getDist2Threshold/1","title":"Evision.BackgroundSubtractorKNN.getDist2Threshold/1","type":"function"},{"doc":"Raising version of getHistory/1 .","ref":"Evision.BackgroundSubtractorKNN.html#getHistory!/1","title":"Evision.BackgroundSubtractorKNN.getHistory!/1","type":"function"},{"doc":"Returns the number of last frames that affect the background model Python prototype (for reference): getHistory() -&gt; retval","ref":"Evision.BackgroundSubtractorKNN.html#getHistory/1","title":"Evision.BackgroundSubtractorKNN.getHistory/1","type":"function"},{"doc":"Raising version of getkNNSamples/1 .","ref":"Evision.BackgroundSubtractorKNN.html#getkNNSamples!/1","title":"Evision.BackgroundSubtractorKNN.getkNNSamples!/1","type":"function"},{"doc":"Returns the number of neighbours, the k in the kNN. K is the number of samples that need to be within dist2Threshold in order to decide that that pixel is matching the kNN background model. Python prototype (for reference): getkNNSamples() -&gt; retval","ref":"Evision.BackgroundSubtractorKNN.html#getkNNSamples/1","title":"Evision.BackgroundSubtractorKNN.getkNNSamples/1","type":"function"},{"doc":"Raising version of getNSamples/1 .","ref":"Evision.BackgroundSubtractorKNN.html#getNSamples!/1","title":"Evision.BackgroundSubtractorKNN.getNSamples!/1","type":"function"},{"doc":"Returns the number of data samples in the background model Python prototype (for reference): getNSamples() -&gt; retval","ref":"Evision.BackgroundSubtractorKNN.html#getNSamples/1","title":"Evision.BackgroundSubtractorKNN.getNSamples/1","type":"function"},{"doc":"Raising version of getShadowThreshold/1 .","ref":"Evision.BackgroundSubtractorKNN.html#getShadowThreshold!/1","title":"Evision.BackgroundSubtractorKNN.getShadowThreshold!/1","type":"function"},{"doc":"Returns the shadow threshold A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara, Detecting Moving Shadows...*, IEEE PAMI,2003. Python prototype (for reference): getShadowThreshold() -&gt; retval","ref":"Evision.BackgroundSubtractorKNN.html#getShadowThreshold/1","title":"Evision.BackgroundSubtractorKNN.getShadowThreshold/1","type":"function"},{"doc":"Raising version of getShadowValue/1 .","ref":"Evision.BackgroundSubtractorKNN.html#getShadowValue!/1","title":"Evision.BackgroundSubtractorKNN.getShadowValue!/1","type":"function"},{"doc":"Returns the shadow value Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground. Python prototype (for reference): getShadowValue() -&gt; retval","ref":"Evision.BackgroundSubtractorKNN.html#getShadowValue/1","title":"Evision.BackgroundSubtractorKNN.getShadowValue/1","type":"function"},{"doc":"Raising version of setDetectShadows/2 .","ref":"Evision.BackgroundSubtractorKNN.html#setDetectShadows!/2","title":"Evision.BackgroundSubtractorKNN.setDetectShadows!/2","type":"function"},{"doc":"Enables or disables shadow detection Positional Arguments detectShadows : bool Python prototype (for reference): setDetectShadows(detectShadows) -&gt; None","ref":"Evision.BackgroundSubtractorKNN.html#setDetectShadows/2","title":"Evision.BackgroundSubtractorKNN.setDetectShadows/2","type":"function"},{"doc":"Raising version of setDist2Threshold/2 .","ref":"Evision.BackgroundSubtractorKNN.html#setDist2Threshold!/2","title":"Evision.BackgroundSubtractorKNN.setDist2Threshold!/2","type":"function"},{"doc":"Sets the threshold on the squared distance Positional Arguments dist2Threshold : double Python prototype (for reference): setDist2Threshold(_dist2Threshold) -&gt; None","ref":"Evision.BackgroundSubtractorKNN.html#setDist2Threshold/2","title":"Evision.BackgroundSubtractorKNN.setDist2Threshold/2","type":"function"},{"doc":"Raising version of setHistory/2 .","ref":"Evision.BackgroundSubtractorKNN.html#setHistory!/2","title":"Evision.BackgroundSubtractorKNN.setHistory!/2","type":"function"},{"doc":"Sets the number of last frames that affect the background model Positional Arguments history : int Python prototype (for reference): setHistory(history) -&gt; None","ref":"Evision.BackgroundSubtractorKNN.html#setHistory/2","title":"Evision.BackgroundSubtractorKNN.setHistory/2","type":"function"},{"doc":"Raising version of setkNNSamples/2 .","ref":"Evision.BackgroundSubtractorKNN.html#setkNNSamples!/2","title":"Evision.BackgroundSubtractorKNN.setkNNSamples!/2","type":"function"},{"doc":"Sets the k in the kNN. How many nearest neighbours need to match. Positional Arguments nkNN : int Python prototype (for reference): setkNNSamples(_nkNN) -&gt; None","ref":"Evision.BackgroundSubtractorKNN.html#setkNNSamples/2","title":"Evision.BackgroundSubtractorKNN.setkNNSamples/2","type":"function"},{"doc":"Raising version of setNSamples/2 .","ref":"Evision.BackgroundSubtractorKNN.html#setNSamples!/2","title":"Evision.BackgroundSubtractorKNN.setNSamples!/2","type":"function"},{"doc":"Sets the number of data samples in the background model. Positional Arguments nN : int The model needs to be reinitalized to reserve memory. Python prototype (for reference): setNSamples(_nN) -&gt; None","ref":"Evision.BackgroundSubtractorKNN.html#setNSamples/2","title":"Evision.BackgroundSubtractorKNN.setNSamples/2","type":"function"},{"doc":"Raising version of setShadowThreshold/2 .","ref":"Evision.BackgroundSubtractorKNN.html#setShadowThreshold!/2","title":"Evision.BackgroundSubtractorKNN.setShadowThreshold!/2","type":"function"},{"doc":"Sets the shadow threshold Positional Arguments threshold : double Python prototype (for reference): setShadowThreshold(threshold) -&gt; None","ref":"Evision.BackgroundSubtractorKNN.html#setShadowThreshold/2","title":"Evision.BackgroundSubtractorKNN.setShadowThreshold/2","type":"function"},{"doc":"Raising version of setShadowValue/2 .","ref":"Evision.BackgroundSubtractorKNN.html#setShadowValue!/2","title":"Evision.BackgroundSubtractorKNN.setShadowValue!/2","type":"function"},{"doc":"Sets the shadow value Positional Arguments value : int Python prototype (for reference): setShadowValue(value) -&gt; None","ref":"Evision.BackgroundSubtractorKNN.html#setShadowValue/2","title":"Evision.BackgroundSubtractorKNN.setShadowValue/2","type":"function"},{"doc":"","ref":"Evision.BackgroundSubtractorMOG2.html","title":"Evision.BackgroundSubtractorMOG2","type":"module"},{"doc":"Raising version of apply/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#apply!/2","title":"Evision.BackgroundSubtractorMOG2.apply!/2","type":"function"},{"doc":"Raising version of apply/3 .","ref":"Evision.BackgroundSubtractorMOG2.html#apply!/3","title":"Evision.BackgroundSubtractorMOG2.apply!/3","type":"function"},{"doc":"Computes a foreground mask. Positional Arguments image : Evision.Mat . Next video frame. Floating point frame will be used without scaling and should be in range \\f$[0,255]\\f$. Keyword Arguments learningRate : double . The value between 0 and 1 that indicates how fast the background model is learnt. Negative parameter value makes the algorithm to use some automatically chosen learning rate. 0 means that the background model is not updated at all, 1 means that the background model is completely reinitialized from the last frame. Return fgmask : Evision.Mat . The output foreground mask as an 8-bit binary image. Python prototype (for reference): apply(image[, fgmask[, learningRate]]) -&gt; fgmask","ref":"Evision.BackgroundSubtractorMOG2.html#apply/2","title":"Evision.BackgroundSubtractorMOG2.apply/2","type":"function"},{"doc":"Computes a foreground mask. Positional Arguments image : Evision.Mat . Next video frame. Floating point frame will be used without scaling and should be in range \\f$[0,255]\\f$. Keyword Arguments learningRate : double . The value between 0 and 1 that indicates how fast the background model is learnt. Negative parameter value makes the algorithm to use some automatically chosen learning rate. 0 means that the background model is not updated at all, 1 means that the background model is completely reinitialized from the last frame. Return fgmask : Evision.Mat . The output foreground mask as an 8-bit binary image. Python prototype (for reference): apply(image[, fgmask[, learningRate]]) -&gt; fgmask","ref":"Evision.BackgroundSubtractorMOG2.html#apply/3","title":"Evision.BackgroundSubtractorMOG2.apply/3","type":"function"},{"doc":"Raising version of getBackgroundRatio/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getBackgroundRatio!/1","title":"Evision.BackgroundSubtractorMOG2.getBackgroundRatio!/1","type":"function"},{"doc":"Returns the &quot;background ratio&quot; parameter of the algorithm If a foreground pixel keeps semi-constant value for about backgroundRatio*history frames, it's considered background and added to the model as a center of a new component. It corresponds to TB parameter in the paper. Python prototype (for reference): getBackgroundRatio() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getBackgroundRatio/1","title":"Evision.BackgroundSubtractorMOG2.getBackgroundRatio/1","type":"function"},{"doc":"Raising version of getComplexityReductionThreshold/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getComplexityReductionThreshold!/1","title":"Evision.BackgroundSubtractorMOG2.getComplexityReductionThreshold!/1","type":"function"},{"doc":"Returns the complexity reduction threshold This parameter defines the number of samples needed to accept to prove the component exists. CT=0.05 is a default value for all the samples. By setting CT=0 you get an algorithm very similar to the standard Stauffer&amp;Grimson algorithm. Python prototype (for reference): getComplexityReductionThreshold() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getComplexityReductionThreshold/1","title":"Evision.BackgroundSubtractorMOG2.getComplexityReductionThreshold/1","type":"function"},{"doc":"Raising version of getDetectShadows/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getDetectShadows!/1","title":"Evision.BackgroundSubtractorMOG2.getDetectShadows!/1","type":"function"},{"doc":"Returns the shadow detection flag If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorMOG2 for details. Python prototype (for reference): getDetectShadows() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getDetectShadows/1","title":"Evision.BackgroundSubtractorMOG2.getDetectShadows/1","type":"function"},{"doc":"Raising version of getHistory/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getHistory!/1","title":"Evision.BackgroundSubtractorMOG2.getHistory!/1","type":"function"},{"doc":"Returns the number of last frames that affect the background model Python prototype (for reference): getHistory() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getHistory/1","title":"Evision.BackgroundSubtractorMOG2.getHistory/1","type":"function"},{"doc":"Raising version of getNMixtures/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getNMixtures!/1","title":"Evision.BackgroundSubtractorMOG2.getNMixtures!/1","type":"function"},{"doc":"Returns the number of gaussian components in the background model Python prototype (for reference): getNMixtures() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getNMixtures/1","title":"Evision.BackgroundSubtractorMOG2.getNMixtures/1","type":"function"},{"doc":"Raising version of getShadowThreshold/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getShadowThreshold!/1","title":"Evision.BackgroundSubtractorMOG2.getShadowThreshold!/1","type":"function"},{"doc":"Returns the shadow threshold A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara, Detecting Moving Shadows...*, IEEE PAMI,2003. Python prototype (for reference): getShadowThreshold() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getShadowThreshold/1","title":"Evision.BackgroundSubtractorMOG2.getShadowThreshold/1","type":"function"},{"doc":"Raising version of getShadowValue/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getShadowValue!/1","title":"Evision.BackgroundSubtractorMOG2.getShadowValue!/1","type":"function"},{"doc":"Returns the shadow value Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground. Python prototype (for reference): getShadowValue() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getShadowValue/1","title":"Evision.BackgroundSubtractorMOG2.getShadowValue/1","type":"function"},{"doc":"Raising version of getVarInit/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getVarInit!/1","title":"Evision.BackgroundSubtractorMOG2.getVarInit!/1","type":"function"},{"doc":"Returns the initial variance of each gaussian component Python prototype (for reference): getVarInit() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getVarInit/1","title":"Evision.BackgroundSubtractorMOG2.getVarInit/1","type":"function"},{"doc":"Raising version of getVarMax/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getVarMax!/1","title":"Evision.BackgroundSubtractorMOG2.getVarMax!/1","type":"function"},{"doc":"Python prototype (for reference): getVarMax() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getVarMax/1","title":"Evision.BackgroundSubtractorMOG2.getVarMax/1","type":"function"},{"doc":"Raising version of getVarMin/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getVarMin!/1","title":"Evision.BackgroundSubtractorMOG2.getVarMin!/1","type":"function"},{"doc":"Python prototype (for reference): getVarMin() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getVarMin/1","title":"Evision.BackgroundSubtractorMOG2.getVarMin/1","type":"function"},{"doc":"Raising version of getVarThreshold/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getVarThreshold!/1","title":"Evision.BackgroundSubtractorMOG2.getVarThreshold!/1","type":"function"},{"doc":"Returns the variance threshold for the pixel-model match The main threshold on the squared Mahalanobis distance to decide if the sample is well described by the background model or not. Related to Cthr from the paper. Python prototype (for reference): getVarThreshold() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getVarThreshold/1","title":"Evision.BackgroundSubtractorMOG2.getVarThreshold/1","type":"function"},{"doc":"Raising version of getVarThresholdGen/1 .","ref":"Evision.BackgroundSubtractorMOG2.html#getVarThresholdGen!/1","title":"Evision.BackgroundSubtractorMOG2.getVarThresholdGen!/1","type":"function"},{"doc":"Returns the variance threshold for the pixel-model match used for new mixture component generation Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the existing components (corresponds to Tg in the paper). If a pixel is not close to any component, it is considered foreground or added as a new component. 3 sigma =&gt; Tg=3*3=9 is default. A smaller Tg value generates more components. A higher Tg value may result in a small number of components but they can grow too large. Python prototype (for reference): getVarThresholdGen() -&gt; retval","ref":"Evision.BackgroundSubtractorMOG2.html#getVarThresholdGen/1","title":"Evision.BackgroundSubtractorMOG2.getVarThresholdGen/1","type":"function"},{"doc":"Raising version of setBackgroundRatio/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setBackgroundRatio!/2","title":"Evision.BackgroundSubtractorMOG2.setBackgroundRatio!/2","type":"function"},{"doc":"Sets the &quot;background ratio&quot; parameter of the algorithm Positional Arguments ratio : double Python prototype (for reference): setBackgroundRatio(ratio) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setBackgroundRatio/2","title":"Evision.BackgroundSubtractorMOG2.setBackgroundRatio/2","type":"function"},{"doc":"Raising version of setComplexityReductionThreshold/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setComplexityReductionThreshold!/2","title":"Evision.BackgroundSubtractorMOG2.setComplexityReductionThreshold!/2","type":"function"},{"doc":"Sets the complexity reduction threshold Positional Arguments ct : double Python prototype (for reference): setComplexityReductionThreshold(ct) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setComplexityReductionThreshold/2","title":"Evision.BackgroundSubtractorMOG2.setComplexityReductionThreshold/2","type":"function"},{"doc":"Raising version of setDetectShadows/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setDetectShadows!/2","title":"Evision.BackgroundSubtractorMOG2.setDetectShadows!/2","type":"function"},{"doc":"Enables or disables shadow detection Positional Arguments detectShadows : bool Python prototype (for reference): setDetectShadows(detectShadows) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setDetectShadows/2","title":"Evision.BackgroundSubtractorMOG2.setDetectShadows/2","type":"function"},{"doc":"Raising version of setHistory/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setHistory!/2","title":"Evision.BackgroundSubtractorMOG2.setHistory!/2","type":"function"},{"doc":"Sets the number of last frames that affect the background model Positional Arguments history : int Python prototype (for reference): setHistory(history) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setHistory/2","title":"Evision.BackgroundSubtractorMOG2.setHistory/2","type":"function"},{"doc":"Raising version of setNMixtures/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setNMixtures!/2","title":"Evision.BackgroundSubtractorMOG2.setNMixtures!/2","type":"function"},{"doc":"Sets the number of gaussian components in the background model. Positional Arguments nmixtures : int The model needs to be reinitalized to reserve memory. Python prototype (for reference): setNMixtures(nmixtures) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setNMixtures/2","title":"Evision.BackgroundSubtractorMOG2.setNMixtures/2","type":"function"},{"doc":"Raising version of setShadowThreshold/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setShadowThreshold!/2","title":"Evision.BackgroundSubtractorMOG2.setShadowThreshold!/2","type":"function"},{"doc":"Sets the shadow threshold Positional Arguments threshold : double Python prototype (for reference): setShadowThreshold(threshold) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setShadowThreshold/2","title":"Evision.BackgroundSubtractorMOG2.setShadowThreshold/2","type":"function"},{"doc":"Raising version of setShadowValue/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setShadowValue!/2","title":"Evision.BackgroundSubtractorMOG2.setShadowValue!/2","type":"function"},{"doc":"Sets the shadow value Positional Arguments value : int Python prototype (for reference): setShadowValue(value) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setShadowValue/2","title":"Evision.BackgroundSubtractorMOG2.setShadowValue/2","type":"function"},{"doc":"Raising version of setVarInit/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setVarInit!/2","title":"Evision.BackgroundSubtractorMOG2.setVarInit!/2","type":"function"},{"doc":"Sets the initial variance of each gaussian component Positional Arguments varInit : double Python prototype (for reference): setVarInit(varInit) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setVarInit/2","title":"Evision.BackgroundSubtractorMOG2.setVarInit/2","type":"function"},{"doc":"Raising version of setVarMax/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setVarMax!/2","title":"Evision.BackgroundSubtractorMOG2.setVarMax!/2","type":"function"},{"doc":"Positional Arguments varMax : double Python prototype (for reference): setVarMax(varMax) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setVarMax/2","title":"Evision.BackgroundSubtractorMOG2.setVarMax/2","type":"function"},{"doc":"Raising version of setVarMin/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setVarMin!/2","title":"Evision.BackgroundSubtractorMOG2.setVarMin!/2","type":"function"},{"doc":"Positional Arguments varMin : double Python prototype (for reference): setVarMin(varMin) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setVarMin/2","title":"Evision.BackgroundSubtractorMOG2.setVarMin/2","type":"function"},{"doc":"Raising version of setVarThreshold/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setVarThreshold!/2","title":"Evision.BackgroundSubtractorMOG2.setVarThreshold!/2","type":"function"},{"doc":"Sets the variance threshold for the pixel-model match Positional Arguments varThreshold : double Python prototype (for reference): setVarThreshold(varThreshold) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setVarThreshold/2","title":"Evision.BackgroundSubtractorMOG2.setVarThreshold/2","type":"function"},{"doc":"Raising version of setVarThresholdGen/2 .","ref":"Evision.BackgroundSubtractorMOG2.html#setVarThresholdGen!/2","title":"Evision.BackgroundSubtractorMOG2.setVarThresholdGen!/2","type":"function"},{"doc":"Sets the variance threshold for the pixel-model match used for new mixture component generation Positional Arguments varThresholdGen : double Python prototype (for reference): setVarThresholdGen(varThresholdGen) -&gt; None","ref":"Evision.BackgroundSubtractorMOG2.html#setVarThresholdGen/2","title":"Evision.BackgroundSubtractorMOG2.setVarThresholdGen/2","type":"function"},{"doc":"","ref":"Evision.CLAHE.html","title":"Evision.CLAHE","type":"module"},{"doc":"Raising version of apply/2 .","ref":"Evision.CLAHE.html#apply!/2","title":"Evision.CLAHE.apply!/2","type":"function"},{"doc":"Raising version of apply/3 .","ref":"Evision.CLAHE.html#apply!/3","title":"Evision.CLAHE.apply!/3","type":"function"},{"doc":"Equalizes the histogram of a grayscale image using Contrast Limited Adaptive Histogram Equalization. Positional Arguments src : Evision.Mat . Source image of type CV_8UC1 or CV_16UC1. Return dst : Evision.Mat . Destination image. Python prototype (for reference): apply(src[, dst]) -&gt; dst","ref":"Evision.CLAHE.html#apply/2","title":"Evision.CLAHE.apply/2","type":"function"},{"doc":"Equalizes the histogram of a grayscale image using Contrast Limited Adaptive Histogram Equalization. Positional Arguments src : Evision.Mat . Source image of type CV_8UC1 or CV_16UC1. Return dst : Evision.Mat . Destination image. Python prototype (for reference): apply(src[, dst]) -&gt; dst","ref":"Evision.CLAHE.html#apply/3","title":"Evision.CLAHE.apply/3","type":"function"},{"doc":"Raising version of collectGarbage/1 .","ref":"Evision.CLAHE.html#collectGarbage!/1","title":"Evision.CLAHE.collectGarbage!/1","type":"function"},{"doc":"Python prototype (for reference): collectGarbage() -&gt; None","ref":"Evision.CLAHE.html#collectGarbage/1","title":"Evision.CLAHE.collectGarbage/1","type":"function"},{"doc":"Raising version of getClipLimit/1 .","ref":"Evision.CLAHE.html#getClipLimit!/1","title":"Evision.CLAHE.getClipLimit!/1","type":"function"},{"doc":"Python prototype (for reference): getClipLimit() -&gt; retval","ref":"Evision.CLAHE.html#getClipLimit/1","title":"Evision.CLAHE.getClipLimit/1","type":"function"},{"doc":"Raising version of getTilesGridSize/1 .","ref":"Evision.CLAHE.html#getTilesGridSize!/1","title":"Evision.CLAHE.getTilesGridSize!/1","type":"function"},{"doc":"Python prototype (for reference): getTilesGridSize() -&gt; retval","ref":"Evision.CLAHE.html#getTilesGridSize/1","title":"Evision.CLAHE.getTilesGridSize/1","type":"function"},{"doc":"Raising version of setClipLimit/2 .","ref":"Evision.CLAHE.html#setClipLimit!/2","title":"Evision.CLAHE.setClipLimit!/2","type":"function"},{"doc":"Sets threshold for contrast limiting. Positional Arguments clipLimit : double . threshold value. Python prototype (for reference): setClipLimit(clipLimit) -&gt; None","ref":"Evision.CLAHE.html#setClipLimit/2","title":"Evision.CLAHE.setClipLimit/2","type":"function"},{"doc":"Raising version of setTilesGridSize/2 .","ref":"Evision.CLAHE.html#setTilesGridSize!/2","title":"Evision.CLAHE.setTilesGridSize!/2","type":"function"},{"doc":"Sets size of grid for histogram equalization. Input image will be divided into equally sized rectangular tiles. Positional Arguments tileGridSize : Size . defines the number of tiles in row and column. Python prototype (for reference): setTilesGridSize(tileGridSize) -&gt; None","ref":"Evision.CLAHE.html#setTilesGridSize/2","title":"Evision.CLAHE.setTilesGridSize/2","type":"function"},{"doc":"","ref":"Evision.CUDA.html","title":"Evision.CUDA","type":"module"},{"doc":"Raising version of createContinuous/3 .","ref":"Evision.CUDA.html#createContinuous!/3","title":"Evision.CUDA.createContinuous!/3","type":"function"},{"doc":"Raising version of createContinuous/4 .","ref":"Evision.CUDA.html#createContinuous!/4","title":"Evision.CUDA.createContinuous!/4","type":"function"},{"doc":"Creates a continuous matrix. Positional Arguments rows : int . Row count. cols : int . Column count. type : int . Type of the matrix. Return arr : Evision.Mat . Destination matrix. This parameter changes only if it has a proper type and area ( \\f$\\texttt{rows} \\times \\texttt{cols}\\f$ ). Matrix is called continuous if its elements are stored continuously, that is, without gaps at the end of each row. Python prototype (for reference): createContinuous(rows, cols, type[, arr]) -&gt; arr","ref":"Evision.CUDA.html#createContinuous/3","title":"Evision.CUDA.createContinuous/3","type":"function"},{"doc":"Creates a continuous matrix. Positional Arguments rows : int . Row count. cols : int . Column count. type : int . Type of the matrix. Return arr : Evision.Mat . Destination matrix. This parameter changes only if it has a proper type and area ( \\f$\\texttt{rows} \\times \\texttt{cols}\\f$ ). Matrix is called continuous if its elements are stored continuously, that is, without gaps at the end of each row. Python prototype (for reference): createContinuous(rows, cols, type[, arr]) -&gt; arr","ref":"Evision.CUDA.html#createContinuous/4","title":"Evision.CUDA.createContinuous/4","type":"function"},{"doc":"Raising version of ensureSizeIsEnough/3 .","ref":"Evision.CUDA.html#ensureSizeIsEnough!/3","title":"Evision.CUDA.ensureSizeIsEnough!/3","type":"function"},{"doc":"Raising version of ensureSizeIsEnough/4 .","ref":"Evision.CUDA.html#ensureSizeIsEnough!/4","title":"Evision.CUDA.ensureSizeIsEnough!/4","type":"function"},{"doc":"Ensures that the size of a matrix is big enough and the matrix has a proper type. Positional Arguments rows : int . Minimum desired number of rows. cols : int . Minimum desired number of columns. type : int . Desired matrix type. Return arr : Evision.Mat . Destination matrix. The function does not reallocate memory if the matrix has proper attributes already. Python prototype (for reference): ensureSizeIsEnough(rows, cols, type[, arr]) -&gt; arr","ref":"Evision.CUDA.html#ensureSizeIsEnough/3","title":"Evision.CUDA.ensureSizeIsEnough/3","type":"function"},{"doc":"Ensures that the size of a matrix is big enough and the matrix has a proper type. Positional Arguments rows : int . Minimum desired number of rows. cols : int . Minimum desired number of columns. type : int . Desired matrix type. Return arr : Evision.Mat . Destination matrix. The function does not reallocate memory if the matrix has proper attributes already. Python prototype (for reference): ensureSizeIsEnough(rows, cols, type[, arr]) -&gt; arr","ref":"Evision.CUDA.html#ensureSizeIsEnough/4","title":"Evision.CUDA.ensureSizeIsEnough/4","type":"function"},{"doc":"Raising version of getCudaEnabledDeviceCount/0 .","ref":"Evision.CUDA.html#getCudaEnabledDeviceCount!/0","title":"Evision.CUDA.getCudaEnabledDeviceCount!/0","type":"function"},{"doc":"Returns the number of installed CUDA-enabled devices. Use this function before any other CUDA functions calls. If OpenCV is compiled without CUDA support, this function returns 0. If the CUDA driver is not installed, or is incompatible, this function returns -1. Python prototype (for reference): getCudaEnabledDeviceCount() -&gt; retval","ref":"Evision.CUDA.html#getCudaEnabledDeviceCount/0","title":"Evision.CUDA.getCudaEnabledDeviceCount/0","type":"function"},{"doc":"Raising version of getDevice/0 .","ref":"Evision.CUDA.html#getDevice!/0","title":"Evision.CUDA.getDevice!/0","type":"function"},{"doc":"Returns the current device index set by cuda::setDevice or initialized by default. Python prototype (for reference): getDevice() -&gt; retval","ref":"Evision.CUDA.html#getDevice/0","title":"Evision.CUDA.getDevice/0","type":"function"},{"doc":"Raising version of printCudaDeviceInfo/1 .","ref":"Evision.CUDA.html#printCudaDeviceInfo!/1","title":"Evision.CUDA.printCudaDeviceInfo!/1","type":"function"},{"doc":"Positional Arguments device : int Python prototype (for reference): printCudaDeviceInfo(device) -&gt; None","ref":"Evision.CUDA.html#printCudaDeviceInfo/1","title":"Evision.CUDA.printCudaDeviceInfo/1","type":"function"},{"doc":"Raising version of printShortCudaDeviceInfo/1 .","ref":"Evision.CUDA.html#printShortCudaDeviceInfo!/1","title":"Evision.CUDA.printShortCudaDeviceInfo!/1","type":"function"},{"doc":"Positional Arguments device : int Python prototype (for reference): printShortCudaDeviceInfo(device) -&gt; None","ref":"Evision.CUDA.html#printShortCudaDeviceInfo/1","title":"Evision.CUDA.printShortCudaDeviceInfo/1","type":"function"},{"doc":"Raising version of registerPageLocked/1 .","ref":"Evision.CUDA.html#registerPageLocked!/1","title":"Evision.CUDA.registerPageLocked!/1","type":"function"},{"doc":"Page-locks the memory of matrix and maps it for the device(s). Positional Arguments m : Evision.Mat . Input matrix. Python prototype (for reference): registerPageLocked(m) -&gt; None","ref":"Evision.CUDA.html#registerPageLocked/1","title":"Evision.CUDA.registerPageLocked/1","type":"function"},{"doc":"Raising version of resetDevice/0 .","ref":"Evision.CUDA.html#resetDevice!/0","title":"Evision.CUDA.resetDevice!/0","type":"function"},{"doc":"Explicitly destroys and cleans up all resources associated with the current device in the current process. Any subsequent API call to this device will reinitialize the device. Python prototype (for reference): resetDevice() -&gt; None","ref":"Evision.CUDA.html#resetDevice/0","title":"Evision.CUDA.resetDevice/0","type":"function"},{"doc":"Raising version of setBufferPoolConfig/3 .","ref":"Evision.CUDA.html#setBufferPoolConfig!/3","title":"Evision.CUDA.setBufferPoolConfig!/3","type":"function"},{"doc":"Positional Arguments deviceId : int stackSize : size_t stackCount : int Python prototype (for reference): setBufferPoolConfig(deviceId, stackSize, stackCount) -&gt; None","ref":"Evision.CUDA.html#setBufferPoolConfig/3","title":"Evision.CUDA.setBufferPoolConfig/3","type":"function"},{"doc":"Raising version of setBufferPoolUsage/1 .","ref":"Evision.CUDA.html#setBufferPoolUsage!/1","title":"Evision.CUDA.setBufferPoolUsage!/1","type":"function"},{"doc":"Positional Arguments on : bool Python prototype (for reference): setBufferPoolUsage(on) -&gt; None","ref":"Evision.CUDA.html#setBufferPoolUsage/1","title":"Evision.CUDA.setBufferPoolUsage/1","type":"function"},{"doc":"Raising version of setDevice/1 .","ref":"Evision.CUDA.html#setDevice!/1","title":"Evision.CUDA.setDevice!/1","type":"function"},{"doc":"Sets a device and initializes it for the current thread. Positional Arguments device : int . System index of a CUDA device starting with 0. If the call of this function is omitted, a default device is initialized at the fist CUDA usage. Python prototype (for reference): setDevice(device) -&gt; None","ref":"Evision.CUDA.html#setDevice/1","title":"Evision.CUDA.setDevice/1","type":"function"},{"doc":"Raising version of unregisterPageLocked/1 .","ref":"Evision.CUDA.html#unregisterPageLocked!/1","title":"Evision.CUDA.unregisterPageLocked!/1","type":"function"},{"doc":"Unmaps the memory of matrix and makes it pageable again. Positional Arguments m : Evision.Mat . Input matrix. Python prototype (for reference): unregisterPageLocked(m) -&gt; None","ref":"Evision.CUDA.html#unregisterPageLocked/1","title":"Evision.CUDA.unregisterPageLocked/1","type":"function"},{"doc":"","ref":"Evision.CUDA.BufferPool.html","title":"Evision.CUDA.BufferPool","type":"module"},{"doc":"Raising version of cuda_BufferPool/1 .","ref":"Evision.CUDA.BufferPool.html#cuda_BufferPool!/1","title":"Evision.CUDA.BufferPool.cuda_BufferPool!/1","type":"function"},{"doc":"Positional Arguments stream : Stream Python prototype (for reference): BufferPool(stream) -&gt; &lt;cuda_BufferPool object&gt;","ref":"Evision.CUDA.BufferPool.html#cuda_BufferPool/1","title":"Evision.CUDA.BufferPool.cuda_BufferPool/1","type":"function"},{"doc":"Raising version of getAllocator/1 .","ref":"Evision.CUDA.BufferPool.html#getAllocator!/1","title":"Evision.CUDA.BufferPool.getAllocator!/1","type":"function"},{"doc":"Python prototype (for reference): getAllocator() -&gt; retval","ref":"Evision.CUDA.BufferPool.html#getAllocator/1","title":"Evision.CUDA.BufferPool.getAllocator/1","type":"function"},{"doc":"Raising version of getBuffer/3 .","ref":"Evision.CUDA.BufferPool.html#getBuffer!/3","title":"Evision.CUDA.BufferPool.getBuffer!/3","type":"function"},{"doc":"Raising version of getBuffer/4 .","ref":"Evision.CUDA.BufferPool.html#getBuffer!/4","title":"Evision.CUDA.BufferPool.getBuffer!/4","type":"function"},{"doc":"Positional Arguments size : Size type : int Python prototype (for reference): getBuffer(size, type) -&gt; retval","ref":"Evision.CUDA.BufferPool.html#getBuffer/3","title":"Evision.CUDA.BufferPool.getBuffer/3","type":"function"},{"doc":"Positional Arguments rows : int cols : int type : int Python prototype (for reference): getBuffer(rows, cols, type) -&gt; retval","ref":"Evision.CUDA.BufferPool.html#getBuffer/4","title":"Evision.CUDA.BufferPool.getBuffer/4","type":"function"},{"doc":"","ref":"Evision.CUDA.DeviceInfo.html","title":"Evision.CUDA.DeviceInfo","type":"module"},{"doc":"Raising version of asyncEngineCount/1 .","ref":"Evision.CUDA.DeviceInfo.html#asyncEngineCount!/1","title":"Evision.CUDA.DeviceInfo.asyncEngineCount!/1","type":"function"},{"doc":"Python prototype (for reference): asyncEngineCount() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#asyncEngineCount/1","title":"Evision.CUDA.DeviceInfo.asyncEngineCount/1","type":"function"},{"doc":"Raising version of canMapHostMemory/1 .","ref":"Evision.CUDA.DeviceInfo.html#canMapHostMemory!/1","title":"Evision.CUDA.DeviceInfo.canMapHostMemory!/1","type":"function"},{"doc":"Python prototype (for reference): canMapHostMemory() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#canMapHostMemory/1","title":"Evision.CUDA.DeviceInfo.canMapHostMemory/1","type":"function"},{"doc":"Raising version of clockRate/1 .","ref":"Evision.CUDA.DeviceInfo.html#clockRate!/1","title":"Evision.CUDA.DeviceInfo.clockRate!/1","type":"function"},{"doc":"Python prototype (for reference): clockRate() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#clockRate/1","title":"Evision.CUDA.DeviceInfo.clockRate/1","type":"function"},{"doc":"Raising version of computeMode/1 .","ref":"Evision.CUDA.DeviceInfo.html#computeMode!/1","title":"Evision.CUDA.DeviceInfo.computeMode!/1","type":"function"},{"doc":"Python prototype (for reference): computeMode() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#computeMode/1","title":"Evision.CUDA.DeviceInfo.computeMode/1","type":"function"},{"doc":"Raising version of concurrentKernels/1 .","ref":"Evision.CUDA.DeviceInfo.html#concurrentKernels!/1","title":"Evision.CUDA.DeviceInfo.concurrentKernels!/1","type":"function"},{"doc":"Python prototype (for reference): concurrentKernels() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#concurrentKernels/1","title":"Evision.CUDA.DeviceInfo.concurrentKernels/1","type":"function"},{"doc":"Raising version of cuda_DeviceInfo/0 .","ref":"Evision.CUDA.DeviceInfo.html#cuda_DeviceInfo!/0","title":"Evision.CUDA.DeviceInfo.cuda_DeviceInfo!/0","type":"function"},{"doc":"Raising version of cuda_DeviceInfo/1 .","ref":"Evision.CUDA.DeviceInfo.html#cuda_DeviceInfo!/1","title":"Evision.CUDA.DeviceInfo.cuda_DeviceInfo!/1","type":"function"},{"doc":"Python prototype (for reference): DeviceInfo() -&gt; &lt;cuda_DeviceInfo object&gt;","ref":"Evision.CUDA.DeviceInfo.html#cuda_DeviceInfo/0","title":"Evision.CUDA.DeviceInfo.cuda_DeviceInfo/0","type":"function"},{"doc":"The constructors. Positional Arguments device_id : int . System index of the CUDA device starting with 0. Constructs the DeviceInfo object for the specified device. If device_id parameter is missed, it constructs an object for the current device. Python prototype (for reference): DeviceInfo(device_id) -&gt; &lt;cuda_DeviceInfo object&gt;","ref":"Evision.CUDA.DeviceInfo.html#cuda_DeviceInfo/1","title":"Evision.CUDA.DeviceInfo.cuda_DeviceInfo/1","type":"function"},{"doc":"Raising version of deviceID/1 .","ref":"Evision.CUDA.DeviceInfo.html#deviceID!/1","title":"Evision.CUDA.DeviceInfo.deviceID!/1","type":"function"},{"doc":"Returns system index of the CUDA device starting with 0. Python prototype (for reference): deviceID() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#deviceID/1","title":"Evision.CUDA.DeviceInfo.deviceID/1","type":"function"},{"doc":"Raising version of eccEnabled/1 .","ref":"Evision.CUDA.DeviceInfo.html#eccEnabled!/1","title":"Evision.CUDA.DeviceInfo.eccEnabled!/1","type":"function"},{"doc":"Python prototype (for reference): ECCEnabled() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#eccEnabled/1","title":"Evision.CUDA.DeviceInfo.eccEnabled/1","type":"function"},{"doc":"Raising version of freeMemory/1 .","ref":"Evision.CUDA.DeviceInfo.html#freeMemory!/1","title":"Evision.CUDA.DeviceInfo.freeMemory!/1","type":"function"},{"doc":"Python prototype (for reference): freeMemory() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#freeMemory/1","title":"Evision.CUDA.DeviceInfo.freeMemory/1","type":"function"},{"doc":"Raising version of integrated/1 .","ref":"Evision.CUDA.DeviceInfo.html#integrated!/1","title":"Evision.CUDA.DeviceInfo.integrated!/1","type":"function"},{"doc":"Python prototype (for reference): integrated() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#integrated/1","title":"Evision.CUDA.DeviceInfo.integrated/1","type":"function"},{"doc":"Raising version of isCompatible/1 .","ref":"Evision.CUDA.DeviceInfo.html#isCompatible!/1","title":"Evision.CUDA.DeviceInfo.isCompatible!/1","type":"function"},{"doc":"Checks the CUDA module and device compatibility. This function returns true if the CUDA module can be run on the specified device. Otherwise, it returns false . Python prototype (for reference): isCompatible() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#isCompatible/1","title":"Evision.CUDA.DeviceInfo.isCompatible/1","type":"function"},{"doc":"Raising version of kernelExecTimeoutEnabled/1 .","ref":"Evision.CUDA.DeviceInfo.html#kernelExecTimeoutEnabled!/1","title":"Evision.CUDA.DeviceInfo.kernelExecTimeoutEnabled!/1","type":"function"},{"doc":"Python prototype (for reference): kernelExecTimeoutEnabled() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#kernelExecTimeoutEnabled/1","title":"Evision.CUDA.DeviceInfo.kernelExecTimeoutEnabled/1","type":"function"},{"doc":"Raising version of l2CacheSize/1 .","ref":"Evision.CUDA.DeviceInfo.html#l2CacheSize!/1","title":"Evision.CUDA.DeviceInfo.l2CacheSize!/1","type":"function"},{"doc":"Python prototype (for reference): l2CacheSize() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#l2CacheSize/1","title":"Evision.CUDA.DeviceInfo.l2CacheSize/1","type":"function"},{"doc":"Raising version of majorVersion/1 .","ref":"Evision.CUDA.DeviceInfo.html#majorVersion!/1","title":"Evision.CUDA.DeviceInfo.majorVersion!/1","type":"function"},{"doc":"Python prototype (for reference): majorVersion() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#majorVersion/1","title":"Evision.CUDA.DeviceInfo.majorVersion/1","type":"function"},{"doc":"Raising version of maxGridSize/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxGridSize!/1","title":"Evision.CUDA.DeviceInfo.maxGridSize!/1","type":"function"},{"doc":"Python prototype (for reference): maxGridSize() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxGridSize/1","title":"Evision.CUDA.DeviceInfo.maxGridSize/1","type":"function"},{"doc":"Raising version of maxSurface1D/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxSurface1D!/1","title":"Evision.CUDA.DeviceInfo.maxSurface1D!/1","type":"function"},{"doc":"Python prototype (for reference): maxSurface1D() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxSurface1D/1","title":"Evision.CUDA.DeviceInfo.maxSurface1D/1","type":"function"},{"doc":"Raising version of maxSurface1DLayered/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxSurface1DLayered!/1","title":"Evision.CUDA.DeviceInfo.maxSurface1DLayered!/1","type":"function"},{"doc":"Python prototype (for reference): maxSurface1DLayered() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxSurface1DLayered/1","title":"Evision.CUDA.DeviceInfo.maxSurface1DLayered/1","type":"function"},{"doc":"Raising version of maxSurface2D/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxSurface2D!/1","title":"Evision.CUDA.DeviceInfo.maxSurface2D!/1","type":"function"},{"doc":"Python prototype (for reference): maxSurface2D() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxSurface2D/1","title":"Evision.CUDA.DeviceInfo.maxSurface2D/1","type":"function"},{"doc":"Raising version of maxSurface2DLayered/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxSurface2DLayered!/1","title":"Evision.CUDA.DeviceInfo.maxSurface2DLayered!/1","type":"function"},{"doc":"Python prototype (for reference): maxSurface2DLayered() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxSurface2DLayered/1","title":"Evision.CUDA.DeviceInfo.maxSurface2DLayered/1","type":"function"},{"doc":"Raising version of maxSurface3D/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxSurface3D!/1","title":"Evision.CUDA.DeviceInfo.maxSurface3D!/1","type":"function"},{"doc":"Python prototype (for reference): maxSurface3D() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxSurface3D/1","title":"Evision.CUDA.DeviceInfo.maxSurface3D/1","type":"function"},{"doc":"Raising version of maxSurfaceCubemap/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxSurfaceCubemap!/1","title":"Evision.CUDA.DeviceInfo.maxSurfaceCubemap!/1","type":"function"},{"doc":"Python prototype (for reference): maxSurfaceCubemap() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxSurfaceCubemap/1","title":"Evision.CUDA.DeviceInfo.maxSurfaceCubemap/1","type":"function"},{"doc":"Raising version of maxSurfaceCubemapLayered/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxSurfaceCubemapLayered!/1","title":"Evision.CUDA.DeviceInfo.maxSurfaceCubemapLayered!/1","type":"function"},{"doc":"Python prototype (for reference): maxSurfaceCubemapLayered() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxSurfaceCubemapLayered/1","title":"Evision.CUDA.DeviceInfo.maxSurfaceCubemapLayered/1","type":"function"},{"doc":"Raising version of maxTexture1D/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1D!/1","title":"Evision.CUDA.DeviceInfo.maxTexture1D!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture1D() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1D/1","title":"Evision.CUDA.DeviceInfo.maxTexture1D/1","type":"function"},{"doc":"Raising version of maxTexture1DLayered/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1DLayered!/1","title":"Evision.CUDA.DeviceInfo.maxTexture1DLayered!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture1DLayered() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1DLayered/1","title":"Evision.CUDA.DeviceInfo.maxTexture1DLayered/1","type":"function"},{"doc":"Raising version of maxTexture1DLinear/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1DLinear!/1","title":"Evision.CUDA.DeviceInfo.maxTexture1DLinear!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture1DLinear() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1DLinear/1","title":"Evision.CUDA.DeviceInfo.maxTexture1DLinear/1","type":"function"},{"doc":"Raising version of maxTexture1DMipmap/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1DMipmap!/1","title":"Evision.CUDA.DeviceInfo.maxTexture1DMipmap!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture1DMipmap() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture1DMipmap/1","title":"Evision.CUDA.DeviceInfo.maxTexture1DMipmap/1","type":"function"},{"doc":"Raising version of maxTexture2D/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2D!/1","title":"Evision.CUDA.DeviceInfo.maxTexture2D!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture2D() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2D/1","title":"Evision.CUDA.DeviceInfo.maxTexture2D/1","type":"function"},{"doc":"Raising version of maxTexture2DGather/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DGather!/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DGather!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture2DGather() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DGather/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DGather/1","type":"function"},{"doc":"Raising version of maxTexture2DLayered/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DLayered!/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DLayered!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture2DLayered() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DLayered/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DLayered/1","type":"function"},{"doc":"Raising version of maxTexture2DLinear/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DLinear!/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DLinear!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture2DLinear() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DLinear/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DLinear/1","type":"function"},{"doc":"Raising version of maxTexture2DMipmap/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DMipmap!/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DMipmap!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture2DMipmap() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture2DMipmap/1","title":"Evision.CUDA.DeviceInfo.maxTexture2DMipmap/1","type":"function"},{"doc":"Raising version of maxTexture3D/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTexture3D!/1","title":"Evision.CUDA.DeviceInfo.maxTexture3D!/1","type":"function"},{"doc":"Python prototype (for reference): maxTexture3D() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTexture3D/1","title":"Evision.CUDA.DeviceInfo.maxTexture3D/1","type":"function"},{"doc":"Raising version of maxTextureCubemap/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTextureCubemap!/1","title":"Evision.CUDA.DeviceInfo.maxTextureCubemap!/1","type":"function"},{"doc":"Python prototype (for reference): maxTextureCubemap() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTextureCubemap/1","title":"Evision.CUDA.DeviceInfo.maxTextureCubemap/1","type":"function"},{"doc":"Raising version of maxTextureCubemapLayered/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxTextureCubemapLayered!/1","title":"Evision.CUDA.DeviceInfo.maxTextureCubemapLayered!/1","type":"function"},{"doc":"Python prototype (for reference): maxTextureCubemapLayered() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxTextureCubemapLayered/1","title":"Evision.CUDA.DeviceInfo.maxTextureCubemapLayered/1","type":"function"},{"doc":"Raising version of maxThreadsDim/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxThreadsDim!/1","title":"Evision.CUDA.DeviceInfo.maxThreadsDim!/1","type":"function"},{"doc":"Python prototype (for reference): maxThreadsDim() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxThreadsDim/1","title":"Evision.CUDA.DeviceInfo.maxThreadsDim/1","type":"function"},{"doc":"Raising version of maxThreadsPerBlock/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxThreadsPerBlock!/1","title":"Evision.CUDA.DeviceInfo.maxThreadsPerBlock!/1","type":"function"},{"doc":"Python prototype (for reference): maxThreadsPerBlock() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxThreadsPerBlock/1","title":"Evision.CUDA.DeviceInfo.maxThreadsPerBlock/1","type":"function"},{"doc":"Raising version of maxThreadsPerMultiProcessor/1 .","ref":"Evision.CUDA.DeviceInfo.html#maxThreadsPerMultiProcessor!/1","title":"Evision.CUDA.DeviceInfo.maxThreadsPerMultiProcessor!/1","type":"function"},{"doc":"Python prototype (for reference): maxThreadsPerMultiProcessor() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#maxThreadsPerMultiProcessor/1","title":"Evision.CUDA.DeviceInfo.maxThreadsPerMultiProcessor/1","type":"function"},{"doc":"Raising version of memoryBusWidth/1 .","ref":"Evision.CUDA.DeviceInfo.html#memoryBusWidth!/1","title":"Evision.CUDA.DeviceInfo.memoryBusWidth!/1","type":"function"},{"doc":"Python prototype (for reference): memoryBusWidth() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#memoryBusWidth/1","title":"Evision.CUDA.DeviceInfo.memoryBusWidth/1","type":"function"},{"doc":"Raising version of memoryClockRate/1 .","ref":"Evision.CUDA.DeviceInfo.html#memoryClockRate!/1","title":"Evision.CUDA.DeviceInfo.memoryClockRate!/1","type":"function"},{"doc":"Python prototype (for reference): memoryClockRate() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#memoryClockRate/1","title":"Evision.CUDA.DeviceInfo.memoryClockRate/1","type":"function"},{"doc":"Raising version of memPitch/1 .","ref":"Evision.CUDA.DeviceInfo.html#memPitch!/1","title":"Evision.CUDA.DeviceInfo.memPitch!/1","type":"function"},{"doc":"Python prototype (for reference): memPitch() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#memPitch/1","title":"Evision.CUDA.DeviceInfo.memPitch/1","type":"function"},{"doc":"Raising version of minorVersion/1 .","ref":"Evision.CUDA.DeviceInfo.html#minorVersion!/1","title":"Evision.CUDA.DeviceInfo.minorVersion!/1","type":"function"},{"doc":"Python prototype (for reference): minorVersion() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#minorVersion/1","title":"Evision.CUDA.DeviceInfo.minorVersion/1","type":"function"},{"doc":"Raising version of multiProcessorCount/1 .","ref":"Evision.CUDA.DeviceInfo.html#multiProcessorCount!/1","title":"Evision.CUDA.DeviceInfo.multiProcessorCount!/1","type":"function"},{"doc":"Python prototype (for reference): multiProcessorCount() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#multiProcessorCount/1","title":"Evision.CUDA.DeviceInfo.multiProcessorCount/1","type":"function"},{"doc":"Raising version of pciBusID/1 .","ref":"Evision.CUDA.DeviceInfo.html#pciBusID!/1","title":"Evision.CUDA.DeviceInfo.pciBusID!/1","type":"function"},{"doc":"Python prototype (for reference): pciBusID() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#pciBusID/1","title":"Evision.CUDA.DeviceInfo.pciBusID/1","type":"function"},{"doc":"Raising version of pciDeviceID/1 .","ref":"Evision.CUDA.DeviceInfo.html#pciDeviceID!/1","title":"Evision.CUDA.DeviceInfo.pciDeviceID!/1","type":"function"},{"doc":"Python prototype (for reference): pciDeviceID() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#pciDeviceID/1","title":"Evision.CUDA.DeviceInfo.pciDeviceID/1","type":"function"},{"doc":"Raising version of pciDomainID/1 .","ref":"Evision.CUDA.DeviceInfo.html#pciDomainID!/1","title":"Evision.CUDA.DeviceInfo.pciDomainID!/1","type":"function"},{"doc":"Python prototype (for reference): pciDomainID() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#pciDomainID/1","title":"Evision.CUDA.DeviceInfo.pciDomainID/1","type":"function"},{"doc":"Raising version of queryMemory/3 .","ref":"Evision.CUDA.DeviceInfo.html#queryMemory!/3","title":"Evision.CUDA.DeviceInfo.queryMemory!/3","type":"function"},{"doc":"Positional Arguments totalMemory : size_t freeMemory : size_t Python prototype (for reference): queryMemory(totalMemory, freeMemory) -&gt; None","ref":"Evision.CUDA.DeviceInfo.html#queryMemory/3","title":"Evision.CUDA.DeviceInfo.queryMemory/3","type":"function"},{"doc":"Raising version of regsPerBlock/1 .","ref":"Evision.CUDA.DeviceInfo.html#regsPerBlock!/1","title":"Evision.CUDA.DeviceInfo.regsPerBlock!/1","type":"function"},{"doc":"Python prototype (for reference): regsPerBlock() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#regsPerBlock/1","title":"Evision.CUDA.DeviceInfo.regsPerBlock/1","type":"function"},{"doc":"Raising version of sharedMemPerBlock/1 .","ref":"Evision.CUDA.DeviceInfo.html#sharedMemPerBlock!/1","title":"Evision.CUDA.DeviceInfo.sharedMemPerBlock!/1","type":"function"},{"doc":"Python prototype (for reference): sharedMemPerBlock() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#sharedMemPerBlock/1","title":"Evision.CUDA.DeviceInfo.sharedMemPerBlock/1","type":"function"},{"doc":"Raising version of surfaceAlignment/1 .","ref":"Evision.CUDA.DeviceInfo.html#surfaceAlignment!/1","title":"Evision.CUDA.DeviceInfo.surfaceAlignment!/1","type":"function"},{"doc":"Python prototype (for reference): surfaceAlignment() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#surfaceAlignment/1","title":"Evision.CUDA.DeviceInfo.surfaceAlignment/1","type":"function"},{"doc":"Raising version of tccDriver/1 .","ref":"Evision.CUDA.DeviceInfo.html#tccDriver!/1","title":"Evision.CUDA.DeviceInfo.tccDriver!/1","type":"function"},{"doc":"Python prototype (for reference): tccDriver() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#tccDriver/1","title":"Evision.CUDA.DeviceInfo.tccDriver/1","type":"function"},{"doc":"Raising version of textureAlignment/1 .","ref":"Evision.CUDA.DeviceInfo.html#textureAlignment!/1","title":"Evision.CUDA.DeviceInfo.textureAlignment!/1","type":"function"},{"doc":"Python prototype (for reference): textureAlignment() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#textureAlignment/1","title":"Evision.CUDA.DeviceInfo.textureAlignment/1","type":"function"},{"doc":"Raising version of texturePitchAlignment/1 .","ref":"Evision.CUDA.DeviceInfo.html#texturePitchAlignment!/1","title":"Evision.CUDA.DeviceInfo.texturePitchAlignment!/1","type":"function"},{"doc":"Python prototype (for reference): texturePitchAlignment() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#texturePitchAlignment/1","title":"Evision.CUDA.DeviceInfo.texturePitchAlignment/1","type":"function"},{"doc":"Raising version of totalConstMem/1 .","ref":"Evision.CUDA.DeviceInfo.html#totalConstMem!/1","title":"Evision.CUDA.DeviceInfo.totalConstMem!/1","type":"function"},{"doc":"Python prototype (for reference): totalConstMem() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#totalConstMem/1","title":"Evision.CUDA.DeviceInfo.totalConstMem/1","type":"function"},{"doc":"Raising version of totalGlobalMem/1 .","ref":"Evision.CUDA.DeviceInfo.html#totalGlobalMem!/1","title":"Evision.CUDA.DeviceInfo.totalGlobalMem!/1","type":"function"},{"doc":"Python prototype (for reference): totalGlobalMem() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#totalGlobalMem/1","title":"Evision.CUDA.DeviceInfo.totalGlobalMem/1","type":"function"},{"doc":"Raising version of totalMemory/1 .","ref":"Evision.CUDA.DeviceInfo.html#totalMemory!/1","title":"Evision.CUDA.DeviceInfo.totalMemory!/1","type":"function"},{"doc":"Python prototype (for reference): totalMemory() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#totalMemory/1","title":"Evision.CUDA.DeviceInfo.totalMemory/1","type":"function"},{"doc":"Raising version of unifiedAddressing/1 .","ref":"Evision.CUDA.DeviceInfo.html#unifiedAddressing!/1","title":"Evision.CUDA.DeviceInfo.unifiedAddressing!/1","type":"function"},{"doc":"Python prototype (for reference): unifiedAddressing() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#unifiedAddressing/1","title":"Evision.CUDA.DeviceInfo.unifiedAddressing/1","type":"function"},{"doc":"Raising version of warpSize/1 .","ref":"Evision.CUDA.DeviceInfo.html#warpSize!/1","title":"Evision.CUDA.DeviceInfo.warpSize!/1","type":"function"},{"doc":"Python prototype (for reference): warpSize() -&gt; retval","ref":"Evision.CUDA.DeviceInfo.html#warpSize/1","title":"Evision.CUDA.DeviceInfo.warpSize/1","type":"function"},{"doc":"","ref":"Evision.CUDA.Event.html","title":"Evision.CUDA.Event","type":"module"},{"doc":"Raising version of cuda_Event/0 .","ref":"Evision.CUDA.Event.html#cuda_Event!/0","title":"Evision.CUDA.Event.cuda_Event!/0","type":"function"},{"doc":"Raising version of cuda_Event/1 .","ref":"Evision.CUDA.Event.html#cuda_Event!/1","title":"Evision.CUDA.Event.cuda_Event!/1","type":"function"},{"doc":"##### Keyword Arguments flags : Event_CreateFlags . Python prototype (for reference): Event([, flags]) -&gt; &lt;cuda_Event object&gt;","ref":"Evision.CUDA.Event.html#cuda_Event/0","title":"Evision.CUDA.Event.cuda_Event/0","type":"function"},{"doc":"##### Keyword Arguments flags : Event_CreateFlags . Python prototype (for reference): Event([, flags]) -&gt; &lt;cuda_Event object&gt;","ref":"Evision.CUDA.Event.html#cuda_Event/1","title":"Evision.CUDA.Event.cuda_Event/1","type":"function"},{"doc":"Raising version of elapsedTime/2 .","ref":"Evision.CUDA.Event.html#elapsedTime!/2","title":"Evision.CUDA.Event.elapsedTime!/2","type":"function"},{"doc":"Positional Arguments start : Event end_ : Event Python prototype (for reference): elapsedTime(start, end_) -&gt; retval","ref":"Evision.CUDA.Event.html#elapsedTime/2","title":"Evision.CUDA.Event.elapsedTime/2","type":"function"},{"doc":"Raising version of queryIfComplete/1 .","ref":"Evision.CUDA.Event.html#queryIfComplete!/1","title":"Evision.CUDA.Event.queryIfComplete!/1","type":"function"},{"doc":"Python prototype (for reference): queryIfComplete() -&gt; retval","ref":"Evision.CUDA.Event.html#queryIfComplete/1","title":"Evision.CUDA.Event.queryIfComplete/1","type":"function"},{"doc":"Raising version of record/1 .","ref":"Evision.CUDA.Event.html#record!/1","title":"Evision.CUDA.Event.record!/1","type":"function"},{"doc":"##### Keyword Arguments stream : Stream . Python prototype (for reference): record([, stream]) -&gt; None","ref":"Evision.CUDA.Event.html#record/1","title":"Evision.CUDA.Event.record/1","type":"function"},{"doc":"Raising version of waitForCompletion/1 .","ref":"Evision.CUDA.Event.html#waitForCompletion!/1","title":"Evision.CUDA.Event.waitForCompletion!/1","type":"function"},{"doc":"Python prototype (for reference): waitForCompletion() -&gt; None","ref":"Evision.CUDA.Event.html#waitForCompletion/1","title":"Evision.CUDA.Event.waitForCompletion/1","type":"function"},{"doc":"","ref":"Evision.CUDA.GpuMat.html","title":"Evision.CUDA.GpuMat","type":"module"},{"doc":"Raising version of adjustROI/5 .","ref":"Evision.CUDA.GpuMat.html#adjustROI!/5","title":"Evision.CUDA.GpuMat.adjustROI!/5","type":"function"},{"doc":"Positional Arguments dtop : int dbottom : int dleft : int dright : int Python prototype (for reference): adjustROI(dtop, dbottom, dleft, dright) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#adjustROI/5","title":"Evision.CUDA.GpuMat.adjustROI/5","type":"function"},{"doc":"Raising version of assignTo/2 .","ref":"Evision.CUDA.GpuMat.html#assignTo!/2","title":"Evision.CUDA.GpuMat.assignTo!/2","type":"function"},{"doc":"Raising version of assignTo/3 .","ref":"Evision.CUDA.GpuMat.html#assignTo!/3","title":"Evision.CUDA.GpuMat.assignTo!/3","type":"function"},{"doc":"Positional Arguments m : GpuMat Keyword Arguments type : int . Python prototype (for reference): assignTo(m[, type]) -&gt; None","ref":"Evision.CUDA.GpuMat.html#assignTo/2","title":"Evision.CUDA.GpuMat.assignTo/2","type":"function"},{"doc":"Positional Arguments m : GpuMat Keyword Arguments type : int . Python prototype (for reference): assignTo(m[, type]) -&gt; None","ref":"Evision.CUDA.GpuMat.html#assignTo/3","title":"Evision.CUDA.GpuMat.assignTo/3","type":"function"},{"doc":"Raising version of channels/1 .","ref":"Evision.CUDA.GpuMat.html#channels!/1","title":"Evision.CUDA.GpuMat.channels!/1","type":"function"},{"doc":"Python prototype (for reference): channels() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#channels/1","title":"Evision.CUDA.GpuMat.channels/1","type":"function"},{"doc":"Raising version of clone/1 .","ref":"Evision.CUDA.GpuMat.html#clone!/1","title":"Evision.CUDA.GpuMat.clone!/1","type":"function"},{"doc":"Python prototype (for reference): clone() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#clone/1","title":"Evision.CUDA.GpuMat.clone/1","type":"function"},{"doc":"Raising version of col/2 .","ref":"Evision.CUDA.GpuMat.html#col!/2","title":"Evision.CUDA.GpuMat.col!/2","type":"function"},{"doc":"Positional Arguments x : int Python prototype (for reference): col(x) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#col/2","title":"Evision.CUDA.GpuMat.col/2","type":"function"},{"doc":"Raising version of colRange/2 .","ref":"Evision.CUDA.GpuMat.html#colRange!/2","title":"Evision.CUDA.GpuMat.colRange!/2","type":"function"},{"doc":"Raising version of colRange/3 .","ref":"Evision.CUDA.GpuMat.html#colRange!/3","title":"Evision.CUDA.GpuMat.colRange!/3","type":"function"},{"doc":"Positional Arguments r : Range Python prototype (for reference): colRange(r) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#colRange/2","title":"Evision.CUDA.GpuMat.colRange/2","type":"function"},{"doc":"Positional Arguments startcol : int endcol : int Python prototype (for reference): colRange(startcol, endcol) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#colRange/3","title":"Evision.CUDA.GpuMat.colRange/3","type":"function"},{"doc":"Raising version of convertTo/2 .","ref":"Evision.CUDA.GpuMat.html#convertTo!/2","title":"Evision.CUDA.GpuMat.convertTo!/2","type":"function"},{"doc":"Raising version of convertTo/3 .","ref":"Evision.CUDA.GpuMat.html#convertTo!/3","title":"Evision.CUDA.GpuMat.convertTo!/3","type":"function"},{"doc":"Raising version of convertTo/4 .","ref":"Evision.CUDA.GpuMat.html#convertTo!/4","title":"Evision.CUDA.GpuMat.convertTo!/4","type":"function"},{"doc":"Raising version of convertTo/5 .","ref":"Evision.CUDA.GpuMat.html#convertTo!/5","title":"Evision.CUDA.GpuMat.convertTo!/5","type":"function"},{"doc":"Raising version of convertTo/6 .","ref":"Evision.CUDA.GpuMat.html#convertTo!/6","title":"Evision.CUDA.GpuMat.convertTo!/6","type":"function"},{"doc":"Positional Arguments rtype : int Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#convertTo/2","title":"Evision.CUDA.GpuMat.convertTo/2","type":"function"},{"doc":"Variant 1: Positional Arguments rtype : int alpha : double Keyword Arguments beta : double . Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, alpha[, dst[, beta]]) -&gt; dst Variant 2: Positional Arguments rtype : int stream : Stream Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, stream[, dst]) -&gt; dst Variant 3: Positional Arguments rtype : int Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#convertTo/3","title":"Evision.CUDA.GpuMat.convertTo/3","type":"function"},{"doc":"Variant 1: Positional Arguments rtype : int alpha : double stream : Stream Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, alpha, stream[, dst]) -&gt; dst Variant 2: Positional Arguments rtype : int alpha : double Keyword Arguments beta : double . Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, alpha[, dst[, beta]]) -&gt; dst Variant 3: Positional Arguments rtype : int stream : Stream Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, stream[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#convertTo/4","title":"Evision.CUDA.GpuMat.convertTo/4","type":"function"},{"doc":"Variant 1: Positional Arguments rtype : int alpha : double beta : double stream : Stream Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, alpha, beta, stream[, dst]) -&gt; dst Variant 2: Positional Arguments rtype : int alpha : double stream : Stream Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, alpha, stream[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#convertTo/5","title":"Evision.CUDA.GpuMat.convertTo/5","type":"function"},{"doc":"Positional Arguments rtype : int alpha : double beta : double stream : Stream Return dst : Evision.Mat . Python prototype (for reference): convertTo(rtype, alpha, beta, stream[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#convertTo/6","title":"Evision.CUDA.GpuMat.convertTo/6","type":"function"},{"doc":"Raising version of copyTo/1 .","ref":"Evision.CUDA.GpuMat.html#copyTo!/1","title":"Evision.CUDA.GpuMat.copyTo!/1","type":"function"},{"doc":"Raising version of copyTo/2 .","ref":"Evision.CUDA.GpuMat.html#copyTo!/2","title":"Evision.CUDA.GpuMat.copyTo!/2","type":"function"},{"doc":"Raising version of copyTo/3 .","ref":"Evision.CUDA.GpuMat.html#copyTo!/3","title":"Evision.CUDA.GpuMat.copyTo!/3","type":"function"},{"doc":"Raising version of copyTo/4 .","ref":"Evision.CUDA.GpuMat.html#copyTo!/4","title":"Evision.CUDA.GpuMat.copyTo!/4","type":"function"},{"doc":"##### Return dst : Evision.Mat . Python prototype (for reference): copyTo([, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#copyTo/1","title":"Evision.CUDA.GpuMat.copyTo/1","type":"function"},{"doc":"Positional Arguments mask : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): copyTo(mask[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#copyTo/2","title":"Evision.CUDA.GpuMat.copyTo/2","type":"function"},{"doc":"Variant 1: Positional Arguments mask : Evision.Mat stream : Stream Return dst : Evision.Mat . Python prototype (for reference): copyTo(mask, stream[, dst]) -&gt; dst Variant 2: Positional Arguments mask : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): copyTo(mask[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#copyTo/3","title":"Evision.CUDA.GpuMat.copyTo/3","type":"function"},{"doc":"Positional Arguments mask : Evision.Mat stream : Stream Return dst : Evision.Mat . Python prototype (for reference): copyTo(mask, stream[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#copyTo/4","title":"Evision.CUDA.GpuMat.copyTo/4","type":"function"},{"doc":"Raising version of create/3 .","ref":"Evision.CUDA.GpuMat.html#create!/3","title":"Evision.CUDA.GpuMat.create!/3","type":"function"},{"doc":"Raising version of create/4 .","ref":"Evision.CUDA.GpuMat.html#create!/4","title":"Evision.CUDA.GpuMat.create!/4","type":"function"},{"doc":"Positional Arguments size : Size type : int Python prototype (for reference): create(size, type) -&gt; None","ref":"Evision.CUDA.GpuMat.html#create/3","title":"Evision.CUDA.GpuMat.create/3","type":"function"},{"doc":"Positional Arguments rows : int cols : int type : int Python prototype (for reference): create(rows, cols, type) -&gt; None","ref":"Evision.CUDA.GpuMat.html#create/4","title":"Evision.CUDA.GpuMat.create/4","type":"function"},{"doc":"Raising version of cuda_GpuMat/0 .","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat!/0","title":"Evision.CUDA.GpuMat.cuda_GpuMat!/0","type":"function"},{"doc":"Raising version of cuda_GpuMat/1 .","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat!/1","title":"Evision.CUDA.GpuMat.cuda_GpuMat!/1","type":"function"},{"doc":"Raising version of cuda_GpuMat/2 .","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat!/2","title":"Evision.CUDA.GpuMat.cuda_GpuMat!/2","type":"function"},{"doc":"Raising version of cuda_GpuMat/3 .","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat!/3","title":"Evision.CUDA.GpuMat.cuda_GpuMat!/3","type":"function"},{"doc":"Raising version of cuda_GpuMat/4 .","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat!/4","title":"Evision.CUDA.GpuMat.cuda_GpuMat!/4","type":"function"},{"doc":"Raising version of cuda_GpuMat/5 .","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat!/5","title":"Evision.CUDA.GpuMat.cuda_GpuMat!/5","type":"function"},{"doc":"##### Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat([, allocator]) -&gt; &lt;cuda_GpuMat object&gt;","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat/0","title":"Evision.CUDA.GpuMat.cuda_GpuMat/0","type":"function"},{"doc":"Variant 1: Positional Arguments arr : Evision.Mat Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(arr[, allocator]) -&gt; &lt;cuda_GpuMat object&gt; Variant 2: ##### Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat([, allocator]) -&gt; &lt;cuda_GpuMat object&gt;","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat/1","title":"Evision.CUDA.GpuMat.cuda_GpuMat/1","type":"function"},{"doc":"Variant 1: Positional Arguments m : GpuMat roi : Rect Python prototype (for reference): GpuMat(m, roi) -&gt; &lt;cuda_GpuMat object&gt; Variant 2: Positional Arguments size : Size type : int Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(size, type[, allocator]) -&gt; &lt;cuda_GpuMat object&gt; Variant 3: Positional Arguments arr : Evision.Mat Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(arr[, allocator]) -&gt; &lt;cuda_GpuMat object&gt;","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat/2","title":"Evision.CUDA.GpuMat.cuda_GpuMat/2","type":"function"},{"doc":"Variant 1: Positional Arguments m : GpuMat rowRange : Range colRange : Range Python prototype (for reference): GpuMat(m, rowRange, colRange) -&gt; &lt;cuda_GpuMat object&gt; Variant 2: Positional Arguments size : Size type : int s : Scalar Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(size, type, s[, allocator]) -&gt; &lt;cuda_GpuMat object&gt; Variant 3: Positional Arguments rows : int cols : int type : int Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(rows, cols, type[, allocator]) -&gt; &lt;cuda_GpuMat object&gt; Variant 4: Positional Arguments size : Size type : int Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(size, type[, allocator]) -&gt; &lt;cuda_GpuMat object&gt;","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat/3","title":"Evision.CUDA.GpuMat.cuda_GpuMat/3","type":"function"},{"doc":"Variant 1: Positional Arguments rows : int cols : int type : int s : Scalar Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(rows, cols, type, s[, allocator]) -&gt; &lt;cuda_GpuMat object&gt; Variant 2: Positional Arguments size : Size type : int s : Scalar Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(size, type, s[, allocator]) -&gt; &lt;cuda_GpuMat object&gt; Variant 3: Positional Arguments rows : int cols : int type : int Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(rows, cols, type[, allocator]) -&gt; &lt;cuda_GpuMat object&gt;","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat/4","title":"Evision.CUDA.GpuMat.cuda_GpuMat/4","type":"function"},{"doc":"Positional Arguments rows : int cols : int type : int s : Scalar Keyword Arguments allocator : GpuMat_Allocator* . Python prototype (for reference): GpuMat(rows, cols, type, s[, allocator]) -&gt; &lt;cuda_GpuMat object&gt;","ref":"Evision.CUDA.GpuMat.html#cuda_GpuMat/5","title":"Evision.CUDA.GpuMat.cuda_GpuMat/5","type":"function"},{"doc":"Raising version of cudaPtr/1 .","ref":"Evision.CUDA.GpuMat.html#cudaPtr!/1","title":"Evision.CUDA.GpuMat.cudaPtr!/1","type":"function"},{"doc":"Python prototype (for reference): cudaPtr() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#cudaPtr/1","title":"Evision.CUDA.GpuMat.cudaPtr/1","type":"function"},{"doc":"Raising version of defaultAllocator/0 .","ref":"Evision.CUDA.GpuMat.html#defaultAllocator!/0","title":"Evision.CUDA.GpuMat.defaultAllocator!/0","type":"function"},{"doc":"Python prototype (for reference): defaultAllocator() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#defaultAllocator/0","title":"Evision.CUDA.GpuMat.defaultAllocator/0","type":"function"},{"doc":"Raising version of depth/1 .","ref":"Evision.CUDA.GpuMat.html#depth!/1","title":"Evision.CUDA.GpuMat.depth!/1","type":"function"},{"doc":"Python prototype (for reference): depth() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#depth/1","title":"Evision.CUDA.GpuMat.depth/1","type":"function"},{"doc":"Raising version of download/1 .","ref":"Evision.CUDA.GpuMat.html#download!/1","title":"Evision.CUDA.GpuMat.download!/1","type":"function"},{"doc":"Raising version of download/2 .","ref":"Evision.CUDA.GpuMat.html#download!/2","title":"Evision.CUDA.GpuMat.download!/2","type":"function"},{"doc":"Raising version of download/3 .","ref":"Evision.CUDA.GpuMat.html#download!/3","title":"Evision.CUDA.GpuMat.download!/3","type":"function"},{"doc":"Performs data download from GpuMat (Blocking call) Return dst : Evision.Mat . This function copies data from device memory to host memory. As being a blocking call, it is guaranteed that the copy operation is finished when this function returns. Python prototype (for reference): download([, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#download/1","title":"Evision.CUDA.GpuMat.download/1","type":"function"},{"doc":"Performs data download from GpuMat (Non-Blocking call) Positional Arguments stream : Stream Return dst : Evision.Mat . This function copies data from device memory to host memory. As being a non-blocking call, this function may return even if the copy operation is not finished. The copy operation may be overlapped with operations in other non-default streams if \\p stream is not the default stream and \\p dst is HostMem allocated with HostMem::PAGE_LOCKED option. Python prototype (for reference): download(stream[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#download/2","title":"Evision.CUDA.GpuMat.download/2","type":"function"},{"doc":"Performs data download from GpuMat (Non-Blocking call) Positional Arguments stream : Stream Return dst : Evision.Mat . This function copies data from device memory to host memory. As being a non-blocking call, this function may return even if the copy operation is not finished. The copy operation may be overlapped with operations in other non-default streams if \\p stream is not the default stream and \\p dst is HostMem allocated with HostMem::PAGE_LOCKED option. Python prototype (for reference): download(stream[, dst]) -&gt; dst","ref":"Evision.CUDA.GpuMat.html#download/3","title":"Evision.CUDA.GpuMat.download/3","type":"function"},{"doc":"Raising version of elemSize1/1 .","ref":"Evision.CUDA.GpuMat.html#elemSize1!/1","title":"Evision.CUDA.GpuMat.elemSize1!/1","type":"function"},{"doc":"Python prototype (for reference): elemSize1() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#elemSize1/1","title":"Evision.CUDA.GpuMat.elemSize1/1","type":"function"},{"doc":"Raising version of elemSize/1 .","ref":"Evision.CUDA.GpuMat.html#elemSize!/1","title":"Evision.CUDA.GpuMat.elemSize!/1","type":"function"},{"doc":"Python prototype (for reference): elemSize() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#elemSize/1","title":"Evision.CUDA.GpuMat.elemSize/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.CUDA.GpuMat.html#empty!/1","title":"Evision.CUDA.GpuMat.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#empty/1","title":"Evision.CUDA.GpuMat.empty/1","type":"function"},{"doc":"Raising version of get_step/1 .","ref":"Evision.CUDA.GpuMat.html#get_step!/1","title":"Evision.CUDA.GpuMat.get_step!/1","type":"function"},{"doc":"","ref":"Evision.CUDA.GpuMat.html#get_step/1","title":"Evision.CUDA.GpuMat.get_step/1","type":"function"},{"doc":"Raising version of isContinuous/1 .","ref":"Evision.CUDA.GpuMat.html#isContinuous!/1","title":"Evision.CUDA.GpuMat.isContinuous!/1","type":"function"},{"doc":"Python prototype (for reference): isContinuous() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#isContinuous/1","title":"Evision.CUDA.GpuMat.isContinuous/1","type":"function"},{"doc":"Raising version of locateROI/3 .","ref":"Evision.CUDA.GpuMat.html#locateROI!/3","title":"Evision.CUDA.GpuMat.locateROI!/3","type":"function"},{"doc":"Positional Arguments wholeSize : Size ofs : Point Python prototype (for reference): locateROI(wholeSize, ofs) -&gt; None","ref":"Evision.CUDA.GpuMat.html#locateROI/3","title":"Evision.CUDA.GpuMat.locateROI/3","type":"function"},{"doc":"Raising version of release/1 .","ref":"Evision.CUDA.GpuMat.html#release!/1","title":"Evision.CUDA.GpuMat.release!/1","type":"function"},{"doc":"Python prototype (for reference): release() -&gt; None","ref":"Evision.CUDA.GpuMat.html#release/1","title":"Evision.CUDA.GpuMat.release/1","type":"function"},{"doc":"Raising version of reshape/2 .","ref":"Evision.CUDA.GpuMat.html#reshape!/2","title":"Evision.CUDA.GpuMat.reshape!/2","type":"function"},{"doc":"Raising version of reshape/3 .","ref":"Evision.CUDA.GpuMat.html#reshape!/3","title":"Evision.CUDA.GpuMat.reshape!/3","type":"function"},{"doc":"Positional Arguments cn : int Keyword Arguments rows : int . Python prototype (for reference): reshape(cn[, rows]) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#reshape/2","title":"Evision.CUDA.GpuMat.reshape/2","type":"function"},{"doc":"Positional Arguments cn : int Keyword Arguments rows : int . Python prototype (for reference): reshape(cn[, rows]) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#reshape/3","title":"Evision.CUDA.GpuMat.reshape/3","type":"function"},{"doc":"Raising version of row/2 .","ref":"Evision.CUDA.GpuMat.html#row!/2","title":"Evision.CUDA.GpuMat.row!/2","type":"function"},{"doc":"Positional Arguments y : int Python prototype (for reference): row(y) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#row/2","title":"Evision.CUDA.GpuMat.row/2","type":"function"},{"doc":"Raising version of rowRange/2 .","ref":"Evision.CUDA.GpuMat.html#rowRange!/2","title":"Evision.CUDA.GpuMat.rowRange!/2","type":"function"},{"doc":"Raising version of rowRange/3 .","ref":"Evision.CUDA.GpuMat.html#rowRange!/3","title":"Evision.CUDA.GpuMat.rowRange!/3","type":"function"},{"doc":"Positional Arguments r : Range Python prototype (for reference): rowRange(r) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#rowRange/2","title":"Evision.CUDA.GpuMat.rowRange/2","type":"function"},{"doc":"Positional Arguments startrow : int endrow : int Python prototype (for reference): rowRange(startrow, endrow) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#rowRange/3","title":"Evision.CUDA.GpuMat.rowRange/3","type":"function"},{"doc":"Raising version of setDefaultAllocator/1 .","ref":"Evision.CUDA.GpuMat.html#setDefaultAllocator!/1","title":"Evision.CUDA.GpuMat.setDefaultAllocator!/1","type":"function"},{"doc":"Positional Arguments allocator : GpuMat_Allocator* Python prototype (for reference): setDefaultAllocator(allocator) -&gt; None","ref":"Evision.CUDA.GpuMat.html#setDefaultAllocator/1","title":"Evision.CUDA.GpuMat.setDefaultAllocator/1","type":"function"},{"doc":"Raising version of setTo/2 .","ref":"Evision.CUDA.GpuMat.html#setTo!/2","title":"Evision.CUDA.GpuMat.setTo!/2","type":"function"},{"doc":"Raising version of setTo/3 .","ref":"Evision.CUDA.GpuMat.html#setTo!/3","title":"Evision.CUDA.GpuMat.setTo!/3","type":"function"},{"doc":"Raising version of setTo/4 .","ref":"Evision.CUDA.GpuMat.html#setTo!/4","title":"Evision.CUDA.GpuMat.setTo!/4","type":"function"},{"doc":"Positional Arguments s : Scalar Python prototype (for reference): setTo(s) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#setTo/2","title":"Evision.CUDA.GpuMat.setTo/2","type":"function"},{"doc":"Positional Arguments s : Scalar mask : Evision.Mat Python prototype (for reference): setTo(s, mask) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#setTo/3","title":"Evision.CUDA.GpuMat.setTo/3","type":"function"},{"doc":"Positional Arguments s : Scalar mask : Evision.Mat stream : Stream Python prototype (for reference): setTo(s, mask, stream) -&gt; retval","ref":"Evision.CUDA.GpuMat.html#setTo/4","title":"Evision.CUDA.GpuMat.setTo/4","type":"function"},{"doc":"Raising version of size/1 .","ref":"Evision.CUDA.GpuMat.html#size!/1","title":"Evision.CUDA.GpuMat.size!/1","type":"function"},{"doc":"Python prototype (for reference): size() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#size/1","title":"Evision.CUDA.GpuMat.size/1","type":"function"},{"doc":"Raising version of step1/1 .","ref":"Evision.CUDA.GpuMat.html#step1!/1","title":"Evision.CUDA.GpuMat.step1!/1","type":"function"},{"doc":"Python prototype (for reference): step1() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#step1/1","title":"Evision.CUDA.GpuMat.step1/1","type":"function"},{"doc":"Raising version of swap/2 .","ref":"Evision.CUDA.GpuMat.html#swap!/2","title":"Evision.CUDA.GpuMat.swap!/2","type":"function"},{"doc":"Positional Arguments mat : GpuMat Python prototype (for reference): swap(mat) -&gt; None","ref":"Evision.CUDA.GpuMat.html#swap/2","title":"Evision.CUDA.GpuMat.swap/2","type":"function"},{"doc":"Raising version of type/1 .","ref":"Evision.CUDA.GpuMat.html#type!/1","title":"Evision.CUDA.GpuMat.type!/1","type":"function"},{"doc":"Python prototype (for reference): type() -&gt; retval","ref":"Evision.CUDA.GpuMat.html#type/1","title":"Evision.CUDA.GpuMat.type/1","type":"function"},{"doc":"Raising version of updateContinuityFlag/1 .","ref":"Evision.CUDA.GpuMat.html#updateContinuityFlag!/1","title":"Evision.CUDA.GpuMat.updateContinuityFlag!/1","type":"function"},{"doc":"Python prototype (for reference): updateContinuityFlag() -&gt; None","ref":"Evision.CUDA.GpuMat.html#updateContinuityFlag/1","title":"Evision.CUDA.GpuMat.updateContinuityFlag/1","type":"function"},{"doc":"Raising version of upload/2 .","ref":"Evision.CUDA.GpuMat.html#upload!/2","title":"Evision.CUDA.GpuMat.upload!/2","type":"function"},{"doc":"Raising version of upload/3 .","ref":"Evision.CUDA.GpuMat.html#upload!/3","title":"Evision.CUDA.GpuMat.upload!/3","type":"function"},{"doc":"Performs data upload to GpuMat (Blocking call) Positional Arguments arr : Evision.Mat This function copies data from host memory to device memory. As being a blocking call, it is guaranteed that the copy operation is finished when this function returns. Python prototype (for reference): upload(arr) -&gt; None","ref":"Evision.CUDA.GpuMat.html#upload/2","title":"Evision.CUDA.GpuMat.upload/2","type":"function"},{"doc":"Performs data upload to GpuMat (Non-Blocking call) Positional Arguments arr : Evision.Mat stream : Stream This function copies data from host memory to device memory. As being a non-blocking call, this function may return even if the copy operation is not finished. The copy operation may be overlapped with operations in other non-default streams if \\p stream is not the default stream and \\p dst is HostMem allocated with HostMem::PAGE_LOCKED option. Python prototype (for reference): upload(arr, stream) -&gt; None","ref":"Evision.CUDA.GpuMat.html#upload/3","title":"Evision.CUDA.GpuMat.upload/3","type":"function"},{"doc":"","ref":"Evision.CUDA.HostMem.html","title":"Evision.CUDA.HostMem","type":"module"},{"doc":"Raising version of channels/1 .","ref":"Evision.CUDA.HostMem.html#channels!/1","title":"Evision.CUDA.HostMem.channels!/1","type":"function"},{"doc":"Python prototype (for reference): channels() -&gt; retval","ref":"Evision.CUDA.HostMem.html#channels/1","title":"Evision.CUDA.HostMem.channels/1","type":"function"},{"doc":"Raising version of clone/1 .","ref":"Evision.CUDA.HostMem.html#clone!/1","title":"Evision.CUDA.HostMem.clone!/1","type":"function"},{"doc":"Python prototype (for reference): clone() -&gt; retval","ref":"Evision.CUDA.HostMem.html#clone/1","title":"Evision.CUDA.HostMem.clone/1","type":"function"},{"doc":"Raising version of create/4 .","ref":"Evision.CUDA.HostMem.html#create!/4","title":"Evision.CUDA.HostMem.create!/4","type":"function"},{"doc":"Positional Arguments rows : int cols : int type : int Python prototype (for reference): create(rows, cols, type) -&gt; None","ref":"Evision.CUDA.HostMem.html#create/4","title":"Evision.CUDA.HostMem.create/4","type":"function"},{"doc":"Raising version of createMatHeader/1 .","ref":"Evision.CUDA.HostMem.html#createMatHeader!/1","title":"Evision.CUDA.HostMem.createMatHeader!/1","type":"function"},{"doc":"Python prototype (for reference): createMatHeader() -&gt; retval","ref":"Evision.CUDA.HostMem.html#createMatHeader/1","title":"Evision.CUDA.HostMem.createMatHeader/1","type":"function"},{"doc":"Raising version of cuda_HostMem/0 .","ref":"Evision.CUDA.HostMem.html#cuda_HostMem!/0","title":"Evision.CUDA.HostMem.cuda_HostMem!/0","type":"function"},{"doc":"Raising version of cuda_HostMem/1 .","ref":"Evision.CUDA.HostMem.html#cuda_HostMem!/1","title":"Evision.CUDA.HostMem.cuda_HostMem!/1","type":"function"},{"doc":"Raising version of cuda_HostMem/2 .","ref":"Evision.CUDA.HostMem.html#cuda_HostMem!/2","title":"Evision.CUDA.HostMem.cuda_HostMem!/2","type":"function"},{"doc":"Raising version of cuda_HostMem/3 .","ref":"Evision.CUDA.HostMem.html#cuda_HostMem!/3","title":"Evision.CUDA.HostMem.cuda_HostMem!/3","type":"function"},{"doc":"Raising version of cuda_HostMem/4 .","ref":"Evision.CUDA.HostMem.html#cuda_HostMem!/4","title":"Evision.CUDA.HostMem.cuda_HostMem!/4","type":"function"},{"doc":"##### Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem([, alloc_type]) -&gt; &lt;cuda_HostMem object&gt;","ref":"Evision.CUDA.HostMem.html#cuda_HostMem/0","title":"Evision.CUDA.HostMem.cuda_HostMem/0","type":"function"},{"doc":"Variant 1: Positional Arguments arr : Evision.Mat Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem(arr[, alloc_type]) -&gt; &lt;cuda_HostMem object&gt; Variant 2: ##### Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem([, alloc_type]) -&gt; &lt;cuda_HostMem object&gt;","ref":"Evision.CUDA.HostMem.html#cuda_HostMem/1","title":"Evision.CUDA.HostMem.cuda_HostMem/1","type":"function"},{"doc":"Variant 1: Positional Arguments size : Size type : int Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem(size, type[, alloc_type]) -&gt; &lt;cuda_HostMem object&gt; Variant 2: Positional Arguments arr : Evision.Mat Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem(arr[, alloc_type]) -&gt; &lt;cuda_HostMem object&gt;","ref":"Evision.CUDA.HostMem.html#cuda_HostMem/2","title":"Evision.CUDA.HostMem.cuda_HostMem/2","type":"function"},{"doc":"Variant 1: Positional Arguments rows : int cols : int type : int Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem(rows, cols, type[, alloc_type]) -&gt; &lt;cuda_HostMem object&gt; Variant 2: Positional Arguments size : Size type : int Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem(size, type[, alloc_type]) -&gt; &lt;cuda_HostMem object&gt;","ref":"Evision.CUDA.HostMem.html#cuda_HostMem/3","title":"Evision.CUDA.HostMem.cuda_HostMem/3","type":"function"},{"doc":"Positional Arguments rows : int cols : int type : int Keyword Arguments alloc_type : HostMem_AllocType . Python prototype (for reference): HostMem(rows, cols, type[, alloc_type]) -&gt; &lt;cuda_HostMem object&gt;","ref":"Evision.CUDA.HostMem.html#cuda_HostMem/4","title":"Evision.CUDA.HostMem.cuda_HostMem/4","type":"function"},{"doc":"Raising version of depth/1 .","ref":"Evision.CUDA.HostMem.html#depth!/1","title":"Evision.CUDA.HostMem.depth!/1","type":"function"},{"doc":"Python prototype (for reference): depth() -&gt; retval","ref":"Evision.CUDA.HostMem.html#depth/1","title":"Evision.CUDA.HostMem.depth/1","type":"function"},{"doc":"Raising version of elemSize1/1 .","ref":"Evision.CUDA.HostMem.html#elemSize1!/1","title":"Evision.CUDA.HostMem.elemSize1!/1","type":"function"},{"doc":"Python prototype (for reference): elemSize1() -&gt; retval","ref":"Evision.CUDA.HostMem.html#elemSize1/1","title":"Evision.CUDA.HostMem.elemSize1/1","type":"function"},{"doc":"Raising version of elemSize/1 .","ref":"Evision.CUDA.HostMem.html#elemSize!/1","title":"Evision.CUDA.HostMem.elemSize!/1","type":"function"},{"doc":"Python prototype (for reference): elemSize() -&gt; retval","ref":"Evision.CUDA.HostMem.html#elemSize/1","title":"Evision.CUDA.HostMem.elemSize/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.CUDA.HostMem.html#empty!/1","title":"Evision.CUDA.HostMem.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.CUDA.HostMem.html#empty/1","title":"Evision.CUDA.HostMem.empty/1","type":"function"},{"doc":"Raising version of get_step/1 .","ref":"Evision.CUDA.HostMem.html#get_step!/1","title":"Evision.CUDA.HostMem.get_step!/1","type":"function"},{"doc":"","ref":"Evision.CUDA.HostMem.html#get_step/1","title":"Evision.CUDA.HostMem.get_step/1","type":"function"},{"doc":"Raising version of isContinuous/1 .","ref":"Evision.CUDA.HostMem.html#isContinuous!/1","title":"Evision.CUDA.HostMem.isContinuous!/1","type":"function"},{"doc":"Maps CPU memory to GPU address space and creates the cuda::GpuMat header without reference counting for it. This can be done only if memory was allocated with the SHARED flag and if it is supported by the hardware. Laptops often share video and CPU memory, so address spaces can be mapped, which eliminates an extra copy. Python prototype (for reference): isContinuous() -&gt; retval","ref":"Evision.CUDA.HostMem.html#isContinuous/1","title":"Evision.CUDA.HostMem.isContinuous/1","type":"function"},{"doc":"Raising version of reshape/2 .","ref":"Evision.CUDA.HostMem.html#reshape!/2","title":"Evision.CUDA.HostMem.reshape!/2","type":"function"},{"doc":"Raising version of reshape/3 .","ref":"Evision.CUDA.HostMem.html#reshape!/3","title":"Evision.CUDA.HostMem.reshape!/3","type":"function"},{"doc":"Positional Arguments cn : int Keyword Arguments rows : int . Python prototype (for reference): reshape(cn[, rows]) -&gt; retval","ref":"Evision.CUDA.HostMem.html#reshape/2","title":"Evision.CUDA.HostMem.reshape/2","type":"function"},{"doc":"Positional Arguments cn : int Keyword Arguments rows : int . Python prototype (for reference): reshape(cn[, rows]) -&gt; retval","ref":"Evision.CUDA.HostMem.html#reshape/3","title":"Evision.CUDA.HostMem.reshape/3","type":"function"},{"doc":"Raising version of size/1 .","ref":"Evision.CUDA.HostMem.html#size!/1","title":"Evision.CUDA.HostMem.size!/1","type":"function"},{"doc":"Python prototype (for reference): size() -&gt; retval","ref":"Evision.CUDA.HostMem.html#size/1","title":"Evision.CUDA.HostMem.size/1","type":"function"},{"doc":"Raising version of step1/1 .","ref":"Evision.CUDA.HostMem.html#step1!/1","title":"Evision.CUDA.HostMem.step1!/1","type":"function"},{"doc":"Python prototype (for reference): step1() -&gt; retval","ref":"Evision.CUDA.HostMem.html#step1/1","title":"Evision.CUDA.HostMem.step1/1","type":"function"},{"doc":"Raising version of swap/2 .","ref":"Evision.CUDA.HostMem.html#swap!/2","title":"Evision.CUDA.HostMem.swap!/2","type":"function"},{"doc":"Positional Arguments b : HostMem Python prototype (for reference): swap(b) -&gt; None","ref":"Evision.CUDA.HostMem.html#swap/2","title":"Evision.CUDA.HostMem.swap/2","type":"function"},{"doc":"Raising version of type/1 .","ref":"Evision.CUDA.HostMem.html#type!/1","title":"Evision.CUDA.HostMem.type!/1","type":"function"},{"doc":"Python prototype (for reference): type() -&gt; retval","ref":"Evision.CUDA.HostMem.html#type/1","title":"Evision.CUDA.HostMem.type/1","type":"function"},{"doc":"","ref":"Evision.CUDA.Stream.html","title":"Evision.CUDA.Stream","type":"module"},{"doc":"Raising version of cuda_Stream/0 .","ref":"Evision.CUDA.Stream.html#cuda_Stream!/0","title":"Evision.CUDA.Stream.cuda_Stream!/0","type":"function"},{"doc":"Raising version of cuda_Stream/1 .","ref":"Evision.CUDA.Stream.html#cuda_Stream!/1","title":"Evision.CUDA.Stream.cuda_Stream!/1","type":"function"},{"doc":"Python prototype (for reference): Stream() -&gt; &lt;cuda_Stream object&gt;","ref":"Evision.CUDA.Stream.html#cuda_Stream/0","title":"Evision.CUDA.Stream.cuda_Stream/0","type":"function"},{"doc":"Variant 1: creates a new Stream using the cudaFlags argument to determine the behaviors of the stream Positional Arguments cudaFlags : size_t Note : The cudaFlags parameter is passed to the underlying api cudaStreamCreateWithFlags() and supports the same parameter values. // creates an OpenCV cuda :: Stream that manages an asynchronous , non - blocking , // non - default CUDA stream cv :: cuda :: Stream cvStream ( cudaStreamNonBlocking ) ; Python prototype (for reference): Stream(cudaFlags) -&gt; &lt;cuda_Stream object&gt; Variant 2: Positional Arguments allocator : Ptr&lt;GpuMat::Allocator&gt; Python prototype (for reference): Stream(allocator) -&gt; &lt;cuda_Stream object&gt;","ref":"Evision.CUDA.Stream.html#cuda_Stream/1","title":"Evision.CUDA.Stream.cuda_Stream/1","type":"function"},{"doc":"Raising version of cudaPtr/1 .","ref":"Evision.CUDA.Stream.html#cudaPtr!/1","title":"Evision.CUDA.Stream.cudaPtr!/1","type":"function"},{"doc":"Python prototype (for reference): cudaPtr() -&gt; retval","ref":"Evision.CUDA.Stream.html#cudaPtr/1","title":"Evision.CUDA.Stream.cudaPtr/1","type":"function"},{"doc":"Raising version of null/0 .","ref":"Evision.CUDA.Stream.html#null!/0","title":"Evision.CUDA.Stream.null!/0","type":"function"},{"doc":"Adds a callback to be called on the host after all currently enqueued items in the stream have completed. Note : Callbacks must not make any CUDA API calls. Callbacks must not perform any synchronization that may depend on outstanding device work or other callbacks that are not mandated to run earlier. Callbacks without a mandated order (in independent streams) execute in undefined order and may be serialized. Python prototype (for reference): Null() -&gt; retval","ref":"Evision.CUDA.Stream.html#null/0","title":"Evision.CUDA.Stream.null/0","type":"function"},{"doc":"Raising version of queryIfComplete/1 .","ref":"Evision.CUDA.Stream.html#queryIfComplete!/1","title":"Evision.CUDA.Stream.queryIfComplete!/1","type":"function"},{"doc":"Returns true if the current stream queue is finished. Otherwise, it returns false. Python prototype (for reference): queryIfComplete() -&gt; retval","ref":"Evision.CUDA.Stream.html#queryIfComplete/1","title":"Evision.CUDA.Stream.queryIfComplete/1","type":"function"},{"doc":"Raising version of waitEvent/2 .","ref":"Evision.CUDA.Stream.html#waitEvent!/2","title":"Evision.CUDA.Stream.waitEvent!/2","type":"function"},{"doc":"Makes a compute stream wait on an event. Positional Arguments event : Event Python prototype (for reference): waitEvent(event) -&gt; None","ref":"Evision.CUDA.Stream.html#waitEvent/2","title":"Evision.CUDA.Stream.waitEvent/2","type":"function"},{"doc":"Raising version of waitForCompletion/1 .","ref":"Evision.CUDA.Stream.html#waitForCompletion!/1","title":"Evision.CUDA.Stream.waitForCompletion!/1","type":"function"},{"doc":"Blocks the current CPU thread until all operations in the stream are complete. Python prototype (for reference): waitForCompletion() -&gt; None","ref":"Evision.CUDA.Stream.html#waitForCompletion/1","title":"Evision.CUDA.Stream.waitForCompletion/1","type":"function"},{"doc":"","ref":"Evision.CUDA.TargetArchs.html","title":"Evision.CUDA.TargetArchs","type":"module"},{"doc":"Raising version of has/2 .","ref":"Evision.CUDA.TargetArchs.html#has!/2","title":"Evision.CUDA.TargetArchs.has!/2","type":"function"},{"doc":"There is a set of methods to check whether the module contains intermediate (PTX) or binary CUDA code for the given architecture(s): Positional Arguments major : int . Major compute capability version. minor : int . Minor compute capability version. Python prototype (for reference): has(major, minor) -&gt; retval","ref":"Evision.CUDA.TargetArchs.html#has/2","title":"Evision.CUDA.TargetArchs.has/2","type":"function"},{"doc":"Raising version of hasBin/2 .","ref":"Evision.CUDA.TargetArchs.html#hasBin!/2","title":"Evision.CUDA.TargetArchs.hasBin!/2","type":"function"},{"doc":"Positional Arguments major : int minor : int Python prototype (for reference): hasBin(major, minor) -&gt; retval","ref":"Evision.CUDA.TargetArchs.html#hasBin/2","title":"Evision.CUDA.TargetArchs.hasBin/2","type":"function"},{"doc":"Raising version of hasEqualOrGreater/2 .","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrGreater!/2","title":"Evision.CUDA.TargetArchs.hasEqualOrGreater!/2","type":"function"},{"doc":"Positional Arguments major : int minor : int Python prototype (for reference): hasEqualOrGreater(major, minor) -&gt; retval","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrGreater/2","title":"Evision.CUDA.TargetArchs.hasEqualOrGreater/2","type":"function"},{"doc":"Raising version of hasEqualOrGreaterBin/2 .","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrGreaterBin!/2","title":"Evision.CUDA.TargetArchs.hasEqualOrGreaterBin!/2","type":"function"},{"doc":"Positional Arguments major : int minor : int Python prototype (for reference): hasEqualOrGreaterBin(major, minor) -&gt; retval","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrGreaterBin/2","title":"Evision.CUDA.TargetArchs.hasEqualOrGreaterBin/2","type":"function"},{"doc":"Raising version of hasEqualOrGreaterPtx/2 .","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrGreaterPtx!/2","title":"Evision.CUDA.TargetArchs.hasEqualOrGreaterPtx!/2","type":"function"},{"doc":"Positional Arguments major : int minor : int Python prototype (for reference): hasEqualOrGreaterPtx(major, minor) -&gt; retval","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrGreaterPtx/2","title":"Evision.CUDA.TargetArchs.hasEqualOrGreaterPtx/2","type":"function"},{"doc":"Raising version of hasEqualOrLessPtx/2 .","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrLessPtx!/2","title":"Evision.CUDA.TargetArchs.hasEqualOrLessPtx!/2","type":"function"},{"doc":"Positional Arguments major : int minor : int Python prototype (for reference): hasEqualOrLessPtx(major, minor) -&gt; retval","ref":"Evision.CUDA.TargetArchs.html#hasEqualOrLessPtx/2","title":"Evision.CUDA.TargetArchs.hasEqualOrLessPtx/2","type":"function"},{"doc":"Raising version of hasPtx/2 .","ref":"Evision.CUDA.TargetArchs.html#hasPtx!/2","title":"Evision.CUDA.TargetArchs.hasPtx!/2","type":"function"},{"doc":"Positional Arguments major : int minor : int Python prototype (for reference): hasPtx(major, minor) -&gt; retval","ref":"Evision.CUDA.TargetArchs.html#hasPtx/2","title":"Evision.CUDA.TargetArchs.hasPtx/2","type":"function"},{"doc":"","ref":"Evision.CalibrateCRF.html","title":"Evision.CalibrateCRF","type":"module"},{"doc":"Raising version of clear/1 .","ref":"Evision.CalibrateCRF.html#clear!/1","title":"Evision.CalibrateCRF.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.CalibrateCRF.html#clear/1","title":"Evision.CalibrateCRF.clear/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.CalibrateCRF.html#empty!/1","title":"Evision.CalibrateCRF.empty!/1","type":"function"},{"doc":"Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read Python prototype (for reference): empty() -&gt; retval","ref":"Evision.CalibrateCRF.html#empty/1","title":"Evision.CalibrateCRF.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.CalibrateCRF.html#getDefaultName!/1","title":"Evision.CalibrateCRF.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.CalibrateCRF.html#getDefaultName/1","title":"Evision.CalibrateCRF.getDefaultName/1","type":"function"},{"doc":"Raising version of process/3 .","ref":"Evision.CalibrateCRF.html#process!/3","title":"Evision.CalibrateCRF.process!/3","type":"function"},{"doc":"Raising version of process/4 .","ref":"Evision.CalibrateCRF.html#process!/4","title":"Evision.CalibrateCRF.process!/4","type":"function"},{"doc":"Recovers inverse camera response. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image Return dst : Evision.Mat . 256x1 matrix with inverse camera response function Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.CalibrateCRF.html#process/3","title":"Evision.CalibrateCRF.process/3","type":"function"},{"doc":"Recovers inverse camera response. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image Return dst : Evision.Mat . 256x1 matrix with inverse camera response function Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.CalibrateCRF.html#process/4","title":"Evision.CalibrateCRF.process/4","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.CalibrateCRF.html#read!/2","title":"Evision.CalibrateCRF.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.CalibrateCRF.html#read/2","title":"Evision.CalibrateCRF.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.CalibrateCRF.html#save!/2","title":"Evision.CalibrateCRF.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.CalibrateCRF.html#save/2","title":"Evision.CalibrateCRF.save/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.CalibrateCRF.html#write!/2","title":"Evision.CalibrateCRF.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.CalibrateCRF.html#write!/3","title":"Evision.CalibrateCRF.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.CalibrateCRF.html#write/2","title":"Evision.CalibrateCRF.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.CalibrateCRF.html#write/3","title":"Evision.CalibrateCRF.write/3","type":"function"},{"doc":"","ref":"Evision.CalibrateDebevec.html","title":"Evision.CalibrateDebevec","type":"module"},{"doc":"Raising version of clear/1 .","ref":"Evision.CalibrateDebevec.html#clear!/1","title":"Evision.CalibrateDebevec.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.CalibrateDebevec.html#clear/1","title":"Evision.CalibrateDebevec.clear/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.CalibrateDebevec.html#empty!/1","title":"Evision.CalibrateDebevec.empty!/1","type":"function"},{"doc":"Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read Python prototype (for reference): empty() -&gt; retval","ref":"Evision.CalibrateDebevec.html#empty/1","title":"Evision.CalibrateDebevec.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.CalibrateDebevec.html#getDefaultName!/1","title":"Evision.CalibrateDebevec.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.CalibrateDebevec.html#getDefaultName/1","title":"Evision.CalibrateDebevec.getDefaultName/1","type":"function"},{"doc":"Raising version of getLambda/1 .","ref":"Evision.CalibrateDebevec.html#getLambda!/1","title":"Evision.CalibrateDebevec.getLambda!/1","type":"function"},{"doc":"Python prototype (for reference): getLambda() -&gt; retval","ref":"Evision.CalibrateDebevec.html#getLambda/1","title":"Evision.CalibrateDebevec.getLambda/1","type":"function"},{"doc":"Raising version of getRandom/1 .","ref":"Evision.CalibrateDebevec.html#getRandom!/1","title":"Evision.CalibrateDebevec.getRandom!/1","type":"function"},{"doc":"Python prototype (for reference): getRandom() -&gt; retval","ref":"Evision.CalibrateDebevec.html#getRandom/1","title":"Evision.CalibrateDebevec.getRandom/1","type":"function"},{"doc":"Raising version of getSamples/1 .","ref":"Evision.CalibrateDebevec.html#getSamples!/1","title":"Evision.CalibrateDebevec.getSamples!/1","type":"function"},{"doc":"Python prototype (for reference): getSamples() -&gt; retval","ref":"Evision.CalibrateDebevec.html#getSamples/1","title":"Evision.CalibrateDebevec.getSamples/1","type":"function"},{"doc":"Raising version of process/3 .","ref":"Evision.CalibrateDebevec.html#process!/3","title":"Evision.CalibrateDebevec.process!/3","type":"function"},{"doc":"Raising version of process/4 .","ref":"Evision.CalibrateDebevec.html#process!/4","title":"Evision.CalibrateDebevec.process!/4","type":"function"},{"doc":"Recovers inverse camera response. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image Return dst : Evision.Mat . 256x1 matrix with inverse camera response function Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.CalibrateDebevec.html#process/3","title":"Evision.CalibrateDebevec.process/3","type":"function"},{"doc":"Recovers inverse camera response. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image Return dst : Evision.Mat . 256x1 matrix with inverse camera response function Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.CalibrateDebevec.html#process/4","title":"Evision.CalibrateDebevec.process/4","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.CalibrateDebevec.html#read!/2","title":"Evision.CalibrateDebevec.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.CalibrateDebevec.html#read/2","title":"Evision.CalibrateDebevec.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.CalibrateDebevec.html#save!/2","title":"Evision.CalibrateDebevec.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.CalibrateDebevec.html#save/2","title":"Evision.CalibrateDebevec.save/2","type":"function"},{"doc":"Raising version of setLambda/2 .","ref":"Evision.CalibrateDebevec.html#setLambda!/2","title":"Evision.CalibrateDebevec.setLambda!/2","type":"function"},{"doc":"Positional Arguments lambda : float Python prototype (for reference): setLambda(lambda) -&gt; None","ref":"Evision.CalibrateDebevec.html#setLambda/2","title":"Evision.CalibrateDebevec.setLambda/2","type":"function"},{"doc":"Raising version of setRandom/2 .","ref":"Evision.CalibrateDebevec.html#setRandom!/2","title":"Evision.CalibrateDebevec.setRandom!/2","type":"function"},{"doc":"Positional Arguments random : bool Python prototype (for reference): setRandom(random) -&gt; None","ref":"Evision.CalibrateDebevec.html#setRandom/2","title":"Evision.CalibrateDebevec.setRandom/2","type":"function"},{"doc":"Raising version of setSamples/2 .","ref":"Evision.CalibrateDebevec.html#setSamples!/2","title":"Evision.CalibrateDebevec.setSamples!/2","type":"function"},{"doc":"Positional Arguments samples : int Python prototype (for reference): setSamples(samples) -&gt; None","ref":"Evision.CalibrateDebevec.html#setSamples/2","title":"Evision.CalibrateDebevec.setSamples/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.CalibrateDebevec.html#write!/2","title":"Evision.CalibrateDebevec.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.CalibrateDebevec.html#write!/3","title":"Evision.CalibrateDebevec.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.CalibrateDebevec.html#write/2","title":"Evision.CalibrateDebevec.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.CalibrateDebevec.html#write/3","title":"Evision.CalibrateDebevec.write/3","type":"function"},{"doc":"","ref":"Evision.CalibrateRobertson.html","title":"Evision.CalibrateRobertson","type":"module"},{"doc":"Raising version of clear/1 .","ref":"Evision.CalibrateRobertson.html#clear!/1","title":"Evision.CalibrateRobertson.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.CalibrateRobertson.html#clear/1","title":"Evision.CalibrateRobertson.clear/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.CalibrateRobertson.html#empty!/1","title":"Evision.CalibrateRobertson.empty!/1","type":"function"},{"doc":"Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read Python prototype (for reference): empty() -&gt; retval","ref":"Evision.CalibrateRobertson.html#empty/1","title":"Evision.CalibrateRobertson.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.CalibrateRobertson.html#getDefaultName!/1","title":"Evision.CalibrateRobertson.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.CalibrateRobertson.html#getDefaultName/1","title":"Evision.CalibrateRobertson.getDefaultName/1","type":"function"},{"doc":"Raising version of getMaxIter/1 .","ref":"Evision.CalibrateRobertson.html#getMaxIter!/1","title":"Evision.CalibrateRobertson.getMaxIter!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxIter() -&gt; retval","ref":"Evision.CalibrateRobertson.html#getMaxIter/1","title":"Evision.CalibrateRobertson.getMaxIter/1","type":"function"},{"doc":"Raising version of getRadiance/1 .","ref":"Evision.CalibrateRobertson.html#getRadiance!/1","title":"Evision.CalibrateRobertson.getRadiance!/1","type":"function"},{"doc":"Python prototype (for reference): getRadiance() -&gt; retval","ref":"Evision.CalibrateRobertson.html#getRadiance/1","title":"Evision.CalibrateRobertson.getRadiance/1","type":"function"},{"doc":"Raising version of getThreshold/1 .","ref":"Evision.CalibrateRobertson.html#getThreshold!/1","title":"Evision.CalibrateRobertson.getThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getThreshold() -&gt; retval","ref":"Evision.CalibrateRobertson.html#getThreshold/1","title":"Evision.CalibrateRobertson.getThreshold/1","type":"function"},{"doc":"Raising version of process/3 .","ref":"Evision.CalibrateRobertson.html#process!/3","title":"Evision.CalibrateRobertson.process!/3","type":"function"},{"doc":"Raising version of process/4 .","ref":"Evision.CalibrateRobertson.html#process!/4","title":"Evision.CalibrateRobertson.process!/4","type":"function"},{"doc":"Recovers inverse camera response. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image Return dst : Evision.Mat . 256x1 matrix with inverse camera response function Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.CalibrateRobertson.html#process/3","title":"Evision.CalibrateRobertson.process/3","type":"function"},{"doc":"Recovers inverse camera response. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image Return dst : Evision.Mat . 256x1 matrix with inverse camera response function Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.CalibrateRobertson.html#process/4","title":"Evision.CalibrateRobertson.process/4","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.CalibrateRobertson.html#read!/2","title":"Evision.CalibrateRobertson.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.CalibrateRobertson.html#read/2","title":"Evision.CalibrateRobertson.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.CalibrateRobertson.html#save!/2","title":"Evision.CalibrateRobertson.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.CalibrateRobertson.html#save/2","title":"Evision.CalibrateRobertson.save/2","type":"function"},{"doc":"Raising version of setMaxIter/2 .","ref":"Evision.CalibrateRobertson.html#setMaxIter!/2","title":"Evision.CalibrateRobertson.setMaxIter!/2","type":"function"},{"doc":"Positional Arguments max_iter : int Python prototype (for reference): setMaxIter(max_iter) -&gt; None","ref":"Evision.CalibrateRobertson.html#setMaxIter/2","title":"Evision.CalibrateRobertson.setMaxIter/2","type":"function"},{"doc":"Raising version of setThreshold/2 .","ref":"Evision.CalibrateRobertson.html#setThreshold!/2","title":"Evision.CalibrateRobertson.setThreshold!/2","type":"function"},{"doc":"Positional Arguments threshold : float Python prototype (for reference): setThreshold(threshold) -&gt; None","ref":"Evision.CalibrateRobertson.html#setThreshold/2","title":"Evision.CalibrateRobertson.setThreshold/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.CalibrateRobertson.html#write!/2","title":"Evision.CalibrateRobertson.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.CalibrateRobertson.html#write!/3","title":"Evision.CalibrateRobertson.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.CalibrateRobertson.html#write/2","title":"Evision.CalibrateRobertson.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.CalibrateRobertson.html#write/3","title":"Evision.CalibrateRobertson.write/3","type":"function"},{"doc":"","ref":"Evision.CascadeClassifier.html","title":"Evision.CascadeClassifier","type":"module"},{"doc":"Raising version of cascadeClassifier/0 .","ref":"Evision.CascadeClassifier.html#cascadeClassifier!/0","title":"Evision.CascadeClassifier.cascadeClassifier!/0","type":"function"},{"doc":"Raising version of cascadeClassifier/1 .","ref":"Evision.CascadeClassifier.html#cascadeClassifier!/1","title":"Evision.CascadeClassifier.cascadeClassifier!/1","type":"function"},{"doc":"Python prototype (for reference): CascadeClassifier() -&gt; &lt;CascadeClassifier object&gt;","ref":"Evision.CascadeClassifier.html#cascadeClassifier/0","title":"Evision.CascadeClassifier.cascadeClassifier/0","type":"function"},{"doc":"Loads a classifier from a file. Positional Arguments filename : String . Name of the file from which the classifier is loaded. Python prototype (for reference): CascadeClassifier(filename) -&gt; &lt;CascadeClassifier object&gt;","ref":"Evision.CascadeClassifier.html#cascadeClassifier/1","title":"Evision.CascadeClassifier.cascadeClassifier/1","type":"function"},{"doc":"Raising version of convert/2 .","ref":"Evision.CascadeClassifier.html#convert!/2","title":"Evision.CascadeClassifier.convert!/2","type":"function"},{"doc":"Positional Arguments oldcascade : String newcascade : String Python prototype (for reference): convert(oldcascade, newcascade) -&gt; retval","ref":"Evision.CascadeClassifier.html#convert/2","title":"Evision.CascadeClassifier.convert/2","type":"function"},{"doc":"Raising version of detectMultiScale2/2 .","ref":"Evision.CascadeClassifier.html#detectMultiScale2!/2","title":"Evision.CascadeClassifier.detectMultiScale2!/2","type":"function"},{"doc":"Raising version of detectMultiScale2/3 .","ref":"Evision.CascadeClassifier.html#detectMultiScale2!/3","title":"Evision.CascadeClassifier.detectMultiScale2!/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat . Matrix of the type CV_8U containing an image where objects are detected. Keyword Arguments scaleFactor : double . Parameter specifying how much the image size is reduced at each image scale. minNeighbors : int . Parameter specifying how many neighbors each candidate rectangle should have to retain it. flags : int . Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade. minSize : Size . Minimum possible object size. Objects smaller than that are ignored. maxSize : Size . Maximum possible object size. Objects larger than that are ignored. If maxSize == minSize model is evaluated on single scale. Return objects : [Rect] . Vector of rectangles where each rectangle contains the detected object, the rectangles may be partially outside the original image. numDetections : [int] . Vector of detection numbers for the corresponding objects. An object's number of detections is the number of neighboring positively classified rectangles that were joined together to form the object. Has overloading in C++ Python prototype (for reference): detectMultiScale2(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]]) -&gt; objects, numDetections","ref":"Evision.CascadeClassifier.html#detectMultiScale2/2","title":"Evision.CascadeClassifier.detectMultiScale2/2","type":"function"},{"doc":"Positional Arguments image : Evision.Mat . Matrix of the type CV_8U containing an image where objects are detected. Keyword Arguments scaleFactor : double . Parameter specifying how much the image size is reduced at each image scale. minNeighbors : int . Parameter specifying how many neighbors each candidate rectangle should have to retain it. flags : int . Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade. minSize : Size . Minimum possible object size. Objects smaller than that are ignored. maxSize : Size . Maximum possible object size. Objects larger than that are ignored. If maxSize == minSize model is evaluated on single scale. Return objects : [Rect] . Vector of rectangles where each rectangle contains the detected object, the rectangles may be partially outside the original image. numDetections : [int] . Vector of detection numbers for the corresponding objects. An object's number of detections is the number of neighboring positively classified rectangles that were joined together to form the object. Has overloading in C++ Python prototype (for reference): detectMultiScale2(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]]) -&gt; objects, numDetections","ref":"Evision.CascadeClassifier.html#detectMultiScale2/3","title":"Evision.CascadeClassifier.detectMultiScale2/3","type":"function"},{"doc":"Raising version of detectMultiScale3/2 .","ref":"Evision.CascadeClassifier.html#detectMultiScale3!/2","title":"Evision.CascadeClassifier.detectMultiScale3!/2","type":"function"},{"doc":"Raising version of detectMultiScale3/3 .","ref":"Evision.CascadeClassifier.html#detectMultiScale3!/3","title":"Evision.CascadeClassifier.detectMultiScale3!/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat Keyword Arguments scaleFactor : double . minNeighbors : int . flags : int . minSize : Size . maxSize : Size . outputRejectLevels : bool . Return objects : [Rect] rejectLevels : [int] levelWeights : [double] Has overloading in C++ This function allows you to retrieve the final stage decision certainty of classification. For this, one needs to set outputRejectLevels on true and provide the rejectLevels and levelWeights parameter. For each resulting detection, levelWeights will then contain the certainty of classification at the final stage. This value can then be used to separate strong from weaker classifications. A code sample on how to use it efficiently can be found below: Mat img ; vector &lt; double &gt; weights ; vector &lt; int &gt; levels ; vector &lt; Rect &gt; detections ; CascadeClassifier model ( &quot;/path/to/your/model.xml&quot; ) ; model . detectMultiScale ( img , detections , levels , weights , 1.1 , 3 , 0 , Size ( ) , Size ( ) , true ) ; cerr &lt;&lt; &quot;Detection &quot; &lt;&lt; detections [ 0 ] &lt;&lt; &quot; with weight &quot; &lt;&lt; weights [ 0 ] &lt;&lt; endl ; Python prototype (for reference): detectMultiScale3(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize[, outputRejectLevels]]]]]]) -&gt; objects, rejectLevels, levelWeights","ref":"Evision.CascadeClassifier.html#detectMultiScale3/2","title":"Evision.CascadeClassifier.detectMultiScale3/2","type":"function"},{"doc":"Positional Arguments image : Evision.Mat Keyword Arguments scaleFactor : double . minNeighbors : int . flags : int . minSize : Size . maxSize : Size . outputRejectLevels : bool . Return objects : [Rect] rejectLevels : [int] levelWeights : [double] Has overloading in C++ This function allows you to retrieve the final stage decision certainty of classification. For this, one needs to set outputRejectLevels on true and provide the rejectLevels and levelWeights parameter. For each resulting detection, levelWeights will then contain the certainty of classification at the final stage. This value can then be used to separate strong from weaker classifications. A code sample on how to use it efficiently can be found below: Mat img ; vector &lt; double &gt; weights ; vector &lt; int &gt; levels ; vector &lt; Rect &gt; detections ; CascadeClassifier model ( &quot;/path/to/your/model.xml&quot; ) ; model . detectMultiScale ( img , detections , levels , weights , 1.1 , 3 , 0 , Size ( ) , Size ( ) , true ) ; cerr &lt;&lt; &quot;Detection &quot; &lt;&lt; detections [ 0 ] &lt;&lt; &quot; with weight &quot; &lt;&lt; weights [ 0 ] &lt;&lt; endl ; Python prototype (for reference): detectMultiScale3(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize[, outputRejectLevels]]]]]]) -&gt; objects, rejectLevels, levelWeights","ref":"Evision.CascadeClassifier.html#detectMultiScale3/3","title":"Evision.CascadeClassifier.detectMultiScale3/3","type":"function"},{"doc":"Raising version of detectMultiScale/2 .","ref":"Evision.CascadeClassifier.html#detectMultiScale!/2","title":"Evision.CascadeClassifier.detectMultiScale!/2","type":"function"},{"doc":"Raising version of detectMultiScale/3 .","ref":"Evision.CascadeClassifier.html#detectMultiScale!/3","title":"Evision.CascadeClassifier.detectMultiScale!/3","type":"function"},{"doc":"Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles. Positional Arguments image : Evision.Mat . Matrix of the type CV_8U containing an image where objects are detected. Keyword Arguments scaleFactor : double . Parameter specifying how much the image size is reduced at each image scale. minNeighbors : int . Parameter specifying how many neighbors each candidate rectangle should have to retain it. flags : int . Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade. minSize : Size . Minimum possible object size. Objects smaller than that are ignored. maxSize : Size . Maximum possible object size. Objects larger than that are ignored. If maxSize == minSize model is evaluated on single scale. Return objects : [Rect] . Vector of rectangles where each rectangle contains the detected object, the rectangles may be partially outside the original image. Python prototype (for reference): detectMultiScale(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]]) -&gt; objects","ref":"Evision.CascadeClassifier.html#detectMultiScale/2","title":"Evision.CascadeClassifier.detectMultiScale/2","type":"function"},{"doc":"Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles. Positional Arguments image : Evision.Mat . Matrix of the type CV_8U containing an image where objects are detected. Keyword Arguments scaleFactor : double . Parameter specifying how much the image size is reduced at each image scale. minNeighbors : int . Parameter specifying how many neighbors each candidate rectangle should have to retain it. flags : int . Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade. minSize : Size . Minimum possible object size. Objects smaller than that are ignored. maxSize : Size . Maximum possible object size. Objects larger than that are ignored. If maxSize == minSize model is evaluated on single scale. Return objects : [Rect] . Vector of rectangles where each rectangle contains the detected object, the rectangles may be partially outside the original image. Python prototype (for reference): detectMultiScale(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]]) -&gt; objects","ref":"Evision.CascadeClassifier.html#detectMultiScale/3","title":"Evision.CascadeClassifier.detectMultiScale/3","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.CascadeClassifier.html#empty!/1","title":"Evision.CascadeClassifier.empty!/1","type":"function"},{"doc":"Checks whether the classifier has been loaded. Python prototype (for reference): empty() -&gt; retval","ref":"Evision.CascadeClassifier.html#empty/1","title":"Evision.CascadeClassifier.empty/1","type":"function"},{"doc":"Raising version of getFeatureType/1 .","ref":"Evision.CascadeClassifier.html#getFeatureType!/1","title":"Evision.CascadeClassifier.getFeatureType!/1","type":"function"},{"doc":"Python prototype (for reference): getFeatureType() -&gt; retval","ref":"Evision.CascadeClassifier.html#getFeatureType/1","title":"Evision.CascadeClassifier.getFeatureType/1","type":"function"},{"doc":"Raising version of getOriginalWindowSize/1 .","ref":"Evision.CascadeClassifier.html#getOriginalWindowSize!/1","title":"Evision.CascadeClassifier.getOriginalWindowSize!/1","type":"function"},{"doc":"Python prototype (for reference): getOriginalWindowSize() -&gt; retval","ref":"Evision.CascadeClassifier.html#getOriginalWindowSize/1","title":"Evision.CascadeClassifier.getOriginalWindowSize/1","type":"function"},{"doc":"Raising version of isOldFormatCascade/1 .","ref":"Evision.CascadeClassifier.html#isOldFormatCascade!/1","title":"Evision.CascadeClassifier.isOldFormatCascade!/1","type":"function"},{"doc":"Python prototype (for reference): isOldFormatCascade() -&gt; retval","ref":"Evision.CascadeClassifier.html#isOldFormatCascade/1","title":"Evision.CascadeClassifier.isOldFormatCascade/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.CascadeClassifier.html#load!/2","title":"Evision.CascadeClassifier.load!/2","type":"function"},{"doc":"Loads a classifier from a file. Positional Arguments filename : String . Name of the file from which the classifier is loaded. The file may contain an old HAAR classifier trained by the haartraining application or a new cascade classifier trained by the traincascade application. Python prototype (for reference): load(filename) -&gt; retval","ref":"Evision.CascadeClassifier.html#load/2","title":"Evision.CascadeClassifier.load/2","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.CascadeClassifier.html#read!/2","title":"Evision.CascadeClassifier.read!/2","type":"function"},{"doc":"Reads a classifier from a FileStorage node. Positional Arguments node : FileNode Note : The file may contain a new cascade classifier (trained by the traincascade application) only. Python prototype (for reference): read(node) -&gt; retval","ref":"Evision.CascadeClassifier.html#read/2","title":"Evision.CascadeClassifier.read/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html","title":"Evision.CirclesGridFinderParameters","type":"module"},{"doc":"Raising version of circlesGridFinderParameters/0 .","ref":"Evision.CirclesGridFinderParameters.html#circlesGridFinderParameters!/0","title":"Evision.CirclesGridFinderParameters.circlesGridFinderParameters!/0","type":"function"},{"doc":"Python prototype (for reference): CirclesGridFinderParameters() -&gt; &lt;CirclesGridFinderParameters object&gt;","ref":"Evision.CirclesGridFinderParameters.html#circlesGridFinderParameters/0","title":"Evision.CirclesGridFinderParameters.circlesGridFinderParameters/0","type":"function"},{"doc":"Raising version of get_convexHullFactor/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_convexHullFactor!/1","title":"Evision.CirclesGridFinderParameters.get_convexHullFactor!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_convexHullFactor/1","title":"Evision.CirclesGridFinderParameters.get_convexHullFactor/1","type":"function"},{"doc":"Raising version of get_densityNeighborhoodSize/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_densityNeighborhoodSize!/1","title":"Evision.CirclesGridFinderParameters.get_densityNeighborhoodSize!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_densityNeighborhoodSize/1","title":"Evision.CirclesGridFinderParameters.get_densityNeighborhoodSize/1","type":"function"},{"doc":"Raising version of get_edgeGain/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_edgeGain!/1","title":"Evision.CirclesGridFinderParameters.get_edgeGain!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_edgeGain/1","title":"Evision.CirclesGridFinderParameters.get_edgeGain/1","type":"function"},{"doc":"Raising version of get_edgePenalty/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_edgePenalty!/1","title":"Evision.CirclesGridFinderParameters.get_edgePenalty!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_edgePenalty/1","title":"Evision.CirclesGridFinderParameters.get_edgePenalty/1","type":"function"},{"doc":"Raising version of get_existingVertexGain/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_existingVertexGain!/1","title":"Evision.CirclesGridFinderParameters.get_existingVertexGain!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_existingVertexGain/1","title":"Evision.CirclesGridFinderParameters.get_existingVertexGain/1","type":"function"},{"doc":"Raising version of get_keypointScale/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_keypointScale!/1","title":"Evision.CirclesGridFinderParameters.get_keypointScale!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_keypointScale/1","title":"Evision.CirclesGridFinderParameters.get_keypointScale/1","type":"function"},{"doc":"Raising version of get_kmeansAttempts/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_kmeansAttempts!/1","title":"Evision.CirclesGridFinderParameters.get_kmeansAttempts!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_kmeansAttempts/1","title":"Evision.CirclesGridFinderParameters.get_kmeansAttempts/1","type":"function"},{"doc":"Raising version of get_maxRectifiedDistance/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_maxRectifiedDistance!/1","title":"Evision.CirclesGridFinderParameters.get_maxRectifiedDistance!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_maxRectifiedDistance/1","title":"Evision.CirclesGridFinderParameters.get_maxRectifiedDistance/1","type":"function"},{"doc":"Raising version of get_minDensity/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_minDensity!/1","title":"Evision.CirclesGridFinderParameters.get_minDensity!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_minDensity/1","title":"Evision.CirclesGridFinderParameters.get_minDensity/1","type":"function"},{"doc":"Raising version of get_minDistanceToAddKeypoint/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_minDistanceToAddKeypoint!/1","title":"Evision.CirclesGridFinderParameters.get_minDistanceToAddKeypoint!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_minDistanceToAddKeypoint/1","title":"Evision.CirclesGridFinderParameters.get_minDistanceToAddKeypoint/1","type":"function"},{"doc":"Raising version of get_minGraphConfidence/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_minGraphConfidence!/1","title":"Evision.CirclesGridFinderParameters.get_minGraphConfidence!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_minGraphConfidence/1","title":"Evision.CirclesGridFinderParameters.get_minGraphConfidence/1","type":"function"},{"doc":"Raising version of get_minRNGEdgeSwitchDist/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_minRNGEdgeSwitchDist!/1","title":"Evision.CirclesGridFinderParameters.get_minRNGEdgeSwitchDist!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_minRNGEdgeSwitchDist/1","title":"Evision.CirclesGridFinderParameters.get_minRNGEdgeSwitchDist/1","type":"function"},{"doc":"Raising version of get_squareSize/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_squareSize!/1","title":"Evision.CirclesGridFinderParameters.get_squareSize!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_squareSize/1","title":"Evision.CirclesGridFinderParameters.get_squareSize/1","type":"function"},{"doc":"Raising version of get_vertexGain/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_vertexGain!/1","title":"Evision.CirclesGridFinderParameters.get_vertexGain!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_vertexGain/1","title":"Evision.CirclesGridFinderParameters.get_vertexGain/1","type":"function"},{"doc":"Raising version of get_vertexPenalty/1 .","ref":"Evision.CirclesGridFinderParameters.html#get_vertexPenalty!/1","title":"Evision.CirclesGridFinderParameters.get_vertexPenalty!/1","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#get_vertexPenalty/1","title":"Evision.CirclesGridFinderParameters.get_vertexPenalty/1","type":"function"},{"doc":"Raising version of set_convexHullFactor/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_convexHullFactor!/2","title":"Evision.CirclesGridFinderParameters.set_convexHullFactor!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_convexHullFactor/2","title":"Evision.CirclesGridFinderParameters.set_convexHullFactor/2","type":"function"},{"doc":"Raising version of set_densityNeighborhoodSize/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_densityNeighborhoodSize!/2","title":"Evision.CirclesGridFinderParameters.set_densityNeighborhoodSize!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_densityNeighborhoodSize/2","title":"Evision.CirclesGridFinderParameters.set_densityNeighborhoodSize/2","type":"function"},{"doc":"Raising version of set_edgeGain/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_edgeGain!/2","title":"Evision.CirclesGridFinderParameters.set_edgeGain!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_edgeGain/2","title":"Evision.CirclesGridFinderParameters.set_edgeGain/2","type":"function"},{"doc":"Raising version of set_edgePenalty/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_edgePenalty!/2","title":"Evision.CirclesGridFinderParameters.set_edgePenalty!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_edgePenalty/2","title":"Evision.CirclesGridFinderParameters.set_edgePenalty/2","type":"function"},{"doc":"Raising version of set_existingVertexGain/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_existingVertexGain!/2","title":"Evision.CirclesGridFinderParameters.set_existingVertexGain!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_existingVertexGain/2","title":"Evision.CirclesGridFinderParameters.set_existingVertexGain/2","type":"function"},{"doc":"Raising version of set_keypointScale/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_keypointScale!/2","title":"Evision.CirclesGridFinderParameters.set_keypointScale!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_keypointScale/2","title":"Evision.CirclesGridFinderParameters.set_keypointScale/2","type":"function"},{"doc":"Raising version of set_kmeansAttempts/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_kmeansAttempts!/2","title":"Evision.CirclesGridFinderParameters.set_kmeansAttempts!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_kmeansAttempts/2","title":"Evision.CirclesGridFinderParameters.set_kmeansAttempts/2","type":"function"},{"doc":"Raising version of set_maxRectifiedDistance/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_maxRectifiedDistance!/2","title":"Evision.CirclesGridFinderParameters.set_maxRectifiedDistance!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_maxRectifiedDistance/2","title":"Evision.CirclesGridFinderParameters.set_maxRectifiedDistance/2","type":"function"},{"doc":"Raising version of set_minDensity/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_minDensity!/2","title":"Evision.CirclesGridFinderParameters.set_minDensity!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_minDensity/2","title":"Evision.CirclesGridFinderParameters.set_minDensity/2","type":"function"},{"doc":"Raising version of set_minDistanceToAddKeypoint/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_minDistanceToAddKeypoint!/2","title":"Evision.CirclesGridFinderParameters.set_minDistanceToAddKeypoint!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_minDistanceToAddKeypoint/2","title":"Evision.CirclesGridFinderParameters.set_minDistanceToAddKeypoint/2","type":"function"},{"doc":"Raising version of set_minGraphConfidence/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_minGraphConfidence!/2","title":"Evision.CirclesGridFinderParameters.set_minGraphConfidence!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_minGraphConfidence/2","title":"Evision.CirclesGridFinderParameters.set_minGraphConfidence/2","type":"function"},{"doc":"Raising version of set_minRNGEdgeSwitchDist/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_minRNGEdgeSwitchDist!/2","title":"Evision.CirclesGridFinderParameters.set_minRNGEdgeSwitchDist!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_minRNGEdgeSwitchDist/2","title":"Evision.CirclesGridFinderParameters.set_minRNGEdgeSwitchDist/2","type":"function"},{"doc":"Raising version of set_squareSize/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_squareSize!/2","title":"Evision.CirclesGridFinderParameters.set_squareSize!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_squareSize/2","title":"Evision.CirclesGridFinderParameters.set_squareSize/2","type":"function"},{"doc":"Raising version of set_vertexGain/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_vertexGain!/2","title":"Evision.CirclesGridFinderParameters.set_vertexGain!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_vertexGain/2","title":"Evision.CirclesGridFinderParameters.set_vertexGain/2","type":"function"},{"doc":"Raising version of set_vertexPenalty/2 .","ref":"Evision.CirclesGridFinderParameters.html#set_vertexPenalty!/2","title":"Evision.CirclesGridFinderParameters.set_vertexPenalty!/2","type":"function"},{"doc":"","ref":"Evision.CirclesGridFinderParameters.html#set_vertexPenalty/2","title":"Evision.CirclesGridFinderParameters.set_vertexPenalty/2","type":"function"},{"doc":"","ref":"Evision.DISOpticalFlow.html","title":"Evision.DISOpticalFlow","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.DISOpticalFlow.html#create!/0","title":"Evision.DISOpticalFlow.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.DISOpticalFlow.html#create!/1","title":"Evision.DISOpticalFlow.create!/1","type":"function"},{"doc":"Creates an instance of DISOpticalFlow Keyword Arguments preset : int . one of PRESET_ULTRAFAST, PRESET_FAST and PRESET_MEDIUM Python prototype (for reference): create([, preset]) -&gt; retval","ref":"Evision.DISOpticalFlow.html#create/0","title":"Evision.DISOpticalFlow.create/0","type":"function"},{"doc":"Creates an instance of DISOpticalFlow Keyword Arguments preset : int . one of PRESET_ULTRAFAST, PRESET_FAST and PRESET_MEDIUM Python prototype (for reference): create([, preset]) -&gt; retval","ref":"Evision.DISOpticalFlow.html#create/1","title":"Evision.DISOpticalFlow.create/1","type":"function"},{"doc":"Raising version of getFinestScale/1 .","ref":"Evision.DISOpticalFlow.html#getFinestScale!/1","title":"Evision.DISOpticalFlow.getFinestScale!/1","type":"function"},{"doc":"Finest level of the Gaussian pyramid on which the flow is computed (zero level corresponds to the original image resolution). The final flow is obtained by bilinear upscaling. @see setFinestScale Python prototype (for reference): getFinestScale() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getFinestScale/1","title":"Evision.DISOpticalFlow.getFinestScale/1","type":"function"},{"doc":"Raising version of getGradientDescentIterations/1 .","ref":"Evision.DISOpticalFlow.html#getGradientDescentIterations!/1","title":"Evision.DISOpticalFlow.getGradientDescentIterations!/1","type":"function"},{"doc":"Maximum number of gradient descent iterations in the patch inverse search stage. Higher values may improve quality in some cases. @see setGradientDescentIterations Python prototype (for reference): getGradientDescentIterations() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getGradientDescentIterations/1","title":"Evision.DISOpticalFlow.getGradientDescentIterations/1","type":"function"},{"doc":"Raising version of getPatchSize/1 .","ref":"Evision.DISOpticalFlow.html#getPatchSize!/1","title":"Evision.DISOpticalFlow.getPatchSize!/1","type":"function"},{"doc":"Size of an image patch for matching (in pixels). Normally, default 8x8 patches work well enough in most cases. @see setPatchSize Python prototype (for reference): getPatchSize() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getPatchSize/1","title":"Evision.DISOpticalFlow.getPatchSize/1","type":"function"},{"doc":"Raising version of getPatchStride/1 .","ref":"Evision.DISOpticalFlow.html#getPatchStride!/1","title":"Evision.DISOpticalFlow.getPatchStride!/1","type":"function"},{"doc":"Stride between neighbor patches. Must be less than patch size. Lower values correspond to higher flow quality. @see setPatchStride Python prototype (for reference): getPatchStride() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getPatchStride/1","title":"Evision.DISOpticalFlow.getPatchStride/1","type":"function"},{"doc":"Raising version of getUseMeanNormalization/1 .","ref":"Evision.DISOpticalFlow.html#getUseMeanNormalization!/1","title":"Evision.DISOpticalFlow.getUseMeanNormalization!/1","type":"function"},{"doc":"Whether to use mean-normalization of patches when computing patch distance. It is turned on by default as it typically provides a noticeable quality boost because of increased robustness to illumination variations. Turn it off if you are certain that your sequence doesn't contain any changes in illumination. @see setUseMeanNormalization Python prototype (for reference): getUseMeanNormalization() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getUseMeanNormalization/1","title":"Evision.DISOpticalFlow.getUseMeanNormalization/1","type":"function"},{"doc":"Raising version of getUseSpatialPropagation/1 .","ref":"Evision.DISOpticalFlow.html#getUseSpatialPropagation!/1","title":"Evision.DISOpticalFlow.getUseSpatialPropagation!/1","type":"function"},{"doc":"Whether to use spatial propagation of good optical flow vectors. This option is turned on by default, as it tends to work better on average and can sometimes help recover from major errors introduced by the coarse-to-fine scheme employed by the DIS optical flow algorithm. Turning this option off can make the output flow field a bit smoother, however. @see setUseSpatialPropagation Python prototype (for reference): getUseSpatialPropagation() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getUseSpatialPropagation/1","title":"Evision.DISOpticalFlow.getUseSpatialPropagation/1","type":"function"},{"doc":"Raising version of getVariationalRefinementAlpha/1 .","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementAlpha!/1","title":"Evision.DISOpticalFlow.getVariationalRefinementAlpha!/1","type":"function"},{"doc":"Weight of the smoothness term @see setVariationalRefinementAlpha Python prototype (for reference): getVariationalRefinementAlpha() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementAlpha/1","title":"Evision.DISOpticalFlow.getVariationalRefinementAlpha/1","type":"function"},{"doc":"Raising version of getVariationalRefinementDelta/1 .","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementDelta!/1","title":"Evision.DISOpticalFlow.getVariationalRefinementDelta!/1","type":"function"},{"doc":"Weight of the color constancy term @see setVariationalRefinementDelta Python prototype (for reference): getVariationalRefinementDelta() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementDelta/1","title":"Evision.DISOpticalFlow.getVariationalRefinementDelta/1","type":"function"},{"doc":"Raising version of getVariationalRefinementGamma/1 .","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementGamma!/1","title":"Evision.DISOpticalFlow.getVariationalRefinementGamma!/1","type":"function"},{"doc":"Weight of the gradient constancy term @see setVariationalRefinementGamma Python prototype (for reference): getVariationalRefinementGamma() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementGamma/1","title":"Evision.DISOpticalFlow.getVariationalRefinementGamma/1","type":"function"},{"doc":"Raising version of getVariationalRefinementIterations/1 .","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementIterations!/1","title":"Evision.DISOpticalFlow.getVariationalRefinementIterations!/1","type":"function"},{"doc":"Number of fixed point iterations of variational refinement per scale. Set to zero to disable variational refinement completely. Higher values will typically result in more smooth and high-quality flow. @see setGradientDescentIterations Python prototype (for reference): getVariationalRefinementIterations() -&gt; retval","ref":"Evision.DISOpticalFlow.html#getVariationalRefinementIterations/1","title":"Evision.DISOpticalFlow.getVariationalRefinementIterations/1","type":"function"},{"doc":"Raising version of setFinestScale/2 .","ref":"Evision.DISOpticalFlow.html#setFinestScale!/2","title":"Evision.DISOpticalFlow.setFinestScale!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getFinestScale @see getFinestScale Python prototype (for reference): setFinestScale(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setFinestScale/2","title":"Evision.DISOpticalFlow.setFinestScale/2","type":"function"},{"doc":"Raising version of setGradientDescentIterations/2 .","ref":"Evision.DISOpticalFlow.html#setGradientDescentIterations!/2","title":"Evision.DISOpticalFlow.setGradientDescentIterations!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getGradientDescentIterations @see getGradientDescentIterations Python prototype (for reference): setGradientDescentIterations(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setGradientDescentIterations/2","title":"Evision.DISOpticalFlow.setGradientDescentIterations/2","type":"function"},{"doc":"Raising version of setPatchSize/2 .","ref":"Evision.DISOpticalFlow.html#setPatchSize!/2","title":"Evision.DISOpticalFlow.setPatchSize!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getPatchSize @see getPatchSize Python prototype (for reference): setPatchSize(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setPatchSize/2","title":"Evision.DISOpticalFlow.setPatchSize/2","type":"function"},{"doc":"Raising version of setPatchStride/2 .","ref":"Evision.DISOpticalFlow.html#setPatchStride!/2","title":"Evision.DISOpticalFlow.setPatchStride!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getPatchStride @see getPatchStride Python prototype (for reference): setPatchStride(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setPatchStride/2","title":"Evision.DISOpticalFlow.setPatchStride/2","type":"function"},{"doc":"Raising version of setUseMeanNormalization/2 .","ref":"Evision.DISOpticalFlow.html#setUseMeanNormalization!/2","title":"Evision.DISOpticalFlow.setUseMeanNormalization!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUseMeanNormalization @see getUseMeanNormalization Python prototype (for reference): setUseMeanNormalization(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setUseMeanNormalization/2","title":"Evision.DISOpticalFlow.setUseMeanNormalization/2","type":"function"},{"doc":"Raising version of setUseSpatialPropagation/2 .","ref":"Evision.DISOpticalFlow.html#setUseSpatialPropagation!/2","title":"Evision.DISOpticalFlow.setUseSpatialPropagation!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUseSpatialPropagation @see getUseSpatialPropagation Python prototype (for reference): setUseSpatialPropagation(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setUseSpatialPropagation/2","title":"Evision.DISOpticalFlow.setUseSpatialPropagation/2","type":"function"},{"doc":"Raising version of setVariationalRefinementAlpha/2 .","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementAlpha!/2","title":"Evision.DISOpticalFlow.setVariationalRefinementAlpha!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getVariationalRefinementAlpha @see getVariationalRefinementAlpha Python prototype (for reference): setVariationalRefinementAlpha(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementAlpha/2","title":"Evision.DISOpticalFlow.setVariationalRefinementAlpha/2","type":"function"},{"doc":"Raising version of setVariationalRefinementDelta/2 .","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementDelta!/2","title":"Evision.DISOpticalFlow.setVariationalRefinementDelta!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getVariationalRefinementDelta @see getVariationalRefinementDelta Python prototype (for reference): setVariationalRefinementDelta(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementDelta/2","title":"Evision.DISOpticalFlow.setVariationalRefinementDelta/2","type":"function"},{"doc":"Raising version of setVariationalRefinementGamma/2 .","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementGamma!/2","title":"Evision.DISOpticalFlow.setVariationalRefinementGamma!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getVariationalRefinementGamma @see getVariationalRefinementGamma Python prototype (for reference): setVariationalRefinementGamma(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementGamma/2","title":"Evision.DISOpticalFlow.setVariationalRefinementGamma/2","type":"function"},{"doc":"Raising version of setVariationalRefinementIterations/2 .","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementIterations!/2","title":"Evision.DISOpticalFlow.setVariationalRefinementIterations!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getGradientDescentIterations @see getGradientDescentIterations Python prototype (for reference): setVariationalRefinementIterations(val) -&gt; None","ref":"Evision.DISOpticalFlow.html#setVariationalRefinementIterations/2","title":"Evision.DISOpticalFlow.setVariationalRefinementIterations/2","type":"function"},{"doc":"","ref":"Evision.DMatch.html","title":"Evision.DMatch","type":"module"},{"doc":"Raising version of dMatcher/0 .","ref":"Evision.DMatch.html#dMatcher!/0","title":"Evision.DMatch.dMatcher!/0","type":"function"},{"doc":"Raising version of dMatcher/3 .","ref":"Evision.DMatch.html#dMatcher!/3","title":"Evision.DMatch.dMatcher!/3","type":"function"},{"doc":"Raising version of dMatcher/4 .","ref":"Evision.DMatch.html#dMatcher!/4","title":"Evision.DMatch.dMatcher!/4","type":"function"},{"doc":"Python prototype (for reference): DMatch() -&gt; &lt;DMatch object&gt;","ref":"Evision.DMatch.html#dMatcher/0","title":"Evision.DMatch.dMatcher/0","type":"function"},{"doc":"Positional Arguments queryIdx : int trainIdx : int distance : float Python prototype (for reference): DMatch(_queryIdx, _trainIdx, _distance) -&gt; &lt;DMatch object&gt;","ref":"Evision.DMatch.html#dMatcher/3","title":"Evision.DMatch.dMatcher/3","type":"function"},{"doc":"Positional Arguments queryIdx : int trainIdx : int imgIdx : int distance : float Python prototype (for reference): DMatch(_queryIdx, _trainIdx, _imgIdx, _distance) -&gt; &lt;DMatch object&gt;","ref":"Evision.DMatch.html#dMatcher/4","title":"Evision.DMatch.dMatcher/4","type":"function"},{"doc":"Raising version of get_distance/1 .","ref":"Evision.DMatch.html#get_distance!/1","title":"Evision.DMatch.get_distance!/1","type":"function"},{"doc":"","ref":"Evision.DMatch.html#get_distance/1","title":"Evision.DMatch.get_distance/1","type":"function"},{"doc":"Raising version of get_imgIdx/1 .","ref":"Evision.DMatch.html#get_imgIdx!/1","title":"Evision.DMatch.get_imgIdx!/1","type":"function"},{"doc":"","ref":"Evision.DMatch.html#get_imgIdx/1","title":"Evision.DMatch.get_imgIdx/1","type":"function"},{"doc":"Raising version of get_queryIdx/1 .","ref":"Evision.DMatch.html#get_queryIdx!/1","title":"Evision.DMatch.get_queryIdx!/1","type":"function"},{"doc":"","ref":"Evision.DMatch.html#get_queryIdx/1","title":"Evision.DMatch.get_queryIdx/1","type":"function"},{"doc":"Raising version of get_trainIdx/1 .","ref":"Evision.DMatch.html#get_trainIdx!/1","title":"Evision.DMatch.get_trainIdx!/1","type":"function"},{"doc":"","ref":"Evision.DMatch.html#get_trainIdx/1","title":"Evision.DMatch.get_trainIdx/1","type":"function"},{"doc":"Raising version of set_distance/2 .","ref":"Evision.DMatch.html#set_distance!/2","title":"Evision.DMatch.set_distance!/2","type":"function"},{"doc":"","ref":"Evision.DMatch.html#set_distance/2","title":"Evision.DMatch.set_distance/2","type":"function"},{"doc":"Raising version of set_imgIdx/2 .","ref":"Evision.DMatch.html#set_imgIdx!/2","title":"Evision.DMatch.set_imgIdx!/2","type":"function"},{"doc":"","ref":"Evision.DMatch.html#set_imgIdx/2","title":"Evision.DMatch.set_imgIdx/2","type":"function"},{"doc":"Raising version of set_queryIdx/2 .","ref":"Evision.DMatch.html#set_queryIdx!/2","title":"Evision.DMatch.set_queryIdx!/2","type":"function"},{"doc":"","ref":"Evision.DMatch.html#set_queryIdx/2","title":"Evision.DMatch.set_queryIdx/2","type":"function"},{"doc":"Raising version of set_trainIdx/2 .","ref":"Evision.DMatch.html#set_trainIdx!/2","title":"Evision.DMatch.set_trainIdx!/2","type":"function"},{"doc":"","ref":"Evision.DMatch.html#set_trainIdx/2","title":"Evision.DMatch.set_trainIdx/2","type":"function"},{"doc":"","ref":"Evision.DNN.html","title":"Evision.DNN","type":"module"},{"doc":"Raising version of blobFromImage/1 .","ref":"Evision.DNN.html#blobFromImage!/1","title":"Evision.DNN.blobFromImage!/1","type":"function"},{"doc":"Raising version of blobFromImage/2 .","ref":"Evision.DNN.html#blobFromImage!/2","title":"Evision.DNN.blobFromImage!/2","type":"function"},{"doc":"Creates 4-dimensional blob from image. Optionally resizes and crops @p image from center, subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels. Positional Arguments image : Evision.Mat . input image (with 1-, 3- or 4-channels). Keyword Arguments scalefactor : double . multiplier for @p image values. size : Size . spatial size for output image mean : Scalar . scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true. swapRB : bool . flag which indicates that swap first and last channels in 3-channel image is necessary. crop : bool . flag which indicates whether image will be cropped after resize or not ddepth : int . Depth of output blob. Choose CV_32F or CV_8U. @details if @p crop is true, input image is resized so one side after resize is equal to corresponding dimension in @p size and another one is equal or larger. Then, crop from the center is performed. If @p crop is false, direct resize without cropping and preserving aspect ratio is performed. @returns 4-dimensional Mat with NCHW dimensions order. Python prototype (for reference): blobFromImage(image[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]) -&gt; retval","ref":"Evision.DNN.html#blobFromImage/1","title":"Evision.DNN.blobFromImage/1","type":"function"},{"doc":"Creates 4-dimensional blob from image. Optionally resizes and crops @p image from center, subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels. Positional Arguments image : Evision.Mat . input image (with 1-, 3- or 4-channels). Keyword Arguments scalefactor : double . multiplier for @p image values. size : Size . spatial size for output image mean : Scalar . scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true. swapRB : bool . flag which indicates that swap first and last channels in 3-channel image is necessary. crop : bool . flag which indicates whether image will be cropped after resize or not ddepth : int . Depth of output blob. Choose CV_32F or CV_8U. @details if @p crop is true, input image is resized so one side after resize is equal to corresponding dimension in @p size and another one is equal or larger. Then, crop from the center is performed. If @p crop is false, direct resize without cropping and preserving aspect ratio is performed. @returns 4-dimensional Mat with NCHW dimensions order. Python prototype (for reference): blobFromImage(image[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]) -&gt; retval","ref":"Evision.DNN.html#blobFromImage/2","title":"Evision.DNN.blobFromImage/2","type":"function"},{"doc":"Raising version of blobFromImages/1 .","ref":"Evision.DNN.html#blobFromImages!/1","title":"Evision.DNN.blobFromImages!/1","type":"function"},{"doc":"Raising version of blobFromImages/2 .","ref":"Evision.DNN.html#blobFromImages!/2","title":"Evision.DNN.blobFromImages!/2","type":"function"},{"doc":"Creates 4-dimensional blob from series of images. Optionally resizes and crops @p images from center, subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels. Positional Arguments images : [Evision.Mat] . input images (all with 1-, 3- or 4-channels). Keyword Arguments scalefactor : double . multiplier for @p images values. size : Size . spatial size for output image mean : Scalar . scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true. swapRB : bool . flag which indicates that swap first and last channels in 3-channel image is necessary. crop : bool . flag which indicates whether image will be cropped after resize or not ddepth : int . Depth of output blob. Choose CV_32F or CV_8U. @details if @p crop is true, input image is resized so one side after resize is equal to corresponding dimension in @p size and another one is equal or larger. Then, crop from the center is performed. If @p crop is false, direct resize without cropping and preserving aspect ratio is performed. @returns 4-dimensional Mat with NCHW dimensions order. Python prototype (for reference): blobFromImages(images[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]) -&gt; retval","ref":"Evision.DNN.html#blobFromImages/1","title":"Evision.DNN.blobFromImages/1","type":"function"},{"doc":"Creates 4-dimensional blob from series of images. Optionally resizes and crops @p images from center, subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels. Positional Arguments images : [Evision.Mat] . input images (all with 1-, 3- or 4-channels). Keyword Arguments scalefactor : double . multiplier for @p images values. size : Size . spatial size for output image mean : Scalar . scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true. swapRB : bool . flag which indicates that swap first and last channels in 3-channel image is necessary. crop : bool . flag which indicates whether image will be cropped after resize or not ddepth : int . Depth of output blob. Choose CV_32F or CV_8U. @details if @p crop is true, input image is resized so one side after resize is equal to corresponding dimension in @p size and another one is equal or larger. Then, crop from the center is performed. If @p crop is false, direct resize without cropping and preserving aspect ratio is performed. @returns 4-dimensional Mat with NCHW dimensions order. Python prototype (for reference): blobFromImages(images[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]) -&gt; retval","ref":"Evision.DNN.html#blobFromImages/2","title":"Evision.DNN.blobFromImages/2","type":"function"},{"doc":"Raising version of getAvailableTargets/1 .","ref":"Evision.DNN.html#getAvailableTargets!/1","title":"Evision.DNN.getAvailableTargets!/1","type":"function"},{"doc":"Positional Arguments be : dnn_Backend Python prototype (for reference): getAvailableTargets(be) -&gt; retval","ref":"Evision.DNN.html#getAvailableTargets/1","title":"Evision.DNN.getAvailableTargets/1","type":"function"},{"doc":"Raising version of imagesFromBlob/1 .","ref":"Evision.DNN.html#imagesFromBlob!/1","title":"Evision.DNN.imagesFromBlob!/1","type":"function"},{"doc":"Raising version of imagesFromBlob/2 .","ref":"Evision.DNN.html#imagesFromBlob!/2","title":"Evision.DNN.imagesFromBlob!/2","type":"function"},{"doc":"Parse a 4D blob and output the images it contains as 2D arrays through a simpler data structure (std::vector&lt;cv::Mat&gt;). Positional Arguments blob_ : Evision.Mat . 4 dimensional array (images, channels, height, width) in floating point precision (CV_32F) from which you would like to extract the images. Return images_ : [Evision.Mat] . array of 2D Mat containing the images extracted from the blob in floating point precision (CV_32F). They are non normalized neither mean added. The number of returned images equals the first dimension of the blob (batch size). Every image has a number of channels equals to the second dimension of the blob (depth). Python prototype (for reference): imagesFromBlob(blob_[, images_]) -&gt; images_","ref":"Evision.DNN.html#imagesFromBlob/1","title":"Evision.DNN.imagesFromBlob/1","type":"function"},{"doc":"Parse a 4D blob and output the images it contains as 2D arrays through a simpler data structure (std::vector&lt;cv::Mat&gt;). Positional Arguments blob_ : Evision.Mat . 4 dimensional array (images, channels, height, width) in floating point precision (CV_32F) from which you would like to extract the images. Return images_ : [Evision.Mat] . array of 2D Mat containing the images extracted from the blob in floating point precision (CV_32F). They are non normalized neither mean added. The number of returned images equals the first dimension of the blob (batch size). Every image has a number of channels equals to the second dimension of the blob (depth). Python prototype (for reference): imagesFromBlob(blob_[, images_]) -&gt; images_","ref":"Evision.DNN.html#imagesFromBlob/2","title":"Evision.DNN.imagesFromBlob/2","type":"function"},{"doc":"Raising version of nmsBoxes/4 .","ref":"Evision.DNN.html#nmsBoxes!/4","title":"Evision.DNN.nmsBoxes!/4","type":"function"},{"doc":"Raising version of nmsBoxes/5 .","ref":"Evision.DNN.html#nmsBoxes!/5","title":"Evision.DNN.nmsBoxes!/5","type":"function"},{"doc":"Performs non maximum suppression given boxes and corresponding scores. Positional Arguments bboxes : [Rect2d] . a set of bounding boxes to apply NMS. scores : [float] . a set of corresponding confidences. score_threshold : float . a threshold used to filter boxes by score. nms_threshold : float . a threshold used in non maximum suppression. Keyword Arguments eta : float . a coefficient in adaptive threshold formula: \\f$nms_threshold_{i+1}=eta\\cdot nms_threshold_i\\f$. top_k : int . if &gt;0 , keep at most @p top_k picked indices. Return indices : [int] . the kept indices of bboxes after NMS. Python prototype (for reference): NMSBoxes(bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]) -&gt; indices","ref":"Evision.DNN.html#nmsBoxes/4","title":"Evision.DNN.nmsBoxes/4","type":"function"},{"doc":"Performs non maximum suppression given boxes and corresponding scores. Positional Arguments bboxes : [Rect2d] . a set of bounding boxes to apply NMS. scores : [float] . a set of corresponding confidences. score_threshold : float . a threshold used to filter boxes by score. nms_threshold : float . a threshold used in non maximum suppression. Keyword Arguments eta : float . a coefficient in adaptive threshold formula: \\f$nms_threshold_{i+1}=eta\\cdot nms_threshold_i\\f$. top_k : int . if &gt;0 , keep at most @p top_k picked indices. Return indices : [int] . the kept indices of bboxes after NMS. Python prototype (for reference): NMSBoxes(bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]) -&gt; indices","ref":"Evision.DNN.html#nmsBoxes/5","title":"Evision.DNN.nmsBoxes/5","type":"function"},{"doc":"Raising version of nmsBoxesRotated/4 .","ref":"Evision.DNN.html#nmsBoxesRotated!/4","title":"Evision.DNN.nmsBoxesRotated!/4","type":"function"},{"doc":"Raising version of nmsBoxesRotated/5 .","ref":"Evision.DNN.html#nmsBoxesRotated!/5","title":"Evision.DNN.nmsBoxesRotated!/5","type":"function"},{"doc":"Positional Arguments bboxes : [{centre={x, y}, size={s1, s2}, angle}] scores : [float] score_threshold : float nms_threshold : float Keyword Arguments eta : float . top_k : int . Return indices : [int] Python prototype (for reference): NMSBoxesRotated(bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]) -&gt; indices","ref":"Evision.DNN.html#nmsBoxesRotated/4","title":"Evision.DNN.nmsBoxesRotated/4","type":"function"},{"doc":"Positional Arguments bboxes : [{centre={x, y}, size={s1, s2}, angle}] scores : [float] score_threshold : float nms_threshold : float Keyword Arguments eta : float . top_k : int . Return indices : [int] Python prototype (for reference): NMSBoxesRotated(bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]) -&gt; indices","ref":"Evision.DNN.html#nmsBoxesRotated/5","title":"Evision.DNN.nmsBoxesRotated/5","type":"function"},{"doc":"Raising version of readNet/1 .","ref":"Evision.DNN.html#readNet!/1","title":"Evision.DNN.readNet!/1","type":"function"},{"doc":"Raising version of readNet/2 .","ref":"Evision.DNN.html#readNet!/2","title":"Evision.DNN.readNet!/2","type":"function"},{"doc":"Raising version of readNet/3 .","ref":"Evision.DNN.html#readNet!/3","title":"Evision.DNN.readNet!/3","type":"function"},{"doc":"Read deep learning network represented in one of the supported formats. Positional Arguments model : String .Binary file contains trained weights. The following file extensions are expected for models from different frameworks: *.caffemodel (Caffe, http://caffe.berkeleyvision.org/ ) *.pb (TensorFlow, https://www.tensorflow.org/ ) *.t7 | *.net (Torch, http://torch.ch/ ) *.weights (Darknet, https://pjreddie.com/darknet/ ) *.bin (DLDT, https://software.intel.com/openvino-toolkit ) *.onnx (ONNX, https://onnx.ai/ ) Keyword Arguments config : String . Text file contains network configuration. It could be a file with the following extensions: *.prototxt (Caffe, http://caffe.berkeleyvision.org/ ) *.pbtxt (TensorFlow, https://www.tensorflow.org/ ) *.cfg (Darknet, https://pjreddie.com/darknet/ ) *.xml (DLDT, https://software.intel.com/openvino-toolkit ) framework : String . Explicit framework name tag to determine a format. @returns Net object. This function automatically detects an origin framework of trained model and calls an appropriate function such @ref readNetFromCaffe, @ref readNetFromTensorflow, @ref readNetFromTorch or @ref readNetFromDarknet. An order of @p model and @p config arguments does not matter. Python prototype (for reference): readNet(model[, config[, framework]]) -&gt; retval","ref":"Evision.DNN.html#readNet/1","title":"Evision.DNN.readNet/1","type":"function"},{"doc":"Variant 1: Read deep learning network represented in one of the supported formats. Positional Arguments framework : String . Name of origin framework. bufferModel : [uchar] . A buffer with a content of binary file with weights Keyword Arguments bufferConfig : [uchar] . A buffer with a content of text file contains network configuration. @details This is an overloaded member function, provided for convenience. It differs from the above function only in what argument ( s ) it accepts . @returns Net object. Python prototype (for reference): readNet(framework, bufferModel[, bufferConfig]) -&gt; retval Variant 2: Read deep learning network represented in one of the supported formats. Positional Arguments model : String .Binary file contains trained weights. The following file extensions are expected for models from different frameworks: *.caffemodel (Caffe, http://caffe.berkeleyvision.org/ ) *.pb (TensorFlow, https://www.tensorflow.org/ ) *.t7 | *.net (Torch, http://torch.ch/ ) *.weights (Darknet, https://pjreddie.com/darknet/ ) *.bin (DLDT, https://software.intel.com/openvino-toolkit ) *.onnx (ONNX, https://onnx.ai/ ) Keyword Arguments config : String . Text file contains network configuration. It could be a file with the following extensions: *.prototxt (Caffe, http://caffe.berkeleyvision.org/ ) *.pbtxt (TensorFlow, https://www.tensorflow.org/ ) *.cfg (Darknet, https://pjreddie.com/darknet/ ) *.xml (DLDT, https://software.intel.com/openvino-toolkit ) framework : String . Explicit framework name tag to determine a format. @returns Net object. This function automatically detects an origin framework of trained model and calls an appropriate function such @ref readNetFromCaffe, @ref readNetFromTensorflow, @ref readNetFromTorch or @ref readNetFromDarknet. An order of @p model and @p config arguments does not matter. Python prototype (for reference): readNet(model[, config[, framework]]) -&gt; retval","ref":"Evision.DNN.html#readNet/2","title":"Evision.DNN.readNet/2","type":"function"},{"doc":"Read deep learning network represented in one of the supported formats. Positional Arguments framework : String . Name of origin framework. bufferModel : [uchar] . A buffer with a content of binary file with weights Keyword Arguments bufferConfig : [uchar] . A buffer with a content of text file contains network configuration. @details This is an overloaded member function, provided for convenience. It differs from the above function only in what argument ( s ) it accepts . @returns Net object. Python prototype (for reference): readNet(framework, bufferModel[, bufferConfig]) -&gt; retval","ref":"Evision.DNN.html#readNet/3","title":"Evision.DNN.readNet/3","type":"function"},{"doc":"Raising version of readNetFromCaffe/1 .","ref":"Evision.DNN.html#readNetFromCaffe!/1","title":"Evision.DNN.readNetFromCaffe!/1","type":"function"},{"doc":"Raising version of readNetFromCaffe/2 .","ref":"Evision.DNN.html#readNetFromCaffe!/2","title":"Evision.DNN.readNetFromCaffe!/2","type":"function"},{"doc":"Variant 1: Reads a network model stored in Caffe model in memory. Positional Arguments bufferProto : [uchar] . buffer containing the content of the .prototxt file Keyword Arguments bufferModel : [uchar] . buffer containing the content of the .caffemodel file @returns Net object. Python prototype (for reference): readNetFromCaffe(bufferProto[, bufferModel]) -&gt; retval Variant 2: Reads a network model stored in &lt;a href=&quot; http://caffe.berkeleyvision.org&quot; &gt;Caffe&lt;/a&gt; framework's format. Positional Arguments prototxt : String . path to the .prototxt file with text description of the network architecture. Keyword Arguments caffeModel : String . path to the .caffemodel file with learned network. @returns Net object. Python prototype (for reference): readNetFromCaffe(prototxt[, caffeModel]) -&gt; retval","ref":"Evision.DNN.html#readNetFromCaffe/1","title":"Evision.DNN.readNetFromCaffe/1","type":"function"},{"doc":"Variant 1: Reads a network model stored in Caffe model in memory. Positional Arguments bufferProto : [uchar] . buffer containing the content of the .prototxt file Keyword Arguments bufferModel : [uchar] . buffer containing the content of the .caffemodel file @returns Net object. Python prototype (for reference): readNetFromCaffe(bufferProto[, bufferModel]) -&gt; retval Variant 2: Reads a network model stored in &lt;a href=&quot; http://caffe.berkeleyvision.org&quot; &gt;Caffe&lt;/a&gt; framework's format. Positional Arguments prototxt : String . path to the .prototxt file with text description of the network architecture. Keyword Arguments caffeModel : String . path to the .caffemodel file with learned network. @returns Net object. Python prototype (for reference): readNetFromCaffe(prototxt[, caffeModel]) -&gt; retval","ref":"Evision.DNN.html#readNetFromCaffe/2","title":"Evision.DNN.readNetFromCaffe/2","type":"function"},{"doc":"Raising version of readNetFromDarknet/1 .","ref":"Evision.DNN.html#readNetFromDarknet!/1","title":"Evision.DNN.readNetFromDarknet!/1","type":"function"},{"doc":"Raising version of readNetFromDarknet/2 .","ref":"Evision.DNN.html#readNetFromDarknet!/2","title":"Evision.DNN.readNetFromDarknet!/2","type":"function"},{"doc":"Variant 1: Reads a network model stored in &lt;a href=&quot; https://pjreddie.com/darknet/&quot; &gt;Darknet&lt;/a&gt; model files. Positional Arguments bufferCfg : [uchar] . A buffer contains a content of .cfg file with text description of the network architecture. Keyword Arguments bufferModel : [uchar] . A buffer contains a content of .weights file with learned network. @returns Net object. Python prototype (for reference): readNetFromDarknet(bufferCfg[, bufferModel]) -&gt; retval Variant 2: Reads a network model stored in &lt;a href=&quot; https://pjreddie.com/darknet/&quot; &gt;Darknet&lt;/a&gt; model files. Positional Arguments cfgFile : String . path to the .cfg file with text description of the network architecture. Keyword Arguments darknetModel : String . path to the .weights file with learned network. @returns Network object that ready to do forward, throw an exception in failure cases. @returns Net object. Python prototype (for reference): readNetFromDarknet(cfgFile[, darknetModel]) -&gt; retval","ref":"Evision.DNN.html#readNetFromDarknet/1","title":"Evision.DNN.readNetFromDarknet/1","type":"function"},{"doc":"Variant 1: Reads a network model stored in &lt;a href=&quot; https://pjreddie.com/darknet/&quot; &gt;Darknet&lt;/a&gt; model files. Positional Arguments bufferCfg : [uchar] . A buffer contains a content of .cfg file with text description of the network architecture. Keyword Arguments bufferModel : [uchar] . A buffer contains a content of .weights file with learned network. @returns Net object. Python prototype (for reference): readNetFromDarknet(bufferCfg[, bufferModel]) -&gt; retval Variant 2: Reads a network model stored in &lt;a href=&quot; https://pjreddie.com/darknet/&quot; &gt;Darknet&lt;/a&gt; model files. Positional Arguments cfgFile : String . path to the .cfg file with text description of the network architecture. Keyword Arguments darknetModel : String . path to the .weights file with learned network. @returns Network object that ready to do forward, throw an exception in failure cases. @returns Net object. Python prototype (for reference): readNetFromDarknet(cfgFile[, darknetModel]) -&gt; retval","ref":"Evision.DNN.html#readNetFromDarknet/2","title":"Evision.DNN.readNetFromDarknet/2","type":"function"},{"doc":"Raising version of readNetFromModelOptimizer/2 .","ref":"Evision.DNN.html#readNetFromModelOptimizer!/2","title":"Evision.DNN.readNetFromModelOptimizer!/2","type":"function"},{"doc":"Variant 1: Load a network from Intel's Model Optimizer intermediate representation. Positional Arguments bufferModelConfig : [uchar] . Buffer contains XML configuration with network's topology. bufferWeights : [uchar] . Buffer contains binary data with trained weights. @returns Net object. Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine backend. Python prototype (for reference): readNetFromModelOptimizer(bufferModelConfig, bufferWeights) -&gt; retval Variant 2: Load a network from Intel's Model Optimizer intermediate representation. Positional Arguments xml : String . XML configuration file with network's topology. bin : String . Binary file with trained weights. @returns Net object. Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine backend. Python prototype (for reference): readNetFromModelOptimizer(xml, bin) -&gt; retval","ref":"Evision.DNN.html#readNetFromModelOptimizer/2","title":"Evision.DNN.readNetFromModelOptimizer/2","type":"function"},{"doc":"Raising version of readNetFromONNX/1 .","ref":"Evision.DNN.html#readNetFromONNX!/1","title":"Evision.DNN.readNetFromONNX!/1","type":"function"},{"doc":"Variant 1: Reads a network model from &lt;a href=&quot; https://onnx.ai/&quot; &gt;ONNX&lt;/a&gt; in-memory buffer. Positional Arguments buffer : [uchar] . in-memory buffer that stores the ONNX model bytes. @returns Network object that ready to do forward, throw an exception in failure cases . Python prototype (for reference): readNetFromONNX(buffer) -&gt; retval Variant 2: Reads a network model &lt;a href=&quot; https://onnx.ai/&quot; &gt;ONNX&lt;/a&gt;. Positional Arguments onnxFile : String . path to the .onnx file with text description of the network architecture. @returns Network object that ready to do forward, throw an exception in failure cases. Python prototype (for reference): readNetFromONNX(onnxFile) -&gt; retval","ref":"Evision.DNN.html#readNetFromONNX/1","title":"Evision.DNN.readNetFromONNX/1","type":"function"},{"doc":"Raising version of readNetFromTensorflow/1 .","ref":"Evision.DNN.html#readNetFromTensorflow!/1","title":"Evision.DNN.readNetFromTensorflow!/1","type":"function"},{"doc":"Raising version of readNetFromTensorflow/2 .","ref":"Evision.DNN.html#readNetFromTensorflow!/2","title":"Evision.DNN.readNetFromTensorflow!/2","type":"function"},{"doc":"Variant 1: Reads a network model stored in &lt;a href=&quot; https://www.tensorflow.org/&quot; &gt;TensorFlow&lt;/a&gt; framework's format. Positional Arguments bufferModel : [uchar] . buffer containing the content of the pb file Keyword Arguments bufferConfig : [uchar] . buffer containing the content of the pbtxt file @returns Net object. Python prototype (for reference): readNetFromTensorflow(bufferModel[, bufferConfig]) -&gt; retval Variant 2: Reads a network model stored in &lt;a href=&quot; https://www.tensorflow.org/&quot; &gt;TensorFlow&lt;/a&gt; framework's format. Positional Arguments model : String . path to the .pb file with binary protobuf description of the network architecture Keyword Arguments config : String . path to the .pbtxt file that contains text graph definition in protobuf format. Resulting Net object is built by text graph using weights from a binary one that let us make it more flexible. @returns Net object. Python prototype (for reference): readNetFromTensorflow(model[, config]) -&gt; retval","ref":"Evision.DNN.html#readNetFromTensorflow/1","title":"Evision.DNN.readNetFromTensorflow/1","type":"function"},{"doc":"Variant 1: Reads a network model stored in &lt;a href=&quot; https://www.tensorflow.org/&quot; &gt;TensorFlow&lt;/a&gt; framework's format. Positional Arguments bufferModel : [uchar] . buffer containing the content of the pb file Keyword Arguments bufferConfig : [uchar] . buffer containing the content of the pbtxt file @returns Net object. Python prototype (for reference): readNetFromTensorflow(bufferModel[, bufferConfig]) -&gt; retval Variant 2: Reads a network model stored in &lt;a href=&quot; https://www.tensorflow.org/&quot; &gt;TensorFlow&lt;/a&gt; framework's format. Positional Arguments model : String . path to the .pb file with binary protobuf description of the network architecture Keyword Arguments config : String . path to the .pbtxt file that contains text graph definition in protobuf format. Resulting Net object is built by text graph using weights from a binary one that let us make it more flexible. @returns Net object. Python prototype (for reference): readNetFromTensorflow(model[, config]) -&gt; retval","ref":"Evision.DNN.html#readNetFromTensorflow/2","title":"Evision.DNN.readNetFromTensorflow/2","type":"function"},{"doc":"Raising version of readNetFromTorch/1 .","ref":"Evision.DNN.html#readNetFromTorch!/1","title":"Evision.DNN.readNetFromTorch!/1","type":"function"},{"doc":"Raising version of readNetFromTorch/2 .","ref":"Evision.DNN.html#readNetFromTorch!/2","title":"Evision.DNN.readNetFromTorch!/2","type":"function"},{"doc":"Reads a network model stored in &lt;a href=&quot; http://torch.ch&quot; &gt;Torch7&lt;/a&gt; framework's format. Positional Arguments model : String . path to the file, dumped from Torch by using torch.save() function. Keyword Arguments isBinary : bool . specifies whether the network was serialized in ascii mode or binary. evaluate : bool . specifies testing phase of network. If true, it's similar to evaluate() method in Torch. @returns Net object. Note : Ascii mode of Torch serializer is more preferable, because binary mode extensively use long type of C language, which has various bit-length on different systems. The loading file must contain serialized &lt;a href=&quot; https://github.com/torch/nn/blob/master/doc/module.md&quot; &gt;nn.Module&lt;/a&gt; object with importing network. Try to eliminate a custom objects from serialazing data to avoid importing errors. List of supported layers (i.e. object instances derived from Torch nn.Module class): nn.Sequential nn.Parallel nn.Concat nn.Linear nn.SpatialConvolution nn.SpatialMaxPooling, nn.SpatialAveragePooling nn.ReLU, nn.TanH, nn.Sigmoid nn.Reshape nn.SoftMax, nn.LogSoftMax Also some equivalents of these classes from cunn, cudnn, and fbcunn may be successfully imported. Python prototype (for reference): readNetFromTorch(model[, isBinary[, evaluate]]) -&gt; retval","ref":"Evision.DNN.html#readNetFromTorch/1","title":"Evision.DNN.readNetFromTorch/1","type":"function"},{"doc":"Reads a network model stored in &lt;a href=&quot; http://torch.ch&quot; &gt;Torch7&lt;/a&gt; framework's format. Positional Arguments model : String . path to the file, dumped from Torch by using torch.save() function. Keyword Arguments isBinary : bool . specifies whether the network was serialized in ascii mode or binary. evaluate : bool . specifies testing phase of network. If true, it's similar to evaluate() method in Torch. @returns Net object. Note : Ascii mode of Torch serializer is more preferable, because binary mode extensively use long type of C language, which has various bit-length on different systems. The loading file must contain serialized &lt;a href=&quot; https://github.com/torch/nn/blob/master/doc/module.md&quot; &gt;nn.Module&lt;/a&gt; object with importing network. Try to eliminate a custom objects from serialazing data to avoid importing errors. List of supported layers (i.e. object instances derived from Torch nn.Module class): nn.Sequential nn.Parallel nn.Concat nn.Linear nn.SpatialConvolution nn.SpatialMaxPooling, nn.SpatialAveragePooling nn.ReLU, nn.TanH, nn.Sigmoid nn.Reshape nn.SoftMax, nn.LogSoftMax Also some equivalents of these classes from cunn, cudnn, and fbcunn may be successfully imported. Python prototype (for reference): readNetFromTorch(model[, isBinary[, evaluate]]) -&gt; retval","ref":"Evision.DNN.html#readNetFromTorch/2","title":"Evision.DNN.readNetFromTorch/2","type":"function"},{"doc":"Raising version of readTensorFromONNX/1 .","ref":"Evision.DNN.html#readTensorFromONNX!/1","title":"Evision.DNN.readTensorFromONNX!/1","type":"function"},{"doc":"Creates blob from .pb file. Positional Arguments path : String . to the .pb file with input tensor. @returns Mat. Python prototype (for reference): readTensorFromONNX(path) -&gt; retval","ref":"Evision.DNN.html#readTensorFromONNX/1","title":"Evision.DNN.readTensorFromONNX/1","type":"function"},{"doc":"Raising version of readTorchBlob/1 .","ref":"Evision.DNN.html#readTorchBlob!/1","title":"Evision.DNN.readTorchBlob!/1","type":"function"},{"doc":"Raising version of readTorchBlob/2 .","ref":"Evision.DNN.html#readTorchBlob!/2","title":"Evision.DNN.readTorchBlob!/2","type":"function"},{"doc":"Loads blob which was serialized as torch.Tensor object of Torch7 framework. Positional Arguments filename : String Keyword Arguments isBinary : bool . @warning This function has the same limitations as readNetFromTorch(). Python prototype (for reference): readTorchBlob(filename[, isBinary]) -&gt; retval","ref":"Evision.DNN.html#readTorchBlob/1","title":"Evision.DNN.readTorchBlob/1","type":"function"},{"doc":"Loads blob which was serialized as torch.Tensor object of Torch7 framework. Positional Arguments filename : String Keyword Arguments isBinary : bool . @warning This function has the same limitations as readNetFromTorch(). Python prototype (for reference): readTorchBlob(filename[, isBinary]) -&gt; retval","ref":"Evision.DNN.html#readTorchBlob/2","title":"Evision.DNN.readTorchBlob/2","type":"function"},{"doc":"Raising version of shrinkCaffeModel/2 .","ref":"Evision.DNN.html#shrinkCaffeModel!/2","title":"Evision.DNN.shrinkCaffeModel!/2","type":"function"},{"doc":"Raising version of shrinkCaffeModel/3 .","ref":"Evision.DNN.html#shrinkCaffeModel!/3","title":"Evision.DNN.shrinkCaffeModel!/3","type":"function"},{"doc":"Convert all weights of Caffe network to half precision floating point. Positional Arguments src : String . Path to origin model from Caffe framework contains single precision floating point weights (usually has .caffemodel extension). dst : String . Path to destination model with updated weights. Keyword Arguments layersTypes : [String] . Set of layers types which parameters will be converted. By default, converts only Convolutional and Fully-Connected layers' weights. Note : Shrinked model has no origin float32 weights so it can't be used in origin Caffe framework anymore . However the structure of data is taken from NVidia &#39; s Caffe fork : https :// github . com / NVIDIA / caffe . So the resulting model may be used there . Python prototype (for reference): shrinkCaffeModel(src, dst[, layersTypes]) -&gt; None","ref":"Evision.DNN.html#shrinkCaffeModel/2","title":"Evision.DNN.shrinkCaffeModel/2","type":"function"},{"doc":"Convert all weights of Caffe network to half precision floating point. Positional Arguments src : String . Path to origin model from Caffe framework contains single precision floating point weights (usually has .caffemodel extension). dst : String . Path to destination model with updated weights. Keyword Arguments layersTypes : [String] . Set of layers types which parameters will be converted. By default, converts only Convolutional and Fully-Connected layers' weights. Note : Shrinked model has no origin float32 weights so it can't be used in origin Caffe framework anymore . However the structure of data is taken from NVidia &#39; s Caffe fork : https :// github . com / NVIDIA / caffe . So the resulting model may be used there . Python prototype (for reference): shrinkCaffeModel(src, dst[, layersTypes]) -&gt; None","ref":"Evision.DNN.html#shrinkCaffeModel/3","title":"Evision.DNN.shrinkCaffeModel/3","type":"function"},{"doc":"Raising version of softNMSBoxes/4 .","ref":"Evision.DNN.html#softNMSBoxes!/4","title":"Evision.DNN.softNMSBoxes!/4","type":"function"},{"doc":"Raising version of softNMSBoxes/5 .","ref":"Evision.DNN.html#softNMSBoxes!/5","title":"Evision.DNN.softNMSBoxes!/5","type":"function"},{"doc":"Performs soft non maximum suppression given boxes and corresponding scores. Reference: https://arxiv.org/abs/1704.04503 Positional Arguments bboxes : [Rect] . a set of bounding boxes to apply Soft NMS. scores : [float] . a set of corresponding confidences. score_threshold : float . a threshold used to filter boxes by score. nms_threshold : float . a threshold used in non maximum suppression. Keyword Arguments top_k : size_t . keep at most @p top_k picked indices. sigma : float . parameter of Gaussian weighting. method : SoftNMSMethod . Gaussian or linear. Return updated_scores : [float] . a set of corresponding updated confidences. indices : [int] . the kept indices of bboxes after NMS. @see SoftNMSMethod Python prototype (for reference): softNMSBoxes(bboxes, scores, score_threshold, nms_threshold[, top_k[, sigma[, method]]]) -&gt; updated_scores, indices","ref":"Evision.DNN.html#softNMSBoxes/4","title":"Evision.DNN.softNMSBoxes/4","type":"function"},{"doc":"Performs soft non maximum suppression given boxes and corresponding scores. Reference: https://arxiv.org/abs/1704.04503 Positional Arguments bboxes : [Rect] . a set of bounding boxes to apply Soft NMS. scores : [float] . a set of corresponding confidences. score_threshold : float . a threshold used to filter boxes by score. nms_threshold : float . a threshold used in non maximum suppression. Keyword Arguments top_k : size_t . keep at most @p top_k picked indices. sigma : float . parameter of Gaussian weighting. method : SoftNMSMethod . Gaussian or linear. Return updated_scores : [float] . a set of corresponding updated confidences. indices : [int] . the kept indices of bboxes after NMS. @see SoftNMSMethod Python prototype (for reference): softNMSBoxes(bboxes, scores, score_threshold, nms_threshold[, top_k[, sigma[, method]]]) -&gt; updated_scores, indices","ref":"Evision.DNN.html#softNMSBoxes/5","title":"Evision.DNN.softNMSBoxes/5","type":"function"},{"doc":"Raising version of writeTextGraph/2 .","ref":"Evision.DNN.html#writeTextGraph!/2","title":"Evision.DNN.writeTextGraph!/2","type":"function"},{"doc":"Create a text representation for a binary network stored in protocol buffer format. Positional Arguments model : String . A path to binary network. output : String . A path to output text file to be created. Note : To reduce output file size, trained weights are not included. Python prototype (for reference): writeTextGraph(model, output) -&gt; None","ref":"Evision.DNN.html#writeTextGraph/2","title":"Evision.DNN.writeTextGraph/2","type":"function"},{"doc":"","ref":"Evision.DNN.ClassificationModel.html","title":"Evision.DNN.ClassificationModel","type":"module"},{"doc":"Raising version of classify/2 .","ref":"Evision.DNN.ClassificationModel.html#classify!/2","title":"Evision.DNN.ClassificationModel.classify!/2","type":"function"},{"doc":"Positional Arguments frame : Evision.Mat Return classId : int conf : float Has overloading in C++ Python prototype (for reference): classify(frame) -&gt; classId, conf","ref":"Evision.DNN.ClassificationModel.html#classify/2","title":"Evision.DNN.ClassificationModel.classify/2","type":"function"},{"doc":"Raising version of dnn_ClassificationModel/1 .","ref":"Evision.DNN.ClassificationModel.html#dnn_ClassificationModel!/1","title":"Evision.DNN.ClassificationModel.dnn_ClassificationModel!/1","type":"function"},{"doc":"Raising version of dnn_ClassificationModel/2 .","ref":"Evision.DNN.ClassificationModel.html#dnn_ClassificationModel!/2","title":"Evision.DNN.ClassificationModel.dnn_ClassificationModel!/2","type":"function"},{"doc":"Variant 1: Create model from deep learning network. Positional Arguments network : Net . Net object. Python prototype (for reference): ClassificationModel(network) -&gt; &lt;dnn_ClassificationModel object&gt; Variant 2: Create classification model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): ClassificationModel(model[, config]) -&gt; &lt;dnn_ClassificationModel object&gt;","ref":"Evision.DNN.ClassificationModel.html#dnn_ClassificationModel/1","title":"Evision.DNN.ClassificationModel.dnn_ClassificationModel/1","type":"function"},{"doc":"Create classification model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): ClassificationModel(model[, config]) -&gt; &lt;dnn_ClassificationModel object&gt;","ref":"Evision.DNN.ClassificationModel.html#dnn_ClassificationModel/2","title":"Evision.DNN.ClassificationModel.dnn_ClassificationModel/2","type":"function"},{"doc":"Raising version of getEnableSoftmaxPostProcessing/1 .","ref":"Evision.DNN.ClassificationModel.html#getEnableSoftmaxPostProcessing!/1","title":"Evision.DNN.ClassificationModel.getEnableSoftmaxPostProcessing!/1","type":"function"},{"doc":"Get enable/disable softmax post processing option. This option defaults to false, softmax post processing is not applied within the classify() function. Python prototype (for reference): getEnableSoftmaxPostProcessing() -&gt; retval","ref":"Evision.DNN.ClassificationModel.html#getEnableSoftmaxPostProcessing/1","title":"Evision.DNN.ClassificationModel.getEnableSoftmaxPostProcessing/1","type":"function"},{"doc":"Raising version of setEnableSoftmaxPostProcessing/2 .","ref":"Evision.DNN.ClassificationModel.html#setEnableSoftmaxPostProcessing!/2","title":"Evision.DNN.ClassificationModel.setEnableSoftmaxPostProcessing!/2","type":"function"},{"doc":"Set enable/disable softmax post processing option. Positional Arguments enable : bool . Set enable softmax post processing within the classify() function. If this option is true, softmax is applied after forward inference within the classify() function to convert the confidences range to [0.0-1.0]. This function allows you to toggle this behavior. Please turn true when not contain softmax layer in model. Python prototype (for reference): setEnableSoftmaxPostProcessing(enable) -&gt; retval","ref":"Evision.DNN.ClassificationModel.html#setEnableSoftmaxPostProcessing/2","title":"Evision.DNN.ClassificationModel.setEnableSoftmaxPostProcessing/2","type":"function"},{"doc":"","ref":"Evision.DNN.DetectionModel.html","title":"Evision.DNN.DetectionModel","type":"module"},{"doc":"Raising version of detect/2 .","ref":"Evision.DNN.DetectionModel.html#detect!/2","title":"Evision.DNN.DetectionModel.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.DNN.DetectionModel.html#detect!/3","title":"Evision.DNN.DetectionModel.detect!/3","type":"function"},{"doc":"Given the @p input frame, create input blob, run net and return result detections. Positional Arguments frame : Evision.Mat Keyword Arguments confThreshold : float . A threshold used to filter boxes by confidences. nmsThreshold : float . A threshold used in non maximum suppression. Return classIds : [int] . Class indexes in result detection. confidences : [float] . A set of corresponding confidences. boxes : [Rect] . A set of bounding boxes. Python prototype (for reference): detect(frame[, confThreshold[, nmsThreshold]]) -&gt; classIds, confidences, boxes","ref":"Evision.DNN.DetectionModel.html#detect/2","title":"Evision.DNN.DetectionModel.detect/2","type":"function"},{"doc":"Given the @p input frame, create input blob, run net and return result detections. Positional Arguments frame : Evision.Mat Keyword Arguments confThreshold : float . A threshold used to filter boxes by confidences. nmsThreshold : float . A threshold used in non maximum suppression. Return classIds : [int] . Class indexes in result detection. confidences : [float] . A set of corresponding confidences. boxes : [Rect] . A set of bounding boxes. Python prototype (for reference): detect(frame[, confThreshold[, nmsThreshold]]) -&gt; classIds, confidences, boxes","ref":"Evision.DNN.DetectionModel.html#detect/3","title":"Evision.DNN.DetectionModel.detect/3","type":"function"},{"doc":"Raising version of dnn_DetectionModel/1 .","ref":"Evision.DNN.DetectionModel.html#dnn_DetectionModel!/1","title":"Evision.DNN.DetectionModel.dnn_DetectionModel!/1","type":"function"},{"doc":"Raising version of dnn_DetectionModel/2 .","ref":"Evision.DNN.DetectionModel.html#dnn_DetectionModel!/2","title":"Evision.DNN.DetectionModel.dnn_DetectionModel!/2","type":"function"},{"doc":"Variant 1: Create model from deep learning network. Positional Arguments network : Net . Net object. Python prototype (for reference): DetectionModel(network) -&gt; &lt;dnn_DetectionModel object&gt; Variant 2: Create detection model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): DetectionModel(model[, config]) -&gt; &lt;dnn_DetectionModel object&gt;","ref":"Evision.DNN.DetectionModel.html#dnn_DetectionModel/1","title":"Evision.DNN.DetectionModel.dnn_DetectionModel/1","type":"function"},{"doc":"Create detection model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): DetectionModel(model[, config]) -&gt; &lt;dnn_DetectionModel object&gt;","ref":"Evision.DNN.DetectionModel.html#dnn_DetectionModel/2","title":"Evision.DNN.DetectionModel.dnn_DetectionModel/2","type":"function"},{"doc":"Raising version of getNmsAcrossClasses/1 .","ref":"Evision.DNN.DetectionModel.html#getNmsAcrossClasses!/1","title":"Evision.DNN.DetectionModel.getNmsAcrossClasses!/1","type":"function"},{"doc":"Getter for nmsAcrossClasses. This variable defaults to false, such that when non max suppression is used during the detect() function, it will do so only per-class Python prototype (for reference): getNmsAcrossClasses() -&gt; retval","ref":"Evision.DNN.DetectionModel.html#getNmsAcrossClasses/1","title":"Evision.DNN.DetectionModel.getNmsAcrossClasses/1","type":"function"},{"doc":"Raising version of setNmsAcrossClasses/2 .","ref":"Evision.DNN.DetectionModel.html#setNmsAcrossClasses!/2","title":"Evision.DNN.DetectionModel.setNmsAcrossClasses!/2","type":"function"},{"doc":"nmsAcrossClasses defaults to false, such that when non max suppression is used during the detect() function, it will do so per-class. This function allows you to toggle this behaviour. Positional Arguments value : bool . The new value for nmsAcrossClasses Python prototype (for reference): setNmsAcrossClasses(value) -&gt; retval","ref":"Evision.DNN.DetectionModel.html#setNmsAcrossClasses/2","title":"Evision.DNN.DetectionModel.setNmsAcrossClasses/2","type":"function"},{"doc":"","ref":"Evision.DNN.DictValue.html","title":"Evision.DNN.DictValue","type":"module"},{"doc":"Raising version of dnn_DictValue/1 .","ref":"Evision.DNN.DictValue.html#dnn_DictValue!/1","title":"Evision.DNN.DictValue.dnn_DictValue!/1","type":"function"},{"doc":"Variant 1: Positional Arguments s : String Python prototype (for reference): DictValue(s) -&gt; &lt;dnn_DictValue object&gt; Variant 2: Positional Arguments p : double Python prototype (for reference): DictValue(p) -&gt; &lt;dnn_DictValue object&gt; Variant 3: Positional Arguments i : int Python prototype (for reference): DictValue(i) -&gt; &lt;dnn_DictValue object&gt;","ref":"Evision.DNN.DictValue.html#dnn_DictValue/1","title":"Evision.DNN.DictValue.dnn_DictValue/1","type":"function"},{"doc":"Raising version of getIntValue/1 .","ref":"Evision.DNN.DictValue.html#getIntValue!/1","title":"Evision.DNN.DictValue.getIntValue!/1","type":"function"},{"doc":"##### Keyword Arguments idx : int . Python prototype (for reference): getIntValue([, idx]) -&gt; retval","ref":"Evision.DNN.DictValue.html#getIntValue/1","title":"Evision.DNN.DictValue.getIntValue/1","type":"function"},{"doc":"Raising version of getRealValue/1 .","ref":"Evision.DNN.DictValue.html#getRealValue!/1","title":"Evision.DNN.DictValue.getRealValue!/1","type":"function"},{"doc":"##### Keyword Arguments idx : int . Python prototype (for reference): getRealValue([, idx]) -&gt; retval","ref":"Evision.DNN.DictValue.html#getRealValue/1","title":"Evision.DNN.DictValue.getRealValue/1","type":"function"},{"doc":"Raising version of getStringValue/1 .","ref":"Evision.DNN.DictValue.html#getStringValue!/1","title":"Evision.DNN.DictValue.getStringValue!/1","type":"function"},{"doc":"##### Keyword Arguments idx : int . Python prototype (for reference): getStringValue([, idx]) -&gt; retval","ref":"Evision.DNN.DictValue.html#getStringValue/1","title":"Evision.DNN.DictValue.getStringValue/1","type":"function"},{"doc":"Raising version of isInt/1 .","ref":"Evision.DNN.DictValue.html#isInt!/1","title":"Evision.DNN.DictValue.isInt!/1","type":"function"},{"doc":"Python prototype (for reference): isInt() -&gt; retval","ref":"Evision.DNN.DictValue.html#isInt/1","title":"Evision.DNN.DictValue.isInt/1","type":"function"},{"doc":"Raising version of isReal/1 .","ref":"Evision.DNN.DictValue.html#isReal!/1","title":"Evision.DNN.DictValue.isReal!/1","type":"function"},{"doc":"Python prototype (for reference): isReal() -&gt; retval","ref":"Evision.DNN.DictValue.html#isReal/1","title":"Evision.DNN.DictValue.isReal/1","type":"function"},{"doc":"Raising version of isString/1 .","ref":"Evision.DNN.DictValue.html#isString!/1","title":"Evision.DNN.DictValue.isString!/1","type":"function"},{"doc":"Python prototype (for reference): isString() -&gt; retval","ref":"Evision.DNN.DictValue.html#isString/1","title":"Evision.DNN.DictValue.isString/1","type":"function"},{"doc":"","ref":"Evision.DNN.KeypointsModel.html","title":"Evision.DNN.KeypointsModel","type":"module"},{"doc":"Raising version of dnn_KeypointsModel/1 .","ref":"Evision.DNN.KeypointsModel.html#dnn_KeypointsModel!/1","title":"Evision.DNN.KeypointsModel.dnn_KeypointsModel!/1","type":"function"},{"doc":"Raising version of dnn_KeypointsModel/2 .","ref":"Evision.DNN.KeypointsModel.html#dnn_KeypointsModel!/2","title":"Evision.DNN.KeypointsModel.dnn_KeypointsModel!/2","type":"function"},{"doc":"Variant 1: Create model from deep learning network. Positional Arguments network : Net . Net object. Python prototype (for reference): KeypointsModel(network) -&gt; &lt;dnn_KeypointsModel object&gt; Variant 2: Create keypoints model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): KeypointsModel(model[, config]) -&gt; &lt;dnn_KeypointsModel object&gt;","ref":"Evision.DNN.KeypointsModel.html#dnn_KeypointsModel/1","title":"Evision.DNN.KeypointsModel.dnn_KeypointsModel/1","type":"function"},{"doc":"Create keypoints model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): KeypointsModel(model[, config]) -&gt; &lt;dnn_KeypointsModel object&gt;","ref":"Evision.DNN.KeypointsModel.html#dnn_KeypointsModel/2","title":"Evision.DNN.KeypointsModel.dnn_KeypointsModel/2","type":"function"},{"doc":"Raising version of estimate/2 .","ref":"Evision.DNN.KeypointsModel.html#estimate!/2","title":"Evision.DNN.KeypointsModel.estimate!/2","type":"function"},{"doc":"Raising version of estimate/3 .","ref":"Evision.DNN.KeypointsModel.html#estimate!/3","title":"Evision.DNN.KeypointsModel.estimate!/3","type":"function"},{"doc":"Given the @p input frame, create input blob, run net Positional Arguments frame : Evision.Mat Keyword Arguments thresh : float . minimum confidence threshold to select a keypoint @returns a vector holding the x and y coordinates of each detected keypoint Python prototype (for reference): estimate(frame[, thresh]) -&gt; retval","ref":"Evision.DNN.KeypointsModel.html#estimate/2","title":"Evision.DNN.KeypointsModel.estimate/2","type":"function"},{"doc":"Given the @p input frame, create input blob, run net Positional Arguments frame : Evision.Mat Keyword Arguments thresh : float . minimum confidence threshold to select a keypoint @returns a vector holding the x and y coordinates of each detected keypoint Python prototype (for reference): estimate(frame[, thresh]) -&gt; retval","ref":"Evision.DNN.KeypointsModel.html#estimate/3","title":"Evision.DNN.KeypointsModel.estimate/3","type":"function"},{"doc":"","ref":"Evision.DNN.Layer.html","title":"Evision.DNN.Layer","type":"module"},{"doc":"Raising version of finalize/2 .","ref":"Evision.DNN.Layer.html#finalize!/2","title":"Evision.DNN.Layer.finalize!/2","type":"function"},{"doc":"Raising version of finalize/3 .","ref":"Evision.DNN.Layer.html#finalize!/3","title":"Evision.DNN.Layer.finalize!/3","type":"function"},{"doc":"Computes and sets internal parameters according to inputs, outputs and blobs. Positional Arguments inputs : [Evision.Mat] Return outputs : [Evision.Mat] . vector of already allocated output blobs If this method is called after network has allocated all memory for input and output blobs and before inferencing. Python prototype (for reference): finalize(inputs[, outputs]) -&gt; outputs","ref":"Evision.DNN.Layer.html#finalize/2","title":"Evision.DNN.Layer.finalize/2","type":"function"},{"doc":"Computes and sets internal parameters according to inputs, outputs and blobs. Positional Arguments inputs : [Evision.Mat] Return outputs : [Evision.Mat] . vector of already allocated output blobs If this method is called after network has allocated all memory for input and output blobs and before inferencing. Python prototype (for reference): finalize(inputs[, outputs]) -&gt; outputs","ref":"Evision.DNN.Layer.html#finalize/3","title":"Evision.DNN.Layer.finalize/3","type":"function"},{"doc":"Raising version of get_blobs/1 .","ref":"Evision.DNN.Layer.html#get_blobs!/1","title":"Evision.DNN.Layer.get_blobs!/1","type":"function"},{"doc":"","ref":"Evision.DNN.Layer.html#get_blobs/1","title":"Evision.DNN.Layer.get_blobs/1","type":"function"},{"doc":"Raising version of get_name/1 .","ref":"Evision.DNN.Layer.html#get_name!/1","title":"Evision.DNN.Layer.get_name!/1","type":"function"},{"doc":"","ref":"Evision.DNN.Layer.html#get_name/1","title":"Evision.DNN.Layer.get_name/1","type":"function"},{"doc":"Raising version of get_preferableTarget/1 .","ref":"Evision.DNN.Layer.html#get_preferableTarget!/1","title":"Evision.DNN.Layer.get_preferableTarget!/1","type":"function"},{"doc":"","ref":"Evision.DNN.Layer.html#get_preferableTarget/1","title":"Evision.DNN.Layer.get_preferableTarget/1","type":"function"},{"doc":"Raising version of get_type/1 .","ref":"Evision.DNN.Layer.html#get_type!/1","title":"Evision.DNN.Layer.get_type!/1","type":"function"},{"doc":"","ref":"Evision.DNN.Layer.html#get_type/1","title":"Evision.DNN.Layer.get_type/1","type":"function"},{"doc":"Raising version of outputNameToIndex/2 .","ref":"Evision.DNN.Layer.html#outputNameToIndex!/2","title":"Evision.DNN.Layer.outputNameToIndex!/2","type":"function"},{"doc":"Returns index of output blob in output array. Positional Arguments outputName : String @see inputNameToIndex() Python prototype (for reference): outputNameToIndex(outputName) -&gt; retval","ref":"Evision.DNN.Layer.html#outputNameToIndex/2","title":"Evision.DNN.Layer.outputNameToIndex/2","type":"function"},{"doc":"Raising version of run/3 .","ref":"Evision.DNN.Layer.html#run!/3","title":"Evision.DNN.Layer.run!/3","type":"function"},{"doc":"Raising version of run/4 .","ref":"Evision.DNN.Layer.html#run!/4","title":"Evision.DNN.Layer.run!/4","type":"function"},{"doc":"Allocates layer and computes output. Positional Arguments inputs : [Evision.Mat] Return outputs : [Evision.Mat] . internals : [Evision.Mat] @deprecated This method will be removed in the future release. Python prototype (for reference): run(inputs, internals[, outputs]) -&gt; outputs, internals","ref":"Evision.DNN.Layer.html#run/3","title":"Evision.DNN.Layer.run/3","type":"function"},{"doc":"Allocates layer and computes output. Positional Arguments inputs : [Evision.Mat] Return outputs : [Evision.Mat] . internals : [Evision.Mat] @deprecated This method will be removed in the future release. Python prototype (for reference): run(inputs, internals[, outputs]) -&gt; outputs, internals","ref":"Evision.DNN.Layer.html#run/4","title":"Evision.DNN.Layer.run/4","type":"function"},{"doc":"Raising version of set_blobs/2 .","ref":"Evision.DNN.Layer.html#set_blobs!/2","title":"Evision.DNN.Layer.set_blobs!/2","type":"function"},{"doc":"","ref":"Evision.DNN.Layer.html#set_blobs/2","title":"Evision.DNN.Layer.set_blobs/2","type":"function"},{"doc":"","ref":"Evision.DNN.Model.html","title":"Evision.DNN.Model","type":"module"},{"doc":"Raising version of dnn_Model/1 .","ref":"Evision.DNN.Model.html#dnn_Model!/1","title":"Evision.DNN.Model.dnn_Model!/1","type":"function"},{"doc":"Raising version of dnn_Model/2 .","ref":"Evision.DNN.Model.html#dnn_Model!/2","title":"Evision.DNN.Model.dnn_Model!/2","type":"function"},{"doc":"Variant 1: Create model from deep learning network. Positional Arguments network : Net . Net object. Python prototype (for reference): Model(network) -&gt; &lt;dnn_Model object&gt; Variant 2: Create model from deep learning network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): Model(model[, config]) -&gt; &lt;dnn_Model object&gt;","ref":"Evision.DNN.Model.html#dnn_Model/1","title":"Evision.DNN.Model.dnn_Model/1","type":"function"},{"doc":"Create model from deep learning network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): Model(model[, config]) -&gt; &lt;dnn_Model object&gt;","ref":"Evision.DNN.Model.html#dnn_Model/2","title":"Evision.DNN.Model.dnn_Model/2","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.DNN.Model.html#predict!/2","title":"Evision.DNN.Model.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.DNN.Model.html#predict!/3","title":"Evision.DNN.Model.predict!/3","type":"function"},{"doc":"Given the @p input frame, create input blob, run net and return the output @p blobs. Positional Arguments frame : Evision.Mat Return outs : [Evision.Mat] . Allocated output blobs, which will store results of the computation. Python prototype (for reference): predict(frame[, outs]) -&gt; outs","ref":"Evision.DNN.Model.html#predict/2","title":"Evision.DNN.Model.predict/2","type":"function"},{"doc":"Given the @p input frame, create input blob, run net and return the output @p blobs. Positional Arguments frame : Evision.Mat Return outs : [Evision.Mat] . Allocated output blobs, which will store results of the computation. Python prototype (for reference): predict(frame[, outs]) -&gt; outs","ref":"Evision.DNN.Model.html#predict/3","title":"Evision.DNN.Model.predict/3","type":"function"},{"doc":"Raising version of setInputCrop/2 .","ref":"Evision.DNN.Model.html#setInputCrop!/2","title":"Evision.DNN.Model.setInputCrop!/2","type":"function"},{"doc":"Set flag crop for frame. Positional Arguments crop : bool . Flag which indicates whether image will be cropped after resize or not. Python prototype (for reference): setInputCrop(crop) -&gt; retval","ref":"Evision.DNN.Model.html#setInputCrop/2","title":"Evision.DNN.Model.setInputCrop/2","type":"function"},{"doc":"Raising version of setInputMean/2 .","ref":"Evision.DNN.Model.html#setInputMean!/2","title":"Evision.DNN.Model.setInputMean!/2","type":"function"},{"doc":"Set mean value for frame. Positional Arguments mean : Scalar . Scalar with mean values which are subtracted from channels. Python prototype (for reference): setInputMean(mean) -&gt; retval","ref":"Evision.DNN.Model.html#setInputMean/2","title":"Evision.DNN.Model.setInputMean/2","type":"function"},{"doc":"Raising version of setInputParams/1 .","ref":"Evision.DNN.Model.html#setInputParams!/1","title":"Evision.DNN.Model.setInputParams!/1","type":"function"},{"doc":"Set preprocessing parameters for frame. Keyword Arguments scale : double . Multiplier for frame values. size : Size . New input size. mean : Scalar . Scalar with mean values which are subtracted from channels. swapRB : bool . Flag which indicates that swap first and last channels. crop : bool . Flag which indicates whether image will be cropped after resize or not. blob(n, c, y, x) = scale * resize( frame(y, x, c) ) - mean(c) ) Python prototype (for reference): setInputParams([, scale[, size[, mean[, swapRB[, crop]]]]]) -&gt; None","ref":"Evision.DNN.Model.html#setInputParams/1","title":"Evision.DNN.Model.setInputParams/1","type":"function"},{"doc":"Raising version of setInputScale/2 .","ref":"Evision.DNN.Model.html#setInputScale!/2","title":"Evision.DNN.Model.setInputScale!/2","type":"function"},{"doc":"Set scalefactor value for frame. Positional Arguments scale : double . Multiplier for frame values. Python prototype (for reference): setInputScale(scale) -&gt; retval","ref":"Evision.DNN.Model.html#setInputScale/2","title":"Evision.DNN.Model.setInputScale/2","type":"function"},{"doc":"Raising version of setInputSize/2 .","ref":"Evision.DNN.Model.html#setInputSize!/2","title":"Evision.DNN.Model.setInputSize!/2","type":"function"},{"doc":"Raising version of setInputSize/3 .","ref":"Evision.DNN.Model.html#setInputSize!/3","title":"Evision.DNN.Model.setInputSize!/3","type":"function"},{"doc":"Set input size for frame. Positional Arguments size : Size . New input size. Note : If shape of the new blob less than 0, then frame size not change. Python prototype (for reference): setInputSize(size) -&gt; retval","ref":"Evision.DNN.Model.html#setInputSize/2","title":"Evision.DNN.Model.setInputSize/2","type":"function"},{"doc":"Positional Arguments width : int . New input width. height : int . New input height. Has overloading in C++ Python prototype (for reference): setInputSize(width, height) -&gt; retval","ref":"Evision.DNN.Model.html#setInputSize/3","title":"Evision.DNN.Model.setInputSize/3","type":"function"},{"doc":"Raising version of setInputSwapRB/2 .","ref":"Evision.DNN.Model.html#setInputSwapRB!/2","title":"Evision.DNN.Model.setInputSwapRB!/2","type":"function"},{"doc":"Set flag swapRB for frame. Positional Arguments swapRB : bool . Flag which indicates that swap first and last channels. Python prototype (for reference): setInputSwapRB(swapRB) -&gt; retval","ref":"Evision.DNN.Model.html#setInputSwapRB/2","title":"Evision.DNN.Model.setInputSwapRB/2","type":"function"},{"doc":"Raising version of setPreferableBackend/2 .","ref":"Evision.DNN.Model.html#setPreferableBackend!/2","title":"Evision.DNN.Model.setPreferableBackend!/2","type":"function"},{"doc":"Positional Arguments backendId : dnn_Backend Python prototype (for reference): setPreferableBackend(backendId) -&gt; retval","ref":"Evision.DNN.Model.html#setPreferableBackend/2","title":"Evision.DNN.Model.setPreferableBackend/2","type":"function"},{"doc":"Raising version of setPreferableTarget/2 .","ref":"Evision.DNN.Model.html#setPreferableTarget!/2","title":"Evision.DNN.Model.setPreferableTarget!/2","type":"function"},{"doc":"Positional Arguments targetId : dnn_Target Python prototype (for reference): setPreferableTarget(targetId) -&gt; retval","ref":"Evision.DNN.Model.html#setPreferableTarget/2","title":"Evision.DNN.Model.setPreferableTarget/2","type":"function"},{"doc":"","ref":"Evision.DNN.Net.html","title":"Evision.DNN.Net","type":"module"},{"doc":"Raising version of connect/3 .","ref":"Evision.DNN.Net.html#connect!/3","title":"Evision.DNN.Net.connect!/3","type":"function"},{"doc":"Connects output of the first layer to input of the second layer. Positional Arguments outPin : String . descriptor of the first layer output. inpPin : String . descriptor of the second layer input. Descriptors have the following template &lt;DFN&gt;&amp;lt;layer_name&amp;gt;[.input_number]&lt;/DFN&gt;: the first part of the template &lt;DFN&gt;layer_name&lt;/DFN&gt; is string name of the added layer. If this part is empty then the network input pseudo layer will be used; the second optional part of the template &lt;DFN&gt;input_number&lt;/DFN&gt; is either number of the layer input, either label one. If this part is omitted then the first layer input will be used. @see setNetInputs(), Layer::inputNameToIndex(), Layer::outputNameToIndex() Python prototype (for reference): connect(outPin, inpPin) -&gt; None","ref":"Evision.DNN.Net.html#connect/3","title":"Evision.DNN.Net.connect/3","type":"function"},{"doc":"Raising version of dnn_Net/0 .","ref":"Evision.DNN.Net.html#dnn_Net!/0","title":"Evision.DNN.Net.dnn_Net!/0","type":"function"},{"doc":"Python prototype (for reference): Net() -&gt; &lt;dnn_Net object&gt;","ref":"Evision.DNN.Net.html#dnn_Net/0","title":"Evision.DNN.Net.dnn_Net/0","type":"function"},{"doc":"Raising version of dump/1 .","ref":"Evision.DNN.Net.html#dump!/1","title":"Evision.DNN.Net.dump!/1","type":"function"},{"doc":"Dump net to String @returns String with structure, hyperparameters, backend, target and fusion Call method after setInput(). To see correct backend, target and fusion run after forward(). Python prototype (for reference): dump() -&gt; retval","ref":"Evision.DNN.Net.html#dump/1","title":"Evision.DNN.Net.dump/1","type":"function"},{"doc":"Raising version of dumpToFile/2 .","ref":"Evision.DNN.Net.html#dumpToFile!/2","title":"Evision.DNN.Net.dumpToFile!/2","type":"function"},{"doc":"Dump net structure, hyperparameters, backend, target and fusion to dot file Positional Arguments path : String . path to output file with .dot extension @see dump() Python prototype (for reference): dumpToFile(path) -&gt; None","ref":"Evision.DNN.Net.html#dumpToFile/2","title":"Evision.DNN.Net.dumpToFile/2","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.DNN.Net.html#empty!/1","title":"Evision.DNN.Net.empty!/1","type":"function"},{"doc":"Returns true if there are no layers in the network. Python prototype (for reference): empty() -&gt; retval","ref":"Evision.DNN.Net.html#empty/1","title":"Evision.DNN.Net.empty/1","type":"function"},{"doc":"Raising version of enableFusion/2 .","ref":"Evision.DNN.Net.html#enableFusion!/2","title":"Evision.DNN.Net.enableFusion!/2","type":"function"},{"doc":"Enables or disables layer fusion in the network. Positional Arguments fusion : bool . true to enable the fusion, false to disable. The fusion is enabled by default. Python prototype (for reference): enableFusion(fusion) -&gt; None","ref":"Evision.DNN.Net.html#enableFusion/2","title":"Evision.DNN.Net.enableFusion/2","type":"function"},{"doc":"Raising version of forward/2 .","ref":"Evision.DNN.Net.html#forward!/2","title":"Evision.DNN.Net.forward!/2","type":"function"},{"doc":"Runs forward pass to compute outputs of layers listed in @p outBlobNames. Positional Arguments outBlobNames : [String] . names for layers which outputs are needed to get Return outputBlobs : [Evision.Mat] . contains blobs for first outputs of specified layers. Python prototype (for reference): forward(outBlobNames[, outputBlobs]) -&gt; outputBlobs","ref":"Evision.DNN.Net.html#forward/2","title":"Evision.DNN.Net.forward/2","type":"function"},{"doc":"Raising version of forwardAndRetrieve/2 .","ref":"Evision.DNN.Net.html#forwardAndRetrieve!/2","title":"Evision.DNN.Net.forwardAndRetrieve!/2","type":"function"},{"doc":"Runs forward pass to compute outputs of layers listed in @p outBlobNames. Positional Arguments outBlobNames : [String] . names for layers which outputs are needed to get Return outputBlobs : [vector_Mat] . contains all output blobs for each layer specified in @p outBlobNames. Python prototype (for reference): forwardAndRetrieve(outBlobNames) -&gt; outputBlobs","ref":"Evision.DNN.Net.html#forwardAndRetrieve/2","title":"Evision.DNN.Net.forwardAndRetrieve/2","type":"function"},{"doc":"Raising version of forwardAsync/1 .","ref":"Evision.DNN.Net.html#forwardAsync!/1","title":"Evision.DNN.Net.forwardAsync!/1","type":"function"},{"doc":"Runs forward pass to compute output of layer with name @p outputName. Keyword Arguments outputName : String . name for layer which output is needed to get @details By default runs forward pass for the whole network. This is an asynchronous version of forward(const String&amp;). dnn::DNN_BACKEND_INFERENCE_ENGINE backend is required. Python prototype (for reference): forwardAsync([, outputName]) -&gt; retval","ref":"Evision.DNN.Net.html#forwardAsync/1","title":"Evision.DNN.Net.forwardAsync/1","type":"function"},{"doc":"Raising version of getFLOPS/2 .","ref":"Evision.DNN.Net.html#getFLOPS!/2","title":"Evision.DNN.Net.getFLOPS!/2","type":"function"},{"doc":"Raising version of getFLOPS/3 .","ref":"Evision.DNN.Net.html#getFLOPS!/3","title":"Evision.DNN.Net.getFLOPS!/3","type":"function"},{"doc":"Variant 1: Positional Arguments netInputShape : MatShape Has overloading in C++ Python prototype (for reference): getFLOPS(netInputShape) -&gt; retval Variant 2: Computes FLOP for whole loaded model with specified input shapes. Positional Arguments netInputShapes : [MatShape] . vector of shapes for all net inputs. @returns computed FLOP. Python prototype (for reference): getFLOPS(netInputShapes) -&gt; retval","ref":"Evision.DNN.Net.html#getFLOPS/2","title":"Evision.DNN.Net.getFLOPS/2","type":"function"},{"doc":"Variant 1: Positional Arguments layerId : int netInputShape : MatShape Has overloading in C++ Python prototype (for reference): getFLOPS(layerId, netInputShape) -&gt; retval Variant 2: Positional Arguments layerId : int netInputShapes : [MatShape] Has overloading in C++ Python prototype (for reference): getFLOPS(layerId, netInputShapes) -&gt; retval","ref":"Evision.DNN.Net.html#getFLOPS/3","title":"Evision.DNN.Net.getFLOPS/3","type":"function"},{"doc":"Raising version of getInputDetails/1 .","ref":"Evision.DNN.Net.html#getInputDetails!/1","title":"Evision.DNN.Net.getInputDetails!/1","type":"function"},{"doc":"Returns input scale and zeropoint for a quantized Net. Return scales : [float] . output parameter for returning input scales. zeropoints : [int] . output parameter for returning input zeropoints. Python prototype (for reference): getInputDetails() -&gt; scales, zeropoints","ref":"Evision.DNN.Net.html#getInputDetails/1","title":"Evision.DNN.Net.getInputDetails/1","type":"function"},{"doc":"Raising version of getLayer/2 .","ref":"Evision.DNN.Net.html#getLayer!/2","title":"Evision.DNN.Net.getLayer!/2","type":"function"},{"doc":"Variant 1: Positional Arguments layerName : String Has overloading in C++ @deprecated Use int getLayerId(const String &amp;layer) Python prototype (for reference): getLayer(layerName) -&gt; retval Variant 2: Returns pointer to layer with specified id or name which the network use. Positional Arguments layerId : int Python prototype (for reference): getLayer(layerId) -&gt; retval Variant 3: Positional Arguments layerId : LayerId Has overloading in C++ @deprecated to be removed Python prototype (for reference): getLayer(layerId) -&gt; retval","ref":"Evision.DNN.Net.html#getLayer/2","title":"Evision.DNN.Net.getLayer/2","type":"function"},{"doc":"Raising version of getLayerId/2 .","ref":"Evision.DNN.Net.html#getLayerId!/2","title":"Evision.DNN.Net.getLayerId!/2","type":"function"},{"doc":"Converts string name of the layer to the integer identifier. Positional Arguments layer : String @returns id of the layer, or -1 if the layer wasn't found. Python prototype (for reference): getLayerId(layer) -&gt; retval","ref":"Evision.DNN.Net.html#getLayerId/2","title":"Evision.DNN.Net.getLayerId/2","type":"function"},{"doc":"Raising version of getLayerNames/1 .","ref":"Evision.DNN.Net.html#getLayerNames!/1","title":"Evision.DNN.Net.getLayerNames!/1","type":"function"},{"doc":"Python prototype (for reference): getLayerNames() -&gt; retval","ref":"Evision.DNN.Net.html#getLayerNames/1","title":"Evision.DNN.Net.getLayerNames/1","type":"function"},{"doc":"Raising version of getLayerShapes/2 .","ref":"Evision.DNN.Net.html#getLayerShapes!/2","title":"Evision.DNN.Net.getLayerShapes!/2","type":"function"},{"doc":"Positional Arguments netInputShapes : [MatShape] layerId : int Return inLayerShapes : [MatShape] outLayerShapes : [MatShape] Has overloading in C++ Python prototype (for reference): getLayerShapes(netInputShapes, layerId) -&gt; inLayerShapes, outLayerShapes","ref":"Evision.DNN.Net.html#getLayerShapes/2","title":"Evision.DNN.Net.getLayerShapes/2","type":"function"},{"doc":"Raising version of getLayersCount/2 .","ref":"Evision.DNN.Net.html#getLayersCount!/2","title":"Evision.DNN.Net.getLayersCount!/2","type":"function"},{"doc":"Returns count of layers of specified type. Positional Arguments layerType : String . type. @returns count of layers Python prototype (for reference): getLayersCount(layerType) -&gt; retval","ref":"Evision.DNN.Net.html#getLayersCount/2","title":"Evision.DNN.Net.getLayersCount/2","type":"function"},{"doc":"Raising version of getLayersShapes/2 .","ref":"Evision.DNN.Net.html#getLayersShapes!/2","title":"Evision.DNN.Net.getLayersShapes!/2","type":"function"},{"doc":"Positional Arguments netInputShape : MatShape Return layersIds : [int] inLayersShapes : [vector_MatShape] outLayersShapes : [vector_MatShape] Has overloading in C++ Python prototype (for reference): getLayersShapes(netInputShape) -&gt; layersIds, inLayersShapes, outLayersShapes","ref":"Evision.DNN.Net.html#getLayersShapes/2","title":"Evision.DNN.Net.getLayersShapes/2","type":"function"},{"doc":"Raising version of getLayerTypes/1 .","ref":"Evision.DNN.Net.html#getLayerTypes!/1","title":"Evision.DNN.Net.getLayerTypes!/1","type":"function"},{"doc":"Returns list of types for layer used in model. Return layersTypes : [String] . output parameter for returning types. Python prototype (for reference): getLayerTypes() -&gt; layersTypes","ref":"Evision.DNN.Net.html#getLayerTypes/1","title":"Evision.DNN.Net.getLayerTypes/1","type":"function"},{"doc":"Raising version of getMemoryConsumption/2 .","ref":"Evision.DNN.Net.html#getMemoryConsumption!/2","title":"Evision.DNN.Net.getMemoryConsumption!/2","type":"function"},{"doc":"Raising version of getMemoryConsumption/3 .","ref":"Evision.DNN.Net.html#getMemoryConsumption!/3","title":"Evision.DNN.Net.getMemoryConsumption!/3","type":"function"},{"doc":"Positional Arguments netInputShape : MatShape Return weights : size_t blobs : size_t Has overloading in C++ Python prototype (for reference): getMemoryConsumption(netInputShape) -&gt; weights, blobs","ref":"Evision.DNN.Net.html#getMemoryConsumption/2","title":"Evision.DNN.Net.getMemoryConsumption/2","type":"function"},{"doc":"Variant 1: Positional Arguments layerId : int netInputShape : MatShape Return weights : size_t blobs : size_t Has overloading in C++ Python prototype (for reference): getMemoryConsumption(layerId, netInputShape) -&gt; weights, blobs Variant 2: Positional Arguments layerId : int netInputShapes : [MatShape] Return weights : size_t blobs : size_t Has overloading in C++ Python prototype (for reference): getMemoryConsumption(layerId, netInputShapes) -&gt; weights, blobs","ref":"Evision.DNN.Net.html#getMemoryConsumption/3","title":"Evision.DNN.Net.getMemoryConsumption/3","type":"function"},{"doc":"Raising version of getOutputDetails/1 .","ref":"Evision.DNN.Net.html#getOutputDetails!/1","title":"Evision.DNN.Net.getOutputDetails!/1","type":"function"},{"doc":"Returns output scale and zeropoint for a quantized Net. Return scales : [float] . output parameter for returning output scales. zeropoints : [int] . output parameter for returning output zeropoints. Python prototype (for reference): getOutputDetails() -&gt; scales, zeropoints","ref":"Evision.DNN.Net.html#getOutputDetails/1","title":"Evision.DNN.Net.getOutputDetails/1","type":"function"},{"doc":"Raising version of getParam/2 .","ref":"Evision.DNN.Net.html#getParam!/2","title":"Evision.DNN.Net.getParam!/2","type":"function"},{"doc":"Raising version of getParam/3 .","ref":"Evision.DNN.Net.html#getParam!/3","title":"Evision.DNN.Net.getParam!/3","type":"function"},{"doc":"Variant 1: Positional Arguments layerName : String Keyword Arguments numParam : int . Python prototype (for reference): getParam(layerName[, numParam]) -&gt; retval Variant 2: Returns parameter blob of the layer. Positional Arguments layer : int . name or id of the layer. Keyword Arguments numParam : int . index of the layer parameter in the Layer::blobs array. @see Layer::blobs Python prototype (for reference): getParam(layer[, numParam]) -&gt; retval","ref":"Evision.DNN.Net.html#getParam/2","title":"Evision.DNN.Net.getParam/2","type":"function"},{"doc":"Variant 1: Positional Arguments layerName : String Keyword Arguments numParam : int . Python prototype (for reference): getParam(layerName[, numParam]) -&gt; retval Variant 2: Returns parameter blob of the layer. Positional Arguments layer : int . name or id of the layer. Keyword Arguments numParam : int . index of the layer parameter in the Layer::blobs array. @see Layer::blobs Python prototype (for reference): getParam(layer[, numParam]) -&gt; retval","ref":"Evision.DNN.Net.html#getParam/3","title":"Evision.DNN.Net.getParam/3","type":"function"},{"doc":"Raising version of getPerfProfile/1 .","ref":"Evision.DNN.Net.html#getPerfProfile!/1","title":"Evision.DNN.Net.getPerfProfile!/1","type":"function"},{"doc":"Returns overall time for inference and timings (in ticks) for layers. Return timings : [double] . vector for tick timings for all layers. Indexes in returned vector correspond to layers ids. Some layers can be fused with others, in this case zero ticks count will be return for that skipped layers. Supported by DNN_BACKEND_OPENCV on DNN_TARGET_CPU only. @return overall ticks for model inference. Python prototype (for reference): getPerfProfile() -&gt; retval, timings","ref":"Evision.DNN.Net.html#getPerfProfile/1","title":"Evision.DNN.Net.getPerfProfile/1","type":"function"},{"doc":"Raising version of getUnconnectedOutLayers/1 .","ref":"Evision.DNN.Net.html#getUnconnectedOutLayers!/1","title":"Evision.DNN.Net.getUnconnectedOutLayers!/1","type":"function"},{"doc":"Returns indexes of layers with unconnected outputs. FIXIT: Rework API to registerOutput() approach, deprecate this call Python prototype (for reference): getUnconnectedOutLayers() -&gt; retval","ref":"Evision.DNN.Net.html#getUnconnectedOutLayers/1","title":"Evision.DNN.Net.getUnconnectedOutLayers/1","type":"function"},{"doc":"Raising version of getUnconnectedOutLayersNames/1 .","ref":"Evision.DNN.Net.html#getUnconnectedOutLayersNames!/1","title":"Evision.DNN.Net.getUnconnectedOutLayersNames!/1","type":"function"},{"doc":"Returns names of layers with unconnected outputs. FIXIT: Rework API to registerOutput() approach, deprecate this call Python prototype (for reference): getUnconnectedOutLayersNames() -&gt; retval","ref":"Evision.DNN.Net.html#getUnconnectedOutLayersNames/1","title":"Evision.DNN.Net.getUnconnectedOutLayersNames/1","type":"function"},{"doc":"Raising version of quantize/4 .","ref":"Evision.DNN.Net.html#quantize!/4","title":"Evision.DNN.Net.quantize!/4","type":"function"},{"doc":"Returns a quantized Net from a floating-point Net. Positional Arguments calibData : [Evision.Mat] . Calibration data to compute the quantization parameters. inputsDtype : int . Datatype of quantized net's inputs. Can be CV_32F or CV_8S. outputsDtype : int . Datatype of quantized net's outputs. Can be CV_32F or CV_8S. Python prototype (for reference): quantize(calibData, inputsDtype, outputsDtype) -&gt; retval","ref":"Evision.DNN.Net.html#quantize/4","title":"Evision.DNN.Net.quantize/4","type":"function"},{"doc":"Raising version of readFromModelOptimizer/2 .","ref":"Evision.DNN.Net.html#readFromModelOptimizer!/2","title":"Evision.DNN.Net.readFromModelOptimizer!/2","type":"function"},{"doc":"Variant 1: Create a network from Intel's Model Optimizer in-memory buffers with intermediate representation (IR). Positional Arguments bufferModelConfig : [uchar] . buffer with model's configuration. bufferWeights : [uchar] . buffer with model's trained weights. @returns Net object. Python prototype (for reference): readFromModelOptimizer(bufferModelConfig, bufferWeights) -&gt; retval Variant 2: Create a network from Intel's Model Optimizer intermediate representation (IR). Positional Arguments xml : String . XML configuration file with network's topology. bin : String . Binary file with trained weights. Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine backend. Python prototype (for reference): readFromModelOptimizer(xml, bin) -&gt; retval","ref":"Evision.DNN.Net.html#readFromModelOptimizer/2","title":"Evision.DNN.Net.readFromModelOptimizer/2","type":"function"},{"doc":"Raising version of setHalideScheduler/2 .","ref":"Evision.DNN.Net.html#setHalideScheduler!/2","title":"Evision.DNN.Net.setHalideScheduler!/2","type":"function"},{"doc":"Compile Halide layers. Positional Arguments scheduler : String . Path to YAML file with scheduling directives. @see setPreferableBackend Schedule layers that support Halide backend. Then compile them for specific target. For layers that not represented in scheduling file or if no manual scheduling used at all, automatic scheduling will be applied. Python prototype (for reference): setHalideScheduler(scheduler) -&gt; None","ref":"Evision.DNN.Net.html#setHalideScheduler/2","title":"Evision.DNN.Net.setHalideScheduler/2","type":"function"},{"doc":"Raising version of setInput/2 .","ref":"Evision.DNN.Net.html#setInput!/2","title":"Evision.DNN.Net.setInput!/2","type":"function"},{"doc":"Raising version of setInput/3 .","ref":"Evision.DNN.Net.html#setInput!/3","title":"Evision.DNN.Net.setInput!/3","type":"function"},{"doc":"Sets the new input value for the network Positional Arguments blob : Evision.Mat . A new blob. Should have CV_32F or CV_8U depth. Keyword Arguments name : String . A name of input layer. scalefactor : double . An optional normalization scale. mean : Scalar . An optional mean subtraction values. @see connect(String, String) to know format of the descriptor. If scale or mean values are specified, a final input blob is computed as: \\f[input(n,c,h,w) = scalefactor \\times (blob(n,c,h,w) - mean_c)\\f] Python prototype (for reference): setInput(blob[, name[, scalefactor[, mean]]]) -&gt; None","ref":"Evision.DNN.Net.html#setInput/2","title":"Evision.DNN.Net.setInput/2","type":"function"},{"doc":"Sets the new input value for the network Positional Arguments blob : Evision.Mat . A new blob. Should have CV_32F or CV_8U depth. Keyword Arguments name : String . A name of input layer. scalefactor : double . An optional normalization scale. mean : Scalar . An optional mean subtraction values. @see connect(String, String) to know format of the descriptor. If scale or mean values are specified, a final input blob is computed as: \\f[input(n,c,h,w) = scalefactor \\times (blob(n,c,h,w) - mean_c)\\f] Python prototype (for reference): setInput(blob[, name[, scalefactor[, mean]]]) -&gt; None","ref":"Evision.DNN.Net.html#setInput/3","title":"Evision.DNN.Net.setInput/3","type":"function"},{"doc":"Raising version of setInputShape/3 .","ref":"Evision.DNN.Net.html#setInputShape!/3","title":"Evision.DNN.Net.setInputShape!/3","type":"function"},{"doc":"Specify shape of network input. Positional Arguments inputName : String shape : MatShape Python prototype (for reference): setInputShape(inputName, shape) -&gt; None","ref":"Evision.DNN.Net.html#setInputShape/3","title":"Evision.DNN.Net.setInputShape/3","type":"function"},{"doc":"Raising version of setInputsNames/2 .","ref":"Evision.DNN.Net.html#setInputsNames!/2","title":"Evision.DNN.Net.setInputsNames!/2","type":"function"},{"doc":"Sets outputs names of the network input pseudo layer. Positional Arguments inputBlobNames : [String] Each net always has special own the network input pseudo layer with id=0. This layer stores the user blobs only and don't make any computations. In fact, this layer provides the only way to pass user data into the network. As any other layer, this layer can label its outputs and this function provides an easy way to do this. Python prototype (for reference): setInputsNames(inputBlobNames) -&gt; None","ref":"Evision.DNN.Net.html#setInputsNames/2","title":"Evision.DNN.Net.setInputsNames/2","type":"function"},{"doc":"Raising version of setParam/4 .","ref":"Evision.DNN.Net.html#setParam!/4","title":"Evision.DNN.Net.setParam!/4","type":"function"},{"doc":"Variant 1: Positional Arguments layerName : String numParam : int blob : Evision.Mat Python prototype (for reference): setParam(layerName, numParam, blob) -&gt; None Variant 2: Sets the new value for the learned param of the layer. Positional Arguments layer : int . name or id of the layer. numParam : int . index of the layer parameter in the Layer::blobs array. blob : Evision.Mat . the new value. @see Layer::blobs Note : If shape of the new blob differs from the previous shape, then the following forward pass may fail. Python prototype (for reference): setParam(layer, numParam, blob) -&gt; None","ref":"Evision.DNN.Net.html#setParam/4","title":"Evision.DNN.Net.setParam/4","type":"function"},{"doc":"Raising version of setPreferableBackend/2 .","ref":"Evision.DNN.Net.html#setPreferableBackend!/2","title":"Evision.DNN.Net.setPreferableBackend!/2","type":"function"},{"doc":"Ask network to use specific computation backend where it supported. Positional Arguments backendId : int . backend identifier. @see Backend If OpenCV is compiled with Intel's Inference Engine library, DNN_BACKEND_DEFAULT means DNN_BACKEND_INFERENCE_ENGINE. Otherwise it equals to DNN_BACKEND_OPENCV. Python prototype (for reference): setPreferableBackend(backendId) -&gt; None","ref":"Evision.DNN.Net.html#setPreferableBackend/2","title":"Evision.DNN.Net.setPreferableBackend/2","type":"function"},{"doc":"Raising version of setPreferableTarget/2 .","ref":"Evision.DNN.Net.html#setPreferableTarget!/2","title":"Evision.DNN.Net.setPreferableTarget!/2","type":"function"},{"doc":"Ask network to make computations on specific target device. Positional Arguments targetId : int . target identifier. @see Target List of supported combinations backend / target: | | DNN_BACKEND_OPENCV | DNN_BACKEND_INFERENCE_ENGINE | DNN_BACKEND_HALIDE | DNN_BACKEND_CUDA | |------------------------|--------------------|------------------------------|--------------------|-------------------| | DNN_TARGET_CPU | + | + | + | | | DNN_TARGET_OPENCL | + | + | + | | | DNN_TARGET_OPENCL_FP16 | + | + | | | | DNN_TARGET_MYRIAD | | + | | | | DNN_TARGET_FPGA | | + | | | | DNN_TARGET_CUDA | | | | + | | DNN_TARGET_CUDA_FP16 | | | | + | | DNN_TARGET_HDDL | | + | | | Python prototype (for reference): setPreferableTarget(targetId) -&gt; None","ref":"Evision.DNN.Net.html#setPreferableTarget/2","title":"Evision.DNN.Net.setPreferableTarget/2","type":"function"},{"doc":"","ref":"Evision.DNN.SegmentationModel.html","title":"Evision.DNN.SegmentationModel","type":"module"},{"doc":"Raising version of dnn_SegmentationModel/1 .","ref":"Evision.DNN.SegmentationModel.html#dnn_SegmentationModel!/1","title":"Evision.DNN.SegmentationModel.dnn_SegmentationModel!/1","type":"function"},{"doc":"Raising version of dnn_SegmentationModel/2 .","ref":"Evision.DNN.SegmentationModel.html#dnn_SegmentationModel!/2","title":"Evision.DNN.SegmentationModel.dnn_SegmentationModel!/2","type":"function"},{"doc":"Variant 1: Create model from deep learning network. Positional Arguments network : Net . Net object. Python prototype (for reference): SegmentationModel(network) -&gt; &lt;dnn_SegmentationModel object&gt; Variant 2: Create segmentation model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): SegmentationModel(model[, config]) -&gt; &lt;dnn_SegmentationModel object&gt;","ref":"Evision.DNN.SegmentationModel.html#dnn_SegmentationModel/1","title":"Evision.DNN.SegmentationModel.dnn_SegmentationModel/1","type":"function"},{"doc":"Create segmentation model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : String . Binary file contains trained weights. Keyword Arguments config : String . Text file contains network configuration. Python prototype (for reference): SegmentationModel(model[, config]) -&gt; &lt;dnn_SegmentationModel object&gt;","ref":"Evision.DNN.SegmentationModel.html#dnn_SegmentationModel/2","title":"Evision.DNN.SegmentationModel.dnn_SegmentationModel/2","type":"function"},{"doc":"Raising version of segment/2 .","ref":"Evision.DNN.SegmentationModel.html#segment!/2","title":"Evision.DNN.SegmentationModel.segment!/2","type":"function"},{"doc":"Raising version of segment/3 .","ref":"Evision.DNN.SegmentationModel.html#segment!/3","title":"Evision.DNN.SegmentationModel.segment!/3","type":"function"},{"doc":"Given the @p input frame, create input blob, run net Positional Arguments frame : Evision.Mat Return mask : Evision.Mat . Allocated class prediction for each pixel Python prototype (for reference): segment(frame[, mask]) -&gt; mask","ref":"Evision.DNN.SegmentationModel.html#segment/2","title":"Evision.DNN.SegmentationModel.segment/2","type":"function"},{"doc":"Given the @p input frame, create input blob, run net Positional Arguments frame : Evision.Mat Return mask : Evision.Mat . Allocated class prediction for each pixel Python prototype (for reference): segment(frame[, mask]) -&gt; mask","ref":"Evision.DNN.SegmentationModel.html#segment/3","title":"Evision.DNN.SegmentationModel.segment/3","type":"function"},{"doc":"","ref":"Evision.DNN.TextDetectionModel.html","title":"Evision.DNN.TextDetectionModel","type":"module"},{"doc":"Raising version of detect/2 .","ref":"Evision.DNN.TextDetectionModel.html#detect!/2","title":"Evision.DNN.TextDetectionModel.detect!/2","type":"function"},{"doc":"Positional Arguments frame : Evision.Mat Return detections : [vector_Point] Has overloading in C++ Python prototype (for reference): detect(frame) -&gt; detections","ref":"Evision.DNN.TextDetectionModel.html#detect/2","title":"Evision.DNN.TextDetectionModel.detect/2","type":"function"},{"doc":"Raising version of detectTextRectangles/2 .","ref":"Evision.DNN.TextDetectionModel.html#detectTextRectangles!/2","title":"Evision.DNN.TextDetectionModel.detectTextRectangles!/2","type":"function"},{"doc":"Positional Arguments frame : Evision.Mat Return detections : [{centre={x, y}, size={s1, s2}, angle}] Has overloading in C++ Python prototype (for reference): detectTextRectangles(frame) -&gt; detections","ref":"Evision.DNN.TextDetectionModel.html#detectTextRectangles/2","title":"Evision.DNN.TextDetectionModel.detectTextRectangles/2","type":"function"},{"doc":"","ref":"Evision.DNN.TextDetectionModelDB.html","title":"Evision.DNN.TextDetectionModelDB","type":"module"},{"doc":"Raising version of dnn_TextDetectionModel_DB/1 .","ref":"Evision.DNN.TextDetectionModelDB.html#dnn_TextDetectionModel_DB!/1","title":"Evision.DNN.TextDetectionModelDB.dnn_TextDetectionModel_DB!/1","type":"function"},{"doc":"Raising version of dnn_TextDetectionModel_DB/2 .","ref":"Evision.DNN.TextDetectionModelDB.html#dnn_TextDetectionModel_DB!/2","title":"Evision.DNN.TextDetectionModelDB.dnn_TextDetectionModel_DB!/2","type":"function"},{"doc":"Create text detection model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : string . Binary file contains trained weights. Keyword Arguments config : string . Text file contains network configuration. Python prototype (for reference): TextDetectionModel_DB(model[, config]) -&gt; &lt;dnn_TextDetectionModel_DB object&gt;","ref":"Evision.DNN.TextDetectionModelDB.html#dnn_TextDetectionModel_DB/1","title":"Evision.DNN.TextDetectionModelDB.dnn_TextDetectionModel_DB/1","type":"function"},{"doc":"Create text detection model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : string . Binary file contains trained weights. Keyword Arguments config : string . Text file contains network configuration. Python prototype (for reference): TextDetectionModel_DB(model[, config]) -&gt; &lt;dnn_TextDetectionModel_DB object&gt;","ref":"Evision.DNN.TextDetectionModelDB.html#dnn_TextDetectionModel_DB/2","title":"Evision.DNN.TextDetectionModelDB.dnn_TextDetectionModel_DB/2","type":"function"},{"doc":"Raising version of getBinaryThreshold/1 .","ref":"Evision.DNN.TextDetectionModelDB.html#getBinaryThreshold!/1","title":"Evision.DNN.TextDetectionModelDB.getBinaryThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getBinaryThreshold() -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#getBinaryThreshold/1","title":"Evision.DNN.TextDetectionModelDB.getBinaryThreshold/1","type":"function"},{"doc":"Raising version of getMaxCandidates/1 .","ref":"Evision.DNN.TextDetectionModelDB.html#getMaxCandidates!/1","title":"Evision.DNN.TextDetectionModelDB.getMaxCandidates!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxCandidates() -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#getMaxCandidates/1","title":"Evision.DNN.TextDetectionModelDB.getMaxCandidates/1","type":"function"},{"doc":"Raising version of getPolygonThreshold/1 .","ref":"Evision.DNN.TextDetectionModelDB.html#getPolygonThreshold!/1","title":"Evision.DNN.TextDetectionModelDB.getPolygonThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getPolygonThreshold() -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#getPolygonThreshold/1","title":"Evision.DNN.TextDetectionModelDB.getPolygonThreshold/1","type":"function"},{"doc":"Raising version of getUnclipRatio/1 .","ref":"Evision.DNN.TextDetectionModelDB.html#getUnclipRatio!/1","title":"Evision.DNN.TextDetectionModelDB.getUnclipRatio!/1","type":"function"},{"doc":"Python prototype (for reference): getUnclipRatio() -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#getUnclipRatio/1","title":"Evision.DNN.TextDetectionModelDB.getUnclipRatio/1","type":"function"},{"doc":"Raising version of setBinaryThreshold/2 .","ref":"Evision.DNN.TextDetectionModelDB.html#setBinaryThreshold!/2","title":"Evision.DNN.TextDetectionModelDB.setBinaryThreshold!/2","type":"function"},{"doc":"Positional Arguments binaryThreshold : float Python prototype (for reference): setBinaryThreshold(binaryThreshold) -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#setBinaryThreshold/2","title":"Evision.DNN.TextDetectionModelDB.setBinaryThreshold/2","type":"function"},{"doc":"Raising version of setMaxCandidates/2 .","ref":"Evision.DNN.TextDetectionModelDB.html#setMaxCandidates!/2","title":"Evision.DNN.TextDetectionModelDB.setMaxCandidates!/2","type":"function"},{"doc":"Positional Arguments maxCandidates : int Python prototype (for reference): setMaxCandidates(maxCandidates) -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#setMaxCandidates/2","title":"Evision.DNN.TextDetectionModelDB.setMaxCandidates/2","type":"function"},{"doc":"Raising version of setPolygonThreshold/2 .","ref":"Evision.DNN.TextDetectionModelDB.html#setPolygonThreshold!/2","title":"Evision.DNN.TextDetectionModelDB.setPolygonThreshold!/2","type":"function"},{"doc":"Positional Arguments polygonThreshold : float Python prototype (for reference): setPolygonThreshold(polygonThreshold) -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#setPolygonThreshold/2","title":"Evision.DNN.TextDetectionModelDB.setPolygonThreshold/2","type":"function"},{"doc":"Raising version of setUnclipRatio/2 .","ref":"Evision.DNN.TextDetectionModelDB.html#setUnclipRatio!/2","title":"Evision.DNN.TextDetectionModelDB.setUnclipRatio!/2","type":"function"},{"doc":"Positional Arguments unclipRatio : double Python prototype (for reference): setUnclipRatio(unclipRatio) -&gt; retval","ref":"Evision.DNN.TextDetectionModelDB.html#setUnclipRatio/2","title":"Evision.DNN.TextDetectionModelDB.setUnclipRatio/2","type":"function"},{"doc":"","ref":"Evision.DNN.TextDetectionModelEAST.html","title":"Evision.DNN.TextDetectionModelEAST","type":"module"},{"doc":"Raising version of dnn_TextDetectionModel_EAST/1 .","ref":"Evision.DNN.TextDetectionModelEAST.html#dnn_TextDetectionModel_EAST!/1","title":"Evision.DNN.TextDetectionModelEAST.dnn_TextDetectionModel_EAST!/1","type":"function"},{"doc":"Raising version of dnn_TextDetectionModel_EAST/2 .","ref":"Evision.DNN.TextDetectionModelEAST.html#dnn_TextDetectionModel_EAST!/2","title":"Evision.DNN.TextDetectionModelEAST.dnn_TextDetectionModel_EAST!/2","type":"function"},{"doc":"Create text detection model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : string . Binary file contains trained weights. Keyword Arguments config : string . Text file contains network configuration. Python prototype (for reference): TextDetectionModel_EAST(model[, config]) -&gt; &lt;dnn_TextDetectionModel_EAST object&gt;","ref":"Evision.DNN.TextDetectionModelEAST.html#dnn_TextDetectionModel_EAST/1","title":"Evision.DNN.TextDetectionModelEAST.dnn_TextDetectionModel_EAST/1","type":"function"},{"doc":"Create text detection model from network represented in one of the supported formats. An order of @p model and @p config arguments does not matter. Positional Arguments model : string . Binary file contains trained weights. Keyword Arguments config : string . Text file contains network configuration. Python prototype (for reference): TextDetectionModel_EAST(model[, config]) -&gt; &lt;dnn_TextDetectionModel_EAST object&gt;","ref":"Evision.DNN.TextDetectionModelEAST.html#dnn_TextDetectionModel_EAST/2","title":"Evision.DNN.TextDetectionModelEAST.dnn_TextDetectionModel_EAST/2","type":"function"},{"doc":"Raising version of getConfidenceThreshold/1 .","ref":"Evision.DNN.TextDetectionModelEAST.html#getConfidenceThreshold!/1","title":"Evision.DNN.TextDetectionModelEAST.getConfidenceThreshold!/1","type":"function"},{"doc":"Get the detection confidence threshold Python prototype (for reference): getConfidenceThreshold() -&gt; retval","ref":"Evision.DNN.TextDetectionModelEAST.html#getConfidenceThreshold/1","title":"Evision.DNN.TextDetectionModelEAST.getConfidenceThreshold/1","type":"function"},{"doc":"Raising version of getNMSThreshold/1 .","ref":"Evision.DNN.TextDetectionModelEAST.html#getNMSThreshold!/1","title":"Evision.DNN.TextDetectionModelEAST.getNMSThreshold!/1","type":"function"},{"doc":"Get the detection confidence threshold Python prototype (for reference): getNMSThreshold() -&gt; retval","ref":"Evision.DNN.TextDetectionModelEAST.html#getNMSThreshold/1","title":"Evision.DNN.TextDetectionModelEAST.getNMSThreshold/1","type":"function"},{"doc":"Raising version of setConfidenceThreshold/2 .","ref":"Evision.DNN.TextDetectionModelEAST.html#setConfidenceThreshold!/2","title":"Evision.DNN.TextDetectionModelEAST.setConfidenceThreshold!/2","type":"function"},{"doc":"Set the detection confidence threshold Positional Arguments confThreshold : float . A threshold used to filter boxes by confidences Python prototype (for reference): setConfidenceThreshold(confThreshold) -&gt; retval","ref":"Evision.DNN.TextDetectionModelEAST.html#setConfidenceThreshold/2","title":"Evision.DNN.TextDetectionModelEAST.setConfidenceThreshold/2","type":"function"},{"doc":"Raising version of setNMSThreshold/2 .","ref":"Evision.DNN.TextDetectionModelEAST.html#setNMSThreshold!/2","title":"Evision.DNN.TextDetectionModelEAST.setNMSThreshold!/2","type":"function"},{"doc":"Set the detection NMS filter threshold Positional Arguments nmsThreshold : float . A threshold used in non maximum suppression Python prototype (for reference): setNMSThreshold(nmsThreshold) -&gt; retval","ref":"Evision.DNN.TextDetectionModelEAST.html#setNMSThreshold/2","title":"Evision.DNN.TextDetectionModelEAST.setNMSThreshold/2","type":"function"},{"doc":"","ref":"Evision.DNN.TextRecognitionModel.html","title":"Evision.DNN.TextRecognitionModel","type":"module"},{"doc":"Raising version of dnn_TextRecognitionModel/1 .","ref":"Evision.DNN.TextRecognitionModel.html#dnn_TextRecognitionModel!/1","title":"Evision.DNN.TextRecognitionModel.dnn_TextRecognitionModel!/1","type":"function"},{"doc":"Raising version of dnn_TextRecognitionModel/2 .","ref":"Evision.DNN.TextRecognitionModel.html#dnn_TextRecognitionModel!/2","title":"Evision.DNN.TextRecognitionModel.dnn_TextRecognitionModel!/2","type":"function"},{"doc":"Create text recognition model from network represented in one of the supported formats Call setDecodeType() and setVocabulary() after constructor to initialize the decoding method Positional Arguments model : string . Binary file contains trained weights Keyword Arguments config : string . Text file contains network configuration Python prototype (for reference): TextRecognitionModel(model[, config]) -&gt; &lt;dnn_TextRecognitionModel object&gt;","ref":"Evision.DNN.TextRecognitionModel.html#dnn_TextRecognitionModel/1","title":"Evision.DNN.TextRecognitionModel.dnn_TextRecognitionModel/1","type":"function"},{"doc":"Create text recognition model from network represented in one of the supported formats Call setDecodeType() and setVocabulary() after constructor to initialize the decoding method Positional Arguments model : string . Binary file contains trained weights Keyword Arguments config : string . Text file contains network configuration Python prototype (for reference): TextRecognitionModel(model[, config]) -&gt; &lt;dnn_TextRecognitionModel object&gt;","ref":"Evision.DNN.TextRecognitionModel.html#dnn_TextRecognitionModel/2","title":"Evision.DNN.TextRecognitionModel.dnn_TextRecognitionModel/2","type":"function"},{"doc":"Raising version of getDecodeType/1 .","ref":"Evision.DNN.TextRecognitionModel.html#getDecodeType!/1","title":"Evision.DNN.TextRecognitionModel.getDecodeType!/1","type":"function"},{"doc":"Get the decoding method @return the decoding method Python prototype (for reference): getDecodeType() -&gt; retval","ref":"Evision.DNN.TextRecognitionModel.html#getDecodeType/1","title":"Evision.DNN.TextRecognitionModel.getDecodeType/1","type":"function"},{"doc":"Raising version of getVocabulary/1 .","ref":"Evision.DNN.TextRecognitionModel.html#getVocabulary!/1","title":"Evision.DNN.TextRecognitionModel.getVocabulary!/1","type":"function"},{"doc":"Get the vocabulary for recognition. @return vocabulary the associated vocabulary Python prototype (for reference): getVocabulary() -&gt; retval","ref":"Evision.DNN.TextRecognitionModel.html#getVocabulary/1","title":"Evision.DNN.TextRecognitionModel.getVocabulary/1","type":"function"},{"doc":"Raising version of recognize/2 .","ref":"Evision.DNN.TextRecognitionModel.html#recognize!/2","title":"Evision.DNN.TextRecognitionModel.recognize!/2","type":"function"},{"doc":"Raising version of recognize/3 .","ref":"Evision.DNN.TextRecognitionModel.html#recognize!/3","title":"Evision.DNN.TextRecognitionModel.recognize!/3","type":"function"},{"doc":"Given the @p input frame, create input blob, run net and return recognition result Positional Arguments frame : Evision.Mat . The input image @return The text recognition result Python prototype (for reference): recognize(frame) -&gt; retval","ref":"Evision.DNN.TextRecognitionModel.html#recognize/2","title":"Evision.DNN.TextRecognitionModel.recognize/2","type":"function"},{"doc":"Given the @p input frame, create input blob, run net and return recognition result Positional Arguments frame : Evision.Mat . The input image roiRects : [Evision.Mat] . List of text detection regions of interest (cv::Rect, CV_32SC4). ROIs is be cropped as the network inputs Return results : [string] . A set of text recognition results. Python prototype (for reference): recognize(frame, roiRects) -&gt; results","ref":"Evision.DNN.TextRecognitionModel.html#recognize/3","title":"Evision.DNN.TextRecognitionModel.recognize/3","type":"function"},{"doc":"Raising version of setDecodeOptsCTCPrefixBeamSearch/2 .","ref":"Evision.DNN.TextRecognitionModel.html#setDecodeOptsCTCPrefixBeamSearch!/2","title":"Evision.DNN.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch!/2","type":"function"},{"doc":"Raising version of setDecodeOptsCTCPrefixBeamSearch/3 .","ref":"Evision.DNN.TextRecognitionModel.html#setDecodeOptsCTCPrefixBeamSearch!/3","title":"Evision.DNN.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch!/3","type":"function"},{"doc":"Set the decoding method options for &quot;CTC-prefix-beam-search&quot; decode usage Positional Arguments beamSize : int . Beam size for search Keyword Arguments vocPruneSize : int . Parameter to optimize big vocabulary search, only take top @p vocPruneSize tokens in each search step, @p vocPruneSize &lt;= 0 stands for disable this prune. Python prototype (for reference): setDecodeOptsCTCPrefixBeamSearch(beamSize[, vocPruneSize]) -&gt; retval","ref":"Evision.DNN.TextRecognitionModel.html#setDecodeOptsCTCPrefixBeamSearch/2","title":"Evision.DNN.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch/2","type":"function"},{"doc":"Set the decoding method options for &quot;CTC-prefix-beam-search&quot; decode usage Positional Arguments beamSize : int . Beam size for search Keyword Arguments vocPruneSize : int . Parameter to optimize big vocabulary search, only take top @p vocPruneSize tokens in each search step, @p vocPruneSize &lt;= 0 stands for disable this prune. Python prototype (for reference): setDecodeOptsCTCPrefixBeamSearch(beamSize[, vocPruneSize]) -&gt; retval","ref":"Evision.DNN.TextRecognitionModel.html#setDecodeOptsCTCPrefixBeamSearch/3","title":"Evision.DNN.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch/3","type":"function"},{"doc":"Raising version of setDecodeType/2 .","ref":"Evision.DNN.TextRecognitionModel.html#setDecodeType!/2","title":"Evision.DNN.TextRecognitionModel.setDecodeType!/2","type":"function"},{"doc":"Set the decoding method of translating the network output into string Positional Arguments decodeType : string .The decoding method of translating the network output into string, currently supported type: &quot;CTC-greedy&quot; greedy decoding for the output of CTC-based methods &quot;CTC-prefix-beam-search&quot; Prefix beam search decoding for the output of CTC-based methods Python prototype (for reference): setDecodeType(decodeType) -&gt; retval","ref":"Evision.DNN.TextRecognitionModel.html#setDecodeType/2","title":"Evision.DNN.TextRecognitionModel.setDecodeType/2","type":"function"},{"doc":"Raising version of setVocabulary/2 .","ref":"Evision.DNN.TextRecognitionModel.html#setVocabulary!/2","title":"Evision.DNN.TextRecognitionModel.setVocabulary!/2","type":"function"},{"doc":"Set the vocabulary for recognition. Positional Arguments vocabulary : [string] . the associated vocabulary of the network. Python prototype (for reference): setVocabulary(vocabulary) -&gt; retval","ref":"Evision.DNN.TextRecognitionModel.html#setVocabulary/2","title":"Evision.DNN.TextRecognitionModel.setVocabulary/2","type":"function"},{"doc":"","ref":"Evision.DenseOpticalFlow.html","title":"Evision.DenseOpticalFlow","type":"module"},{"doc":"Raising version of calc/4 .","ref":"Evision.DenseOpticalFlow.html#calc!/4","title":"Evision.DenseOpticalFlow.calc!/4","type":"function"},{"doc":"Calculates an optical flow. Positional Arguments i0 : Evision.Mat . first 8-bit single-channel input image. i1 : Evision.Mat . second input image of the same size and the same type as prev. Return flow : Evision.Mat . computed flow image that has the same size as prev and type CV_32FC2. Python prototype (for reference): calc(I0, I1, flow) -&gt; flow","ref":"Evision.DenseOpticalFlow.html#calc/4","title":"Evision.DenseOpticalFlow.calc/4","type":"function"},{"doc":"Raising version of collectGarbage/1 .","ref":"Evision.DenseOpticalFlow.html#collectGarbage!/1","title":"Evision.DenseOpticalFlow.collectGarbage!/1","type":"function"},{"doc":"Releases all inner buffers. Python prototype (for reference): collectGarbage() -&gt; None","ref":"Evision.DenseOpticalFlow.html#collectGarbage/1","title":"Evision.DenseOpticalFlow.collectGarbage/1","type":"function"},{"doc":"","ref":"Evision.DescriptorMatcher.html","title":"Evision.DescriptorMatcher","type":"module"},{"doc":"Raising version of add/2 .","ref":"Evision.DescriptorMatcher.html#add!/2","title":"Evision.DescriptorMatcher.add!/2","type":"function"},{"doc":"Adds descriptors to train a CPU(trainDescCollectionis) or GPU(utrainDescCollectionis) descriptor collection. Positional Arguments descriptors : [Evision.Mat] . Descriptors to add. Each descriptors[i] is a set of descriptors from the same train image. If the collection is not empty, the new descriptors are added to existing train descriptors. Python prototype (for reference): add(descriptors) -&gt; None","ref":"Evision.DescriptorMatcher.html#add/2","title":"Evision.DescriptorMatcher.add/2","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.DescriptorMatcher.html#clear!/1","title":"Evision.DescriptorMatcher.clear!/1","type":"function"},{"doc":"Clears the train descriptor collections. Python prototype (for reference): clear() -&gt; None","ref":"Evision.DescriptorMatcher.html#clear/1","title":"Evision.DescriptorMatcher.clear/1","type":"function"},{"doc":"Raising version of clone/1 .","ref":"Evision.DescriptorMatcher.html#clone!/1","title":"Evision.DescriptorMatcher.clone!/1","type":"function"},{"doc":"Clones the matcher. Keyword Arguments emptyTrainData : bool . If emptyTrainData is false, the method creates a deep copy of the object, that is, copies both parameters and train data. If emptyTrainData is true, the method creates an object copy with the current parameters but with empty train data. Python prototype (for reference): clone([, emptyTrainData]) -&gt; retval","ref":"Evision.DescriptorMatcher.html#clone/1","title":"Evision.DescriptorMatcher.clone/1","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.DescriptorMatcher.html#create!/1","title":"Evision.DescriptorMatcher.create!/1","type":"function"},{"doc":"Variant 1: Positional Arguments matcherType : DescriptorMatcher_MatcherType Python prototype (for reference): create(matcherType) -&gt; retval Variant 2: Creates a descriptor matcher of a given type with the default parameters (using default constructor). Positional Arguments descriptorMatcherType : String .Descriptor matcher type. Now the following matcher types are supported: BruteForce (it uses L2 ) BruteForce-L1 BruteForce-Hamming BruteForce-Hamming(2) FlannBased Python prototype (for reference): create(descriptorMatcherType) -&gt; retval","ref":"Evision.DescriptorMatcher.html#create/1","title":"Evision.DescriptorMatcher.create/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.DescriptorMatcher.html#empty!/1","title":"Evision.DescriptorMatcher.empty!/1","type":"function"},{"doc":"Returns true if there are no train descriptors in the both collections. Python prototype (for reference): empty() -&gt; retval","ref":"Evision.DescriptorMatcher.html#empty/1","title":"Evision.DescriptorMatcher.empty/1","type":"function"},{"doc":"Raising version of getTrainDescriptors/1 .","ref":"Evision.DescriptorMatcher.html#getTrainDescriptors!/1","title":"Evision.DescriptorMatcher.getTrainDescriptors!/1","type":"function"},{"doc":"Returns a constant link to the train descriptor collection trainDescCollection . Python prototype (for reference): getTrainDescriptors() -&gt; retval","ref":"Evision.DescriptorMatcher.html#getTrainDescriptors/1","title":"Evision.DescriptorMatcher.getTrainDescriptors/1","type":"function"},{"doc":"Raising version of isMaskSupported/1 .","ref":"Evision.DescriptorMatcher.html#isMaskSupported!/1","title":"Evision.DescriptorMatcher.isMaskSupported!/1","type":"function"},{"doc":"Returns true if the descriptor matcher supports masking permissible matches. Python prototype (for reference): isMaskSupported() -&gt; retval","ref":"Evision.DescriptorMatcher.html#isMaskSupported/1","title":"Evision.DescriptorMatcher.isMaskSupported/1","type":"function"},{"doc":"Raising version of knnMatch/3 .","ref":"Evision.DescriptorMatcher.html#knnMatch!/3","title":"Evision.DescriptorMatcher.knnMatch!/3","type":"function"},{"doc":"Raising version of knnMatch/4 .","ref":"Evision.DescriptorMatcher.html#knnMatch!/4","title":"Evision.DescriptorMatcher.knnMatch!/4","type":"function"},{"doc":"Raising version of knnMatch/5 .","ref":"Evision.DescriptorMatcher.html#knnMatch!/5","title":"Evision.DescriptorMatcher.knnMatch!/5","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. Has overloading in C++ Python prototype (for reference): knnMatch(queryDescriptors, k[, masks[, compactResult]]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#knnMatch/3","title":"Evision.DescriptorMatcher.knnMatch/3","type":"function"},{"doc":"Variant 1: Finds the k best matches for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. These extended variants of DescriptorMatcher::match methods find several best matches for each query descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match for the details about query and train descriptors. Python prototype (for reference): knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. Has overloading in C++ Python prototype (for reference): knnMatch(queryDescriptors, k[, masks[, compactResult]]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#knnMatch/4","title":"Evision.DescriptorMatcher.knnMatch/4","type":"function"},{"doc":"Finds the k best matches for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. These extended variants of DescriptorMatcher::match methods find several best matches for each query descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match for the details about query and train descriptors. Python prototype (for reference): knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#knnMatch/5","title":"Evision.DescriptorMatcher.knnMatch/5","type":"function"},{"doc":"Raising version of match/2 .","ref":"Evision.DescriptorMatcher.html#match!/2","title":"Evision.DescriptorMatcher.match!/2","type":"function"},{"doc":"Raising version of match/3 .","ref":"Evision.DescriptorMatcher.html#match!/3","title":"Evision.DescriptorMatcher.match!/3","type":"function"},{"doc":"Raising version of match/4 .","ref":"Evision.DescriptorMatcher.html#match!/4","title":"Evision.DescriptorMatcher.match!/4","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. Has overloading in C++ Python prototype (for reference): match(queryDescriptors[, masks]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#match/2","title":"Evision.DescriptorMatcher.match/2","type":"function"},{"doc":"Variant 1: Finds the best match for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. In the first variant of this method, the train descriptors are passed as an input argument. In the second variant of the method, train descriptors collection that was set by DescriptorMatcher::add is used. Optional mask (or masks) can be passed to specify which query and training descriptors can be matched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if mask.at\\&lt;uchar&gt;(i,j) is non-zero. Python prototype (for reference): match(queryDescriptors, trainDescriptors[, mask]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. Has overloading in C++ Python prototype (for reference): match(queryDescriptors[, masks]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#match/3","title":"Evision.DescriptorMatcher.match/3","type":"function"},{"doc":"Finds the best match for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. In the first variant of this method, the train descriptors are passed as an input argument. In the second variant of the method, train descriptors collection that was set by DescriptorMatcher::add is used. Optional mask (or masks) can be passed to specify which query and training descriptors can be matched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if mask.at\\&lt;uchar&gt;(i,j) is non-zero. Python prototype (for reference): match(queryDescriptors, trainDescriptors[, mask]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#match/4","title":"Evision.DescriptorMatcher.match/4","type":"function"},{"doc":"Raising version of radiusMatch/3 .","ref":"Evision.DescriptorMatcher.html#radiusMatch!/3","title":"Evision.DescriptorMatcher.radiusMatch!/3","type":"function"},{"doc":"Raising version of radiusMatch/4 .","ref":"Evision.DescriptorMatcher.html#radiusMatch!/4","title":"Evision.DescriptorMatcher.radiusMatch!/4","type":"function"},{"doc":"Raising version of radiusMatch/5 .","ref":"Evision.DescriptorMatcher.html#radiusMatch!/5","title":"Evision.DescriptorMatcher.radiusMatch!/5","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. Has overloading in C++ Python prototype (for reference): radiusMatch(queryDescriptors, maxDistance[, masks[, compactResult]]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#radiusMatch/3","title":"Evision.DescriptorMatcher.radiusMatch/3","type":"function"},{"doc":"Variant 1: For each query descriptor, finds the training descriptors not farther than the specified distance. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. For each query descriptor, the methods find such training descriptors that the distance between the query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are returned in the distance increasing order. Python prototype (for reference): radiusMatch(queryDescriptors, trainDescriptors, maxDistance[, mask[, compactResult]]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. Has overloading in C++ Python prototype (for reference): radiusMatch(queryDescriptors, maxDistance[, masks[, compactResult]]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#radiusMatch/4","title":"Evision.DescriptorMatcher.radiusMatch/4","type":"function"},{"doc":"For each query descriptor, finds the training descriptors not farther than the specified distance. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. For each query descriptor, the methods find such training descriptors that the distance between the query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are returned in the distance increasing order. Python prototype (for reference): radiusMatch(queryDescriptors, trainDescriptors, maxDistance[, mask[, compactResult]]) -&gt; matches","ref":"Evision.DescriptorMatcher.html#radiusMatch/5","title":"Evision.DescriptorMatcher.radiusMatch/5","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.DescriptorMatcher.html#read!/2","title":"Evision.DescriptorMatcher.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.DescriptorMatcher.html#read/2","title":"Evision.DescriptorMatcher.read/2","type":"function"},{"doc":"Raising version of train/1 .","ref":"Evision.DescriptorMatcher.html#train!/1","title":"Evision.DescriptorMatcher.train!/1","type":"function"},{"doc":"Trains a descriptor matcher Trains a descriptor matcher (for example, the flann index). In all methods to match, the method train() is run every time before matching. Some descriptor matchers (for example, BruteForceMatcher) have an empty implementation of this method. Other matchers really train their inner structures (for example, FlannBasedMatcher trains flann::Index ). Python prototype (for reference): train() -&gt; None","ref":"Evision.DescriptorMatcher.html#train/1","title":"Evision.DescriptorMatcher.train/1","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.DescriptorMatcher.html#write!/2","title":"Evision.DescriptorMatcher.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.DescriptorMatcher.html#write!/3","title":"Evision.DescriptorMatcher.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.DescriptorMatcher.html#write/2","title":"Evision.DescriptorMatcher.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.DescriptorMatcher.html#write/3","title":"Evision.DescriptorMatcher.write/3","type":"function"},{"doc":"","ref":"Evision.Detail.html","title":"Evision.Detail","type":"module"},{"doc":"Raising version of calibrateRotatingCamera/1 .","ref":"Evision.Detail.html#calibrateRotatingCamera!/1","title":"Evision.Detail.calibrateRotatingCamera!/1","type":"function"},{"doc":"Raising version of calibrateRotatingCamera/2 .","ref":"Evision.Detail.html#calibrateRotatingCamera!/2","title":"Evision.Detail.calibrateRotatingCamera!/2","type":"function"},{"doc":"Estimates focal lengths for each given camera. Positional Arguments hs : [Evision.Mat] Return k : Evision.Mat . Python prototype (for reference): calibrateRotatingCamera(Hs[, K]) -&gt; retval, K","ref":"Evision.Detail.html#calibrateRotatingCamera/1","title":"Evision.Detail.calibrateRotatingCamera/1","type":"function"},{"doc":"Estimates focal lengths for each given camera. Positional Arguments hs : [Evision.Mat] Return k : Evision.Mat . Python prototype (for reference): calibrateRotatingCamera(Hs[, K]) -&gt; retval, K","ref":"Evision.Detail.html#calibrateRotatingCamera/2","title":"Evision.Detail.calibrateRotatingCamera/2","type":"function"},{"doc":"Raising version of computeImageFeatures2/2 .","ref":"Evision.Detail.html#computeImageFeatures2!/2","title":"Evision.Detail.computeImageFeatures2!/2","type":"function"},{"doc":"Raising version of computeImageFeatures2/3 .","ref":"Evision.Detail.html#computeImageFeatures2!/3","title":"Evision.Detail.computeImageFeatures2!/3","type":"function"},{"doc":"Positional Arguments featuresFinder : Ptr&lt;Feature2D&gt; . image : Evision.Mat . Keyword Arguments mask : Evision.Mat . Return features : ImageFeatures . Python prototype (for reference): computeImageFeatures2(featuresFinder, image[, mask]) -&gt; features","ref":"Evision.Detail.html#computeImageFeatures2/2","title":"Evision.Detail.computeImageFeatures2/2","type":"function"},{"doc":"Positional Arguments featuresFinder : Ptr&lt;Feature2D&gt; . image : Evision.Mat . Keyword Arguments mask : Evision.Mat . Return features : ImageFeatures . Python prototype (for reference): computeImageFeatures2(featuresFinder, image[, mask]) -&gt; features","ref":"Evision.Detail.html#computeImageFeatures2/3","title":"Evision.Detail.computeImageFeatures2/3","type":"function"},{"doc":"Raising version of computeImageFeatures/2 .","ref":"Evision.Detail.html#computeImageFeatures!/2","title":"Evision.Detail.computeImageFeatures!/2","type":"function"},{"doc":"Raising version of computeImageFeatures/3 .","ref":"Evision.Detail.html#computeImageFeatures!/3","title":"Evision.Detail.computeImageFeatures!/3","type":"function"},{"doc":"Positional Arguments featuresFinder : Ptr&lt;Feature2D&gt; . images : [Evision.Mat] . Keyword Arguments masks : [Evision.Mat] . Return features : [ImageFeatures] . Python prototype (for reference): computeImageFeatures(featuresFinder, images[, masks]) -&gt; features","ref":"Evision.Detail.html#computeImageFeatures/2","title":"Evision.Detail.computeImageFeatures/2","type":"function"},{"doc":"Positional Arguments featuresFinder : Ptr&lt;Feature2D&gt; . images : [Evision.Mat] . Keyword Arguments masks : [Evision.Mat] . Return features : [ImageFeatures] . Python prototype (for reference): computeImageFeatures(featuresFinder, images[, masks]) -&gt; features","ref":"Evision.Detail.html#computeImageFeatures/3","title":"Evision.Detail.computeImageFeatures/3","type":"function"},{"doc":"Raising version of createLaplacePyr/3 .","ref":"Evision.Detail.html#createLaplacePyr!/3","title":"Evision.Detail.createLaplacePyr!/3","type":"function"},{"doc":"Positional Arguments img : Evision.Mat num_levels : int Return pyr : [Evision.Mat] Python prototype (for reference): createLaplacePyr(img, num_levels, pyr) -&gt; pyr","ref":"Evision.Detail.html#createLaplacePyr/3","title":"Evision.Detail.createLaplacePyr/3","type":"function"},{"doc":"Raising version of createLaplacePyrGpu/3 .","ref":"Evision.Detail.html#createLaplacePyrGpu!/3","title":"Evision.Detail.createLaplacePyrGpu!/3","type":"function"},{"doc":"Positional Arguments img : Evision.Mat num_levels : int Return pyr : [Evision.Mat] Python prototype (for reference): createLaplacePyrGpu(img, num_levels, pyr) -&gt; pyr","ref":"Evision.Detail.html#createLaplacePyrGpu/3","title":"Evision.Detail.createLaplacePyrGpu/3","type":"function"},{"doc":"Raising version of createWeightMap/3 .","ref":"Evision.Detail.html#createWeightMap!/3","title":"Evision.Detail.createWeightMap!/3","type":"function"},{"doc":"Positional Arguments mask : Evision.Mat sharpness : float Return weight : Evision.Mat Python prototype (for reference): createWeightMap(mask, sharpness, weight) -&gt; weight","ref":"Evision.Detail.html#createWeightMap/3","title":"Evision.Detail.createWeightMap/3","type":"function"},{"doc":"Raising version of focalsFromHomography/5 .","ref":"Evision.Detail.html#focalsFromHomography!/5","title":"Evision.Detail.focalsFromHomography!/5","type":"function"},{"doc":"Tries to estimate focal lengths from the given homography under the assumption that the camera undergoes rotations around its centre only. Positional Arguments h : Evision.Mat . Homography. f0 : double . Estimated focal length along X axis. f1 : double . Estimated focal length along Y axis. f0_ok : bool . True, if f0 was estimated successfully, false otherwise. f1_ok : bool . True, if f1 was estimated successfully, false otherwise. See &quot;Construction of Panoramic Image Mosaics with Global and Local Alignment&quot; by Heung-Yeung Shum and Richard Szeliski. Python prototype (for reference): focalsFromHomography(H, f0, f1, f0_ok, f1_ok) -&gt; None","ref":"Evision.Detail.html#focalsFromHomography/5","title":"Evision.Detail.focalsFromHomography/5","type":"function"},{"doc":"Raising version of leaveBiggestComponent/3 .","ref":"Evision.Detail.html#leaveBiggestComponent!/3","title":"Evision.Detail.leaveBiggestComponent!/3","type":"function"},{"doc":"Positional Arguments features : [ImageFeatures] pairwise_matches : [MatchesInfo] conf_threshold : float Python prototype (for reference): leaveBiggestComponent(features, pairwise_matches, conf_threshold) -&gt; retval","ref":"Evision.Detail.html#leaveBiggestComponent/3","title":"Evision.Detail.leaveBiggestComponent/3","type":"function"},{"doc":"Raising version of matchesGraphAsString/3 .","ref":"Evision.Detail.html#matchesGraphAsString!/3","title":"Evision.Detail.matchesGraphAsString!/3","type":"function"},{"doc":"Positional Arguments pathes : [String] pairwise_matches : [MatchesInfo] conf_threshold : float Python prototype (for reference): matchesGraphAsString(pathes, pairwise_matches, conf_threshold) -&gt; retval","ref":"Evision.Detail.html#matchesGraphAsString/3","title":"Evision.Detail.matchesGraphAsString/3","type":"function"},{"doc":"Raising version of normalizeUsingWeightMap/2 .","ref":"Evision.Detail.html#normalizeUsingWeightMap!/2","title":"Evision.Detail.normalizeUsingWeightMap!/2","type":"function"},{"doc":"Positional Arguments weight : Evision.Mat Return src : Evision.Mat Python prototype (for reference): normalizeUsingWeightMap(weight, src) -&gt; src","ref":"Evision.Detail.html#normalizeUsingWeightMap/2","title":"Evision.Detail.normalizeUsingWeightMap/2","type":"function"},{"doc":"Raising version of overlapRoi/5 .","ref":"Evision.Detail.html#overlapRoi!/5","title":"Evision.Detail.overlapRoi!/5","type":"function"},{"doc":"Positional Arguments tl1 : Point tl2 : Point sz1 : Size sz2 : Size roi : Rect Python prototype (for reference): overlapRoi(tl1, tl2, sz1, sz2, roi) -&gt; retval","ref":"Evision.Detail.html#overlapRoi/5","title":"Evision.Detail.overlapRoi/5","type":"function"},{"doc":"Raising version of restoreImageFromLaplacePyr/1 .","ref":"Evision.Detail.html#restoreImageFromLaplacePyr!/1","title":"Evision.Detail.restoreImageFromLaplacePyr!/1","type":"function"},{"doc":"##### Return pyr : [Evision.Mat] Python prototype (for reference): restoreImageFromLaplacePyr(pyr) -&gt; pyr","ref":"Evision.Detail.html#restoreImageFromLaplacePyr/1","title":"Evision.Detail.restoreImageFromLaplacePyr/1","type":"function"},{"doc":"Raising version of restoreImageFromLaplacePyrGpu/1 .","ref":"Evision.Detail.html#restoreImageFromLaplacePyrGpu!/1","title":"Evision.Detail.restoreImageFromLaplacePyrGpu!/1","type":"function"},{"doc":"##### Return pyr : [Evision.Mat] Python prototype (for reference): restoreImageFromLaplacePyrGpu(pyr) -&gt; pyr","ref":"Evision.Detail.html#restoreImageFromLaplacePyrGpu/1","title":"Evision.Detail.restoreImageFromLaplacePyrGpu/1","type":"function"},{"doc":"Raising version of resultRoi/2 .","ref":"Evision.Detail.html#resultRoi!/2","title":"Evision.Detail.resultRoi!/2","type":"function"},{"doc":"Positional Arguments corners : [Point] sizes : [Size] Python prototype (for reference): resultRoi(corners, sizes) -&gt; retval","ref":"Evision.Detail.html#resultRoi/2","title":"Evision.Detail.resultRoi/2","type":"function"},{"doc":"Raising version of resultRoiIntersection/2 .","ref":"Evision.Detail.html#resultRoiIntersection!/2","title":"Evision.Detail.resultRoiIntersection!/2","type":"function"},{"doc":"Positional Arguments corners : [Point] sizes : [Size] Python prototype (for reference): resultRoiIntersection(corners, sizes) -&gt; retval","ref":"Evision.Detail.html#resultRoiIntersection/2","title":"Evision.Detail.resultRoiIntersection/2","type":"function"},{"doc":"Raising version of resultTl/1 .","ref":"Evision.Detail.html#resultTl!/1","title":"Evision.Detail.resultTl!/1","type":"function"},{"doc":"Positional Arguments corners : [Point] Python prototype (for reference): resultTl(corners) -&gt; retval","ref":"Evision.Detail.html#resultTl/1","title":"Evision.Detail.resultTl/1","type":"function"},{"doc":"Raising version of selectRandomSubset/3 .","ref":"Evision.Detail.html#selectRandomSubset!/3","title":"Evision.Detail.selectRandomSubset!/3","type":"function"},{"doc":"Positional Arguments count : int size : int subset : [int] Python prototype (for reference): selectRandomSubset(count, size, subset) -&gt; None","ref":"Evision.Detail.html#selectRandomSubset/3","title":"Evision.Detail.selectRandomSubset/3","type":"function"},{"doc":"Raising version of stitchingLogLevel/0 .","ref":"Evision.Detail.html#stitchingLogLevel!/0","title":"Evision.Detail.stitchingLogLevel!/0","type":"function"},{"doc":"Python prototype (for reference): stitchingLogLevel() -&gt; retval","ref":"Evision.Detail.html#stitchingLogLevel/0","title":"Evision.Detail.stitchingLogLevel/0","type":"function"},{"doc":"Raising version of waveCorrect/2 .","ref":"Evision.Detail.html#waveCorrect!/2","title":"Evision.Detail.waveCorrect!/2","type":"function"},{"doc":"Tries to make panorama more horizontal (or vertical). Positional Arguments kind : WaveCorrectKind . Correction kind, see detail::WaveCorrectKind. Return rmats : [Evision.Mat] . Camera rotation matrices. Python prototype (for reference): waveCorrect(rmats, kind) -&gt; rmats","ref":"Evision.Detail.html#waveCorrect/2","title":"Evision.Detail.waveCorrect/2","type":"function"},{"doc":"","ref":"Evision.Detail.AffineBasedEstimator.html","title":"Evision.Detail.AffineBasedEstimator","type":"module"},{"doc":"Raising version of detail_AffineBasedEstimator/0 .","ref":"Evision.Detail.AffineBasedEstimator.html#detail_AffineBasedEstimator!/0","title":"Evision.Detail.AffineBasedEstimator.detail_AffineBasedEstimator!/0","type":"function"},{"doc":"Python prototype (for reference): AffineBasedEstimator() -&gt; &lt;detail_AffineBasedEstimator object&gt;","ref":"Evision.Detail.AffineBasedEstimator.html#detail_AffineBasedEstimator/0","title":"Evision.Detail.AffineBasedEstimator.detail_AffineBasedEstimator/0","type":"function"},{"doc":"","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html","title":"Evision.Detail.AffineBestOf2NearestMatcher","type":"module"},{"doc":"Raising version of apply2/2 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#apply2!/2","title":"Evision.Detail.AffineBestOf2NearestMatcher.apply2!/2","type":"function"},{"doc":"Raising version of apply2/3 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#apply2!/3","title":"Evision.Detail.AffineBestOf2NearestMatcher.apply2!/3","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#apply2/2","title":"Evision.Detail.AffineBestOf2NearestMatcher.apply2/2","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#apply2/3","title":"Evision.Detail.AffineBestOf2NearestMatcher.apply2/3","type":"function"},{"doc":"Raising version of apply/3 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#apply!/3","title":"Evision.Detail.AffineBestOf2NearestMatcher.apply!/3","type":"function"},{"doc":"Positional Arguments features1 : ImageFeatures . First image features features2 : ImageFeatures . Second image features Return matches_info : MatchesInfo . Found matches Has overloading in C++ Python prototype (for reference): apply(features1, features2) -&gt; matches_info","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#apply/3","title":"Evision.Detail.AffineBestOf2NearestMatcher.apply/3","type":"function"},{"doc":"Raising version of collectGarbage/1 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#collectGarbage!/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.collectGarbage!/1","type":"function"},{"doc":"Python prototype (for reference): collectGarbage() -&gt; None","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#collectGarbage/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.collectGarbage/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#create!/0","title":"Evision.Detail.AffineBestOf2NearestMatcher.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#create!/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.create!/1","type":"function"},{"doc":"##### Keyword Arguments try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): create([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; retval","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#create/0","title":"Evision.Detail.AffineBestOf2NearestMatcher.create/0","type":"function"},{"doc":"##### Keyword Arguments try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): create([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; retval","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#create/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.create/1","type":"function"},{"doc":"Raising version of detail_AffineBestOf2NearestMatcher/0 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#detail_AffineBestOf2NearestMatcher!/0","title":"Evision.Detail.AffineBestOf2NearestMatcher.detail_AffineBestOf2NearestMatcher!/0","type":"function"},{"doc":"Raising version of detail_AffineBestOf2NearestMatcher/1 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#detail_AffineBestOf2NearestMatcher!/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.detail_AffineBestOf2NearestMatcher!/1","type":"function"},{"doc":"Constructs a &quot;best of 2 nearest&quot; matcher that expects affine transformation between images Keyword Arguments full_affine : bool . whether to use full affine transformation with 6 degress of freedom or reduced transformation with 4 degrees of freedom using only rotation, translation and uniform scaling try_use_gpu : bool . Should try to use GPU or not match_conf : float . Match distances ration threshold num_matches_thresh1 : int . Minimum number of matches required for the 2D affine transform estimation used in the inliers classification step @sa cv::estimateAffine2D cv::estimateAffinePartial2D Python prototype (for reference): AffineBestOf2NearestMatcher([, full_affine[, try_use_gpu[, match_conf[, num_matches_thresh1]]]]) -&gt; &lt;detail_AffineBestOf2NearestMatcher object&gt;","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#detail_AffineBestOf2NearestMatcher/0","title":"Evision.Detail.AffineBestOf2NearestMatcher.detail_AffineBestOf2NearestMatcher/0","type":"function"},{"doc":"Constructs a &quot;best of 2 nearest&quot; matcher that expects affine transformation between images Keyword Arguments full_affine : bool . whether to use full affine transformation with 6 degress of freedom or reduced transformation with 4 degrees of freedom using only rotation, translation and uniform scaling try_use_gpu : bool . Should try to use GPU or not match_conf : float . Match distances ration threshold num_matches_thresh1 : int . Minimum number of matches required for the 2D affine transform estimation used in the inliers classification step @sa cv::estimateAffine2D cv::estimateAffinePartial2D Python prototype (for reference): AffineBestOf2NearestMatcher([, full_affine[, try_use_gpu[, match_conf[, num_matches_thresh1]]]]) -&gt; &lt;detail_AffineBestOf2NearestMatcher object&gt;","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#detail_AffineBestOf2NearestMatcher/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.detail_AffineBestOf2NearestMatcher/1","type":"function"},{"doc":"Raising version of isThreadSafe/1 .","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#isThreadSafe!/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.isThreadSafe!/1","type":"function"},{"doc":"@return True, if it's possible to use the same matcher instance in parallel, false otherwise Python prototype (for reference): isThreadSafe() -&gt; retval","ref":"Evision.Detail.AffineBestOf2NearestMatcher.html#isThreadSafe/1","title":"Evision.Detail.AffineBestOf2NearestMatcher.isThreadSafe/1","type":"function"},{"doc":"","ref":"Evision.Detail.BestOf2NearestMatcher.html","title":"Evision.Detail.BestOf2NearestMatcher","type":"module"},{"doc":"Raising version of apply2/2 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#apply2!/2","title":"Evision.Detail.BestOf2NearestMatcher.apply2!/2","type":"function"},{"doc":"Raising version of apply2/3 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#apply2!/3","title":"Evision.Detail.BestOf2NearestMatcher.apply2!/3","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.BestOf2NearestMatcher.html#apply2/2","title":"Evision.Detail.BestOf2NearestMatcher.apply2/2","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.BestOf2NearestMatcher.html#apply2/3","title":"Evision.Detail.BestOf2NearestMatcher.apply2/3","type":"function"},{"doc":"Raising version of apply/3 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#apply!/3","title":"Evision.Detail.BestOf2NearestMatcher.apply!/3","type":"function"},{"doc":"Positional Arguments features1 : ImageFeatures . First image features features2 : ImageFeatures . Second image features Return matches_info : MatchesInfo . Found matches Has overloading in C++ Python prototype (for reference): apply(features1, features2) -&gt; matches_info","ref":"Evision.Detail.BestOf2NearestMatcher.html#apply/3","title":"Evision.Detail.BestOf2NearestMatcher.apply/3","type":"function"},{"doc":"Raising version of collectGarbage/1 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#collectGarbage!/1","title":"Evision.Detail.BestOf2NearestMatcher.collectGarbage!/1","type":"function"},{"doc":"Python prototype (for reference): collectGarbage() -&gt; None","ref":"Evision.Detail.BestOf2NearestMatcher.html#collectGarbage/1","title":"Evision.Detail.BestOf2NearestMatcher.collectGarbage/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#create!/0","title":"Evision.Detail.BestOf2NearestMatcher.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#create!/1","title":"Evision.Detail.BestOf2NearestMatcher.create!/1","type":"function"},{"doc":"##### Keyword Arguments try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): create([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; retval","ref":"Evision.Detail.BestOf2NearestMatcher.html#create/0","title":"Evision.Detail.BestOf2NearestMatcher.create/0","type":"function"},{"doc":"##### Keyword Arguments try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): create([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; retval","ref":"Evision.Detail.BestOf2NearestMatcher.html#create/1","title":"Evision.Detail.BestOf2NearestMatcher.create/1","type":"function"},{"doc":"Raising version of detail_BestOf2NearestMatcher/0 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#detail_BestOf2NearestMatcher!/0","title":"Evision.Detail.BestOf2NearestMatcher.detail_BestOf2NearestMatcher!/0","type":"function"},{"doc":"Raising version of detail_BestOf2NearestMatcher/1 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#detail_BestOf2NearestMatcher!/1","title":"Evision.Detail.BestOf2NearestMatcher.detail_BestOf2NearestMatcher!/1","type":"function"},{"doc":"Constructs a &quot;best of 2 nearest&quot; matcher. Keyword Arguments try_use_gpu : bool . Should try to use GPU or not match_conf : float . Match distances ration threshold num_matches_thresh1 : int . Minimum number of matches required for the 2D projective transform estimation used in the inliers classification step num_matches_thresh2 : int . Minimum number of matches required for the 2D projective transform re-estimation on inliers Python prototype (for reference): BestOf2NearestMatcher([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; &lt;detail_BestOf2NearestMatcher object&gt;","ref":"Evision.Detail.BestOf2NearestMatcher.html#detail_BestOf2NearestMatcher/0","title":"Evision.Detail.BestOf2NearestMatcher.detail_BestOf2NearestMatcher/0","type":"function"},{"doc":"Constructs a &quot;best of 2 nearest&quot; matcher. Keyword Arguments try_use_gpu : bool . Should try to use GPU or not match_conf : float . Match distances ration threshold num_matches_thresh1 : int . Minimum number of matches required for the 2D projective transform estimation used in the inliers classification step num_matches_thresh2 : int . Minimum number of matches required for the 2D projective transform re-estimation on inliers Python prototype (for reference): BestOf2NearestMatcher([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; &lt;detail_BestOf2NearestMatcher object&gt;","ref":"Evision.Detail.BestOf2NearestMatcher.html#detail_BestOf2NearestMatcher/1","title":"Evision.Detail.BestOf2NearestMatcher.detail_BestOf2NearestMatcher/1","type":"function"},{"doc":"Raising version of isThreadSafe/1 .","ref":"Evision.Detail.BestOf2NearestMatcher.html#isThreadSafe!/1","title":"Evision.Detail.BestOf2NearestMatcher.isThreadSafe!/1","type":"function"},{"doc":"@return True, if it's possible to use the same matcher instance in parallel, false otherwise Python prototype (for reference): isThreadSafe() -&gt; retval","ref":"Evision.Detail.BestOf2NearestMatcher.html#isThreadSafe/1","title":"Evision.Detail.BestOf2NearestMatcher.isThreadSafe/1","type":"function"},{"doc":"","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html","title":"Evision.Detail.BestOf2NearestRangeMatcher","type":"module"},{"doc":"Raising version of apply2/2 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#apply2!/2","title":"Evision.Detail.BestOf2NearestRangeMatcher.apply2!/2","type":"function"},{"doc":"Raising version of apply2/3 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#apply2!/3","title":"Evision.Detail.BestOf2NearestRangeMatcher.apply2!/3","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#apply2/2","title":"Evision.Detail.BestOf2NearestRangeMatcher.apply2/2","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#apply2/3","title":"Evision.Detail.BestOf2NearestRangeMatcher.apply2/3","type":"function"},{"doc":"Raising version of apply/3 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#apply!/3","title":"Evision.Detail.BestOf2NearestRangeMatcher.apply!/3","type":"function"},{"doc":"Positional Arguments features1 : ImageFeatures . First image features features2 : ImageFeatures . Second image features Return matches_info : MatchesInfo . Found matches Has overloading in C++ Python prototype (for reference): apply(features1, features2) -&gt; matches_info","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#apply/3","title":"Evision.Detail.BestOf2NearestRangeMatcher.apply/3","type":"function"},{"doc":"Raising version of collectGarbage/1 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#collectGarbage!/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.collectGarbage!/1","type":"function"},{"doc":"Python prototype (for reference): collectGarbage() -&gt; None","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#collectGarbage/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.collectGarbage/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#create!/0","title":"Evision.Detail.BestOf2NearestRangeMatcher.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#create!/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.create!/1","type":"function"},{"doc":"##### Keyword Arguments try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): create([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; retval","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#create/0","title":"Evision.Detail.BestOf2NearestRangeMatcher.create/0","type":"function"},{"doc":"##### Keyword Arguments try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): create([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -&gt; retval","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#create/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.create/1","type":"function"},{"doc":"Raising version of detail_BestOf2NearestRangeMatcher/0 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#detail_BestOf2NearestRangeMatcher!/0","title":"Evision.Detail.BestOf2NearestRangeMatcher.detail_BestOf2NearestRangeMatcher!/0","type":"function"},{"doc":"Raising version of detail_BestOf2NearestRangeMatcher/1 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#detail_BestOf2NearestRangeMatcher!/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.detail_BestOf2NearestRangeMatcher!/1","type":"function"},{"doc":"##### Keyword Arguments range_width : int . try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): BestOf2NearestRangeMatcher([, range_width[, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]]) -&gt; &lt;detail_BestOf2NearestRangeMatcher object&gt;","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#detail_BestOf2NearestRangeMatcher/0","title":"Evision.Detail.BestOf2NearestRangeMatcher.detail_BestOf2NearestRangeMatcher/0","type":"function"},{"doc":"##### Keyword Arguments range_width : int . try_use_gpu : bool . match_conf : float . num_matches_thresh1 : int . num_matches_thresh2 : int . Python prototype (for reference): BestOf2NearestRangeMatcher([, range_width[, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]]) -&gt; &lt;detail_BestOf2NearestRangeMatcher object&gt;","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#detail_BestOf2NearestRangeMatcher/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.detail_BestOf2NearestRangeMatcher/1","type":"function"},{"doc":"Raising version of isThreadSafe/1 .","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#isThreadSafe!/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.isThreadSafe!/1","type":"function"},{"doc":"@return True, if it's possible to use the same matcher instance in parallel, false otherwise Python prototype (for reference): isThreadSafe() -&gt; retval","ref":"Evision.Detail.BestOf2NearestRangeMatcher.html#isThreadSafe/1","title":"Evision.Detail.BestOf2NearestRangeMatcher.isThreadSafe/1","type":"function"},{"doc":"","ref":"Evision.Detail.Blender.html","title":"Evision.Detail.Blender","type":"module"},{"doc":"Raising version of blend/3 .","ref":"Evision.Detail.Blender.html#blend!/3","title":"Evision.Detail.Blender.blend!/3","type":"function"},{"doc":"Blends and returns the final pano. Return dst : Evision.Mat . Final pano dst_mask : Evision.Mat . Final pano mask Python prototype (for reference): blend(dst, dst_mask) -&gt; dst, dst_mask","ref":"Evision.Detail.Blender.html#blend/3","title":"Evision.Detail.Blender.blend/3","type":"function"},{"doc":"Raising version of createDefault/1 .","ref":"Evision.Detail.Blender.html#createDefault!/1","title":"Evision.Detail.Blender.createDefault!/1","type":"function"},{"doc":"Raising version of createDefault/2 .","ref":"Evision.Detail.Blender.html#createDefault!/2","title":"Evision.Detail.Blender.createDefault!/2","type":"function"},{"doc":"Positional Arguments type : int Keyword Arguments try_gpu : bool . Python prototype (for reference): createDefault(type[, try_gpu]) -&gt; retval","ref":"Evision.Detail.Blender.html#createDefault/1","title":"Evision.Detail.Blender.createDefault/1","type":"function"},{"doc":"Positional Arguments type : int Keyword Arguments try_gpu : bool . Python prototype (for reference): createDefault(type[, try_gpu]) -&gt; retval","ref":"Evision.Detail.Blender.html#createDefault/2","title":"Evision.Detail.Blender.createDefault/2","type":"function"},{"doc":"Raising version of feed/4 .","ref":"Evision.Detail.Blender.html#feed!/4","title":"Evision.Detail.Blender.feed!/4","type":"function"},{"doc":"Processes the image. Positional Arguments img : Evision.Mat . Source image mask : Evision.Mat . Source image mask tl : Point . Source image top-left corners Python prototype (for reference): feed(img, mask, tl) -&gt; None","ref":"Evision.Detail.Blender.html#feed/4","title":"Evision.Detail.Blender.feed/4","type":"function"},{"doc":"Raising version of prepare/2 .","ref":"Evision.Detail.Blender.html#prepare!/2","title":"Evision.Detail.Blender.prepare!/2","type":"function"},{"doc":"Raising version of prepare/3 .","ref":"Evision.Detail.Blender.html#prepare!/3","title":"Evision.Detail.Blender.prepare!/3","type":"function"},{"doc":"Positional Arguments dst_roi : Rect Has overloading in C++ Python prototype (for reference): prepare(dst_roi) -&gt; None","ref":"Evision.Detail.Blender.html#prepare/2","title":"Evision.Detail.Blender.prepare/2","type":"function"},{"doc":"Prepares the blender for blending. Positional Arguments corners : [Point] . Source images top-left corners sizes : [Size] . Source image sizes Python prototype (for reference): prepare(corners, sizes) -&gt; None","ref":"Evision.Detail.Blender.html#prepare/3","title":"Evision.Detail.Blender.prepare/3","type":"function"},{"doc":"","ref":"Evision.Detail.BlocksChannelsCompensator.html","title":"Evision.Detail.BlocksChannelsCompensator","type":"module"},{"doc":"Raising version of detail_BlocksChannelsCompensator/0 .","ref":"Evision.Detail.BlocksChannelsCompensator.html#detail_BlocksChannelsCompensator!/0","title":"Evision.Detail.BlocksChannelsCompensator.detail_BlocksChannelsCompensator!/0","type":"function"},{"doc":"Raising version of detail_BlocksChannelsCompensator/1 .","ref":"Evision.Detail.BlocksChannelsCompensator.html#detail_BlocksChannelsCompensator!/1","title":"Evision.Detail.BlocksChannelsCompensator.detail_BlocksChannelsCompensator!/1","type":"function"},{"doc":"##### Keyword Arguments bl_width : int . bl_height : int . nr_feeds : int . Python prototype (for reference): BlocksChannelsCompensator([, bl_width[, bl_height[, nr_feeds]]]) -&gt; &lt;detail_BlocksChannelsCompensator object&gt;","ref":"Evision.Detail.BlocksChannelsCompensator.html#detail_BlocksChannelsCompensator/0","title":"Evision.Detail.BlocksChannelsCompensator.detail_BlocksChannelsCompensator/0","type":"function"},{"doc":"##### Keyword Arguments bl_width : int . bl_height : int . nr_feeds : int . Python prototype (for reference): BlocksChannelsCompensator([, bl_width[, bl_height[, nr_feeds]]]) -&gt; &lt;detail_BlocksChannelsCompensator object&gt;","ref":"Evision.Detail.BlocksChannelsCompensator.html#detail_BlocksChannelsCompensator/1","title":"Evision.Detail.BlocksChannelsCompensator.detail_BlocksChannelsCompensator/1","type":"function"},{"doc":"","ref":"Evision.Detail.BlocksCompensator.html","title":"Evision.Detail.BlocksCompensator","type":"module"},{"doc":"Raising version of apply/5 .","ref":"Evision.Detail.BlocksCompensator.html#apply!/5","title":"Evision.Detail.BlocksCompensator.apply!/5","type":"function"},{"doc":"Positional Arguments index : int corner : Point mask : Evision.Mat Return image : Evision.Mat Python prototype (for reference): apply(index, corner, image, mask) -&gt; image","ref":"Evision.Detail.BlocksCompensator.html#apply/5","title":"Evision.Detail.BlocksCompensator.apply/5","type":"function"},{"doc":"Raising version of getBlockSize/1 .","ref":"Evision.Detail.BlocksCompensator.html#getBlockSize!/1","title":"Evision.Detail.BlocksCompensator.getBlockSize!/1","type":"function"},{"doc":"Python prototype (for reference): getBlockSize() -&gt; retval","ref":"Evision.Detail.BlocksCompensator.html#getBlockSize/1","title":"Evision.Detail.BlocksCompensator.getBlockSize/1","type":"function"},{"doc":"Raising version of getMatGains/1 .","ref":"Evision.Detail.BlocksCompensator.html#getMatGains!/1","title":"Evision.Detail.BlocksCompensator.getMatGains!/1","type":"function"},{"doc":"##### Return umv : [Evision.Mat] . Python prototype (for reference): getMatGains([, umv]) -&gt; umv","ref":"Evision.Detail.BlocksCompensator.html#getMatGains/1","title":"Evision.Detail.BlocksCompensator.getMatGains/1","type":"function"},{"doc":"Raising version of getNrFeeds/1 .","ref":"Evision.Detail.BlocksCompensator.html#getNrFeeds!/1","title":"Evision.Detail.BlocksCompensator.getNrFeeds!/1","type":"function"},{"doc":"Python prototype (for reference): getNrFeeds() -&gt; retval","ref":"Evision.Detail.BlocksCompensator.html#getNrFeeds/1","title":"Evision.Detail.BlocksCompensator.getNrFeeds/1","type":"function"},{"doc":"Raising version of getNrGainsFilteringIterations/1 .","ref":"Evision.Detail.BlocksCompensator.html#getNrGainsFilteringIterations!/1","title":"Evision.Detail.BlocksCompensator.getNrGainsFilteringIterations!/1","type":"function"},{"doc":"Python prototype (for reference): getNrGainsFilteringIterations() -&gt; retval","ref":"Evision.Detail.BlocksCompensator.html#getNrGainsFilteringIterations/1","title":"Evision.Detail.BlocksCompensator.getNrGainsFilteringIterations/1","type":"function"},{"doc":"Raising version of getSimilarityThreshold/1 .","ref":"Evision.Detail.BlocksCompensator.html#getSimilarityThreshold!/1","title":"Evision.Detail.BlocksCompensator.getSimilarityThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getSimilarityThreshold() -&gt; retval","ref":"Evision.Detail.BlocksCompensator.html#getSimilarityThreshold/1","title":"Evision.Detail.BlocksCompensator.getSimilarityThreshold/1","type":"function"},{"doc":"Raising version of setBlockSize/2 .","ref":"Evision.Detail.BlocksCompensator.html#setBlockSize!/2","title":"Evision.Detail.BlocksCompensator.setBlockSize!/2","type":"function"},{"doc":"Raising version of setBlockSize/3 .","ref":"Evision.Detail.BlocksCompensator.html#setBlockSize!/3","title":"Evision.Detail.BlocksCompensator.setBlockSize!/3","type":"function"},{"doc":"Positional Arguments size : Size Python prototype (for reference): setBlockSize(size) -&gt; None","ref":"Evision.Detail.BlocksCompensator.html#setBlockSize/2","title":"Evision.Detail.BlocksCompensator.setBlockSize/2","type":"function"},{"doc":"Positional Arguments width : int height : int Python prototype (for reference): setBlockSize(width, height) -&gt; None","ref":"Evision.Detail.BlocksCompensator.html#setBlockSize/3","title":"Evision.Detail.BlocksCompensator.setBlockSize/3","type":"function"},{"doc":"Raising version of setMatGains/2 .","ref":"Evision.Detail.BlocksCompensator.html#setMatGains!/2","title":"Evision.Detail.BlocksCompensator.setMatGains!/2","type":"function"},{"doc":"Positional Arguments umv : [Evision.Mat] Python prototype (for reference): setMatGains(umv) -&gt; None","ref":"Evision.Detail.BlocksCompensator.html#setMatGains/2","title":"Evision.Detail.BlocksCompensator.setMatGains/2","type":"function"},{"doc":"Raising version of setNrFeeds/2 .","ref":"Evision.Detail.BlocksCompensator.html#setNrFeeds!/2","title":"Evision.Detail.BlocksCompensator.setNrFeeds!/2","type":"function"},{"doc":"Positional Arguments nr_feeds : int Python prototype (for reference): setNrFeeds(nr_feeds) -&gt; None","ref":"Evision.Detail.BlocksCompensator.html#setNrFeeds/2","title":"Evision.Detail.BlocksCompensator.setNrFeeds/2","type":"function"},{"doc":"Raising version of setNrGainsFilteringIterations/2 .","ref":"Evision.Detail.BlocksCompensator.html#setNrGainsFilteringIterations!/2","title":"Evision.Detail.BlocksCompensator.setNrGainsFilteringIterations!/2","type":"function"},{"doc":"Positional Arguments nr_iterations : int Python prototype (for reference): setNrGainsFilteringIterations(nr_iterations) -&gt; None","ref":"Evision.Detail.BlocksCompensator.html#setNrGainsFilteringIterations/2","title":"Evision.Detail.BlocksCompensator.setNrGainsFilteringIterations/2","type":"function"},{"doc":"Raising version of setSimilarityThreshold/2 .","ref":"Evision.Detail.BlocksCompensator.html#setSimilarityThreshold!/2","title":"Evision.Detail.BlocksCompensator.setSimilarityThreshold!/2","type":"function"},{"doc":"Positional Arguments similarity_threshold : double Python prototype (for reference): setSimilarityThreshold(similarity_threshold) -&gt; None","ref":"Evision.Detail.BlocksCompensator.html#setSimilarityThreshold/2","title":"Evision.Detail.BlocksCompensator.setSimilarityThreshold/2","type":"function"},{"doc":"","ref":"Evision.Detail.BlocksGainCompensator.html","title":"Evision.Detail.BlocksGainCompensator","type":"module"},{"doc":"Raising version of apply/5 .","ref":"Evision.Detail.BlocksGainCompensator.html#apply!/5","title":"Evision.Detail.BlocksGainCompensator.apply!/5","type":"function"},{"doc":"Positional Arguments index : int corner : Point mask : Evision.Mat Return image : Evision.Mat Python prototype (for reference): apply(index, corner, image, mask) -&gt; image","ref":"Evision.Detail.BlocksGainCompensator.html#apply/5","title":"Evision.Detail.BlocksGainCompensator.apply/5","type":"function"},{"doc":"Raising version of detail_BlocksGainCompensator/0 .","ref":"Evision.Detail.BlocksGainCompensator.html#detail_BlocksGainCompensator!/0","title":"Evision.Detail.BlocksGainCompensator.detail_BlocksGainCompensator!/0","type":"function"},{"doc":"Raising version of detail_BlocksGainCompensator/1 .","ref":"Evision.Detail.BlocksGainCompensator.html#detail_BlocksGainCompensator!/1","title":"Evision.Detail.BlocksGainCompensator.detail_BlocksGainCompensator!/1","type":"function"},{"doc":"Raising version of detail_BlocksGainCompensator/3 .","ref":"Evision.Detail.BlocksGainCompensator.html#detail_BlocksGainCompensator!/3","title":"Evision.Detail.BlocksGainCompensator.detail_BlocksGainCompensator!/3","type":"function"},{"doc":"##### Keyword Arguments bl_width : int . bl_height : int . Python prototype (for reference): BlocksGainCompensator([, bl_width[, bl_height]]) -&gt; &lt;detail_BlocksGainCompensator object&gt;","ref":"Evision.Detail.BlocksGainCompensator.html#detail_BlocksGainCompensator/0","title":"Evision.Detail.BlocksGainCompensator.detail_BlocksGainCompensator/0","type":"function"},{"doc":"##### Keyword Arguments bl_width : int . bl_height : int . Python prototype (for reference): BlocksGainCompensator([, bl_width[, bl_height]]) -&gt; &lt;detail_BlocksGainCompensator object&gt;","ref":"Evision.Detail.BlocksGainCompensator.html#detail_BlocksGainCompensator/1","title":"Evision.Detail.BlocksGainCompensator.detail_BlocksGainCompensator/1","type":"function"},{"doc":"Positional Arguments bl_width : int bl_height : int nr_feeds : int Python prototype (for reference): BlocksGainCompensator(bl_width, bl_height, nr_feeds) -&gt; &lt;detail_BlocksGainCompensator object&gt;","ref":"Evision.Detail.BlocksGainCompensator.html#detail_BlocksGainCompensator/3","title":"Evision.Detail.BlocksGainCompensator.detail_BlocksGainCompensator/3","type":"function"},{"doc":"Raising version of getMatGains/1 .","ref":"Evision.Detail.BlocksGainCompensator.html#getMatGains!/1","title":"Evision.Detail.BlocksGainCompensator.getMatGains!/1","type":"function"},{"doc":"##### Return umv : [Evision.Mat] . Python prototype (for reference): getMatGains([, umv]) -&gt; umv","ref":"Evision.Detail.BlocksGainCompensator.html#getMatGains/1","title":"Evision.Detail.BlocksGainCompensator.getMatGains/1","type":"function"},{"doc":"Raising version of setMatGains/2 .","ref":"Evision.Detail.BlocksGainCompensator.html#setMatGains!/2","title":"Evision.Detail.BlocksGainCompensator.setMatGains!/2","type":"function"},{"doc":"Positional Arguments umv : [Evision.Mat] Python prototype (for reference): setMatGains(umv) -&gt; None","ref":"Evision.Detail.BlocksGainCompensator.html#setMatGains/2","title":"Evision.Detail.BlocksGainCompensator.setMatGains/2","type":"function"},{"doc":"","ref":"Evision.Detail.BundleAdjusterAffine.html","title":"Evision.Detail.BundleAdjusterAffine","type":"module"},{"doc":"Raising version of detail_BundleAdjusterAffine/0 .","ref":"Evision.Detail.BundleAdjusterAffine.html#detail_BundleAdjusterAffine!/0","title":"Evision.Detail.BundleAdjusterAffine.detail_BundleAdjusterAffine!/0","type":"function"},{"doc":"Python prototype (for reference): BundleAdjusterAffine() -&gt; &lt;detail_BundleAdjusterAffine object&gt;","ref":"Evision.Detail.BundleAdjusterAffine.html#detail_BundleAdjusterAffine/0","title":"Evision.Detail.BundleAdjusterAffine.detail_BundleAdjusterAffine/0","type":"function"},{"doc":"","ref":"Evision.Detail.BundleAdjusterAffinePartial.html","title":"Evision.Detail.BundleAdjusterAffinePartial","type":"module"},{"doc":"Raising version of detail_BundleAdjusterAffinePartial/0 .","ref":"Evision.Detail.BundleAdjusterAffinePartial.html#detail_BundleAdjusterAffinePartial!/0","title":"Evision.Detail.BundleAdjusterAffinePartial.detail_BundleAdjusterAffinePartial!/0","type":"function"},{"doc":"Python prototype (for reference): BundleAdjusterAffinePartial() -&gt; &lt;detail_BundleAdjusterAffinePartial object&gt;","ref":"Evision.Detail.BundleAdjusterAffinePartial.html#detail_BundleAdjusterAffinePartial/0","title":"Evision.Detail.BundleAdjusterAffinePartial.detail_BundleAdjusterAffinePartial/0","type":"function"},{"doc":"","ref":"Evision.Detail.BundleAdjusterBase.html","title":"Evision.Detail.BundleAdjusterBase","type":"module"},{"doc":"Raising version of confThresh/1 .","ref":"Evision.Detail.BundleAdjusterBase.html#confThresh!/1","title":"Evision.Detail.BundleAdjusterBase.confThresh!/1","type":"function"},{"doc":"Python prototype (for reference): confThresh() -&gt; retval","ref":"Evision.Detail.BundleAdjusterBase.html#confThresh/1","title":"Evision.Detail.BundleAdjusterBase.confThresh/1","type":"function"},{"doc":"Raising version of refinementMask/1 .","ref":"Evision.Detail.BundleAdjusterBase.html#refinementMask!/1","title":"Evision.Detail.BundleAdjusterBase.refinementMask!/1","type":"function"},{"doc":"Python prototype (for reference): refinementMask() -&gt; retval","ref":"Evision.Detail.BundleAdjusterBase.html#refinementMask/1","title":"Evision.Detail.BundleAdjusterBase.refinementMask/1","type":"function"},{"doc":"Raising version of setConfThresh/2 .","ref":"Evision.Detail.BundleAdjusterBase.html#setConfThresh!/2","title":"Evision.Detail.BundleAdjusterBase.setConfThresh!/2","type":"function"},{"doc":"Positional Arguments conf_thresh : double Python prototype (for reference): setConfThresh(conf_thresh) -&gt; None","ref":"Evision.Detail.BundleAdjusterBase.html#setConfThresh/2","title":"Evision.Detail.BundleAdjusterBase.setConfThresh/2","type":"function"},{"doc":"Raising version of setRefinementMask/2 .","ref":"Evision.Detail.BundleAdjusterBase.html#setRefinementMask!/2","title":"Evision.Detail.BundleAdjusterBase.setRefinementMask!/2","type":"function"},{"doc":"Positional Arguments mask : Evision.Mat Python prototype (for reference): setRefinementMask(mask) -&gt; None","ref":"Evision.Detail.BundleAdjusterBase.html#setRefinementMask/2","title":"Evision.Detail.BundleAdjusterBase.setRefinementMask/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.Detail.BundleAdjusterBase.html#setTermCriteria!/2","title":"Evision.Detail.BundleAdjusterBase.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments term_criteria : TermCriteria Python prototype (for reference): setTermCriteria(term_criteria) -&gt; None","ref":"Evision.Detail.BundleAdjusterBase.html#setTermCriteria/2","title":"Evision.Detail.BundleAdjusterBase.setTermCriteria/2","type":"function"},{"doc":"Raising version of termCriteria/1 .","ref":"Evision.Detail.BundleAdjusterBase.html#termCriteria!/1","title":"Evision.Detail.BundleAdjusterBase.termCriteria!/1","type":"function"},{"doc":"Python prototype (for reference): termCriteria() -&gt; retval","ref":"Evision.Detail.BundleAdjusterBase.html#termCriteria/1","title":"Evision.Detail.BundleAdjusterBase.termCriteria/1","type":"function"},{"doc":"","ref":"Evision.Detail.BundleAdjusterRay.html","title":"Evision.Detail.BundleAdjusterRay","type":"module"},{"doc":"Raising version of detail_BundleAdjusterRay/0 .","ref":"Evision.Detail.BundleAdjusterRay.html#detail_BundleAdjusterRay!/0","title":"Evision.Detail.BundleAdjusterRay.detail_BundleAdjusterRay!/0","type":"function"},{"doc":"Python prototype (for reference): BundleAdjusterRay() -&gt; &lt;detail_BundleAdjusterRay object&gt;","ref":"Evision.Detail.BundleAdjusterRay.html#detail_BundleAdjusterRay/0","title":"Evision.Detail.BundleAdjusterRay.detail_BundleAdjusterRay/0","type":"function"},{"doc":"","ref":"Evision.Detail.BundleAdjusterReproj.html","title":"Evision.Detail.BundleAdjusterReproj","type":"module"},{"doc":"Raising version of detail_BundleAdjusterReproj/0 .","ref":"Evision.Detail.BundleAdjusterReproj.html#detail_BundleAdjusterReproj!/0","title":"Evision.Detail.BundleAdjusterReproj.detail_BundleAdjusterReproj!/0","type":"function"},{"doc":"Python prototype (for reference): BundleAdjusterReproj() -&gt; &lt;detail_BundleAdjusterReproj object&gt;","ref":"Evision.Detail.BundleAdjusterReproj.html#detail_BundleAdjusterReproj/0","title":"Evision.Detail.BundleAdjusterReproj.detail_BundleAdjusterReproj/0","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html","title":"Evision.Detail.CameraParams","type":"module"},{"doc":"Raising version of get_aspect/1 .","ref":"Evision.Detail.CameraParams.html#get_aspect!/1","title":"Evision.Detail.CameraParams.get_aspect!/1","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#get_aspect/1","title":"Evision.Detail.CameraParams.get_aspect/1","type":"function"},{"doc":"Raising version of get_focal/1 .","ref":"Evision.Detail.CameraParams.html#get_focal!/1","title":"Evision.Detail.CameraParams.get_focal!/1","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#get_focal/1","title":"Evision.Detail.CameraParams.get_focal/1","type":"function"},{"doc":"Raising version of get_ppx/1 .","ref":"Evision.Detail.CameraParams.html#get_ppx!/1","title":"Evision.Detail.CameraParams.get_ppx!/1","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#get_ppx/1","title":"Evision.Detail.CameraParams.get_ppx/1","type":"function"},{"doc":"Raising version of get_ppy/1 .","ref":"Evision.Detail.CameraParams.html#get_ppy!/1","title":"Evision.Detail.CameraParams.get_ppy!/1","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#get_ppy/1","title":"Evision.Detail.CameraParams.get_ppy/1","type":"function"},{"doc":"Raising version of get_R/1 .","ref":"Evision.Detail.CameraParams.html#get_R!/1","title":"Evision.Detail.CameraParams.get_R!/1","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#get_R/1","title":"Evision.Detail.CameraParams.get_R/1","type":"function"},{"doc":"Raising version of get_t/1 .","ref":"Evision.Detail.CameraParams.html#get_t!/1","title":"Evision.Detail.CameraParams.get_t!/1","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#get_t/1","title":"Evision.Detail.CameraParams.get_t/1","type":"function"},{"doc":"Raising version of k/1 .","ref":"Evision.Detail.CameraParams.html#k!/1","title":"Evision.Detail.CameraParams.k!/1","type":"function"},{"doc":"Python prototype (for reference): K() -&gt; retval","ref":"Evision.Detail.CameraParams.html#k/1","title":"Evision.Detail.CameraParams.k/1","type":"function"},{"doc":"Raising version of set_aspect/2 .","ref":"Evision.Detail.CameraParams.html#set_aspect!/2","title":"Evision.Detail.CameraParams.set_aspect!/2","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#set_aspect/2","title":"Evision.Detail.CameraParams.set_aspect/2","type":"function"},{"doc":"Raising version of set_focal/2 .","ref":"Evision.Detail.CameraParams.html#set_focal!/2","title":"Evision.Detail.CameraParams.set_focal!/2","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#set_focal/2","title":"Evision.Detail.CameraParams.set_focal/2","type":"function"},{"doc":"Raising version of set_ppx/2 .","ref":"Evision.Detail.CameraParams.html#set_ppx!/2","title":"Evision.Detail.CameraParams.set_ppx!/2","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#set_ppx/2","title":"Evision.Detail.CameraParams.set_ppx/2","type":"function"},{"doc":"Raising version of set_ppy/2 .","ref":"Evision.Detail.CameraParams.html#set_ppy!/2","title":"Evision.Detail.CameraParams.set_ppy!/2","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#set_ppy/2","title":"Evision.Detail.CameraParams.set_ppy/2","type":"function"},{"doc":"Raising version of set_R/2 .","ref":"Evision.Detail.CameraParams.html#set_R!/2","title":"Evision.Detail.CameraParams.set_R!/2","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#set_R/2","title":"Evision.Detail.CameraParams.set_R/2","type":"function"},{"doc":"Raising version of set_t/2 .","ref":"Evision.Detail.CameraParams.html#set_t!/2","title":"Evision.Detail.CameraParams.set_t!/2","type":"function"},{"doc":"","ref":"Evision.Detail.CameraParams.html#set_t/2","title":"Evision.Detail.CameraParams.set_t/2","type":"function"},{"doc":"","ref":"Evision.Detail.ChannelsCompensator.html","title":"Evision.Detail.ChannelsCompensator","type":"module"},{"doc":"Raising version of apply/5 .","ref":"Evision.Detail.ChannelsCompensator.html#apply!/5","title":"Evision.Detail.ChannelsCompensator.apply!/5","type":"function"},{"doc":"Positional Arguments index : int corner : Point mask : Evision.Mat Return image : Evision.Mat Python prototype (for reference): apply(index, corner, image, mask) -&gt; image","ref":"Evision.Detail.ChannelsCompensator.html#apply/5","title":"Evision.Detail.ChannelsCompensator.apply/5","type":"function"},{"doc":"Raising version of detail_ChannelsCompensator/0 .","ref":"Evision.Detail.ChannelsCompensator.html#detail_ChannelsCompensator!/0","title":"Evision.Detail.ChannelsCompensator.detail_ChannelsCompensator!/0","type":"function"},{"doc":"Raising version of detail_ChannelsCompensator/1 .","ref":"Evision.Detail.ChannelsCompensator.html#detail_ChannelsCompensator!/1","title":"Evision.Detail.ChannelsCompensator.detail_ChannelsCompensator!/1","type":"function"},{"doc":"##### Keyword Arguments nr_feeds : int . Python prototype (for reference): ChannelsCompensator([, nr_feeds]) -&gt; &lt;detail_ChannelsCompensator object&gt;","ref":"Evision.Detail.ChannelsCompensator.html#detail_ChannelsCompensator/0","title":"Evision.Detail.ChannelsCompensator.detail_ChannelsCompensator/0","type":"function"},{"doc":"##### Keyword Arguments nr_feeds : int . Python prototype (for reference): ChannelsCompensator([, nr_feeds]) -&gt; &lt;detail_ChannelsCompensator object&gt;","ref":"Evision.Detail.ChannelsCompensator.html#detail_ChannelsCompensator/1","title":"Evision.Detail.ChannelsCompensator.detail_ChannelsCompensator/1","type":"function"},{"doc":"Raising version of getMatGains/1 .","ref":"Evision.Detail.ChannelsCompensator.html#getMatGains!/1","title":"Evision.Detail.ChannelsCompensator.getMatGains!/1","type":"function"},{"doc":"##### Return umv : [Evision.Mat] . Python prototype (for reference): getMatGains([, umv]) -&gt; umv","ref":"Evision.Detail.ChannelsCompensator.html#getMatGains/1","title":"Evision.Detail.ChannelsCompensator.getMatGains/1","type":"function"},{"doc":"Raising version of getNrFeeds/1 .","ref":"Evision.Detail.ChannelsCompensator.html#getNrFeeds!/1","title":"Evision.Detail.ChannelsCompensator.getNrFeeds!/1","type":"function"},{"doc":"Python prototype (for reference): getNrFeeds() -&gt; retval","ref":"Evision.Detail.ChannelsCompensator.html#getNrFeeds/1","title":"Evision.Detail.ChannelsCompensator.getNrFeeds/1","type":"function"},{"doc":"Raising version of getSimilarityThreshold/1 .","ref":"Evision.Detail.ChannelsCompensator.html#getSimilarityThreshold!/1","title":"Evision.Detail.ChannelsCompensator.getSimilarityThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getSimilarityThreshold() -&gt; retval","ref":"Evision.Detail.ChannelsCompensator.html#getSimilarityThreshold/1","title":"Evision.Detail.ChannelsCompensator.getSimilarityThreshold/1","type":"function"},{"doc":"Raising version of setMatGains/2 .","ref":"Evision.Detail.ChannelsCompensator.html#setMatGains!/2","title":"Evision.Detail.ChannelsCompensator.setMatGains!/2","type":"function"},{"doc":"Positional Arguments umv : [Evision.Mat] Python prototype (for reference): setMatGains(umv) -&gt; None","ref":"Evision.Detail.ChannelsCompensator.html#setMatGains/2","title":"Evision.Detail.ChannelsCompensator.setMatGains/2","type":"function"},{"doc":"Raising version of setNrFeeds/2 .","ref":"Evision.Detail.ChannelsCompensator.html#setNrFeeds!/2","title":"Evision.Detail.ChannelsCompensator.setNrFeeds!/2","type":"function"},{"doc":"Positional Arguments nr_feeds : int Python prototype (for reference): setNrFeeds(nr_feeds) -&gt; None","ref":"Evision.Detail.ChannelsCompensator.html#setNrFeeds/2","title":"Evision.Detail.ChannelsCompensator.setNrFeeds/2","type":"function"},{"doc":"Raising version of setSimilarityThreshold/2 .","ref":"Evision.Detail.ChannelsCompensator.html#setSimilarityThreshold!/2","title":"Evision.Detail.ChannelsCompensator.setSimilarityThreshold!/2","type":"function"},{"doc":"Positional Arguments similarity_threshold : double Python prototype (for reference): setSimilarityThreshold(similarity_threshold) -&gt; None","ref":"Evision.Detail.ChannelsCompensator.html#setSimilarityThreshold/2","title":"Evision.Detail.ChannelsCompensator.setSimilarityThreshold/2","type":"function"},{"doc":"","ref":"Evision.Detail.DpSeamFinder.html","title":"Evision.Detail.DpSeamFinder","type":"module"},{"doc":"Raising version of detail_DpSeamFinder/1 .","ref":"Evision.Detail.DpSeamFinder.html#detail_DpSeamFinder!/1","title":"Evision.Detail.DpSeamFinder.detail_DpSeamFinder!/1","type":"function"},{"doc":"Positional Arguments costFunc : String Python prototype (for reference): DpSeamFinder(costFunc) -&gt; &lt;detail_DpSeamFinder object&gt;","ref":"Evision.Detail.DpSeamFinder.html#detail_DpSeamFinder/1","title":"Evision.Detail.DpSeamFinder.detail_DpSeamFinder/1","type":"function"},{"doc":"Raising version of setCostFunction/2 .","ref":"Evision.Detail.DpSeamFinder.html#setCostFunction!/2","title":"Evision.Detail.DpSeamFinder.setCostFunction!/2","type":"function"},{"doc":"Positional Arguments val : String Python prototype (for reference): setCostFunction(val) -&gt; None","ref":"Evision.Detail.DpSeamFinder.html#setCostFunction/2","title":"Evision.Detail.DpSeamFinder.setCostFunction/2","type":"function"},{"doc":"","ref":"Evision.Detail.Estimator.html","title":"Evision.Detail.Estimator","type":"module"},{"doc":"Raising version of apply/4 .","ref":"Evision.Detail.Estimator.html#apply!/4","title":"Evision.Detail.Estimator.apply!/4","type":"function"},{"doc":"Estimates camera parameters. Positional Arguments features : [ImageFeatures] . Features of images pairwise_matches : [MatchesInfo] . Pairwise matches of images Return cameras : [CameraParams] . Estimated camera parameters @return True in case of success, false otherwise Python prototype (for reference): apply(features, pairwise_matches, cameras) -&gt; retval, cameras","ref":"Evision.Detail.Estimator.html#apply/4","title":"Evision.Detail.Estimator.apply/4","type":"function"},{"doc":"","ref":"Evision.Detail.ExposureCompensator.html","title":"Evision.Detail.ExposureCompensator","type":"module"},{"doc":"Raising version of apply/5 .","ref":"Evision.Detail.ExposureCompensator.html#apply!/5","title":"Evision.Detail.ExposureCompensator.apply!/5","type":"function"},{"doc":"Compensate exposure in the specified image. Positional Arguments index : int . Image index corner : Point . Image top-left corner mask : Evision.Mat . Image mask Return image : Evision.Mat . Image to process Python prototype (for reference): apply(index, corner, image, mask) -&gt; image","ref":"Evision.Detail.ExposureCompensator.html#apply/5","title":"Evision.Detail.ExposureCompensator.apply/5","type":"function"},{"doc":"Raising version of createDefault/1 .","ref":"Evision.Detail.ExposureCompensator.html#createDefault!/1","title":"Evision.Detail.ExposureCompensator.createDefault!/1","type":"function"},{"doc":"Positional Arguments type : int Python prototype (for reference): createDefault(type) -&gt; retval","ref":"Evision.Detail.ExposureCompensator.html#createDefault/1","title":"Evision.Detail.ExposureCompensator.createDefault/1","type":"function"},{"doc":"Raising version of feed/4 .","ref":"Evision.Detail.ExposureCompensator.html#feed!/4","title":"Evision.Detail.ExposureCompensator.feed!/4","type":"function"},{"doc":"Positional Arguments corners : [Point] . Source image top-left corners images : [Evision.Mat] . Source images masks : [Evision.Mat] . Image masks to update (second value in pair specifies the value which should be used to detect where image is) Python prototype (for reference): feed(corners, images, masks) -&gt; None","ref":"Evision.Detail.ExposureCompensator.html#feed/4","title":"Evision.Detail.ExposureCompensator.feed/4","type":"function"},{"doc":"Raising version of getMatGains/1 .","ref":"Evision.Detail.ExposureCompensator.html#getMatGains!/1","title":"Evision.Detail.ExposureCompensator.getMatGains!/1","type":"function"},{"doc":"##### Return arg1 : [Evision.Mat] . Python prototype (for reference): getMatGains([, arg1]) -&gt; arg1","ref":"Evision.Detail.ExposureCompensator.html#getMatGains/1","title":"Evision.Detail.ExposureCompensator.getMatGains/1","type":"function"},{"doc":"Raising version of getUpdateGain/1 .","ref":"Evision.Detail.ExposureCompensator.html#getUpdateGain!/1","title":"Evision.Detail.ExposureCompensator.getUpdateGain!/1","type":"function"},{"doc":"Python prototype (for reference): getUpdateGain() -&gt; retval","ref":"Evision.Detail.ExposureCompensator.html#getUpdateGain/1","title":"Evision.Detail.ExposureCompensator.getUpdateGain/1","type":"function"},{"doc":"Raising version of setMatGains/2 .","ref":"Evision.Detail.ExposureCompensator.html#setMatGains!/2","title":"Evision.Detail.ExposureCompensator.setMatGains!/2","type":"function"},{"doc":"Positional Arguments arg1 : [Evision.Mat] Python prototype (for reference): setMatGains(arg1) -&gt; None","ref":"Evision.Detail.ExposureCompensator.html#setMatGains/2","title":"Evision.Detail.ExposureCompensator.setMatGains/2","type":"function"},{"doc":"Raising version of setUpdateGain/2 .","ref":"Evision.Detail.ExposureCompensator.html#setUpdateGain!/2","title":"Evision.Detail.ExposureCompensator.setUpdateGain!/2","type":"function"},{"doc":"Positional Arguments b : bool Python prototype (for reference): setUpdateGain(b) -&gt; None","ref":"Evision.Detail.ExposureCompensator.html#setUpdateGain/2","title":"Evision.Detail.ExposureCompensator.setUpdateGain/2","type":"function"},{"doc":"","ref":"Evision.Detail.FeatherBlender.html","title":"Evision.Detail.FeatherBlender","type":"module"},{"doc":"Raising version of blend/3 .","ref":"Evision.Detail.FeatherBlender.html#blend!/3","title":"Evision.Detail.FeatherBlender.blend!/3","type":"function"},{"doc":"##### Return dst : Evision.Mat dst_mask : Evision.Mat Python prototype (for reference): blend(dst, dst_mask) -&gt; dst, dst_mask","ref":"Evision.Detail.FeatherBlender.html#blend/3","title":"Evision.Detail.FeatherBlender.blend/3","type":"function"},{"doc":"Raising version of createWeightMaps/4 .","ref":"Evision.Detail.FeatherBlender.html#createWeightMaps!/4","title":"Evision.Detail.FeatherBlender.createWeightMaps!/4","type":"function"},{"doc":"Positional Arguments masks : [Evision.Mat] corners : [Point] Return weight_maps : [Evision.Mat] Python prototype (for reference): createWeightMaps(masks, corners, weight_maps) -&gt; retval, weight_maps","ref":"Evision.Detail.FeatherBlender.html#createWeightMaps/4","title":"Evision.Detail.FeatherBlender.createWeightMaps/4","type":"function"},{"doc":"Raising version of detail_FeatherBlender/0 .","ref":"Evision.Detail.FeatherBlender.html#detail_FeatherBlender!/0","title":"Evision.Detail.FeatherBlender.detail_FeatherBlender!/0","type":"function"},{"doc":"Raising version of detail_FeatherBlender/1 .","ref":"Evision.Detail.FeatherBlender.html#detail_FeatherBlender!/1","title":"Evision.Detail.FeatherBlender.detail_FeatherBlender!/1","type":"function"},{"doc":"##### Keyword Arguments sharpness : float . Python prototype (for reference): FeatherBlender([, sharpness]) -&gt; &lt;detail_FeatherBlender object&gt;","ref":"Evision.Detail.FeatherBlender.html#detail_FeatherBlender/0","title":"Evision.Detail.FeatherBlender.detail_FeatherBlender/0","type":"function"},{"doc":"##### Keyword Arguments sharpness : float . Python prototype (for reference): FeatherBlender([, sharpness]) -&gt; &lt;detail_FeatherBlender object&gt;","ref":"Evision.Detail.FeatherBlender.html#detail_FeatherBlender/1","title":"Evision.Detail.FeatherBlender.detail_FeatherBlender/1","type":"function"},{"doc":"Raising version of feed/4 .","ref":"Evision.Detail.FeatherBlender.html#feed!/4","title":"Evision.Detail.FeatherBlender.feed!/4","type":"function"},{"doc":"Positional Arguments img : Evision.Mat mask : Evision.Mat tl : Point Python prototype (for reference): feed(img, mask, tl) -&gt; None","ref":"Evision.Detail.FeatherBlender.html#feed/4","title":"Evision.Detail.FeatherBlender.feed/4","type":"function"},{"doc":"Raising version of prepare/2 .","ref":"Evision.Detail.FeatherBlender.html#prepare!/2","title":"Evision.Detail.FeatherBlender.prepare!/2","type":"function"},{"doc":"Positional Arguments dst_roi : Rect Python prototype (for reference): prepare(dst_roi) -&gt; None","ref":"Evision.Detail.FeatherBlender.html#prepare/2","title":"Evision.Detail.FeatherBlender.prepare/2","type":"function"},{"doc":"Raising version of setSharpness/2 .","ref":"Evision.Detail.FeatherBlender.html#setSharpness!/2","title":"Evision.Detail.FeatherBlender.setSharpness!/2","type":"function"},{"doc":"Positional Arguments val : float Python prototype (for reference): setSharpness(val) -&gt; None","ref":"Evision.Detail.FeatherBlender.html#setSharpness/2","title":"Evision.Detail.FeatherBlender.setSharpness/2","type":"function"},{"doc":"Raising version of sharpness/1 .","ref":"Evision.Detail.FeatherBlender.html#sharpness!/1","title":"Evision.Detail.FeatherBlender.sharpness!/1","type":"function"},{"doc":"Python prototype (for reference): sharpness() -&gt; retval","ref":"Evision.Detail.FeatherBlender.html#sharpness/1","title":"Evision.Detail.FeatherBlender.sharpness/1","type":"function"},{"doc":"","ref":"Evision.Detail.FeaturesMatcher.html","title":"Evision.Detail.FeaturesMatcher","type":"module"},{"doc":"Raising version of apply2/2 .","ref":"Evision.Detail.FeaturesMatcher.html#apply2!/2","title":"Evision.Detail.FeaturesMatcher.apply2!/2","type":"function"},{"doc":"Raising version of apply2/3 .","ref":"Evision.Detail.FeaturesMatcher.html#apply2!/3","title":"Evision.Detail.FeaturesMatcher.apply2!/3","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.FeaturesMatcher.html#apply2/2","title":"Evision.Detail.FeaturesMatcher.apply2/2","type":"function"},{"doc":"Performs images matching. Positional Arguments features : [ImageFeatures] . Features of the source images Keyword Arguments mask : Evision.Mat . Mask indicating which image pairs must be matched Return pairwise_matches : [MatchesInfo] . Found pairwise matches The function is parallelized with the TBB library. @sa detail::MatchesInfo Python prototype (for reference): apply2(features[, mask]) -&gt; pairwise_matches","ref":"Evision.Detail.FeaturesMatcher.html#apply2/3","title":"Evision.Detail.FeaturesMatcher.apply2/3","type":"function"},{"doc":"Raising version of apply/3 .","ref":"Evision.Detail.FeaturesMatcher.html#apply!/3","title":"Evision.Detail.FeaturesMatcher.apply!/3","type":"function"},{"doc":"Positional Arguments features1 : ImageFeatures . First image features features2 : ImageFeatures . Second image features Return matches_info : MatchesInfo . Found matches Has overloading in C++ Python prototype (for reference): apply(features1, features2) -&gt; matches_info","ref":"Evision.Detail.FeaturesMatcher.html#apply/3","title":"Evision.Detail.FeaturesMatcher.apply/3","type":"function"},{"doc":"Raising version of collectGarbage/1 .","ref":"Evision.Detail.FeaturesMatcher.html#collectGarbage!/1","title":"Evision.Detail.FeaturesMatcher.collectGarbage!/1","type":"function"},{"doc":"Frees unused memory allocated before if there is any. Python prototype (for reference): collectGarbage() -&gt; None","ref":"Evision.Detail.FeaturesMatcher.html#collectGarbage/1","title":"Evision.Detail.FeaturesMatcher.collectGarbage/1","type":"function"},{"doc":"Raising version of isThreadSafe/1 .","ref":"Evision.Detail.FeaturesMatcher.html#isThreadSafe!/1","title":"Evision.Detail.FeaturesMatcher.isThreadSafe!/1","type":"function"},{"doc":"@return True, if it's possible to use the same matcher instance in parallel, false otherwise Python prototype (for reference): isThreadSafe() -&gt; retval","ref":"Evision.Detail.FeaturesMatcher.html#isThreadSafe/1","title":"Evision.Detail.FeaturesMatcher.isThreadSafe/1","type":"function"},{"doc":"","ref":"Evision.Detail.GainCompensator.html","title":"Evision.Detail.GainCompensator","type":"module"},{"doc":"Raising version of apply/5 .","ref":"Evision.Detail.GainCompensator.html#apply!/5","title":"Evision.Detail.GainCompensator.apply!/5","type":"function"},{"doc":"Positional Arguments index : int corner : Point mask : Evision.Mat Return image : Evision.Mat Python prototype (for reference): apply(index, corner, image, mask) -&gt; image","ref":"Evision.Detail.GainCompensator.html#apply/5","title":"Evision.Detail.GainCompensator.apply/5","type":"function"},{"doc":"Raising version of detail_GainCompensator/0 .","ref":"Evision.Detail.GainCompensator.html#detail_GainCompensator!/0","title":"Evision.Detail.GainCompensator.detail_GainCompensator!/0","type":"function"},{"doc":"Raising version of detail_GainCompensator/1 .","ref":"Evision.Detail.GainCompensator.html#detail_GainCompensator!/1","title":"Evision.Detail.GainCompensator.detail_GainCompensator!/1","type":"function"},{"doc":"Python prototype (for reference): GainCompensator() -&gt; &lt;detail_GainCompensator object&gt;","ref":"Evision.Detail.GainCompensator.html#detail_GainCompensator/0","title":"Evision.Detail.GainCompensator.detail_GainCompensator/0","type":"function"},{"doc":"Positional Arguments nr_feeds : int Python prototype (for reference): GainCompensator(nr_feeds) -&gt; &lt;detail_GainCompensator object&gt;","ref":"Evision.Detail.GainCompensator.html#detail_GainCompensator/1","title":"Evision.Detail.GainCompensator.detail_GainCompensator/1","type":"function"},{"doc":"Raising version of getMatGains/1 .","ref":"Evision.Detail.GainCompensator.html#getMatGains!/1","title":"Evision.Detail.GainCompensator.getMatGains!/1","type":"function"},{"doc":"##### Return umv : [Evision.Mat] . Python prototype (for reference): getMatGains([, umv]) -&gt; umv","ref":"Evision.Detail.GainCompensator.html#getMatGains/1","title":"Evision.Detail.GainCompensator.getMatGains/1","type":"function"},{"doc":"Raising version of getNrFeeds/1 .","ref":"Evision.Detail.GainCompensator.html#getNrFeeds!/1","title":"Evision.Detail.GainCompensator.getNrFeeds!/1","type":"function"},{"doc":"Python prototype (for reference): getNrFeeds() -&gt; retval","ref":"Evision.Detail.GainCompensator.html#getNrFeeds/1","title":"Evision.Detail.GainCompensator.getNrFeeds/1","type":"function"},{"doc":"Raising version of getSimilarityThreshold/1 .","ref":"Evision.Detail.GainCompensator.html#getSimilarityThreshold!/1","title":"Evision.Detail.GainCompensator.getSimilarityThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getSimilarityThreshold() -&gt; retval","ref":"Evision.Detail.GainCompensator.html#getSimilarityThreshold/1","title":"Evision.Detail.GainCompensator.getSimilarityThreshold/1","type":"function"},{"doc":"Raising version of setMatGains/2 .","ref":"Evision.Detail.GainCompensator.html#setMatGains!/2","title":"Evision.Detail.GainCompensator.setMatGains!/2","type":"function"},{"doc":"Positional Arguments umv : [Evision.Mat] Python prototype (for reference): setMatGains(umv) -&gt; None","ref":"Evision.Detail.GainCompensator.html#setMatGains/2","title":"Evision.Detail.GainCompensator.setMatGains/2","type":"function"},{"doc":"Raising version of setNrFeeds/2 .","ref":"Evision.Detail.GainCompensator.html#setNrFeeds!/2","title":"Evision.Detail.GainCompensator.setNrFeeds!/2","type":"function"},{"doc":"Positional Arguments nr_feeds : int Python prototype (for reference): setNrFeeds(nr_feeds) -&gt; None","ref":"Evision.Detail.GainCompensator.html#setNrFeeds/2","title":"Evision.Detail.GainCompensator.setNrFeeds/2","type":"function"},{"doc":"Raising version of setSimilarityThreshold/2 .","ref":"Evision.Detail.GainCompensator.html#setSimilarityThreshold!/2","title":"Evision.Detail.GainCompensator.setSimilarityThreshold!/2","type":"function"},{"doc":"Positional Arguments similarity_threshold : double Python prototype (for reference): setSimilarityThreshold(similarity_threshold) -&gt; None","ref":"Evision.Detail.GainCompensator.html#setSimilarityThreshold/2","title":"Evision.Detail.GainCompensator.setSimilarityThreshold/2","type":"function"},{"doc":"","ref":"Evision.Detail.GraphCutSeamFinder.html","title":"Evision.Detail.GraphCutSeamFinder","type":"module"},{"doc":"Raising version of detail_GraphCutSeamFinder/1 .","ref":"Evision.Detail.GraphCutSeamFinder.html#detail_GraphCutSeamFinder!/1","title":"Evision.Detail.GraphCutSeamFinder.detail_GraphCutSeamFinder!/1","type":"function"},{"doc":"Raising version of detail_GraphCutSeamFinder/2 .","ref":"Evision.Detail.GraphCutSeamFinder.html#detail_GraphCutSeamFinder!/2","title":"Evision.Detail.GraphCutSeamFinder.detail_GraphCutSeamFinder!/2","type":"function"},{"doc":"Positional Arguments cost_type : String Keyword Arguments terminal_cost : float . bad_region_penalty : float . Python prototype (for reference): GraphCutSeamFinder(cost_type[, terminal_cost[, bad_region_penalty]]) -&gt; &lt;detail_GraphCutSeamFinder object&gt;","ref":"Evision.Detail.GraphCutSeamFinder.html#detail_GraphCutSeamFinder/1","title":"Evision.Detail.GraphCutSeamFinder.detail_GraphCutSeamFinder/1","type":"function"},{"doc":"Positional Arguments cost_type : String Keyword Arguments terminal_cost : float . bad_region_penalty : float . Python prototype (for reference): GraphCutSeamFinder(cost_type[, terminal_cost[, bad_region_penalty]]) -&gt; &lt;detail_GraphCutSeamFinder object&gt;","ref":"Evision.Detail.GraphCutSeamFinder.html#detail_GraphCutSeamFinder/2","title":"Evision.Detail.GraphCutSeamFinder.detail_GraphCutSeamFinder/2","type":"function"},{"doc":"Raising version of find/4 .","ref":"Evision.Detail.GraphCutSeamFinder.html#find!/4","title":"Evision.Detail.GraphCutSeamFinder.find!/4","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] corners : [Point] masks : [Evision.Mat] Python prototype (for reference): find(src, corners, masks) -&gt; None","ref":"Evision.Detail.GraphCutSeamFinder.html#find/4","title":"Evision.Detail.GraphCutSeamFinder.find/4","type":"function"},{"doc":"","ref":"Evision.Detail.HomographyBasedEstimator.html","title":"Evision.Detail.HomographyBasedEstimator","type":"module"},{"doc":"Raising version of detail_HomographyBasedEstimator/0 .","ref":"Evision.Detail.HomographyBasedEstimator.html#detail_HomographyBasedEstimator!/0","title":"Evision.Detail.HomographyBasedEstimator.detail_HomographyBasedEstimator!/0","type":"function"},{"doc":"Raising version of detail_HomographyBasedEstimator/1 .","ref":"Evision.Detail.HomographyBasedEstimator.html#detail_HomographyBasedEstimator!/1","title":"Evision.Detail.HomographyBasedEstimator.detail_HomographyBasedEstimator!/1","type":"function"},{"doc":"##### Keyword Arguments is_focals_estimated : bool . Python prototype (for reference): HomographyBasedEstimator([, is_focals_estimated]) -&gt; &lt;detail_HomographyBasedEstimator object&gt;","ref":"Evision.Detail.HomographyBasedEstimator.html#detail_HomographyBasedEstimator/0","title":"Evision.Detail.HomographyBasedEstimator.detail_HomographyBasedEstimator/0","type":"function"},{"doc":"##### Keyword Arguments is_focals_estimated : bool . Python prototype (for reference): HomographyBasedEstimator([, is_focals_estimated]) -&gt; &lt;detail_HomographyBasedEstimator object&gt;","ref":"Evision.Detail.HomographyBasedEstimator.html#detail_HomographyBasedEstimator/1","title":"Evision.Detail.HomographyBasedEstimator.detail_HomographyBasedEstimator/1","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html","title":"Evision.Detail.ImageFeatures","type":"module"},{"doc":"Raising version of get_descriptors/1 .","ref":"Evision.Detail.ImageFeatures.html#get_descriptors!/1","title":"Evision.Detail.ImageFeatures.get_descriptors!/1","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#get_descriptors/1","title":"Evision.Detail.ImageFeatures.get_descriptors/1","type":"function"},{"doc":"Raising version of get_img_idx/1 .","ref":"Evision.Detail.ImageFeatures.html#get_img_idx!/1","title":"Evision.Detail.ImageFeatures.get_img_idx!/1","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#get_img_idx/1","title":"Evision.Detail.ImageFeatures.get_img_idx/1","type":"function"},{"doc":"Raising version of get_img_size/1 .","ref":"Evision.Detail.ImageFeatures.html#get_img_size!/1","title":"Evision.Detail.ImageFeatures.get_img_size!/1","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#get_img_size/1","title":"Evision.Detail.ImageFeatures.get_img_size/1","type":"function"},{"doc":"Raising version of get_keypoints/1 .","ref":"Evision.Detail.ImageFeatures.html#get_keypoints!/1","title":"Evision.Detail.ImageFeatures.get_keypoints!/1","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#get_keypoints/1","title":"Evision.Detail.ImageFeatures.get_keypoints/1","type":"function"},{"doc":"Raising version of getKeypoints/1 .","ref":"Evision.Detail.ImageFeatures.html#getKeypoints!/1","title":"Evision.Detail.ImageFeatures.getKeypoints!/1","type":"function"},{"doc":"Python prototype (for reference): getKeypoints() -&gt; retval","ref":"Evision.Detail.ImageFeatures.html#getKeypoints/1","title":"Evision.Detail.ImageFeatures.getKeypoints/1","type":"function"},{"doc":"Raising version of set_descriptors/2 .","ref":"Evision.Detail.ImageFeatures.html#set_descriptors!/2","title":"Evision.Detail.ImageFeatures.set_descriptors!/2","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#set_descriptors/2","title":"Evision.Detail.ImageFeatures.set_descriptors/2","type":"function"},{"doc":"Raising version of set_img_idx/2 .","ref":"Evision.Detail.ImageFeatures.html#set_img_idx!/2","title":"Evision.Detail.ImageFeatures.set_img_idx!/2","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#set_img_idx/2","title":"Evision.Detail.ImageFeatures.set_img_idx/2","type":"function"},{"doc":"Raising version of set_img_size/2 .","ref":"Evision.Detail.ImageFeatures.html#set_img_size!/2","title":"Evision.Detail.ImageFeatures.set_img_size!/2","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#set_img_size/2","title":"Evision.Detail.ImageFeatures.set_img_size/2","type":"function"},{"doc":"Raising version of set_keypoints/2 .","ref":"Evision.Detail.ImageFeatures.html#set_keypoints!/2","title":"Evision.Detail.ImageFeatures.set_keypoints!/2","type":"function"},{"doc":"","ref":"Evision.Detail.ImageFeatures.html#set_keypoints/2","title":"Evision.Detail.ImageFeatures.set_keypoints/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html","title":"Evision.Detail.MatchesInfo","type":"module"},{"doc":"Raising version of get_confidence/1 .","ref":"Evision.Detail.MatchesInfo.html#get_confidence!/1","title":"Evision.Detail.MatchesInfo.get_confidence!/1","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#get_confidence/1","title":"Evision.Detail.MatchesInfo.get_confidence/1","type":"function"},{"doc":"Raising version of get_dst_img_idx/1 .","ref":"Evision.Detail.MatchesInfo.html#get_dst_img_idx!/1","title":"Evision.Detail.MatchesInfo.get_dst_img_idx!/1","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#get_dst_img_idx/1","title":"Evision.Detail.MatchesInfo.get_dst_img_idx/1","type":"function"},{"doc":"Raising version of get_H/1 .","ref":"Evision.Detail.MatchesInfo.html#get_H!/1","title":"Evision.Detail.MatchesInfo.get_H!/1","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#get_H/1","title":"Evision.Detail.MatchesInfo.get_H/1","type":"function"},{"doc":"Raising version of get_inliers_mask/1 .","ref":"Evision.Detail.MatchesInfo.html#get_inliers_mask!/1","title":"Evision.Detail.MatchesInfo.get_inliers_mask!/1","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#get_inliers_mask/1","title":"Evision.Detail.MatchesInfo.get_inliers_mask/1","type":"function"},{"doc":"Raising version of get_matches/1 .","ref":"Evision.Detail.MatchesInfo.html#get_matches!/1","title":"Evision.Detail.MatchesInfo.get_matches!/1","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#get_matches/1","title":"Evision.Detail.MatchesInfo.get_matches/1","type":"function"},{"doc":"Raising version of get_num_inliers/1 .","ref":"Evision.Detail.MatchesInfo.html#get_num_inliers!/1","title":"Evision.Detail.MatchesInfo.get_num_inliers!/1","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#get_num_inliers/1","title":"Evision.Detail.MatchesInfo.get_num_inliers/1","type":"function"},{"doc":"Raising version of get_src_img_idx/1 .","ref":"Evision.Detail.MatchesInfo.html#get_src_img_idx!/1","title":"Evision.Detail.MatchesInfo.get_src_img_idx!/1","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#get_src_img_idx/1","title":"Evision.Detail.MatchesInfo.get_src_img_idx/1","type":"function"},{"doc":"Raising version of getInliers/1 .","ref":"Evision.Detail.MatchesInfo.html#getInliers!/1","title":"Evision.Detail.MatchesInfo.getInliers!/1","type":"function"},{"doc":"Python prototype (for reference): getInliers() -&gt; retval","ref":"Evision.Detail.MatchesInfo.html#getInliers/1","title":"Evision.Detail.MatchesInfo.getInliers/1","type":"function"},{"doc":"Raising version of getMatches/1 .","ref":"Evision.Detail.MatchesInfo.html#getMatches!/1","title":"Evision.Detail.MatchesInfo.getMatches!/1","type":"function"},{"doc":"Python prototype (for reference): getMatches() -&gt; retval","ref":"Evision.Detail.MatchesInfo.html#getMatches/1","title":"Evision.Detail.MatchesInfo.getMatches/1","type":"function"},{"doc":"Raising version of set_confidence/2 .","ref":"Evision.Detail.MatchesInfo.html#set_confidence!/2","title":"Evision.Detail.MatchesInfo.set_confidence!/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#set_confidence/2","title":"Evision.Detail.MatchesInfo.set_confidence/2","type":"function"},{"doc":"Raising version of set_dst_img_idx/2 .","ref":"Evision.Detail.MatchesInfo.html#set_dst_img_idx!/2","title":"Evision.Detail.MatchesInfo.set_dst_img_idx!/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#set_dst_img_idx/2","title":"Evision.Detail.MatchesInfo.set_dst_img_idx/2","type":"function"},{"doc":"Raising version of set_H/2 .","ref":"Evision.Detail.MatchesInfo.html#set_H!/2","title":"Evision.Detail.MatchesInfo.set_H!/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#set_H/2","title":"Evision.Detail.MatchesInfo.set_H/2","type":"function"},{"doc":"Raising version of set_inliers_mask/2 .","ref":"Evision.Detail.MatchesInfo.html#set_inliers_mask!/2","title":"Evision.Detail.MatchesInfo.set_inliers_mask!/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#set_inliers_mask/2","title":"Evision.Detail.MatchesInfo.set_inliers_mask/2","type":"function"},{"doc":"Raising version of set_matches/2 .","ref":"Evision.Detail.MatchesInfo.html#set_matches!/2","title":"Evision.Detail.MatchesInfo.set_matches!/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#set_matches/2","title":"Evision.Detail.MatchesInfo.set_matches/2","type":"function"},{"doc":"Raising version of set_num_inliers/2 .","ref":"Evision.Detail.MatchesInfo.html#set_num_inliers!/2","title":"Evision.Detail.MatchesInfo.set_num_inliers!/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#set_num_inliers/2","title":"Evision.Detail.MatchesInfo.set_num_inliers/2","type":"function"},{"doc":"Raising version of set_src_img_idx/2 .","ref":"Evision.Detail.MatchesInfo.html#set_src_img_idx!/2","title":"Evision.Detail.MatchesInfo.set_src_img_idx!/2","type":"function"},{"doc":"","ref":"Evision.Detail.MatchesInfo.html#set_src_img_idx/2","title":"Evision.Detail.MatchesInfo.set_src_img_idx/2","type":"function"},{"doc":"","ref":"Evision.Detail.MultiBandBlender.html","title":"Evision.Detail.MultiBandBlender","type":"module"},{"doc":"Raising version of blend/3 .","ref":"Evision.Detail.MultiBandBlender.html#blend!/3","title":"Evision.Detail.MultiBandBlender.blend!/3","type":"function"},{"doc":"##### Return dst : Evision.Mat dst_mask : Evision.Mat Python prototype (for reference): blend(dst, dst_mask) -&gt; dst, dst_mask","ref":"Evision.Detail.MultiBandBlender.html#blend/3","title":"Evision.Detail.MultiBandBlender.blend/3","type":"function"},{"doc":"Raising version of detail_MultiBandBlender/0 .","ref":"Evision.Detail.MultiBandBlender.html#detail_MultiBandBlender!/0","title":"Evision.Detail.MultiBandBlender.detail_MultiBandBlender!/0","type":"function"},{"doc":"Raising version of detail_MultiBandBlender/1 .","ref":"Evision.Detail.MultiBandBlender.html#detail_MultiBandBlender!/1","title":"Evision.Detail.MultiBandBlender.detail_MultiBandBlender!/1","type":"function"},{"doc":"##### Keyword Arguments try_gpu : int . num_bands : int . weight_type : int . Python prototype (for reference): MultiBandBlender([, try_gpu[, num_bands[, weight_type]]]) -&gt; &lt;detail_MultiBandBlender object&gt;","ref":"Evision.Detail.MultiBandBlender.html#detail_MultiBandBlender/0","title":"Evision.Detail.MultiBandBlender.detail_MultiBandBlender/0","type":"function"},{"doc":"##### Keyword Arguments try_gpu : int . num_bands : int . weight_type : int . Python prototype (for reference): MultiBandBlender([, try_gpu[, num_bands[, weight_type]]]) -&gt; &lt;detail_MultiBandBlender object&gt;","ref":"Evision.Detail.MultiBandBlender.html#detail_MultiBandBlender/1","title":"Evision.Detail.MultiBandBlender.detail_MultiBandBlender/1","type":"function"},{"doc":"Raising version of feed/4 .","ref":"Evision.Detail.MultiBandBlender.html#feed!/4","title":"Evision.Detail.MultiBandBlender.feed!/4","type":"function"},{"doc":"Positional Arguments img : Evision.Mat mask : Evision.Mat tl : Point Python prototype (for reference): feed(img, mask, tl) -&gt; None","ref":"Evision.Detail.MultiBandBlender.html#feed/4","title":"Evision.Detail.MultiBandBlender.feed/4","type":"function"},{"doc":"Raising version of numBands/1 .","ref":"Evision.Detail.MultiBandBlender.html#numBands!/1","title":"Evision.Detail.MultiBandBlender.numBands!/1","type":"function"},{"doc":"Python prototype (for reference): numBands() -&gt; retval","ref":"Evision.Detail.MultiBandBlender.html#numBands/1","title":"Evision.Detail.MultiBandBlender.numBands/1","type":"function"},{"doc":"Raising version of prepare/2 .","ref":"Evision.Detail.MultiBandBlender.html#prepare!/2","title":"Evision.Detail.MultiBandBlender.prepare!/2","type":"function"},{"doc":"Positional Arguments dst_roi : Rect Python prototype (for reference): prepare(dst_roi) -&gt; None","ref":"Evision.Detail.MultiBandBlender.html#prepare/2","title":"Evision.Detail.MultiBandBlender.prepare/2","type":"function"},{"doc":"Raising version of setNumBands/2 .","ref":"Evision.Detail.MultiBandBlender.html#setNumBands!/2","title":"Evision.Detail.MultiBandBlender.setNumBands!/2","type":"function"},{"doc":"Positional Arguments val : int Python prototype (for reference): setNumBands(val) -&gt; None","ref":"Evision.Detail.MultiBandBlender.html#setNumBands/2","title":"Evision.Detail.MultiBandBlender.setNumBands/2","type":"function"},{"doc":"","ref":"Evision.Detail.NoBundleAdjuster.html","title":"Evision.Detail.NoBundleAdjuster","type":"module"},{"doc":"Raising version of detail_NoBundleAdjuster/0 .","ref":"Evision.Detail.NoBundleAdjuster.html#detail_NoBundleAdjuster!/0","title":"Evision.Detail.NoBundleAdjuster.detail_NoBundleAdjuster!/0","type":"function"},{"doc":"Python prototype (for reference): NoBundleAdjuster() -&gt; &lt;detail_NoBundleAdjuster object&gt;","ref":"Evision.Detail.NoBundleAdjuster.html#detail_NoBundleAdjuster/0","title":"Evision.Detail.NoBundleAdjuster.detail_NoBundleAdjuster/0","type":"function"},{"doc":"","ref":"Evision.Detail.NoExposureCompensator.html","title":"Evision.Detail.NoExposureCompensator","type":"module"},{"doc":"Raising version of apply/5 .","ref":"Evision.Detail.NoExposureCompensator.html#apply!/5","title":"Evision.Detail.NoExposureCompensator.apply!/5","type":"function"},{"doc":"Positional Arguments arg1 : int arg2 : Point arg4 : Evision.Mat Return arg3 : Evision.Mat Python prototype (for reference): apply(arg1, arg2, arg3, arg4) -&gt; arg3","ref":"Evision.Detail.NoExposureCompensator.html#apply/5","title":"Evision.Detail.NoExposureCompensator.apply/5","type":"function"},{"doc":"Raising version of getMatGains/1 .","ref":"Evision.Detail.NoExposureCompensator.html#getMatGains!/1","title":"Evision.Detail.NoExposureCompensator.getMatGains!/1","type":"function"},{"doc":"##### Return umv : [Evision.Mat] . Python prototype (for reference): getMatGains([, umv]) -&gt; umv","ref":"Evision.Detail.NoExposureCompensator.html#getMatGains/1","title":"Evision.Detail.NoExposureCompensator.getMatGains/1","type":"function"},{"doc":"Raising version of setMatGains/2 .","ref":"Evision.Detail.NoExposureCompensator.html#setMatGains!/2","title":"Evision.Detail.NoExposureCompensator.setMatGains!/2","type":"function"},{"doc":"Positional Arguments umv : [Evision.Mat] Python prototype (for reference): setMatGains(umv) -&gt; None","ref":"Evision.Detail.NoExposureCompensator.html#setMatGains/2","title":"Evision.Detail.NoExposureCompensator.setMatGains/2","type":"function"},{"doc":"","ref":"Evision.Detail.NoSeamFinder.html","title":"Evision.Detail.NoSeamFinder","type":"module"},{"doc":"Raising version of find/4 .","ref":"Evision.Detail.NoSeamFinder.html#find!/4","title":"Evision.Detail.NoSeamFinder.find!/4","type":"function"},{"doc":"Positional Arguments arg1 : [Evision.Mat] arg2 : [Point] Return arg3 : [Evision.Mat] Python prototype (for reference): find(arg1, arg2, arg3) -&gt; arg3","ref":"Evision.Detail.NoSeamFinder.html#find/4","title":"Evision.Detail.NoSeamFinder.find/4","type":"function"},{"doc":"","ref":"Evision.Detail.PairwiseSeamFinder.html","title":"Evision.Detail.PairwiseSeamFinder","type":"module"},{"doc":"Raising version of find/4 .","ref":"Evision.Detail.PairwiseSeamFinder.html#find!/4","title":"Evision.Detail.PairwiseSeamFinder.find!/4","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] corners : [Point] Return masks : [Evision.Mat] Python prototype (for reference): find(src, corners, masks) -&gt; masks","ref":"Evision.Detail.PairwiseSeamFinder.html#find/4","title":"Evision.Detail.PairwiseSeamFinder.find/4","type":"function"},{"doc":"","ref":"Evision.Detail.SeamFinder.html","title":"Evision.Detail.SeamFinder","type":"module"},{"doc":"Raising version of createDefault/1 .","ref":"Evision.Detail.SeamFinder.html#createDefault!/1","title":"Evision.Detail.SeamFinder.createDefault!/1","type":"function"},{"doc":"Positional Arguments type : int Python prototype (for reference): createDefault(type) -&gt; retval","ref":"Evision.Detail.SeamFinder.html#createDefault/1","title":"Evision.Detail.SeamFinder.createDefault/1","type":"function"},{"doc":"Raising version of find/4 .","ref":"Evision.Detail.SeamFinder.html#find!/4","title":"Evision.Detail.SeamFinder.find!/4","type":"function"},{"doc":"Estimates seams. Positional Arguments src : [Evision.Mat] . Source images corners : [Point] . Source image top-left corners Return masks : [Evision.Mat] . Source image masks to update Python prototype (for reference): find(src, corners, masks) -&gt; masks","ref":"Evision.Detail.SeamFinder.html#find/4","title":"Evision.Detail.SeamFinder.find/4","type":"function"},{"doc":"","ref":"Evision.Detail.SphericalProjector.html","title":"Evision.Detail.SphericalProjector","type":"module"},{"doc":"Raising version of mapBackward/5 .","ref":"Evision.Detail.SphericalProjector.html#mapBackward!/5","title":"Evision.Detail.SphericalProjector.mapBackward!/5","type":"function"},{"doc":"Positional Arguments u : float v : float x : float y : float Python prototype (for reference): mapBackward(u, v, x, y) -&gt; None","ref":"Evision.Detail.SphericalProjector.html#mapBackward/5","title":"Evision.Detail.SphericalProjector.mapBackward/5","type":"function"},{"doc":"Raising version of mapForward/5 .","ref":"Evision.Detail.SphericalProjector.html#mapForward!/5","title":"Evision.Detail.SphericalProjector.mapForward!/5","type":"function"},{"doc":"Positional Arguments x : float y : float u : float v : float Python prototype (for reference): mapForward(x, y, u, v) -&gt; None","ref":"Evision.Detail.SphericalProjector.html#mapForward/5","title":"Evision.Detail.SphericalProjector.mapForward/5","type":"function"},{"doc":"","ref":"Evision.Detail.Timelapser.html","title":"Evision.Detail.Timelapser","type":"module"},{"doc":"Raising version of createDefault/1 .","ref":"Evision.Detail.Timelapser.html#createDefault!/1","title":"Evision.Detail.Timelapser.createDefault!/1","type":"function"},{"doc":"Positional Arguments type : int Python prototype (for reference): createDefault(type) -&gt; retval","ref":"Evision.Detail.Timelapser.html#createDefault/1","title":"Evision.Detail.Timelapser.createDefault/1","type":"function"},{"doc":"Raising version of getDst/1 .","ref":"Evision.Detail.Timelapser.html#getDst!/1","title":"Evision.Detail.Timelapser.getDst!/1","type":"function"},{"doc":"Python prototype (for reference): getDst() -&gt; retval","ref":"Evision.Detail.Timelapser.html#getDst/1","title":"Evision.Detail.Timelapser.getDst/1","type":"function"},{"doc":"Raising version of initialize/3 .","ref":"Evision.Detail.Timelapser.html#initialize!/3","title":"Evision.Detail.Timelapser.initialize!/3","type":"function"},{"doc":"Positional Arguments corners : [Point] sizes : [Size] Python prototype (for reference): initialize(corners, sizes) -&gt; None","ref":"Evision.Detail.Timelapser.html#initialize/3","title":"Evision.Detail.Timelapser.initialize/3","type":"function"},{"doc":"Raising version of process/4 .","ref":"Evision.Detail.Timelapser.html#process!/4","title":"Evision.Detail.Timelapser.process!/4","type":"function"},{"doc":"Positional Arguments img : Evision.Mat mask : Evision.Mat tl : Point Python prototype (for reference): process(img, mask, tl) -&gt; None","ref":"Evision.Detail.Timelapser.html#process/4","title":"Evision.Detail.Timelapser.process/4","type":"function"},{"doc":"","ref":"Evision.Detail.VoronoiSeamFinder.html","title":"Evision.Detail.VoronoiSeamFinder","type":"module"},{"doc":"Raising version of find/4 .","ref":"Evision.Detail.VoronoiSeamFinder.html#find!/4","title":"Evision.Detail.VoronoiSeamFinder.find!/4","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] corners : [Point] Return masks : [Evision.Mat] Python prototype (for reference): find(src, corners, masks) -&gt; masks","ref":"Evision.Detail.VoronoiSeamFinder.html#find/4","title":"Evision.Detail.VoronoiSeamFinder.find/4","type":"function"},{"doc":"","ref":"Evision.FaceDetectorYN.html","title":"Evision.FaceDetectorYN","type":"module"},{"doc":"Raising version of create/3 .","ref":"Evision.FaceDetectorYN.html#create!/3","title":"Evision.FaceDetectorYN.create!/3","type":"function"},{"doc":"Raising version of create/4 .","ref":"Evision.FaceDetectorYN.html#create!/4","title":"Evision.FaceDetectorYN.create!/4","type":"function"},{"doc":"Creates an instance of this class with given parameters Positional Arguments model : String . the path to the requested model config : String . the path to the config file for compability, which is not requested for ONNX models input_size : Size . the size of the input image Keyword Arguments score_threshold : float . the threshold to filter out bounding boxes of score smaller than the given value nms_threshold : float . the threshold to suppress bounding boxes of IoU bigger than the given value top_k : int . keep top K bboxes before NMS backend_id : int . the id of backend target_id : int . the id of target device Python prototype (for reference): create(model, config, input_size[, score_threshold[, nms_threshold[, top_k[, backend_id[, target_id]]]]]) -&gt; retval","ref":"Evision.FaceDetectorYN.html#create/3","title":"Evision.FaceDetectorYN.create/3","type":"function"},{"doc":"Creates an instance of this class with given parameters Positional Arguments model : String . the path to the requested model config : String . the path to the config file for compability, which is not requested for ONNX models input_size : Size . the size of the input image Keyword Arguments score_threshold : float . the threshold to filter out bounding boxes of score smaller than the given value nms_threshold : float . the threshold to suppress bounding boxes of IoU bigger than the given value top_k : int . keep top K bboxes before NMS backend_id : int . the id of backend target_id : int . the id of target device Python prototype (for reference): create(model, config, input_size[, score_threshold[, nms_threshold[, top_k[, backend_id[, target_id]]]]]) -&gt; retval","ref":"Evision.FaceDetectorYN.html#create/4","title":"Evision.FaceDetectorYN.create/4","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.FaceDetectorYN.html#detect!/2","title":"Evision.FaceDetectorYN.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.FaceDetectorYN.html#detect!/3","title":"Evision.FaceDetectorYN.detect!/3","type":"function"},{"doc":"A simple interface to detect face from given image Positional Arguments image : Evision.Mat . an image to detect Return faces : Evision.Mat . detection results stored in a cv::Mat Python prototype (for reference): detect(image[, faces]) -&gt; retval, faces","ref":"Evision.FaceDetectorYN.html#detect/2","title":"Evision.FaceDetectorYN.detect/2","type":"function"},{"doc":"A simple interface to detect face from given image Positional Arguments image : Evision.Mat . an image to detect Return faces : Evision.Mat . detection results stored in a cv::Mat Python prototype (for reference): detect(image[, faces]) -&gt; retval, faces","ref":"Evision.FaceDetectorYN.html#detect/3","title":"Evision.FaceDetectorYN.detect/3","type":"function"},{"doc":"Raising version of getInputSize/1 .","ref":"Evision.FaceDetectorYN.html#getInputSize!/1","title":"Evision.FaceDetectorYN.getInputSize!/1","type":"function"},{"doc":"Python prototype (for reference): getInputSize() -&gt; retval","ref":"Evision.FaceDetectorYN.html#getInputSize/1","title":"Evision.FaceDetectorYN.getInputSize/1","type":"function"},{"doc":"Raising version of getNMSThreshold/1 .","ref":"Evision.FaceDetectorYN.html#getNMSThreshold!/1","title":"Evision.FaceDetectorYN.getNMSThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getNMSThreshold() -&gt; retval","ref":"Evision.FaceDetectorYN.html#getNMSThreshold/1","title":"Evision.FaceDetectorYN.getNMSThreshold/1","type":"function"},{"doc":"Raising version of getScoreThreshold/1 .","ref":"Evision.FaceDetectorYN.html#getScoreThreshold!/1","title":"Evision.FaceDetectorYN.getScoreThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getScoreThreshold() -&gt; retval","ref":"Evision.FaceDetectorYN.html#getScoreThreshold/1","title":"Evision.FaceDetectorYN.getScoreThreshold/1","type":"function"},{"doc":"Raising version of getTopK/1 .","ref":"Evision.FaceDetectorYN.html#getTopK!/1","title":"Evision.FaceDetectorYN.getTopK!/1","type":"function"},{"doc":"Python prototype (for reference): getTopK() -&gt; retval","ref":"Evision.FaceDetectorYN.html#getTopK/1","title":"Evision.FaceDetectorYN.getTopK/1","type":"function"},{"doc":"Raising version of setInputSize/2 .","ref":"Evision.FaceDetectorYN.html#setInputSize!/2","title":"Evision.FaceDetectorYN.setInputSize!/2","type":"function"},{"doc":"Set the size for the network input, which overwrites the input size of creating model. Call this method when the size of input image does not match the input size when creating model Positional Arguments input_size : Size . the size of the input image Python prototype (for reference): setInputSize(input_size) -&gt; None","ref":"Evision.FaceDetectorYN.html#setInputSize/2","title":"Evision.FaceDetectorYN.setInputSize/2","type":"function"},{"doc":"Raising version of setNMSThreshold/2 .","ref":"Evision.FaceDetectorYN.html#setNMSThreshold!/2","title":"Evision.FaceDetectorYN.setNMSThreshold!/2","type":"function"},{"doc":"Set the Non-maximum-suppression threshold to suppress bounding boxes that have IoU greater than the given value Positional Arguments nms_threshold : float . threshold for NMS operation Python prototype (for reference): setNMSThreshold(nms_threshold) -&gt; None","ref":"Evision.FaceDetectorYN.html#setNMSThreshold/2","title":"Evision.FaceDetectorYN.setNMSThreshold/2","type":"function"},{"doc":"Raising version of setScoreThreshold/2 .","ref":"Evision.FaceDetectorYN.html#setScoreThreshold!/2","title":"Evision.FaceDetectorYN.setScoreThreshold!/2","type":"function"},{"doc":"Set the score threshold to filter out bounding boxes of score less than the given value Positional Arguments score_threshold : float . threshold for filtering out bounding boxes Python prototype (for reference): setScoreThreshold(score_threshold) -&gt; None","ref":"Evision.FaceDetectorYN.html#setScoreThreshold/2","title":"Evision.FaceDetectorYN.setScoreThreshold/2","type":"function"},{"doc":"Raising version of setTopK/2 .","ref":"Evision.FaceDetectorYN.html#setTopK!/2","title":"Evision.FaceDetectorYN.setTopK!/2","type":"function"},{"doc":"Set the number of bounding boxes preserved before NMS Positional Arguments top_k : int . the number of bounding boxes to preserve from top rank based on score Python prototype (for reference): setTopK(top_k) -&gt; None","ref":"Evision.FaceDetectorYN.html#setTopK/2","title":"Evision.FaceDetectorYN.setTopK/2","type":"function"},{"doc":"","ref":"Evision.FaceRecognizerSF.html","title":"Evision.FaceRecognizerSF","type":"module"},{"doc":"Raising version of alignCrop/3 .","ref":"Evision.FaceRecognizerSF.html#alignCrop!/3","title":"Evision.FaceRecognizerSF.alignCrop!/3","type":"function"},{"doc":"Raising version of alignCrop/4 .","ref":"Evision.FaceRecognizerSF.html#alignCrop!/4","title":"Evision.FaceRecognizerSF.alignCrop!/4","type":"function"},{"doc":"Aligning image to put face on the standard position Positional Arguments src_img : Evision.Mat . input image face_box : Evision.Mat . the detection result used for indicate face in input image Return aligned_img : Evision.Mat . output aligned image Python prototype (for reference): alignCrop(src_img, face_box[, aligned_img]) -&gt; aligned_img","ref":"Evision.FaceRecognizerSF.html#alignCrop/3","title":"Evision.FaceRecognizerSF.alignCrop/3","type":"function"},{"doc":"Aligning image to put face on the standard position Positional Arguments src_img : Evision.Mat . input image face_box : Evision.Mat . the detection result used for indicate face in input image Return aligned_img : Evision.Mat . output aligned image Python prototype (for reference): alignCrop(src_img, face_box[, aligned_img]) -&gt; aligned_img","ref":"Evision.FaceRecognizerSF.html#alignCrop/4","title":"Evision.FaceRecognizerSF.alignCrop/4","type":"function"},{"doc":"Raising version of create/2 .","ref":"Evision.FaceRecognizerSF.html#create!/2","title":"Evision.FaceRecognizerSF.create!/2","type":"function"},{"doc":"Raising version of create/3 .","ref":"Evision.FaceRecognizerSF.html#create!/3","title":"Evision.FaceRecognizerSF.create!/3","type":"function"},{"doc":"Creates an instance of this class with given parameters Positional Arguments model : String . the path of the onnx model used for face recognition config : String . the path to the config file for compability, which is not requested for ONNX models Keyword Arguments backend_id : int . the id of backend target_id : int . the id of target device Python prototype (for reference): create(model, config[, backend_id[, target_id]]) -&gt; retval","ref":"Evision.FaceRecognizerSF.html#create/2","title":"Evision.FaceRecognizerSF.create/2","type":"function"},{"doc":"Creates an instance of this class with given parameters Positional Arguments model : String . the path of the onnx model used for face recognition config : String . the path to the config file for compability, which is not requested for ONNX models Keyword Arguments backend_id : int . the id of backend target_id : int . the id of target device Python prototype (for reference): create(model, config[, backend_id[, target_id]]) -&gt; retval","ref":"Evision.FaceRecognizerSF.html#create/3","title":"Evision.FaceRecognizerSF.create/3","type":"function"},{"doc":"Raising version of feature/2 .","ref":"Evision.FaceRecognizerSF.html#feature!/2","title":"Evision.FaceRecognizerSF.feature!/2","type":"function"},{"doc":"Raising version of feature/3 .","ref":"Evision.FaceRecognizerSF.html#feature!/3","title":"Evision.FaceRecognizerSF.feature!/3","type":"function"},{"doc":"Extracting face feature from aligned image Positional Arguments aligned_img : Evision.Mat . input aligned image Return face_feature : Evision.Mat . output face feature Python prototype (for reference): feature(aligned_img[, face_feature]) -&gt; face_feature","ref":"Evision.FaceRecognizerSF.html#feature/2","title":"Evision.FaceRecognizerSF.feature/2","type":"function"},{"doc":"Extracting face feature from aligned image Positional Arguments aligned_img : Evision.Mat . input aligned image Return face_feature : Evision.Mat . output face feature Python prototype (for reference): feature(aligned_img[, face_feature]) -&gt; face_feature","ref":"Evision.FaceRecognizerSF.html#feature/3","title":"Evision.FaceRecognizerSF.feature/3","type":"function"},{"doc":"Raising version of match/3 .","ref":"Evision.FaceRecognizerSF.html#match!/3","title":"Evision.FaceRecognizerSF.match!/3","type":"function"},{"doc":"Raising version of match/4 .","ref":"Evision.FaceRecognizerSF.html#match!/4","title":"Evision.FaceRecognizerSF.match!/4","type":"function"},{"doc":"Calculating the distance between two face features Positional Arguments face_feature1 : Evision.Mat . the first input feature face_feature2 : Evision.Mat . the second input feature of the same size and the same type as face_feature1 Keyword Arguments dis_type : int . defining the similarity with optional values &quot;FR_OSINE&quot; or &quot;FR_NORM_L2&quot; Python prototype (for reference): match(face_feature1, face_feature2[, dis_type]) -&gt; retval","ref":"Evision.FaceRecognizerSF.html#match/3","title":"Evision.FaceRecognizerSF.match/3","type":"function"},{"doc":"Calculating the distance between two face features Positional Arguments face_feature1 : Evision.Mat . the first input feature face_feature2 : Evision.Mat . the second input feature of the same size and the same type as face_feature1 Keyword Arguments dis_type : int . defining the similarity with optional values &quot;FR_OSINE&quot; or &quot;FR_NORM_L2&quot; Python prototype (for reference): match(face_feature1, face_feature2[, dis_type]) -&gt; retval","ref":"Evision.FaceRecognizerSF.html#match/4","title":"Evision.FaceRecognizerSF.match/4","type":"function"},{"doc":"","ref":"Evision.FarnebackOpticalFlow.html","title":"Evision.FarnebackOpticalFlow","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.FarnebackOpticalFlow.html#create!/0","title":"Evision.FarnebackOpticalFlow.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.FarnebackOpticalFlow.html#create!/1","title":"Evision.FarnebackOpticalFlow.create!/1","type":"function"},{"doc":"##### Keyword Arguments numLevels : int . pyrScale : double . fastPyramids : bool . winSize : int . numIters : int . polyN : int . polySigma : double . flags : int . Python prototype (for reference): create([, numLevels[, pyrScale[, fastPyramids[, winSize[, numIters[, polyN[, polySigma[, flags]]]]]]]]) -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#create/0","title":"Evision.FarnebackOpticalFlow.create/0","type":"function"},{"doc":"##### Keyword Arguments numLevels : int . pyrScale : double . fastPyramids : bool . winSize : int . numIters : int . polyN : int . polySigma : double . flags : int . Python prototype (for reference): create([, numLevels[, pyrScale[, fastPyramids[, winSize[, numIters[, polyN[, polySigma[, flags]]]]]]]]) -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#create/1","title":"Evision.FarnebackOpticalFlow.create/1","type":"function"},{"doc":"Raising version of getFastPyramids/1 .","ref":"Evision.FarnebackOpticalFlow.html#getFastPyramids!/1","title":"Evision.FarnebackOpticalFlow.getFastPyramids!/1","type":"function"},{"doc":"Python prototype (for reference): getFastPyramids() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getFastPyramids/1","title":"Evision.FarnebackOpticalFlow.getFastPyramids/1","type":"function"},{"doc":"Raising version of getFlags/1 .","ref":"Evision.FarnebackOpticalFlow.html#getFlags!/1","title":"Evision.FarnebackOpticalFlow.getFlags!/1","type":"function"},{"doc":"Python prototype (for reference): getFlags() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getFlags/1","title":"Evision.FarnebackOpticalFlow.getFlags/1","type":"function"},{"doc":"Raising version of getNumIters/1 .","ref":"Evision.FarnebackOpticalFlow.html#getNumIters!/1","title":"Evision.FarnebackOpticalFlow.getNumIters!/1","type":"function"},{"doc":"Python prototype (for reference): getNumIters() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getNumIters/1","title":"Evision.FarnebackOpticalFlow.getNumIters/1","type":"function"},{"doc":"Raising version of getNumLevels/1 .","ref":"Evision.FarnebackOpticalFlow.html#getNumLevels!/1","title":"Evision.FarnebackOpticalFlow.getNumLevels!/1","type":"function"},{"doc":"Python prototype (for reference): getNumLevels() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getNumLevels/1","title":"Evision.FarnebackOpticalFlow.getNumLevels/1","type":"function"},{"doc":"Raising version of getPolyN/1 .","ref":"Evision.FarnebackOpticalFlow.html#getPolyN!/1","title":"Evision.FarnebackOpticalFlow.getPolyN!/1","type":"function"},{"doc":"Python prototype (for reference): getPolyN() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getPolyN/1","title":"Evision.FarnebackOpticalFlow.getPolyN/1","type":"function"},{"doc":"Raising version of getPolySigma/1 .","ref":"Evision.FarnebackOpticalFlow.html#getPolySigma!/1","title":"Evision.FarnebackOpticalFlow.getPolySigma!/1","type":"function"},{"doc":"Python prototype (for reference): getPolySigma() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getPolySigma/1","title":"Evision.FarnebackOpticalFlow.getPolySigma/1","type":"function"},{"doc":"Raising version of getPyrScale/1 .","ref":"Evision.FarnebackOpticalFlow.html#getPyrScale!/1","title":"Evision.FarnebackOpticalFlow.getPyrScale!/1","type":"function"},{"doc":"Python prototype (for reference): getPyrScale() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getPyrScale/1","title":"Evision.FarnebackOpticalFlow.getPyrScale/1","type":"function"},{"doc":"Raising version of getWinSize/1 .","ref":"Evision.FarnebackOpticalFlow.html#getWinSize!/1","title":"Evision.FarnebackOpticalFlow.getWinSize!/1","type":"function"},{"doc":"Python prototype (for reference): getWinSize() -&gt; retval","ref":"Evision.FarnebackOpticalFlow.html#getWinSize/1","title":"Evision.FarnebackOpticalFlow.getWinSize/1","type":"function"},{"doc":"Raising version of setFastPyramids/2 .","ref":"Evision.FarnebackOpticalFlow.html#setFastPyramids!/2","title":"Evision.FarnebackOpticalFlow.setFastPyramids!/2","type":"function"},{"doc":"Positional Arguments fastPyramids : bool Python prototype (for reference): setFastPyramids(fastPyramids) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setFastPyramids/2","title":"Evision.FarnebackOpticalFlow.setFastPyramids/2","type":"function"},{"doc":"Raising version of setFlags/2 .","ref":"Evision.FarnebackOpticalFlow.html#setFlags!/2","title":"Evision.FarnebackOpticalFlow.setFlags!/2","type":"function"},{"doc":"Positional Arguments flags : int Python prototype (for reference): setFlags(flags) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setFlags/2","title":"Evision.FarnebackOpticalFlow.setFlags/2","type":"function"},{"doc":"Raising version of setNumIters/2 .","ref":"Evision.FarnebackOpticalFlow.html#setNumIters!/2","title":"Evision.FarnebackOpticalFlow.setNumIters!/2","type":"function"},{"doc":"Positional Arguments numIters : int Python prototype (for reference): setNumIters(numIters) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setNumIters/2","title":"Evision.FarnebackOpticalFlow.setNumIters/2","type":"function"},{"doc":"Raising version of setNumLevels/2 .","ref":"Evision.FarnebackOpticalFlow.html#setNumLevels!/2","title":"Evision.FarnebackOpticalFlow.setNumLevels!/2","type":"function"},{"doc":"Positional Arguments numLevels : int Python prototype (for reference): setNumLevels(numLevels) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setNumLevels/2","title":"Evision.FarnebackOpticalFlow.setNumLevels/2","type":"function"},{"doc":"Raising version of setPolyN/2 .","ref":"Evision.FarnebackOpticalFlow.html#setPolyN!/2","title":"Evision.FarnebackOpticalFlow.setPolyN!/2","type":"function"},{"doc":"Positional Arguments polyN : int Python prototype (for reference): setPolyN(polyN) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setPolyN/2","title":"Evision.FarnebackOpticalFlow.setPolyN/2","type":"function"},{"doc":"Raising version of setPolySigma/2 .","ref":"Evision.FarnebackOpticalFlow.html#setPolySigma!/2","title":"Evision.FarnebackOpticalFlow.setPolySigma!/2","type":"function"},{"doc":"Positional Arguments polySigma : double Python prototype (for reference): setPolySigma(polySigma) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setPolySigma/2","title":"Evision.FarnebackOpticalFlow.setPolySigma/2","type":"function"},{"doc":"Raising version of setPyrScale/2 .","ref":"Evision.FarnebackOpticalFlow.html#setPyrScale!/2","title":"Evision.FarnebackOpticalFlow.setPyrScale!/2","type":"function"},{"doc":"Positional Arguments pyrScale : double Python prototype (for reference): setPyrScale(pyrScale) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setPyrScale/2","title":"Evision.FarnebackOpticalFlow.setPyrScale/2","type":"function"},{"doc":"Raising version of setWinSize/2 .","ref":"Evision.FarnebackOpticalFlow.html#setWinSize!/2","title":"Evision.FarnebackOpticalFlow.setWinSize!/2","type":"function"},{"doc":"Positional Arguments winSize : int Python prototype (for reference): setWinSize(winSize) -&gt; None","ref":"Evision.FarnebackOpticalFlow.html#setWinSize/2","title":"Evision.FarnebackOpticalFlow.setWinSize/2","type":"function"},{"doc":"","ref":"Evision.FastFeatureDetector.html","title":"Evision.FastFeatureDetector","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.FastFeatureDetector.html#compute!/3","title":"Evision.FastFeatureDetector.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.FastFeatureDetector.html#compute!/4","title":"Evision.FastFeatureDetector.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.FastFeatureDetector.html#compute/3","title":"Evision.FastFeatureDetector.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.FastFeatureDetector.html#compute/4","title":"Evision.FastFeatureDetector.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.FastFeatureDetector.html#create!/0","title":"Evision.FastFeatureDetector.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.FastFeatureDetector.html#create!/1","title":"Evision.FastFeatureDetector.create!/1","type":"function"},{"doc":"##### Keyword Arguments threshold : int . nonmaxSuppression : bool . type : FastFeatureDetector_DetectorType . Python prototype (for reference): create([, threshold[, nonmaxSuppression[, type]]]) -&gt; retval","ref":"Evision.FastFeatureDetector.html#create/0","title":"Evision.FastFeatureDetector.create/0","type":"function"},{"doc":"##### Keyword Arguments threshold : int . nonmaxSuppression : bool . type : FastFeatureDetector_DetectorType . Python prototype (for reference): create([, threshold[, nonmaxSuppression[, type]]]) -&gt; retval","ref":"Evision.FastFeatureDetector.html#create/1","title":"Evision.FastFeatureDetector.create/1","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.FastFeatureDetector.html#defaultNorm!/1","title":"Evision.FastFeatureDetector.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.FastFeatureDetector.html#defaultNorm/1","title":"Evision.FastFeatureDetector.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.FastFeatureDetector.html#descriptorSize!/1","title":"Evision.FastFeatureDetector.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.FastFeatureDetector.html#descriptorSize/1","title":"Evision.FastFeatureDetector.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.FastFeatureDetector.html#descriptorType!/1","title":"Evision.FastFeatureDetector.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.FastFeatureDetector.html#descriptorType/1","title":"Evision.FastFeatureDetector.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.FastFeatureDetector.html#detect!/2","title":"Evision.FastFeatureDetector.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.FastFeatureDetector.html#detect!/3","title":"Evision.FastFeatureDetector.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.FastFeatureDetector.html#detect/2","title":"Evision.FastFeatureDetector.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.FastFeatureDetector.html#detect/3","title":"Evision.FastFeatureDetector.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.FastFeatureDetector.html#detectAndCompute!/3","title":"Evision.FastFeatureDetector.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.FastFeatureDetector.html#detectAndCompute!/4","title":"Evision.FastFeatureDetector.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.FastFeatureDetector.html#detectAndCompute/3","title":"Evision.FastFeatureDetector.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.FastFeatureDetector.html#detectAndCompute/4","title":"Evision.FastFeatureDetector.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.FastFeatureDetector.html#empty!/1","title":"Evision.FastFeatureDetector.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.FastFeatureDetector.html#empty/1","title":"Evision.FastFeatureDetector.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.FastFeatureDetector.html#getDefaultName!/1","title":"Evision.FastFeatureDetector.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.FastFeatureDetector.html#getDefaultName/1","title":"Evision.FastFeatureDetector.getDefaultName/1","type":"function"},{"doc":"Raising version of getNonmaxSuppression/1 .","ref":"Evision.FastFeatureDetector.html#getNonmaxSuppression!/1","title":"Evision.FastFeatureDetector.getNonmaxSuppression!/1","type":"function"},{"doc":"Python prototype (for reference): getNonmaxSuppression() -&gt; retval","ref":"Evision.FastFeatureDetector.html#getNonmaxSuppression/1","title":"Evision.FastFeatureDetector.getNonmaxSuppression/1","type":"function"},{"doc":"Raising version of getThreshold/1 .","ref":"Evision.FastFeatureDetector.html#getThreshold!/1","title":"Evision.FastFeatureDetector.getThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getThreshold() -&gt; retval","ref":"Evision.FastFeatureDetector.html#getThreshold/1","title":"Evision.FastFeatureDetector.getThreshold/1","type":"function"},{"doc":"Raising version of getType/1 .","ref":"Evision.FastFeatureDetector.html#getType!/1","title":"Evision.FastFeatureDetector.getType!/1","type":"function"},{"doc":"Python prototype (for reference): getType() -&gt; retval","ref":"Evision.FastFeatureDetector.html#getType/1","title":"Evision.FastFeatureDetector.getType/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.FastFeatureDetector.html#read!/2","title":"Evision.FastFeatureDetector.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.FastFeatureDetector.html#read/2","title":"Evision.FastFeatureDetector.read/2","type":"function"},{"doc":"Raising version of setNonmaxSuppression/2 .","ref":"Evision.FastFeatureDetector.html#setNonmaxSuppression!/2","title":"Evision.FastFeatureDetector.setNonmaxSuppression!/2","type":"function"},{"doc":"Positional Arguments f : bool Python prototype (for reference): setNonmaxSuppression(f) -&gt; None","ref":"Evision.FastFeatureDetector.html#setNonmaxSuppression/2","title":"Evision.FastFeatureDetector.setNonmaxSuppression/2","type":"function"},{"doc":"Raising version of setThreshold/2 .","ref":"Evision.FastFeatureDetector.html#setThreshold!/2","title":"Evision.FastFeatureDetector.setThreshold!/2","type":"function"},{"doc":"Positional Arguments threshold : int Python prototype (for reference): setThreshold(threshold) -&gt; None","ref":"Evision.FastFeatureDetector.html#setThreshold/2","title":"Evision.FastFeatureDetector.setThreshold/2","type":"function"},{"doc":"Raising version of setType/2 .","ref":"Evision.FastFeatureDetector.html#setType!/2","title":"Evision.FastFeatureDetector.setType!/2","type":"function"},{"doc":"Positional Arguments type : FastFeatureDetector_DetectorType Python prototype (for reference): setType(type) -&gt; None","ref":"Evision.FastFeatureDetector.html#setType/2","title":"Evision.FastFeatureDetector.setType/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.FastFeatureDetector.html#write!/2","title":"Evision.FastFeatureDetector.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.FastFeatureDetector.html#write!/3","title":"Evision.FastFeatureDetector.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.FastFeatureDetector.html#write/2","title":"Evision.FastFeatureDetector.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.FastFeatureDetector.html#write/3","title":"Evision.FastFeatureDetector.write/3","type":"function"},{"doc":"","ref":"Evision.Feature2D.html","title":"Evision.Feature2D","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.Feature2D.html#compute!/3","title":"Evision.Feature2D.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.Feature2D.html#compute!/4","title":"Evision.Feature2D.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.Feature2D.html#compute/3","title":"Evision.Feature2D.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.Feature2D.html#compute/4","title":"Evision.Feature2D.compute/4","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.Feature2D.html#defaultNorm!/1","title":"Evision.Feature2D.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.Feature2D.html#defaultNorm/1","title":"Evision.Feature2D.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.Feature2D.html#descriptorSize!/1","title":"Evision.Feature2D.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.Feature2D.html#descriptorSize/1","title":"Evision.Feature2D.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.Feature2D.html#descriptorType!/1","title":"Evision.Feature2D.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.Feature2D.html#descriptorType/1","title":"Evision.Feature2D.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.Feature2D.html#detect!/2","title":"Evision.Feature2D.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.Feature2D.html#detect!/3","title":"Evision.Feature2D.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.Feature2D.html#detect/2","title":"Evision.Feature2D.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.Feature2D.html#detect/3","title":"Evision.Feature2D.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.Feature2D.html#detectAndCompute!/3","title":"Evision.Feature2D.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.Feature2D.html#detectAndCompute!/4","title":"Evision.Feature2D.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.Feature2D.html#detectAndCompute/3","title":"Evision.Feature2D.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.Feature2D.html#detectAndCompute/4","title":"Evision.Feature2D.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.Feature2D.html#empty!/1","title":"Evision.Feature2D.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.Feature2D.html#empty/1","title":"Evision.Feature2D.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.Feature2D.html#getDefaultName!/1","title":"Evision.Feature2D.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.Feature2D.html#getDefaultName/1","title":"Evision.Feature2D.getDefaultName/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.Feature2D.html#read!/2","title":"Evision.Feature2D.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.Feature2D.html#read/2","title":"Evision.Feature2D.read/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.Feature2D.html#write!/2","title":"Evision.Feature2D.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.Feature2D.html#write!/3","title":"Evision.Feature2D.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.Feature2D.html#write/2","title":"Evision.Feature2D.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.Feature2D.html#write/3","title":"Evision.Feature2D.write/3","type":"function"},{"doc":"","ref":"Evision.FileNode.html","title":"Evision.FileNode","type":"module"},{"doc":"Raising version of at/2 .","ref":"Evision.FileNode.html#at!/2","title":"Evision.FileNode.at!/2","type":"function"},{"doc":"Positional Arguments i : int . Index of an element in the sequence node. Has overloading in C++ Python prototype (for reference): at(i) -&gt; retval","ref":"Evision.FileNode.html#at/2","title":"Evision.FileNode.at/2","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.FileNode.html#empty!/1","title":"Evision.FileNode.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.FileNode.html#empty/1","title":"Evision.FileNode.empty/1","type":"function"},{"doc":"Raising version of fileNode/0 .","ref":"Evision.FileNode.html#fileNode!/0","title":"Evision.FileNode.fileNode!/0","type":"function"},{"doc":"The constructors. These constructors are used to create a default file node, construct it from obsolete structures or from the another file node. Python prototype (for reference): FileNode() -&gt; &lt;FileNode object&gt;","ref":"Evision.FileNode.html#fileNode/0","title":"Evision.FileNode.fileNode/0","type":"function"},{"doc":"Raising version of getNode/2 .","ref":"Evision.FileNode.html#getNode!/2","title":"Evision.FileNode.getNode!/2","type":"function"},{"doc":"Positional Arguments nodename : c_string . Name of an element in the mapping node. Has overloading in C++ Python prototype (for reference): getNode(nodename) -&gt; retval","ref":"Evision.FileNode.html#getNode/2","title":"Evision.FileNode.getNode/2","type":"function"},{"doc":"Raising version of isInt/1 .","ref":"Evision.FileNode.html#isInt!/1","title":"Evision.FileNode.isInt!/1","type":"function"},{"doc":"Python prototype (for reference): isInt() -&gt; retval","ref":"Evision.FileNode.html#isInt/1","title":"Evision.FileNode.isInt/1","type":"function"},{"doc":"Raising version of isMap/1 .","ref":"Evision.FileNode.html#isMap!/1","title":"Evision.FileNode.isMap!/1","type":"function"},{"doc":"Python prototype (for reference): isMap() -&gt; retval","ref":"Evision.FileNode.html#isMap/1","title":"Evision.FileNode.isMap/1","type":"function"},{"doc":"Raising version of isNamed/1 .","ref":"Evision.FileNode.html#isNamed!/1","title":"Evision.FileNode.isNamed!/1","type":"function"},{"doc":"Python prototype (for reference): isNamed() -&gt; retval","ref":"Evision.FileNode.html#isNamed/1","title":"Evision.FileNode.isNamed/1","type":"function"},{"doc":"Raising version of isNone/1 .","ref":"Evision.FileNode.html#isNone!/1","title":"Evision.FileNode.isNone!/1","type":"function"},{"doc":"Python prototype (for reference): isNone() -&gt; retval","ref":"Evision.FileNode.html#isNone/1","title":"Evision.FileNode.isNone/1","type":"function"},{"doc":"Raising version of isReal/1 .","ref":"Evision.FileNode.html#isReal!/1","title":"Evision.FileNode.isReal!/1","type":"function"},{"doc":"Python prototype (for reference): isReal() -&gt; retval","ref":"Evision.FileNode.html#isReal/1","title":"Evision.FileNode.isReal/1","type":"function"},{"doc":"Raising version of isSeq/1 .","ref":"Evision.FileNode.html#isSeq!/1","title":"Evision.FileNode.isSeq!/1","type":"function"},{"doc":"Python prototype (for reference): isSeq() -&gt; retval","ref":"Evision.FileNode.html#isSeq/1","title":"Evision.FileNode.isSeq/1","type":"function"},{"doc":"Raising version of isString/1 .","ref":"Evision.FileNode.html#isString!/1","title":"Evision.FileNode.isString!/1","type":"function"},{"doc":"Python prototype (for reference): isString() -&gt; retval","ref":"Evision.FileNode.html#isString/1","title":"Evision.FileNode.isString/1","type":"function"},{"doc":"Raising version of keys/1 .","ref":"Evision.FileNode.html#keys!/1","title":"Evision.FileNode.keys!/1","type":"function"},{"doc":"Returns keys of a mapping node. @returns Keys of a mapping node. Python prototype (for reference): keys() -&gt; retval","ref":"Evision.FileNode.html#keys/1","title":"Evision.FileNode.keys/1","type":"function"},{"doc":"Raising version of mat/1 .","ref":"Evision.FileNode.html#mat!/1","title":"Evision.FileNode.mat!/1","type":"function"},{"doc":"Python prototype (for reference): mat() -&gt; retval","ref":"Evision.FileNode.html#mat/1","title":"Evision.FileNode.mat/1","type":"function"},{"doc":"Raising version of name/1 .","ref":"Evision.FileNode.html#name!/1","title":"Evision.FileNode.name!/1","type":"function"},{"doc":"Python prototype (for reference): name() -&gt; retval","ref":"Evision.FileNode.html#name/1","title":"Evision.FileNode.name/1","type":"function"},{"doc":"Raising version of rawSize/1 .","ref":"Evision.FileNode.html#rawSize!/1","title":"Evision.FileNode.rawSize!/1","type":"function"},{"doc":"Python prototype (for reference): rawSize() -&gt; retval","ref":"Evision.FileNode.html#rawSize/1","title":"Evision.FileNode.rawSize/1","type":"function"},{"doc":"Raising version of real/1 .","ref":"Evision.FileNode.html#real!/1","title":"Evision.FileNode.real!/1","type":"function"},{"doc":"Internal method used when reading FileStorage. Sets the type (int, real or string) and value of the previously created node. Python prototype (for reference): real() -&gt; retval","ref":"Evision.FileNode.html#real/1","title":"Evision.FileNode.real/1","type":"function"},{"doc":"Raising version of size/1 .","ref":"Evision.FileNode.html#size!/1","title":"Evision.FileNode.size!/1","type":"function"},{"doc":"Python prototype (for reference): size() -&gt; retval","ref":"Evision.FileNode.html#size/1","title":"Evision.FileNode.size/1","type":"function"},{"doc":"Raising version of string/1 .","ref":"Evision.FileNode.html#string!/1","title":"Evision.FileNode.string!/1","type":"function"},{"doc":"Python prototype (for reference): string() -&gt; retval","ref":"Evision.FileNode.html#string/1","title":"Evision.FileNode.string/1","type":"function"},{"doc":"Raising version of type/1 .","ref":"Evision.FileNode.html#type!/1","title":"Evision.FileNode.type!/1","type":"function"},{"doc":"Returns type of the node. @returns Type of the node. See FileNode::Type Python prototype (for reference): type() -&gt; retval","ref":"Evision.FileNode.html#type/1","title":"Evision.FileNode.type/1","type":"function"},{"doc":"","ref":"Evision.FileStorage.html","title":"Evision.FileStorage","type":"module"},{"doc":"Raising version of endWriteStruct/1 .","ref":"Evision.FileStorage.html#endWriteStruct!/1","title":"Evision.FileStorage.endWriteStruct!/1","type":"function"},{"doc":"Finishes writing nested structure (should pair startWriteStruct()) Python prototype (for reference): endWriteStruct() -&gt; None","ref":"Evision.FileStorage.html#endWriteStruct/1","title":"Evision.FileStorage.endWriteStruct/1","type":"function"},{"doc":"Raising version of fileStorage/0 .","ref":"Evision.FileStorage.html#fileStorage!/0","title":"Evision.FileStorage.fileStorage!/0","type":"function"},{"doc":"Raising version of fileStorage/2 .","ref":"Evision.FileStorage.html#fileStorage!/2","title":"Evision.FileStorage.fileStorage!/2","type":"function"},{"doc":"Raising version of fileStorage/3 .","ref":"Evision.FileStorage.html#fileStorage!/3","title":"Evision.FileStorage.fileStorage!/3","type":"function"},{"doc":"The constructors. The full constructor opens the file. Alternatively you can use the default constructor and then call FileStorage::open. Python prototype (for reference): FileStorage() -&gt; &lt;FileStorage object&gt;","ref":"Evision.FileStorage.html#fileStorage/0","title":"Evision.FileStorage.fileStorage/0","type":"function"},{"doc":"Positional Arguments filename : String flags : int Keyword Arguments encoding : String . Has overloading in C++ @copydoc open() Python prototype (for reference): FileStorage(filename, flags[, encoding]) -&gt; &lt;FileStorage object&gt;","ref":"Evision.FileStorage.html#fileStorage/2","title":"Evision.FileStorage.fileStorage/2","type":"function"},{"doc":"Positional Arguments filename : String flags : int Keyword Arguments encoding : String . Has overloading in C++ @copydoc open() Python prototype (for reference): FileStorage(filename, flags[, encoding]) -&gt; &lt;FileStorage object&gt;","ref":"Evision.FileStorage.html#fileStorage/3","title":"Evision.FileStorage.fileStorage/3","type":"function"},{"doc":"Raising version of getFirstTopLevelNode/1 .","ref":"Evision.FileStorage.html#getFirstTopLevelNode!/1","title":"Evision.FileStorage.getFirstTopLevelNode!/1","type":"function"},{"doc":"Returns the first element of the top-level mapping. @returns The first element of the top-level mapping. Python prototype (for reference): getFirstTopLevelNode() -&gt; retval","ref":"Evision.FileStorage.html#getFirstTopLevelNode/1","title":"Evision.FileStorage.getFirstTopLevelNode/1","type":"function"},{"doc":"Raising version of getFormat/1 .","ref":"Evision.FileStorage.html#getFormat!/1","title":"Evision.FileStorage.getFormat!/1","type":"function"},{"doc":"Returns the current format. @returns The current format, see FileStorage::Mode Python prototype (for reference): getFormat() -&gt; retval","ref":"Evision.FileStorage.html#getFormat/1","title":"Evision.FileStorage.getFormat/1","type":"function"},{"doc":"Raising version of getNode/2 .","ref":"Evision.FileStorage.html#getNode!/2","title":"Evision.FileStorage.getNode!/2","type":"function"},{"doc":"Positional Arguments nodename : c_string Has overloading in C++ Python prototype (for reference): getNode(nodename) -&gt; retval","ref":"Evision.FileStorage.html#getNode/2","title":"Evision.FileStorage.getNode/2","type":"function"},{"doc":"Raising version of isOpened/1 .","ref":"Evision.FileStorage.html#isOpened!/1","title":"Evision.FileStorage.isOpened!/1","type":"function"},{"doc":"Checks whether the file is opened. @returns true if the object is associated with the current file and false otherwise. It is a good practice to call this method after you tried to open a file. Python prototype (for reference): isOpened() -&gt; retval","ref":"Evision.FileStorage.html#isOpened/1","title":"Evision.FileStorage.isOpened/1","type":"function"},{"doc":"Raising version of open/3 .","ref":"Evision.FileStorage.html#open!/3","title":"Evision.FileStorage.open!/3","type":"function"},{"doc":"Raising version of open/4 .","ref":"Evision.FileStorage.html#open!/4","title":"Evision.FileStorage.open!/4","type":"function"},{"doc":"Opens a file. Positional Arguments filename : String . Name of the file to open or the text string to read the data from. Extension of the file (.xml, .yml/.yaml or .json) determines its format (XML, YAML or JSON respectively). Also you can append .gz to work with compressed files, for example myHugeMatrix.xml.gz. If both FileStorage::WRITE and FileStorage::MEMORY flags are specified, source is used just to specify the output file format (e.g. mydata.xml, .yml etc.). A file name can also contain parameters. You can use this format, &quot;*?base64&quot; (e.g. &quot;file.json?base64&quot; (case sensitive)), as an alternative to FileStorage::BASE64 flag. flags : int . Mode of operation. One of FileStorage::Mode Keyword Arguments encoding : String . Encoding of the file. Note that UTF-16 XML encoding is not supported currently and you should use 8-bit encoding instead of it. See description of parameters in FileStorage::FileStorage. The method calls FileStorage::release before opening the file. Python prototype (for reference): open(filename, flags[, encoding]) -&gt; retval","ref":"Evision.FileStorage.html#open/3","title":"Evision.FileStorage.open/3","type":"function"},{"doc":"Opens a file. Positional Arguments filename : String . Name of the file to open or the text string to read the data from. Extension of the file (.xml, .yml/.yaml or .json) determines its format (XML, YAML or JSON respectively). Also you can append .gz to work with compressed files, for example myHugeMatrix.xml.gz. If both FileStorage::WRITE and FileStorage::MEMORY flags are specified, source is used just to specify the output file format (e.g. mydata.xml, .yml etc.). A file name can also contain parameters. You can use this format, &quot;*?base64&quot; (e.g. &quot;file.json?base64&quot; (case sensitive)), as an alternative to FileStorage::BASE64 flag. flags : int . Mode of operation. One of FileStorage::Mode Keyword Arguments encoding : String . Encoding of the file. Note that UTF-16 XML encoding is not supported currently and you should use 8-bit encoding instead of it. See description of parameters in FileStorage::FileStorage. The method calls FileStorage::release before opening the file. Python prototype (for reference): open(filename, flags[, encoding]) -&gt; retval","ref":"Evision.FileStorage.html#open/4","title":"Evision.FileStorage.open/4","type":"function"},{"doc":"Raising version of release/1 .","ref":"Evision.FileStorage.html#release!/1","title":"Evision.FileStorage.release!/1","type":"function"},{"doc":"Closes the file and releases all the memory buffers. Call this method after all I/O operations with the storage are finished. Python prototype (for reference): release() -&gt; None","ref":"Evision.FileStorage.html#release/1","title":"Evision.FileStorage.release/1","type":"function"},{"doc":"Raising version of releaseAndGetString/1 .","ref":"Evision.FileStorage.html#releaseAndGetString!/1","title":"Evision.FileStorage.releaseAndGetString!/1","type":"function"},{"doc":"Closes the file and releases all the memory buffers. Call this method after all I/O operations with the storage are finished. If the storage was opened for writing data and FileStorage::WRITE was specified Python prototype (for reference): releaseAndGetString() -&gt; retval","ref":"Evision.FileStorage.html#releaseAndGetString/1","title":"Evision.FileStorage.releaseAndGetString/1","type":"function"},{"doc":"Raising version of root/1 .","ref":"Evision.FileStorage.html#root!/1","title":"Evision.FileStorage.root!/1","type":"function"},{"doc":"Returns the top-level mapping Keyword Arguments streamidx : int . Zero-based index of the stream. In most cases there is only one stream in the file. However, YAML supports multiple streams and so there can be several. @returns The top-level mapping. Python prototype (for reference): root([, streamidx]) -&gt; retval","ref":"Evision.FileStorage.html#root/1","title":"Evision.FileStorage.root/1","type":"function"},{"doc":"Raising version of startWriteStruct/3 .","ref":"Evision.FileStorage.html#startWriteStruct!/3","title":"Evision.FileStorage.startWriteStruct!/3","type":"function"},{"doc":"Raising version of startWriteStruct/4 .","ref":"Evision.FileStorage.html#startWriteStruct!/4","title":"Evision.FileStorage.startWriteStruct!/4","type":"function"},{"doc":"Starts to write a nested structure (sequence or a mapping). Positional Arguments name : String . name of the structure. When writing to sequences (a.k.a. &quot;arrays&quot;), pass an empty string. flags : int . type of the structure (FileNode::MAP or FileNode::SEQ (both with optional FileNode::FLOW)). Keyword Arguments typeName : String . optional name of the type you store. The effect of setting this depends on the storage format. I.e. if the format has a specification for storing type information, this parameter is used. Python prototype (for reference): startWriteStruct(name, flags[, typeName]) -&gt; None","ref":"Evision.FileStorage.html#startWriteStruct/3","title":"Evision.FileStorage.startWriteStruct/3","type":"function"},{"doc":"Starts to write a nested structure (sequence or a mapping). Positional Arguments name : String . name of the structure. When writing to sequences (a.k.a. &quot;arrays&quot;), pass an empty string. flags : int . type of the structure (FileNode::MAP or FileNode::SEQ (both with optional FileNode::FLOW)). Keyword Arguments typeName : String . optional name of the type you store. The effect of setting this depends on the storage format. I.e. if the format has a specification for storing type information, this parameter is used. Python prototype (for reference): startWriteStruct(name, flags[, typeName]) -&gt; None","ref":"Evision.FileStorage.html#startWriteStruct/4","title":"Evision.FileStorage.startWriteStruct/4","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.FileStorage.html#write!/3","title":"Evision.FileStorage.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments name : String val : [String] Python prototype (for reference): write(name, val) -&gt; None Variant 2: Positional Arguments name : String val : Evision.Mat Python prototype (for reference): write(name, val) -&gt; None Variant 3: Positional Arguments name : String val : String Python prototype (for reference): write(name, val) -&gt; None Variant 4: Positional Arguments name : String val : double Python prototype (for reference): write(name, val) -&gt; None Variant 5: Simplified writing API to use with bindings. Positional Arguments name : String . Name of the written object. When writing to sequences (a.k.a. &quot;arrays&quot;), pass an empty string. val : int . Value of the written object. Python prototype (for reference): write(name, val) -&gt; None","ref":"Evision.FileStorage.html#write/3","title":"Evision.FileStorage.write/3","type":"function"},{"doc":"Raising version of writeComment/2 .","ref":"Evision.FileStorage.html#writeComment!/2","title":"Evision.FileStorage.writeComment!/2","type":"function"},{"doc":"Raising version of writeComment/3 .","ref":"Evision.FileStorage.html#writeComment!/3","title":"Evision.FileStorage.writeComment!/3","type":"function"},{"doc":"Writes a comment. Positional Arguments comment : String . The written comment, single-line or multi-line Keyword Arguments append : bool . If true, the function tries to put the comment at the end of current line. Else if the comment is multi-line, or if it does not fit at the end of the current line, the comment starts a new line. The function writes a comment into file storage. The comments are skipped when the storage is read. Python prototype (for reference): writeComment(comment[, append]) -&gt; None","ref":"Evision.FileStorage.html#writeComment/2","title":"Evision.FileStorage.writeComment/2","type":"function"},{"doc":"Writes a comment. Positional Arguments comment : String . The written comment, single-line or multi-line Keyword Arguments append : bool . If true, the function tries to put the comment at the end of current line. Else if the comment is multi-line, or if it does not fit at the end of the current line, the comment starts a new line. The function writes a comment into file storage. The comments are skipped when the storage is read. Python prototype (for reference): writeComment(comment[, append]) -&gt; None","ref":"Evision.FileStorage.html#writeComment/3","title":"Evision.FileStorage.writeComment/3","type":"function"},{"doc":"","ref":"Evision.FishEye.html","title":"Evision.FishEye","type":"module"},{"doc":"Raising version of calibrate/5 .","ref":"Evision.FishEye.html#calibrate!/5","title":"Evision.FishEye.calibrate!/5","type":"function"},{"doc":"Raising version of calibrate/6 .","ref":"Evision.FishEye.html#calibrate!/6","title":"Evision.FishEye.calibrate!/6","type":"function"},{"doc":"Performs camera calibration Positional Arguments objectPoints : [Evision.Mat] . vector of vectors of calibration pattern points in the calibration pattern coordinate space. imagePoints : [Evision.Mat] . vector of vectors of the projections of calibration pattern points. imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to objectPoints[i].size() for each i. image_size : Size . Size of the image used only to initialize the camera intrinsic matrix. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref fisheye::CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center ( imageSize is used), and focal distances are computed in a least-squares fashion. @ref fisheye::CALIB_RECOMPUTE_EXTRINSIC Extrinsic will be recomputed after each iteration of intrinsic optimization. @ref fisheye::CALIB_CHECK_COND The functions will check validity of condition number. @ref fisheye::CALIB_FIX_SKEW Skew coefficient (alpha) is set to zero and stay zero. @ref fisheye::CALIB_FIX_K1,..., @ref fisheye::CALIB_FIX_K4 Selected distortion coefficients are set to zeros and stay zero. @ref fisheye::CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global optimization. It stays at the center or at a different location specified when @ref fisheye::CALIB_USE_INTRINSIC_GUESS is set too. @ref fisheye::CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global optimization. It is the \\f$max(width,height)/\\pi\\f$ or the provided \\f$f_x\\f$, \\f$f_y\\f$ when @ref fisheye::CALIB_USE_INTRINSIC_GUESS is set too. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return k : Evision.Mat . Output 3x3 floating-point camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . If d : Evision.Mat . Output vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. rvecs : [Evision.Mat] . Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view. That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-th pattern view (k=0.. M -1). tvecs : [Evision.Mat] . Output vector of translation vectors estimated for each pattern view. @ref fisheye::CALIB_USE_INTRINSIC_GUESS is specified, some or all of fx, fy, cx, cy must be initialized before calling the function. Python prototype (for reference): calibrate(objectPoints, imagePoints, image_size, K, D[, rvecs[, tvecs[, flags[, criteria]]]]) -&gt; retval, K, D, rvecs, tvecs","ref":"Evision.FishEye.html#calibrate/5","title":"Evision.FishEye.calibrate/5","type":"function"},{"doc":"Performs camera calibration Positional Arguments objectPoints : [Evision.Mat] . vector of vectors of calibration pattern points in the calibration pattern coordinate space. imagePoints : [Evision.Mat] . vector of vectors of the projections of calibration pattern points. imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to objectPoints[i].size() for each i. image_size : Size . Size of the image used only to initialize the camera intrinsic matrix. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref fisheye::CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center ( imageSize is used), and focal distances are computed in a least-squares fashion. @ref fisheye::CALIB_RECOMPUTE_EXTRINSIC Extrinsic will be recomputed after each iteration of intrinsic optimization. @ref fisheye::CALIB_CHECK_COND The functions will check validity of condition number. @ref fisheye::CALIB_FIX_SKEW Skew coefficient (alpha) is set to zero and stay zero. @ref fisheye::CALIB_FIX_K1,..., @ref fisheye::CALIB_FIX_K4 Selected distortion coefficients are set to zeros and stay zero. @ref fisheye::CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global optimization. It stays at the center or at a different location specified when @ref fisheye::CALIB_USE_INTRINSIC_GUESS is set too. @ref fisheye::CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global optimization. It is the \\f$max(width,height)/\\pi\\f$ or the provided \\f$f_x\\f$, \\f$f_y\\f$ when @ref fisheye::CALIB_USE_INTRINSIC_GUESS is set too. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return k : Evision.Mat . Output 3x3 floating-point camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ . If d : Evision.Mat . Output vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. rvecs : [Evision.Mat] . Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view. That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-th pattern view (k=0.. M -1). tvecs : [Evision.Mat] . Output vector of translation vectors estimated for each pattern view. @ref fisheye::CALIB_USE_INTRINSIC_GUESS is specified, some or all of fx, fy, cx, cy must be initialized before calling the function. Python prototype (for reference): calibrate(objectPoints, imagePoints, image_size, K, D[, rvecs[, tvecs[, flags[, criteria]]]]) -&gt; retval, K, D, rvecs, tvecs","ref":"Evision.FishEye.html#calibrate/6","title":"Evision.FishEye.calibrate/6","type":"function"},{"doc":"Raising version of distortPoints/3 .","ref":"Evision.FishEye.html#distortPoints!/3","title":"Evision.FishEye.distortPoints!/3","type":"function"},{"doc":"Raising version of distortPoints/4 .","ref":"Evision.FishEye.html#distortPoints!/4","title":"Evision.FishEye.distortPoints!/4","type":"function"},{"doc":"Distorts 2D points using fisheye model. Positional Arguments undistorted : Evision.Mat . Array of object points, 1xN/Nx1 2-channel (or vector\\&lt;Point2f&gt; ), where N is the number of points in the view. k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. Keyword Arguments alpha : double . The skew coefficient. Return distorted : Evision.Mat . Output array of image points, 1xN/Nx1 2-channel, or vector\\&lt;Point2f&gt; . Note that the function assumes the camera intrinsic matrix of the undistorted points to be identity. This means if you want to distort image points you have to multiply them with \\f$K^{-1}\\f$. Python prototype (for reference): distortPoints(undistorted, K, D[, distorted[, alpha]]) -&gt; distorted","ref":"Evision.FishEye.html#distortPoints/3","title":"Evision.FishEye.distortPoints/3","type":"function"},{"doc":"Distorts 2D points using fisheye model. Positional Arguments undistorted : Evision.Mat . Array of object points, 1xN/Nx1 2-channel (or vector\\&lt;Point2f&gt; ), where N is the number of points in the view. k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. Keyword Arguments alpha : double . The skew coefficient. Return distorted : Evision.Mat . Output array of image points, 1xN/Nx1 2-channel, or vector\\&lt;Point2f&gt; . Note that the function assumes the camera intrinsic matrix of the undistorted points to be identity. This means if you want to distort image points you have to multiply them with \\f$K^{-1}\\f$. Python prototype (for reference): distortPoints(undistorted, K, D[, distorted[, alpha]]) -&gt; distorted","ref":"Evision.FishEye.html#distortPoints/4","title":"Evision.FishEye.distortPoints/4","type":"function"},{"doc":"Raising version of estimateNewCameraMatrixForUndistortRectify/4 .","ref":"Evision.FishEye.html#estimateNewCameraMatrixForUndistortRectify!/4","title":"Evision.FishEye.estimateNewCameraMatrixForUndistortRectify!/4","type":"function"},{"doc":"Raising version of estimateNewCameraMatrixForUndistortRectify/5 .","ref":"Evision.FishEye.html#estimateNewCameraMatrixForUndistortRectify!/5","title":"Evision.FishEye.estimateNewCameraMatrixForUndistortRectify!/5","type":"function"},{"doc":"Estimates new camera intrinsic matrix for undistortion or rectification. Positional Arguments k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. image_size : Size . Size of the image r : Evision.Mat . Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel Keyword Arguments balance : double . Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1]. new_size : Size . the new size fov_scale : double . Divisor for new focal length. Return p : Evision.Mat . New camera intrinsic matrix (3x3) or new projection matrix (3x4) Python prototype (for reference): estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R[, P[, balance[, new_size[, fov_scale]]]]) -&gt; P","ref":"Evision.FishEye.html#estimateNewCameraMatrixForUndistortRectify/4","title":"Evision.FishEye.estimateNewCameraMatrixForUndistortRectify/4","type":"function"},{"doc":"Estimates new camera intrinsic matrix for undistortion or rectification. Positional Arguments k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. image_size : Size . Size of the image r : Evision.Mat . Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel Keyword Arguments balance : double . Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1]. new_size : Size . the new size fov_scale : double . Divisor for new focal length. Return p : Evision.Mat . New camera intrinsic matrix (3x3) or new projection matrix (3x4) Python prototype (for reference): estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R[, P[, balance[, new_size[, fov_scale]]]]) -&gt; P","ref":"Evision.FishEye.html#estimateNewCameraMatrixForUndistortRectify/5","title":"Evision.FishEye.estimateNewCameraMatrixForUndistortRectify/5","type":"function"},{"doc":"Raising version of initUndistortRectifyMap/6 .","ref":"Evision.FishEye.html#initUndistortRectifyMap!/6","title":"Evision.FishEye.initUndistortRectifyMap!/6","type":"function"},{"doc":"Raising version of initUndistortRectifyMap/7 .","ref":"Evision.FishEye.html#initUndistortRectifyMap!/7","title":"Evision.FishEye.initUndistortRectifyMap!/7","type":"function"},{"doc":"Computes undistortion and rectification maps for image transform by #remap. If D is empty zero distortion is used, if R or P is empty identity matrixes are used. Positional Arguments k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. r : Evision.Mat . Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel p : Evision.Mat . New camera intrinsic matrix (3x3) or new projection matrix (3x4) size : Size . Undistorted image size. m1type : int . Type of the first output map that can be CV_32FC1 or CV_16SC2 . See #convertMaps for details. Return map1 : Evision.Mat . The first output map. map2 : Evision.Mat . The second output map. Python prototype (for reference): initUndistortRectifyMap(K, D, R, P, size, m1type[, map1[, map2]]) -&gt; map1, map2","ref":"Evision.FishEye.html#initUndistortRectifyMap/6","title":"Evision.FishEye.initUndistortRectifyMap/6","type":"function"},{"doc":"Computes undistortion and rectification maps for image transform by #remap. If D is empty zero distortion is used, if R or P is empty identity matrixes are used. Positional Arguments k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. r : Evision.Mat . Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel p : Evision.Mat . New camera intrinsic matrix (3x3) or new projection matrix (3x4) size : Size . Undistorted image size. m1type : int . Type of the first output map that can be CV_32FC1 or CV_16SC2 . See #convertMaps for details. Return map1 : Evision.Mat . The first output map. map2 : Evision.Mat . The second output map. Python prototype (for reference): initUndistortRectifyMap(K, D, R, P, size, m1type[, map1[, map2]]) -&gt; map1, map2","ref":"Evision.FishEye.html#initUndistortRectifyMap/7","title":"Evision.FishEye.initUndistortRectifyMap/7","type":"function"},{"doc":"Raising version of projectPoints/5 .","ref":"Evision.FishEye.html#projectPoints!/5","title":"Evision.FishEye.projectPoints!/5","type":"function"},{"doc":"Raising version of projectPoints/6 .","ref":"Evision.FishEye.html#projectPoints!/6","title":"Evision.FishEye.projectPoints!/6","type":"function"},{"doc":"Positional Arguments objectPoints : Evision.Mat rvec : Evision.Mat tvec : Evision.Mat k : Evision.Mat d : Evision.Mat Keyword Arguments alpha : double . Return imagePoints : Evision.Mat . jacobian : Evision.Mat . Has overloading in C++ Python prototype (for reference): projectPoints(objectPoints, rvec, tvec, K, D[, imagePoints[, alpha[, jacobian]]]) -&gt; imagePoints, jacobian","ref":"Evision.FishEye.html#projectPoints/5","title":"Evision.FishEye.projectPoints/5","type":"function"},{"doc":"Positional Arguments objectPoints : Evision.Mat rvec : Evision.Mat tvec : Evision.Mat k : Evision.Mat d : Evision.Mat Keyword Arguments alpha : double . Return imagePoints : Evision.Mat . jacobian : Evision.Mat . Has overloading in C++ Python prototype (for reference): projectPoints(objectPoints, rvec, tvec, K, D[, imagePoints[, alpha[, jacobian]]]) -&gt; imagePoints, jacobian","ref":"Evision.FishEye.html#projectPoints/6","title":"Evision.FishEye.projectPoints/6","type":"function"},{"doc":"Raising version of stereoCalibrate/8 .","ref":"Evision.FishEye.html#stereoCalibrate!/8","title":"Evision.FishEye.stereoCalibrate!/8","type":"function"},{"doc":"Raising version of stereoCalibrate/9 .","ref":"Evision.FishEye.html#stereoCalibrate!/9","title":"Evision.FishEye.stereoCalibrate!/9","type":"function"},{"doc":"Performs stereo calibration Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of the calibration pattern points. imagePoints1 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the first camera. imagePoints2 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the second camera. imageSize : Size . Size of the image used only to initialize camera intrinsic matrix. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref fisheye::CALIB_FIX_INTRINSIC Fix K1, K2? and D1, D2? so that only R, T matrices are estimated. @ref fisheye::CALIB_USE_INTRINSIC_GUESS K1, K2 contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center (imageSize is used), and focal distances are computed in a least-squares fashion. @ref fisheye::CALIB_RECOMPUTE_EXTRINSIC Extrinsic will be recomputed after each iteration of intrinsic optimization. @ref fisheye::CALIB_CHECK_COND The functions will check validity of condition number. @ref fisheye::CALIB_FIX_SKEW Skew coefficient (alpha) is set to zero and stay zero. @ref fisheye::CALIB_FIX_K1,..., @ref fisheye::CALIB_FIX_K4 Selected distortion coefficients are set to zeros and stay zero. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return k1 : Evision.Mat . Input/output first camera intrinsic matrix: \\f$\\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\\f$ , \\f$j = 0,\\, 1\\f$ . If any of @ref fisheye::CALIB_USE_INTRINSIC_GUESS , @ref fisheye::CALIB_FIX_INTRINSIC are specified, some or all of the matrix components must be initialized. d1 : Evision.Mat . Input/output vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$ of 4 elements. k2 : Evision.Mat . Input/output second camera intrinsic matrix. The parameter is similar to K1 . d2 : Evision.Mat . Input/output lens distortion coefficients for the second camera. The parameter is similar to D1 . r : Evision.Mat . Output rotation matrix between the 1st and the 2nd camera coordinate systems. t : Evision.Mat . Output translation vector between the coordinate systems of the cameras. Python prototype (for reference): stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize[, R[, T[, flags[, criteria]]]]) -&gt; retval, K1, D1, K2, D2, R, T","ref":"Evision.FishEye.html#stereoCalibrate/8","title":"Evision.FishEye.stereoCalibrate/8","type":"function"},{"doc":"Performs stereo calibration Positional Arguments objectPoints : [Evision.Mat] . Vector of vectors of the calibration pattern points. imagePoints1 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the first camera. imagePoints2 : [Evision.Mat] . Vector of vectors of the projections of the calibration pattern points, observed by the second camera. imageSize : Size . Size of the image used only to initialize camera intrinsic matrix. Keyword Arguments flags : int . Different flags that may be zero or a combination of the following values: @ref fisheye::CALIB_FIX_INTRINSIC Fix K1, K2? and D1, D2? so that only R, T matrices are estimated. @ref fisheye::CALIB_USE_INTRINSIC_GUESS K1, K2 contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center (imageSize is used), and focal distances are computed in a least-squares fashion. @ref fisheye::CALIB_RECOMPUTE_EXTRINSIC Extrinsic will be recomputed after each iteration of intrinsic optimization. @ref fisheye::CALIB_CHECK_COND The functions will check validity of condition number. @ref fisheye::CALIB_FIX_SKEW Skew coefficient (alpha) is set to zero and stay zero. @ref fisheye::CALIB_FIX_K1,..., @ref fisheye::CALIB_FIX_K4 Selected distortion coefficients are set to zeros and stay zero. criteria : TermCriteria . Termination criteria for the iterative optimization algorithm. Return k1 : Evision.Mat . Input/output first camera intrinsic matrix: \\f$\\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\\f$ , \\f$j = 0,\\, 1\\f$ . If any of @ref fisheye::CALIB_USE_INTRINSIC_GUESS , @ref fisheye::CALIB_FIX_INTRINSIC are specified, some or all of the matrix components must be initialized. d1 : Evision.Mat . Input/output vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$ of 4 elements. k2 : Evision.Mat . Input/output second camera intrinsic matrix. The parameter is similar to K1 . d2 : Evision.Mat . Input/output lens distortion coefficients for the second camera. The parameter is similar to D1 . r : Evision.Mat . Output rotation matrix between the 1st and the 2nd camera coordinate systems. t : Evision.Mat . Output translation vector between the coordinate systems of the cameras. Python prototype (for reference): stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize[, R[, T[, flags[, criteria]]]]) -&gt; retval, K1, D1, K2, D2, R, T","ref":"Evision.FishEye.html#stereoCalibrate/9","title":"Evision.FishEye.stereoCalibrate/9","type":"function"},{"doc":"Raising version of stereoRectify/8 .","ref":"Evision.FishEye.html#stereoRectify!/8","title":"Evision.FishEye.stereoRectify!/8","type":"function"},{"doc":"Raising version of stereoRectify/9 .","ref":"Evision.FishEye.html#stereoRectify!/9","title":"Evision.FishEye.stereoRectify!/9","type":"function"},{"doc":"Stereo rectification for fisheye camera model Positional Arguments k1 : Evision.Mat . First camera intrinsic matrix. d1 : Evision.Mat . First camera distortion parameters. k2 : Evision.Mat . Second camera intrinsic matrix. d2 : Evision.Mat . Second camera distortion parameters. imageSize : Size . Size of the image used for stereo calibration. r : Evision.Mat . Rotation matrix between the coordinate systems of the first and the second cameras. tvec : Evision.Mat . Translation vector between coordinate systems of the cameras. flags : int . Operation flags that may be zero or @ref fisheye::CALIB_ZERO_DISPARITY . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area. Keyword Arguments newImageSize : Size . New image resolution after rectification. The same size should be passed to #initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0) is passed (default), it is set to the original imageSize . Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion. balance : double . Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1]. fov_scale : double . Divisor for new focal length. Return r1 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the first camera. r2 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the second camera. p1 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera. p2 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera. q : Evision.Mat . Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see reprojectImageTo3D ). Python prototype (for reference): stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, flags[, R1[, R2[, P1[, P2[, Q[, newImageSize[, balance[, fov_scale]]]]]]]]) -&gt; R1, R2, P1, P2, Q","ref":"Evision.FishEye.html#stereoRectify/8","title":"Evision.FishEye.stereoRectify/8","type":"function"},{"doc":"Stereo rectification for fisheye camera model Positional Arguments k1 : Evision.Mat . First camera intrinsic matrix. d1 : Evision.Mat . First camera distortion parameters. k2 : Evision.Mat . Second camera intrinsic matrix. d2 : Evision.Mat . Second camera distortion parameters. imageSize : Size . Size of the image used for stereo calibration. r : Evision.Mat . Rotation matrix between the coordinate systems of the first and the second cameras. tvec : Evision.Mat . Translation vector between coordinate systems of the cameras. flags : int . Operation flags that may be zero or @ref fisheye::CALIB_ZERO_DISPARITY . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area. Keyword Arguments newImageSize : Size . New image resolution after rectification. The same size should be passed to #initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0) is passed (default), it is set to the original imageSize . Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion. balance : double . Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1]. fov_scale : double . Divisor for new focal length. Return r1 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the first camera. r2 : Evision.Mat . Output 3x3 rectification transform (rotation matrix) for the second camera. p1 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera. p2 : Evision.Mat . Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera. q : Evision.Mat . Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see reprojectImageTo3D ). Python prototype (for reference): stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, flags[, R1[, R2[, P1[, P2[, Q[, newImageSize[, balance[, fov_scale]]]]]]]]) -&gt; R1, R2, P1, P2, Q","ref":"Evision.FishEye.html#stereoRectify/9","title":"Evision.FishEye.stereoRectify/9","type":"function"},{"doc":"Raising version of undistortImage/3 .","ref":"Evision.FishEye.html#undistortImage!/3","title":"Evision.FishEye.undistortImage!/3","type":"function"},{"doc":"Raising version of undistortImage/4 .","ref":"Evision.FishEye.html#undistortImage!/4","title":"Evision.FishEye.undistortImage!/4","type":"function"},{"doc":"Transforms an image to compensate for fisheye lens distortion. Positional Arguments distorted : Evision.Mat . image with fisheye lens distortion. k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. Keyword Arguments knew : Evision.Mat . Camera intrinsic matrix of the distorted image. By default, it is the identity matrix but you may additionally scale and shift the result by using a different matrix. new_size : Size . the new size Return undistorted : Evision.Mat . Output image with compensated fisheye lens distortion. The function transforms an image to compensate radial and tangential lens distortion. The function is simply a combination of #fisheye::initUndistortRectifyMap (with unity R ) and #remap (with bilinear interpolation). See the former function for details of the transformation being performed. See below the results of undistortImage. a) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3, k_4, k_5, k_6) of distortion were optimized under calibration) b) result of #fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2, k_3, k_4) of fisheye distortion were optimized under calibration) c) original image was captured with fisheye lens Pictures a) and b) almost the same. But if we consider points of image located far from the center of image, we can notice that on image a) these points are distorted. Python prototype (for reference): undistortImage(distorted, K, D[, undistorted[, Knew[, new_size]]]) -&gt; undistorted","ref":"Evision.FishEye.html#undistortImage/3","title":"Evision.FishEye.undistortImage/3","type":"function"},{"doc":"Transforms an image to compensate for fisheye lens distortion. Positional Arguments distorted : Evision.Mat . image with fisheye lens distortion. k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. Keyword Arguments knew : Evision.Mat . Camera intrinsic matrix of the distorted image. By default, it is the identity matrix but you may additionally scale and shift the result by using a different matrix. new_size : Size . the new size Return undistorted : Evision.Mat . Output image with compensated fisheye lens distortion. The function transforms an image to compensate radial and tangential lens distortion. The function is simply a combination of #fisheye::initUndistortRectifyMap (with unity R ) and #remap (with bilinear interpolation). See the former function for details of the transformation being performed. See below the results of undistortImage. a) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3, k_4, k_5, k_6) of distortion were optimized under calibration) b) result of #fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2, k_3, k_4) of fisheye distortion were optimized under calibration) c) original image was captured with fisheye lens Pictures a) and b) almost the same. But if we consider points of image located far from the center of image, we can notice that on image a) these points are distorted. Python prototype (for reference): undistortImage(distorted, K, D[, undistorted[, Knew[, new_size]]]) -&gt; undistorted","ref":"Evision.FishEye.html#undistortImage/4","title":"Evision.FishEye.undistortImage/4","type":"function"},{"doc":"Raising version of undistortPoints/3 .","ref":"Evision.FishEye.html#undistortPoints!/3","title":"Evision.FishEye.undistortPoints!/3","type":"function"},{"doc":"Raising version of undistortPoints/4 .","ref":"Evision.FishEye.html#undistortPoints!/4","title":"Evision.FishEye.undistortPoints!/4","type":"function"},{"doc":"Undistorts 2D points using fisheye model Positional Arguments distorted : Evision.Mat . Array of object points, 1xN/Nx1 2-channel (or vector\\&lt;Point2f&gt; ), where N is the number of points in the view. k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. Keyword Arguments r : Evision.Mat . Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel p : Evision.Mat . New camera intrinsic matrix (3x3) or new projection matrix (3x4) criteria : TermCriteria . Termination criteria Return undistorted : Evision.Mat . Output array of image points, 1xN/Nx1 2-channel, or vector\\&lt;Point2f&gt; . Python prototype (for reference): undistortPoints(distorted, K, D[, undistorted[, R[, P[, criteria]]]]) -&gt; undistorted","ref":"Evision.FishEye.html#undistortPoints/3","title":"Evision.FishEye.undistortPoints/3","type":"function"},{"doc":"Undistorts 2D points using fisheye model Positional Arguments distorted : Evision.Mat . Array of object points, 1xN/Nx1 2-channel (or vector\\&lt;Point2f&gt; ), where N is the number of points in the view. k : Evision.Mat . Camera intrinsic matrix \\f$cameramatrix{K}\\f$. d : Evision.Mat . Input vector of distortion coefficients \\f$\\distcoeffsfisheye\\f$. Keyword Arguments r : Evision.Mat . Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel p : Evision.Mat . New camera intrinsic matrix (3x3) or new projection matrix (3x4) criteria : TermCriteria . Termination criteria Return undistorted : Evision.Mat . Output array of image points, 1xN/Nx1 2-channel, or vector\\&lt;Point2f&gt; . Python prototype (for reference): undistortPoints(distorted, K, D[, undistorted[, R[, P[, criteria]]]]) -&gt; undistorted","ref":"Evision.FishEye.html#undistortPoints/4","title":"Evision.FishEye.undistortPoints/4","type":"function"},{"doc":"","ref":"Evision.Flann.html","title":"Evision.Flann","type":"module"},{"doc":"","ref":"Evision.Flann.Index.html","title":"Evision.Flann.Index","type":"module"},{"doc":"Raising version of build/3 .","ref":"Evision.Flann.Index.html#build!/3","title":"Evision.Flann.Index.build!/3","type":"function"},{"doc":"Raising version of build/4 .","ref":"Evision.Flann.Index.html#build!/4","title":"Evision.Flann.Index.build!/4","type":"function"},{"doc":"Positional Arguments features : Evision.Mat params : IndexParams Keyword Arguments distType : cvflann_flann_distance_t . Python prototype (for reference): build(features, params[, distType]) -&gt; None","ref":"Evision.Flann.Index.html#build/3","title":"Evision.Flann.Index.build/3","type":"function"},{"doc":"Positional Arguments features : Evision.Mat params : IndexParams Keyword Arguments distType : cvflann_flann_distance_t . Python prototype (for reference): build(features, params[, distType]) -&gt; None","ref":"Evision.Flann.Index.html#build/4","title":"Evision.Flann.Index.build/4","type":"function"},{"doc":"Raising version of flann_Index/0 .","ref":"Evision.Flann.Index.html#flann_Index!/0","title":"Evision.Flann.Index.flann_Index!/0","type":"function"},{"doc":"Raising version of flann_Index/2 .","ref":"Evision.Flann.Index.html#flann_Index!/2","title":"Evision.Flann.Index.flann_Index!/2","type":"function"},{"doc":"Raising version of flann_Index/3 .","ref":"Evision.Flann.Index.html#flann_Index!/3","title":"Evision.Flann.Index.flann_Index!/3","type":"function"},{"doc":"Python prototype (for reference): Index() -&gt; &lt;flann_Index object&gt;","ref":"Evision.Flann.Index.html#flann_Index/0","title":"Evision.Flann.Index.flann_Index/0","type":"function"},{"doc":"Positional Arguments features : Evision.Mat params : IndexParams Keyword Arguments distType : cvflann_flann_distance_t . Python prototype (for reference): Index(features, params[, distType]) -&gt; &lt;flann_Index object&gt;","ref":"Evision.Flann.Index.html#flann_Index/2","title":"Evision.Flann.Index.flann_Index/2","type":"function"},{"doc":"Positional Arguments features : Evision.Mat params : IndexParams Keyword Arguments distType : cvflann_flann_distance_t . Python prototype (for reference): Index(features, params[, distType]) -&gt; &lt;flann_Index object&gt;","ref":"Evision.Flann.Index.html#flann_Index/3","title":"Evision.Flann.Index.flann_Index/3","type":"function"},{"doc":"Raising version of getAlgorithm/1 .","ref":"Evision.Flann.Index.html#getAlgorithm!/1","title":"Evision.Flann.Index.getAlgorithm!/1","type":"function"},{"doc":"Python prototype (for reference): getAlgorithm() -&gt; retval","ref":"Evision.Flann.Index.html#getAlgorithm/1","title":"Evision.Flann.Index.getAlgorithm/1","type":"function"},{"doc":"Raising version of getDistance/1 .","ref":"Evision.Flann.Index.html#getDistance!/1","title":"Evision.Flann.Index.getDistance!/1","type":"function"},{"doc":"Python prototype (for reference): getDistance() -&gt; retval","ref":"Evision.Flann.Index.html#getDistance/1","title":"Evision.Flann.Index.getDistance/1","type":"function"},{"doc":"Raising version of knnSearch/3 .","ref":"Evision.Flann.Index.html#knnSearch!/3","title":"Evision.Flann.Index.knnSearch!/3","type":"function"},{"doc":"Raising version of knnSearch/4 .","ref":"Evision.Flann.Index.html#knnSearch!/4","title":"Evision.Flann.Index.knnSearch!/4","type":"function"},{"doc":"Positional Arguments query : Evision.Mat knn : int Keyword Arguments params : SearchParams . Return indices : Evision.Mat . dists : Evision.Mat . Python prototype (for reference): knnSearch(query, knn[, indices[, dists[, params]]]) -&gt; indices, dists","ref":"Evision.Flann.Index.html#knnSearch/3","title":"Evision.Flann.Index.knnSearch/3","type":"function"},{"doc":"Positional Arguments query : Evision.Mat knn : int Keyword Arguments params : SearchParams . Return indices : Evision.Mat . dists : Evision.Mat . Python prototype (for reference): knnSearch(query, knn[, indices[, dists[, params]]]) -&gt; indices, dists","ref":"Evision.Flann.Index.html#knnSearch/4","title":"Evision.Flann.Index.knnSearch/4","type":"function"},{"doc":"Raising version of load/3 .","ref":"Evision.Flann.Index.html#load!/3","title":"Evision.Flann.Index.load!/3","type":"function"},{"doc":"Positional Arguments features : Evision.Mat filename : String Python prototype (for reference): load(features, filename) -&gt; retval","ref":"Evision.Flann.Index.html#load/3","title":"Evision.Flann.Index.load/3","type":"function"},{"doc":"Raising version of radiusSearch/4 .","ref":"Evision.Flann.Index.html#radiusSearch!/4","title":"Evision.Flann.Index.radiusSearch!/4","type":"function"},{"doc":"Raising version of radiusSearch/5 .","ref":"Evision.Flann.Index.html#radiusSearch!/5","title":"Evision.Flann.Index.radiusSearch!/5","type":"function"},{"doc":"Positional Arguments query : Evision.Mat radius : double maxResults : int Keyword Arguments params : SearchParams . Return indices : Evision.Mat . dists : Evision.Mat . Python prototype (for reference): radiusSearch(query, radius, maxResults[, indices[, dists[, params]]]) -&gt; retval, indices, dists","ref":"Evision.Flann.Index.html#radiusSearch/4","title":"Evision.Flann.Index.radiusSearch/4","type":"function"},{"doc":"Positional Arguments query : Evision.Mat radius : double maxResults : int Keyword Arguments params : SearchParams . Return indices : Evision.Mat . dists : Evision.Mat . Python prototype (for reference): radiusSearch(query, radius, maxResults[, indices[, dists[, params]]]) -&gt; retval, indices, dists","ref":"Evision.Flann.Index.html#radiusSearch/5","title":"Evision.Flann.Index.radiusSearch/5","type":"function"},{"doc":"Raising version of release/1 .","ref":"Evision.Flann.Index.html#release!/1","title":"Evision.Flann.Index.release!/1","type":"function"},{"doc":"Python prototype (for reference): release() -&gt; None","ref":"Evision.Flann.Index.html#release/1","title":"Evision.Flann.Index.release/1","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.Flann.Index.html#save!/2","title":"Evision.Flann.Index.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.Flann.Index.html#save/2","title":"Evision.Flann.Index.save/2","type":"function"},{"doc":"","ref":"Evision.FlannBasedMatcher.html","title":"Evision.FlannBasedMatcher","type":"module"},{"doc":"Raising version of add/2 .","ref":"Evision.FlannBasedMatcher.html#add!/2","title":"Evision.FlannBasedMatcher.add!/2","type":"function"},{"doc":"Adds descriptors to train a CPU(trainDescCollectionis) or GPU(utrainDescCollectionis) descriptor collection. Positional Arguments descriptors : [Evision.Mat] . Descriptors to add. Each descriptors[i] is a set of descriptors from the same train image. If the collection is not empty, the new descriptors are added to existing train descriptors. Python prototype (for reference): add(descriptors) -&gt; None","ref":"Evision.FlannBasedMatcher.html#add/2","title":"Evision.FlannBasedMatcher.add/2","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.FlannBasedMatcher.html#clear!/1","title":"Evision.FlannBasedMatcher.clear!/1","type":"function"},{"doc":"Clears the train descriptor collections. Python prototype (for reference): clear() -&gt; None","ref":"Evision.FlannBasedMatcher.html#clear/1","title":"Evision.FlannBasedMatcher.clear/1","type":"function"},{"doc":"Raising version of clone/1 .","ref":"Evision.FlannBasedMatcher.html#clone!/1","title":"Evision.FlannBasedMatcher.clone!/1","type":"function"},{"doc":"Clones the matcher. Keyword Arguments emptyTrainData : bool . If emptyTrainData is false, the method creates a deep copy of the object, that is, copies both parameters and train data. If emptyTrainData is true, the method creates an object copy with the current parameters but with empty train data. Python prototype (for reference): clone([, emptyTrainData]) -&gt; retval","ref":"Evision.FlannBasedMatcher.html#clone/1","title":"Evision.FlannBasedMatcher.clone/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.FlannBasedMatcher.html#create!/0","title":"Evision.FlannBasedMatcher.create!/0","type":"function"},{"doc":"Python prototype (for reference): create() -&gt; retval","ref":"Evision.FlannBasedMatcher.html#create/0","title":"Evision.FlannBasedMatcher.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.FlannBasedMatcher.html#empty!/1","title":"Evision.FlannBasedMatcher.empty!/1","type":"function"},{"doc":"Returns true if there are no train descriptors in the both collections. Python prototype (for reference): empty() -&gt; retval","ref":"Evision.FlannBasedMatcher.html#empty/1","title":"Evision.FlannBasedMatcher.empty/1","type":"function"},{"doc":"Raising version of flannBasedMatcher/0 .","ref":"Evision.FlannBasedMatcher.html#flannBasedMatcher!/0","title":"Evision.FlannBasedMatcher.flannBasedMatcher!/0","type":"function"},{"doc":"Raising version of flannBasedMatcher/1 .","ref":"Evision.FlannBasedMatcher.html#flannBasedMatcher!/1","title":"Evision.FlannBasedMatcher.flannBasedMatcher!/1","type":"function"},{"doc":"##### Keyword Arguments indexParams : Ptr&lt;flann::IndexParams&gt; . searchParams : Ptr&lt;flann::SearchParams&gt; . Python prototype (for reference): FlannBasedMatcher([, indexParams[, searchParams]]) -&gt; &lt;FlannBasedMatcher object&gt;","ref":"Evision.FlannBasedMatcher.html#flannBasedMatcher/0","title":"Evision.FlannBasedMatcher.flannBasedMatcher/0","type":"function"},{"doc":"##### Keyword Arguments indexParams : Ptr&lt;flann::IndexParams&gt; . searchParams : Ptr&lt;flann::SearchParams&gt; . Python prototype (for reference): FlannBasedMatcher([, indexParams[, searchParams]]) -&gt; &lt;FlannBasedMatcher object&gt;","ref":"Evision.FlannBasedMatcher.html#flannBasedMatcher/1","title":"Evision.FlannBasedMatcher.flannBasedMatcher/1","type":"function"},{"doc":"Raising version of getTrainDescriptors/1 .","ref":"Evision.FlannBasedMatcher.html#getTrainDescriptors!/1","title":"Evision.FlannBasedMatcher.getTrainDescriptors!/1","type":"function"},{"doc":"Returns a constant link to the train descriptor collection trainDescCollection . Python prototype (for reference): getTrainDescriptors() -&gt; retval","ref":"Evision.FlannBasedMatcher.html#getTrainDescriptors/1","title":"Evision.FlannBasedMatcher.getTrainDescriptors/1","type":"function"},{"doc":"Raising version of isMaskSupported/1 .","ref":"Evision.FlannBasedMatcher.html#isMaskSupported!/1","title":"Evision.FlannBasedMatcher.isMaskSupported!/1","type":"function"},{"doc":"Returns true if the descriptor matcher supports masking permissible matches. Python prototype (for reference): isMaskSupported() -&gt; retval","ref":"Evision.FlannBasedMatcher.html#isMaskSupported/1","title":"Evision.FlannBasedMatcher.isMaskSupported/1","type":"function"},{"doc":"Raising version of knnMatch/3 .","ref":"Evision.FlannBasedMatcher.html#knnMatch!/3","title":"Evision.FlannBasedMatcher.knnMatch!/3","type":"function"},{"doc":"Raising version of knnMatch/4 .","ref":"Evision.FlannBasedMatcher.html#knnMatch!/4","title":"Evision.FlannBasedMatcher.knnMatch!/4","type":"function"},{"doc":"Raising version of knnMatch/5 .","ref":"Evision.FlannBasedMatcher.html#knnMatch!/5","title":"Evision.FlannBasedMatcher.knnMatch!/5","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. Has overloading in C++ Python prototype (for reference): knnMatch(queryDescriptors, k[, masks[, compactResult]]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#knnMatch/3","title":"Evision.FlannBasedMatcher.knnMatch/3","type":"function"},{"doc":"Variant 1: Finds the k best matches for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. These extended variants of DescriptorMatcher::match methods find several best matches for each query descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match for the details about query and train descriptors. Python prototype (for reference): knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. Has overloading in C++ Python prototype (for reference): knnMatch(queryDescriptors, k[, masks[, compactResult]]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#knnMatch/4","title":"Evision.FlannBasedMatcher.knnMatch/4","type":"function"},{"doc":"Finds the k best matches for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. k : int . Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Matches. Each matches[i] is k or less matches for the same query descriptor. These extended variants of DescriptorMatcher::match methods find several best matches for each query descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match for the details about query and train descriptors. Python prototype (for reference): knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#knnMatch/5","title":"Evision.FlannBasedMatcher.knnMatch/5","type":"function"},{"doc":"Raising version of match/2 .","ref":"Evision.FlannBasedMatcher.html#match!/2","title":"Evision.FlannBasedMatcher.match!/2","type":"function"},{"doc":"Raising version of match/3 .","ref":"Evision.FlannBasedMatcher.html#match!/3","title":"Evision.FlannBasedMatcher.match!/3","type":"function"},{"doc":"Raising version of match/4 .","ref":"Evision.FlannBasedMatcher.html#match!/4","title":"Evision.FlannBasedMatcher.match!/4","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. Has overloading in C++ Python prototype (for reference): match(queryDescriptors[, masks]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#match/2","title":"Evision.FlannBasedMatcher.match/2","type":"function"},{"doc":"Variant 1: Finds the best match for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. In the first variant of this method, the train descriptors are passed as an input argument. In the second variant of the method, train descriptors collection that was set by DescriptorMatcher::add is used. Optional mask (or masks) can be passed to specify which query and training descriptors can be matched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if mask.at\\&lt;uchar&gt;(i,j) is non-zero. Python prototype (for reference): match(queryDescriptors, trainDescriptors[, mask]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. Has overloading in C++ Python prototype (for reference): match(queryDescriptors[, masks]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#match/3","title":"Evision.FlannBasedMatcher.match/3","type":"function"},{"doc":"Finds the best match for each descriptor from a query set. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. Return matches : [DMatch] . Matches. If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count. In the first variant of this method, the train descriptors are passed as an input argument. In the second variant of the method, train descriptors collection that was set by DescriptorMatcher::add is used. Optional mask (or masks) can be passed to specify which query and training descriptors can be matched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if mask.at\\&lt;uchar&gt;(i,j) is non-zero. Python prototype (for reference): match(queryDescriptors, trainDescriptors[, mask]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#match/4","title":"Evision.FlannBasedMatcher.match/4","type":"function"},{"doc":"Raising version of radiusMatch/3 .","ref":"Evision.FlannBasedMatcher.html#radiusMatch!/3","title":"Evision.FlannBasedMatcher.radiusMatch!/3","type":"function"},{"doc":"Raising version of radiusMatch/4 .","ref":"Evision.FlannBasedMatcher.html#radiusMatch!/4","title":"Evision.FlannBasedMatcher.radiusMatch!/4","type":"function"},{"doc":"Raising version of radiusMatch/5 .","ref":"Evision.FlannBasedMatcher.html#radiusMatch!/5","title":"Evision.FlannBasedMatcher.radiusMatch!/5","type":"function"},{"doc":"Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. Has overloading in C++ Python prototype (for reference): radiusMatch(queryDescriptors, maxDistance[, masks[, compactResult]]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#radiusMatch/3","title":"Evision.FlannBasedMatcher.radiusMatch/3","type":"function"},{"doc":"Variant 1: For each query descriptor, finds the training descriptors not farther than the specified distance. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. For each query descriptor, the methods find such training descriptors that the distance between the query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are returned in the distance increasing order. Python prototype (for reference): radiusMatch(queryDescriptors, trainDescriptors, maxDistance[, mask[, compactResult]]) -&gt; matches Variant 2: Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments masks : [Evision.Mat] . Set of masks. Each masks[i] specifies permissible matches between the input query descriptors and stored train descriptors from the i-th image trainDescCollection[i]. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. Has overloading in C++ Python prototype (for reference): radiusMatch(queryDescriptors, maxDistance[, masks[, compactResult]]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#radiusMatch/4","title":"Evision.FlannBasedMatcher.radiusMatch/4","type":"function"},{"doc":"For each query descriptor, finds the training descriptors not farther than the specified distance. Positional Arguments queryDescriptors : Evision.Mat . Query set of descriptors. trainDescriptors : Evision.Mat . Train set of descriptors. This set is not added to the train descriptors collection stored in the class object. maxDistance : float . Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)! Keyword Arguments mask : Evision.Mat . Mask specifying permissible matches between an input query and train matrices of descriptors. compactResult : bool . Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors. Return matches : [vector_DMatch] . Found matches. For each query descriptor, the methods find such training descriptors that the distance between the query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are returned in the distance increasing order. Python prototype (for reference): radiusMatch(queryDescriptors, trainDescriptors, maxDistance[, mask[, compactResult]]) -&gt; matches","ref":"Evision.FlannBasedMatcher.html#radiusMatch/5","title":"Evision.FlannBasedMatcher.radiusMatch/5","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.FlannBasedMatcher.html#read!/2","title":"Evision.FlannBasedMatcher.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.FlannBasedMatcher.html#read/2","title":"Evision.FlannBasedMatcher.read/2","type":"function"},{"doc":"Raising version of train/1 .","ref":"Evision.FlannBasedMatcher.html#train!/1","title":"Evision.FlannBasedMatcher.train!/1","type":"function"},{"doc":"Trains a descriptor matcher Trains a descriptor matcher (for example, the flann index). In all methods to match, the method train() is run every time before matching. Some descriptor matchers (for example, BruteForceMatcher) have an empty implementation of this method. Other matchers really train their inner structures (for example, FlannBasedMatcher trains flann::Index ). Python prototype (for reference): train() -&gt; None","ref":"Evision.FlannBasedMatcher.html#train/1","title":"Evision.FlannBasedMatcher.train/1","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.FlannBasedMatcher.html#write!/2","title":"Evision.FlannBasedMatcher.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.FlannBasedMatcher.html#write!/3","title":"Evision.FlannBasedMatcher.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.FlannBasedMatcher.html#write/2","title":"Evision.FlannBasedMatcher.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.FlannBasedMatcher.html#write/3","title":"Evision.FlannBasedMatcher.write/3","type":"function"},{"doc":"","ref":"Evision.GFTTDetector.html","title":"Evision.GFTTDetector","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.GFTTDetector.html#compute!/3","title":"Evision.GFTTDetector.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.GFTTDetector.html#compute!/4","title":"Evision.GFTTDetector.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.GFTTDetector.html#compute/3","title":"Evision.GFTTDetector.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.GFTTDetector.html#compute/4","title":"Evision.GFTTDetector.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.GFTTDetector.html#create!/0","title":"Evision.GFTTDetector.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.GFTTDetector.html#create!/1","title":"Evision.GFTTDetector.create!/1","type":"function"},{"doc":"Raising version of create/5 .","ref":"Evision.GFTTDetector.html#create!/5","title":"Evision.GFTTDetector.create!/5","type":"function"},{"doc":"Raising version of create/6 .","ref":"Evision.GFTTDetector.html#create!/6","title":"Evision.GFTTDetector.create!/6","type":"function"},{"doc":"##### Keyword Arguments maxCorners : int . qualityLevel : double . minDistance : double . blockSize : int . useHarrisDetector : bool . k : double . Python prototype (for reference): create([, maxCorners[, qualityLevel[, minDistance[, blockSize[, useHarrisDetector[, k]]]]]]) -&gt; retval","ref":"Evision.GFTTDetector.html#create/0","title":"Evision.GFTTDetector.create/0","type":"function"},{"doc":"##### Keyword Arguments maxCorners : int . qualityLevel : double . minDistance : double . blockSize : int . useHarrisDetector : bool . k : double . Python prototype (for reference): create([, maxCorners[, qualityLevel[, minDistance[, blockSize[, useHarrisDetector[, k]]]]]]) -&gt; retval","ref":"Evision.GFTTDetector.html#create/1","title":"Evision.GFTTDetector.create/1","type":"function"},{"doc":"Positional Arguments maxCorners : int qualityLevel : double minDistance : double blockSize : int gradiantSize : int Keyword Arguments useHarrisDetector : bool . k : double . Python prototype (for reference): create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize[, useHarrisDetector[, k]]) -&gt; retval","ref":"Evision.GFTTDetector.html#create/5","title":"Evision.GFTTDetector.create/5","type":"function"},{"doc":"Positional Arguments maxCorners : int qualityLevel : double minDistance : double blockSize : int gradiantSize : int Keyword Arguments useHarrisDetector : bool . k : double . Python prototype (for reference): create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize[, useHarrisDetector[, k]]) -&gt; retval","ref":"Evision.GFTTDetector.html#create/6","title":"Evision.GFTTDetector.create/6","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.GFTTDetector.html#defaultNorm!/1","title":"Evision.GFTTDetector.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.GFTTDetector.html#defaultNorm/1","title":"Evision.GFTTDetector.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.GFTTDetector.html#descriptorSize!/1","title":"Evision.GFTTDetector.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.GFTTDetector.html#descriptorSize/1","title":"Evision.GFTTDetector.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.GFTTDetector.html#descriptorType!/1","title":"Evision.GFTTDetector.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.GFTTDetector.html#descriptorType/1","title":"Evision.GFTTDetector.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.GFTTDetector.html#detect!/2","title":"Evision.GFTTDetector.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.GFTTDetector.html#detect!/3","title":"Evision.GFTTDetector.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.GFTTDetector.html#detect/2","title":"Evision.GFTTDetector.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.GFTTDetector.html#detect/3","title":"Evision.GFTTDetector.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.GFTTDetector.html#detectAndCompute!/3","title":"Evision.GFTTDetector.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.GFTTDetector.html#detectAndCompute!/4","title":"Evision.GFTTDetector.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.GFTTDetector.html#detectAndCompute/3","title":"Evision.GFTTDetector.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.GFTTDetector.html#detectAndCompute/4","title":"Evision.GFTTDetector.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.GFTTDetector.html#empty!/1","title":"Evision.GFTTDetector.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.GFTTDetector.html#empty/1","title":"Evision.GFTTDetector.empty/1","type":"function"},{"doc":"Raising version of getBlockSize/1 .","ref":"Evision.GFTTDetector.html#getBlockSize!/1","title":"Evision.GFTTDetector.getBlockSize!/1","type":"function"},{"doc":"Python prototype (for reference): getBlockSize() -&gt; retval","ref":"Evision.GFTTDetector.html#getBlockSize/1","title":"Evision.GFTTDetector.getBlockSize/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.GFTTDetector.html#getDefaultName!/1","title":"Evision.GFTTDetector.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.GFTTDetector.html#getDefaultName/1","title":"Evision.GFTTDetector.getDefaultName/1","type":"function"},{"doc":"Raising version of getHarrisDetector/1 .","ref":"Evision.GFTTDetector.html#getHarrisDetector!/1","title":"Evision.GFTTDetector.getHarrisDetector!/1","type":"function"},{"doc":"Python prototype (for reference): getHarrisDetector() -&gt; retval","ref":"Evision.GFTTDetector.html#getHarrisDetector/1","title":"Evision.GFTTDetector.getHarrisDetector/1","type":"function"},{"doc":"Raising version of getK/1 .","ref":"Evision.GFTTDetector.html#getK!/1","title":"Evision.GFTTDetector.getK!/1","type":"function"},{"doc":"Python prototype (for reference): getK() -&gt; retval","ref":"Evision.GFTTDetector.html#getK/1","title":"Evision.GFTTDetector.getK/1","type":"function"},{"doc":"Raising version of getMaxFeatures/1 .","ref":"Evision.GFTTDetector.html#getMaxFeatures!/1","title":"Evision.GFTTDetector.getMaxFeatures!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxFeatures() -&gt; retval","ref":"Evision.GFTTDetector.html#getMaxFeatures/1","title":"Evision.GFTTDetector.getMaxFeatures/1","type":"function"},{"doc":"Raising version of getMinDistance/1 .","ref":"Evision.GFTTDetector.html#getMinDistance!/1","title":"Evision.GFTTDetector.getMinDistance!/1","type":"function"},{"doc":"Python prototype (for reference): getMinDistance() -&gt; retval","ref":"Evision.GFTTDetector.html#getMinDistance/1","title":"Evision.GFTTDetector.getMinDistance/1","type":"function"},{"doc":"Raising version of getQualityLevel/1 .","ref":"Evision.GFTTDetector.html#getQualityLevel!/1","title":"Evision.GFTTDetector.getQualityLevel!/1","type":"function"},{"doc":"Python prototype (for reference): getQualityLevel() -&gt; retval","ref":"Evision.GFTTDetector.html#getQualityLevel/1","title":"Evision.GFTTDetector.getQualityLevel/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.GFTTDetector.html#read!/2","title":"Evision.GFTTDetector.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.GFTTDetector.html#read/2","title":"Evision.GFTTDetector.read/2","type":"function"},{"doc":"Raising version of setBlockSize/2 .","ref":"Evision.GFTTDetector.html#setBlockSize!/2","title":"Evision.GFTTDetector.setBlockSize!/2","type":"function"},{"doc":"Positional Arguments blockSize : int Python prototype (for reference): setBlockSize(blockSize) -&gt; None","ref":"Evision.GFTTDetector.html#setBlockSize/2","title":"Evision.GFTTDetector.setBlockSize/2","type":"function"},{"doc":"Raising version of setHarrisDetector/2 .","ref":"Evision.GFTTDetector.html#setHarrisDetector!/2","title":"Evision.GFTTDetector.setHarrisDetector!/2","type":"function"},{"doc":"Positional Arguments val : bool Python prototype (for reference): setHarrisDetector(val) -&gt; None","ref":"Evision.GFTTDetector.html#setHarrisDetector/2","title":"Evision.GFTTDetector.setHarrisDetector/2","type":"function"},{"doc":"Raising version of setK/2 .","ref":"Evision.GFTTDetector.html#setK!/2","title":"Evision.GFTTDetector.setK!/2","type":"function"},{"doc":"Positional Arguments k : double Python prototype (for reference): setK(k) -&gt; None","ref":"Evision.GFTTDetector.html#setK/2","title":"Evision.GFTTDetector.setK/2","type":"function"},{"doc":"Raising version of setMaxFeatures/2 .","ref":"Evision.GFTTDetector.html#setMaxFeatures!/2","title":"Evision.GFTTDetector.setMaxFeatures!/2","type":"function"},{"doc":"Positional Arguments maxFeatures : int Python prototype (for reference): setMaxFeatures(maxFeatures) -&gt; None","ref":"Evision.GFTTDetector.html#setMaxFeatures/2","title":"Evision.GFTTDetector.setMaxFeatures/2","type":"function"},{"doc":"Raising version of setMinDistance/2 .","ref":"Evision.GFTTDetector.html#setMinDistance!/2","title":"Evision.GFTTDetector.setMinDistance!/2","type":"function"},{"doc":"Positional Arguments minDistance : double Python prototype (for reference): setMinDistance(minDistance) -&gt; None","ref":"Evision.GFTTDetector.html#setMinDistance/2","title":"Evision.GFTTDetector.setMinDistance/2","type":"function"},{"doc":"Raising version of setQualityLevel/2 .","ref":"Evision.GFTTDetector.html#setQualityLevel!/2","title":"Evision.GFTTDetector.setQualityLevel!/2","type":"function"},{"doc":"Positional Arguments qlevel : double Python prototype (for reference): setQualityLevel(qlevel) -&gt; None","ref":"Evision.GFTTDetector.html#setQualityLevel/2","title":"Evision.GFTTDetector.setQualityLevel/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.GFTTDetector.html#write!/2","title":"Evision.GFTTDetector.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.GFTTDetector.html#write!/3","title":"Evision.GFTTDetector.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.GFTTDetector.html#write/2","title":"Evision.GFTTDetector.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.GFTTDetector.html#write/3","title":"Evision.GFTTDetector.write/3","type":"function"},{"doc":"","ref":"Evision.GeneralizedHough.html","title":"Evision.GeneralizedHough","type":"module"},{"doc":"Raising version of detect/2 .","ref":"Evision.GeneralizedHough.html#detect!/2","title":"Evision.GeneralizedHough.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.GeneralizedHough.html#detect!/3","title":"Evision.GeneralizedHough.detect!/3","type":"function"},{"doc":"Raising version of detect/4 .","ref":"Evision.GeneralizedHough.html#detect!/4","title":"Evision.GeneralizedHough.detect!/4","type":"function"},{"doc":"Raising version of detect/5 .","ref":"Evision.GeneralizedHough.html#detect!/5","title":"Evision.GeneralizedHough.detect!/5","type":"function"},{"doc":"Positional Arguments image : Evision.Mat Return positions : Evision.Mat . votes : Evision.Mat . Python prototype (for reference): detect(image[, positions[, votes]]) -&gt; positions, votes","ref":"Evision.GeneralizedHough.html#detect/2","title":"Evision.GeneralizedHough.detect/2","type":"function"},{"doc":"Positional Arguments image : Evision.Mat Return positions : Evision.Mat . votes : Evision.Mat . Python prototype (for reference): detect(image[, positions[, votes]]) -&gt; positions, votes","ref":"Evision.GeneralizedHough.html#detect/3","title":"Evision.GeneralizedHough.detect/3","type":"function"},{"doc":"Positional Arguments edges : Evision.Mat dx : Evision.Mat dy : Evision.Mat Return positions : Evision.Mat . votes : Evision.Mat . Python prototype (for reference): detect(edges, dx, dy[, positions[, votes]]) -&gt; positions, votes","ref":"Evision.GeneralizedHough.html#detect/4","title":"Evision.GeneralizedHough.detect/4","type":"function"},{"doc":"Positional Arguments edges : Evision.Mat dx : Evision.Mat dy : Evision.Mat Return positions : Evision.Mat . votes : Evision.Mat . Python prototype (for reference): detect(edges, dx, dy[, positions[, votes]]) -&gt; positions, votes","ref":"Evision.GeneralizedHough.html#detect/5","title":"Evision.GeneralizedHough.detect/5","type":"function"},{"doc":"Raising version of getCannyHighThresh/1 .","ref":"Evision.GeneralizedHough.html#getCannyHighThresh!/1","title":"Evision.GeneralizedHough.getCannyHighThresh!/1","type":"function"},{"doc":"Python prototype (for reference): getCannyHighThresh() -&gt; retval","ref":"Evision.GeneralizedHough.html#getCannyHighThresh/1","title":"Evision.GeneralizedHough.getCannyHighThresh/1","type":"function"},{"doc":"Raising version of getCannyLowThresh/1 .","ref":"Evision.GeneralizedHough.html#getCannyLowThresh!/1","title":"Evision.GeneralizedHough.getCannyLowThresh!/1","type":"function"},{"doc":"Python prototype (for reference): getCannyLowThresh() -&gt; retval","ref":"Evision.GeneralizedHough.html#getCannyLowThresh/1","title":"Evision.GeneralizedHough.getCannyLowThresh/1","type":"function"},{"doc":"Raising version of getDp/1 .","ref":"Evision.GeneralizedHough.html#getDp!/1","title":"Evision.GeneralizedHough.getDp!/1","type":"function"},{"doc":"Python prototype (for reference): getDp() -&gt; retval","ref":"Evision.GeneralizedHough.html#getDp/1","title":"Evision.GeneralizedHough.getDp/1","type":"function"},{"doc":"Raising version of getMaxBufferSize/1 .","ref":"Evision.GeneralizedHough.html#getMaxBufferSize!/1","title":"Evision.GeneralizedHough.getMaxBufferSize!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxBufferSize() -&gt; retval","ref":"Evision.GeneralizedHough.html#getMaxBufferSize/1","title":"Evision.GeneralizedHough.getMaxBufferSize/1","type":"function"},{"doc":"Raising version of getMinDist/1 .","ref":"Evision.GeneralizedHough.html#getMinDist!/1","title":"Evision.GeneralizedHough.getMinDist!/1","type":"function"},{"doc":"Python prototype (for reference): getMinDist() -&gt; retval","ref":"Evision.GeneralizedHough.html#getMinDist/1","title":"Evision.GeneralizedHough.getMinDist/1","type":"function"},{"doc":"Raising version of setCannyHighThresh/2 .","ref":"Evision.GeneralizedHough.html#setCannyHighThresh!/2","title":"Evision.GeneralizedHough.setCannyHighThresh!/2","type":"function"},{"doc":"Positional Arguments cannyHighThresh : int Python prototype (for reference): setCannyHighThresh(cannyHighThresh) -&gt; None","ref":"Evision.GeneralizedHough.html#setCannyHighThresh/2","title":"Evision.GeneralizedHough.setCannyHighThresh/2","type":"function"},{"doc":"Raising version of setCannyLowThresh/2 .","ref":"Evision.GeneralizedHough.html#setCannyLowThresh!/2","title":"Evision.GeneralizedHough.setCannyLowThresh!/2","type":"function"},{"doc":"Positional Arguments cannyLowThresh : int Python prototype (for reference): setCannyLowThresh(cannyLowThresh) -&gt; None","ref":"Evision.GeneralizedHough.html#setCannyLowThresh/2","title":"Evision.GeneralizedHough.setCannyLowThresh/2","type":"function"},{"doc":"Raising version of setDp/2 .","ref":"Evision.GeneralizedHough.html#setDp!/2","title":"Evision.GeneralizedHough.setDp!/2","type":"function"},{"doc":"Positional Arguments dp : double Python prototype (for reference): setDp(dp) -&gt; None","ref":"Evision.GeneralizedHough.html#setDp/2","title":"Evision.GeneralizedHough.setDp/2","type":"function"},{"doc":"Raising version of setMaxBufferSize/2 .","ref":"Evision.GeneralizedHough.html#setMaxBufferSize!/2","title":"Evision.GeneralizedHough.setMaxBufferSize!/2","type":"function"},{"doc":"Positional Arguments maxBufferSize : int Python prototype (for reference): setMaxBufferSize(maxBufferSize) -&gt; None","ref":"Evision.GeneralizedHough.html#setMaxBufferSize/2","title":"Evision.GeneralizedHough.setMaxBufferSize/2","type":"function"},{"doc":"Raising version of setMinDist/2 .","ref":"Evision.GeneralizedHough.html#setMinDist!/2","title":"Evision.GeneralizedHough.setMinDist!/2","type":"function"},{"doc":"Positional Arguments minDist : double Python prototype (for reference): setMinDist(minDist) -&gt; None","ref":"Evision.GeneralizedHough.html#setMinDist/2","title":"Evision.GeneralizedHough.setMinDist/2","type":"function"},{"doc":"Raising version of setTemplate/2 .","ref":"Evision.GeneralizedHough.html#setTemplate!/2","title":"Evision.GeneralizedHough.setTemplate!/2","type":"function"},{"doc":"Raising version of setTemplate/3 .","ref":"Evision.GeneralizedHough.html#setTemplate!/3","title":"Evision.GeneralizedHough.setTemplate!/3","type":"function"},{"doc":"Raising version of setTemplate/4 .","ref":"Evision.GeneralizedHough.html#setTemplate!/4","title":"Evision.GeneralizedHough.setTemplate!/4","type":"function"},{"doc":"Raising version of setTemplate/5 .","ref":"Evision.GeneralizedHough.html#setTemplate!/5","title":"Evision.GeneralizedHough.setTemplate!/5","type":"function"},{"doc":"Positional Arguments templ : Evision.Mat Keyword Arguments templCenter : Point . Python prototype (for reference): setTemplate(templ[, templCenter]) -&gt; None","ref":"Evision.GeneralizedHough.html#setTemplate/2","title":"Evision.GeneralizedHough.setTemplate/2","type":"function"},{"doc":"Positional Arguments templ : Evision.Mat Keyword Arguments templCenter : Point . Python prototype (for reference): setTemplate(templ[, templCenter]) -&gt; None","ref":"Evision.GeneralizedHough.html#setTemplate/3","title":"Evision.GeneralizedHough.setTemplate/3","type":"function"},{"doc":"Positional Arguments edges : Evision.Mat dx : Evision.Mat dy : Evision.Mat Keyword Arguments templCenter : Point . Python prototype (for reference): setTemplate(edges, dx, dy[, templCenter]) -&gt; None","ref":"Evision.GeneralizedHough.html#setTemplate/4","title":"Evision.GeneralizedHough.setTemplate/4","type":"function"},{"doc":"Positional Arguments edges : Evision.Mat dx : Evision.Mat dy : Evision.Mat Keyword Arguments templCenter : Point . Python prototype (for reference): setTemplate(edges, dx, dy[, templCenter]) -&gt; None","ref":"Evision.GeneralizedHough.html#setTemplate/5","title":"Evision.GeneralizedHough.setTemplate/5","type":"function"},{"doc":"","ref":"Evision.GeneralizedHoughBallard.html","title":"Evision.GeneralizedHoughBallard","type":"module"},{"doc":"Raising version of getLevels/1 .","ref":"Evision.GeneralizedHoughBallard.html#getLevels!/1","title":"Evision.GeneralizedHoughBallard.getLevels!/1","type":"function"},{"doc":"Python prototype (for reference): getLevels() -&gt; retval","ref":"Evision.GeneralizedHoughBallard.html#getLevels/1","title":"Evision.GeneralizedHoughBallard.getLevels/1","type":"function"},{"doc":"Raising version of getVotesThreshold/1 .","ref":"Evision.GeneralizedHoughBallard.html#getVotesThreshold!/1","title":"Evision.GeneralizedHoughBallard.getVotesThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getVotesThreshold() -&gt; retval","ref":"Evision.GeneralizedHoughBallard.html#getVotesThreshold/1","title":"Evision.GeneralizedHoughBallard.getVotesThreshold/1","type":"function"},{"doc":"Raising version of setLevels/2 .","ref":"Evision.GeneralizedHoughBallard.html#setLevels!/2","title":"Evision.GeneralizedHoughBallard.setLevels!/2","type":"function"},{"doc":"Positional Arguments levels : int Python prototype (for reference): setLevels(levels) -&gt; None","ref":"Evision.GeneralizedHoughBallard.html#setLevels/2","title":"Evision.GeneralizedHoughBallard.setLevels/2","type":"function"},{"doc":"Raising version of setVotesThreshold/2 .","ref":"Evision.GeneralizedHoughBallard.html#setVotesThreshold!/2","title":"Evision.GeneralizedHoughBallard.setVotesThreshold!/2","type":"function"},{"doc":"Positional Arguments votesThreshold : int Python prototype (for reference): setVotesThreshold(votesThreshold) -&gt; None","ref":"Evision.GeneralizedHoughBallard.html#setVotesThreshold/2","title":"Evision.GeneralizedHoughBallard.setVotesThreshold/2","type":"function"},{"doc":"","ref":"Evision.GeneralizedHoughGuil.html","title":"Evision.GeneralizedHoughGuil","type":"module"},{"doc":"Raising version of getAngleEpsilon/1 .","ref":"Evision.GeneralizedHoughGuil.html#getAngleEpsilon!/1","title":"Evision.GeneralizedHoughGuil.getAngleEpsilon!/1","type":"function"},{"doc":"Python prototype (for reference): getAngleEpsilon() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getAngleEpsilon/1","title":"Evision.GeneralizedHoughGuil.getAngleEpsilon/1","type":"function"},{"doc":"Raising version of getAngleStep/1 .","ref":"Evision.GeneralizedHoughGuil.html#getAngleStep!/1","title":"Evision.GeneralizedHoughGuil.getAngleStep!/1","type":"function"},{"doc":"Python prototype (for reference): getAngleStep() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getAngleStep/1","title":"Evision.GeneralizedHoughGuil.getAngleStep/1","type":"function"},{"doc":"Raising version of getAngleThresh/1 .","ref":"Evision.GeneralizedHoughGuil.html#getAngleThresh!/1","title":"Evision.GeneralizedHoughGuil.getAngleThresh!/1","type":"function"},{"doc":"Python prototype (for reference): getAngleThresh() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getAngleThresh/1","title":"Evision.GeneralizedHoughGuil.getAngleThresh/1","type":"function"},{"doc":"Raising version of getLevels/1 .","ref":"Evision.GeneralizedHoughGuil.html#getLevels!/1","title":"Evision.GeneralizedHoughGuil.getLevels!/1","type":"function"},{"doc":"Python prototype (for reference): getLevels() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getLevels/1","title":"Evision.GeneralizedHoughGuil.getLevels/1","type":"function"},{"doc":"Raising version of getMaxAngle/1 .","ref":"Evision.GeneralizedHoughGuil.html#getMaxAngle!/1","title":"Evision.GeneralizedHoughGuil.getMaxAngle!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxAngle() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getMaxAngle/1","title":"Evision.GeneralizedHoughGuil.getMaxAngle/1","type":"function"},{"doc":"Raising version of getMaxScale/1 .","ref":"Evision.GeneralizedHoughGuil.html#getMaxScale!/1","title":"Evision.GeneralizedHoughGuil.getMaxScale!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxScale() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getMaxScale/1","title":"Evision.GeneralizedHoughGuil.getMaxScale/1","type":"function"},{"doc":"Raising version of getMinAngle/1 .","ref":"Evision.GeneralizedHoughGuil.html#getMinAngle!/1","title":"Evision.GeneralizedHoughGuil.getMinAngle!/1","type":"function"},{"doc":"Python prototype (for reference): getMinAngle() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getMinAngle/1","title":"Evision.GeneralizedHoughGuil.getMinAngle/1","type":"function"},{"doc":"Raising version of getMinScale/1 .","ref":"Evision.GeneralizedHoughGuil.html#getMinScale!/1","title":"Evision.GeneralizedHoughGuil.getMinScale!/1","type":"function"},{"doc":"Python prototype (for reference): getMinScale() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getMinScale/1","title":"Evision.GeneralizedHoughGuil.getMinScale/1","type":"function"},{"doc":"Raising version of getPosThresh/1 .","ref":"Evision.GeneralizedHoughGuil.html#getPosThresh!/1","title":"Evision.GeneralizedHoughGuil.getPosThresh!/1","type":"function"},{"doc":"Python prototype (for reference): getPosThresh() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getPosThresh/1","title":"Evision.GeneralizedHoughGuil.getPosThresh/1","type":"function"},{"doc":"Raising version of getScaleStep/1 .","ref":"Evision.GeneralizedHoughGuil.html#getScaleStep!/1","title":"Evision.GeneralizedHoughGuil.getScaleStep!/1","type":"function"},{"doc":"Python prototype (for reference): getScaleStep() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getScaleStep/1","title":"Evision.GeneralizedHoughGuil.getScaleStep/1","type":"function"},{"doc":"Raising version of getScaleThresh/1 .","ref":"Evision.GeneralizedHoughGuil.html#getScaleThresh!/1","title":"Evision.GeneralizedHoughGuil.getScaleThresh!/1","type":"function"},{"doc":"Python prototype (for reference): getScaleThresh() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getScaleThresh/1","title":"Evision.GeneralizedHoughGuil.getScaleThresh/1","type":"function"},{"doc":"Raising version of getXi/1 .","ref":"Evision.GeneralizedHoughGuil.html#getXi!/1","title":"Evision.GeneralizedHoughGuil.getXi!/1","type":"function"},{"doc":"Python prototype (for reference): getXi() -&gt; retval","ref":"Evision.GeneralizedHoughGuil.html#getXi/1","title":"Evision.GeneralizedHoughGuil.getXi/1","type":"function"},{"doc":"Raising version of setAngleEpsilon/2 .","ref":"Evision.GeneralizedHoughGuil.html#setAngleEpsilon!/2","title":"Evision.GeneralizedHoughGuil.setAngleEpsilon!/2","type":"function"},{"doc":"Positional Arguments angleEpsilon : double Python prototype (for reference): setAngleEpsilon(angleEpsilon) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setAngleEpsilon/2","title":"Evision.GeneralizedHoughGuil.setAngleEpsilon/2","type":"function"},{"doc":"Raising version of setAngleStep/2 .","ref":"Evision.GeneralizedHoughGuil.html#setAngleStep!/2","title":"Evision.GeneralizedHoughGuil.setAngleStep!/2","type":"function"},{"doc":"Positional Arguments angleStep : double Python prototype (for reference): setAngleStep(angleStep) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setAngleStep/2","title":"Evision.GeneralizedHoughGuil.setAngleStep/2","type":"function"},{"doc":"Raising version of setAngleThresh/2 .","ref":"Evision.GeneralizedHoughGuil.html#setAngleThresh!/2","title":"Evision.GeneralizedHoughGuil.setAngleThresh!/2","type":"function"},{"doc":"Positional Arguments angleThresh : int Python prototype (for reference): setAngleThresh(angleThresh) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setAngleThresh/2","title":"Evision.GeneralizedHoughGuil.setAngleThresh/2","type":"function"},{"doc":"Raising version of setLevels/2 .","ref":"Evision.GeneralizedHoughGuil.html#setLevels!/2","title":"Evision.GeneralizedHoughGuil.setLevels!/2","type":"function"},{"doc":"Positional Arguments levels : int Python prototype (for reference): setLevels(levels) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setLevels/2","title":"Evision.GeneralizedHoughGuil.setLevels/2","type":"function"},{"doc":"Raising version of setMaxAngle/2 .","ref":"Evision.GeneralizedHoughGuil.html#setMaxAngle!/2","title":"Evision.GeneralizedHoughGuil.setMaxAngle!/2","type":"function"},{"doc":"Positional Arguments maxAngle : double Python prototype (for reference): setMaxAngle(maxAngle) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setMaxAngle/2","title":"Evision.GeneralizedHoughGuil.setMaxAngle/2","type":"function"},{"doc":"Raising version of setMaxScale/2 .","ref":"Evision.GeneralizedHoughGuil.html#setMaxScale!/2","title":"Evision.GeneralizedHoughGuil.setMaxScale!/2","type":"function"},{"doc":"Positional Arguments maxScale : double Python prototype (for reference): setMaxScale(maxScale) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setMaxScale/2","title":"Evision.GeneralizedHoughGuil.setMaxScale/2","type":"function"},{"doc":"Raising version of setMinAngle/2 .","ref":"Evision.GeneralizedHoughGuil.html#setMinAngle!/2","title":"Evision.GeneralizedHoughGuil.setMinAngle!/2","type":"function"},{"doc":"Positional Arguments minAngle : double Python prototype (for reference): setMinAngle(minAngle) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setMinAngle/2","title":"Evision.GeneralizedHoughGuil.setMinAngle/2","type":"function"},{"doc":"Raising version of setMinScale/2 .","ref":"Evision.GeneralizedHoughGuil.html#setMinScale!/2","title":"Evision.GeneralizedHoughGuil.setMinScale!/2","type":"function"},{"doc":"Positional Arguments minScale : double Python prototype (for reference): setMinScale(minScale) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setMinScale/2","title":"Evision.GeneralizedHoughGuil.setMinScale/2","type":"function"},{"doc":"Raising version of setPosThresh/2 .","ref":"Evision.GeneralizedHoughGuil.html#setPosThresh!/2","title":"Evision.GeneralizedHoughGuil.setPosThresh!/2","type":"function"},{"doc":"Positional Arguments posThresh : int Python prototype (for reference): setPosThresh(posThresh) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setPosThresh/2","title":"Evision.GeneralizedHoughGuil.setPosThresh/2","type":"function"},{"doc":"Raising version of setScaleStep/2 .","ref":"Evision.GeneralizedHoughGuil.html#setScaleStep!/2","title":"Evision.GeneralizedHoughGuil.setScaleStep!/2","type":"function"},{"doc":"Positional Arguments scaleStep : double Python prototype (for reference): setScaleStep(scaleStep) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setScaleStep/2","title":"Evision.GeneralizedHoughGuil.setScaleStep/2","type":"function"},{"doc":"Raising version of setScaleThresh/2 .","ref":"Evision.GeneralizedHoughGuil.html#setScaleThresh!/2","title":"Evision.GeneralizedHoughGuil.setScaleThresh!/2","type":"function"},{"doc":"Positional Arguments scaleThresh : int Python prototype (for reference): setScaleThresh(scaleThresh) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setScaleThresh/2","title":"Evision.GeneralizedHoughGuil.setScaleThresh/2","type":"function"},{"doc":"Raising version of setXi/2 .","ref":"Evision.GeneralizedHoughGuil.html#setXi!/2","title":"Evision.GeneralizedHoughGuil.setXi!/2","type":"function"},{"doc":"Positional Arguments xi : double Python prototype (for reference): setXi(xi) -&gt; None","ref":"Evision.GeneralizedHoughGuil.html#setXi/2","title":"Evision.GeneralizedHoughGuil.setXi/2","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html","title":"Evision.HOGDescriptor","type":"module"},{"doc":"Raising version of checkDetectorSize/1 .","ref":"Evision.HOGDescriptor.html#checkDetectorSize!/1","title":"Evision.HOGDescriptor.checkDetectorSize!/1","type":"function"},{"doc":"Checks if detector size equal to descriptor size. Python prototype (for reference): checkDetectorSize() -&gt; retval","ref":"Evision.HOGDescriptor.html#checkDetectorSize/1","title":"Evision.HOGDescriptor.checkDetectorSize/1","type":"function"},{"doc":"Raising version of compute/2 .","ref":"Evision.HOGDescriptor.html#compute!/2","title":"Evision.HOGDescriptor.compute!/2","type":"function"},{"doc":"Raising version of compute/3 .","ref":"Evision.HOGDescriptor.html#compute!/3","title":"Evision.HOGDescriptor.compute!/3","type":"function"},{"doc":"Computes HOG descriptors of given image. Positional Arguments img : Evision.Mat . Matrix of the type CV_8U containing an image where HOG features will be calculated. Keyword Arguments winStride : Size . Window stride. It must be a multiple of block stride. padding : Size . Padding locations : [Point] . Vector of Point Return descriptors : [float] . Matrix of the type CV_32F Python prototype (for reference): compute(img[, winStride[, padding[, locations]]]) -&gt; descriptors","ref":"Evision.HOGDescriptor.html#compute/2","title":"Evision.HOGDescriptor.compute/2","type":"function"},{"doc":"Computes HOG descriptors of given image. Positional Arguments img : Evision.Mat . Matrix of the type CV_8U containing an image where HOG features will be calculated. Keyword Arguments winStride : Size . Window stride. It must be a multiple of block stride. padding : Size . Padding locations : [Point] . Vector of Point Return descriptors : [float] . Matrix of the type CV_32F Python prototype (for reference): compute(img[, winStride[, padding[, locations]]]) -&gt; descriptors","ref":"Evision.HOGDescriptor.html#compute/3","title":"Evision.HOGDescriptor.compute/3","type":"function"},{"doc":"Raising version of computeGradient/4 .","ref":"Evision.HOGDescriptor.html#computeGradient!/4","title":"Evision.HOGDescriptor.computeGradient!/4","type":"function"},{"doc":"Raising version of computeGradient/5 .","ref":"Evision.HOGDescriptor.html#computeGradient!/5","title":"Evision.HOGDescriptor.computeGradient!/5","type":"function"},{"doc":"Computes gradients and quantized gradient orientations. Positional Arguments img : Evision.Mat . Matrix contains the image to be computed Keyword Arguments paddingTL : Size . Padding from top-left paddingBR : Size . Padding from bottom-right Return grad : Evision.Mat . Matrix of type CV_32FC2 contains computed gradients angleOfs : Evision.Mat . Matrix of type CV_8UC2 contains quantized gradient orientations Python prototype (for reference): computeGradient(img, grad, angleOfs[, paddingTL[, paddingBR]]) -&gt; grad, angleOfs","ref":"Evision.HOGDescriptor.html#computeGradient/4","title":"Evision.HOGDescriptor.computeGradient/4","type":"function"},{"doc":"Computes gradients and quantized gradient orientations. Positional Arguments img : Evision.Mat . Matrix contains the image to be computed Keyword Arguments paddingTL : Size . Padding from top-left paddingBR : Size . Padding from bottom-right Return grad : Evision.Mat . Matrix of type CV_32FC2 contains computed gradients angleOfs : Evision.Mat . Matrix of type CV_8UC2 contains quantized gradient orientations Python prototype (for reference): computeGradient(img, grad, angleOfs[, paddingTL[, paddingBR]]) -&gt; grad, angleOfs","ref":"Evision.HOGDescriptor.html#computeGradient/5","title":"Evision.HOGDescriptor.computeGradient/5","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.HOGDescriptor.html#detect!/2","title":"Evision.HOGDescriptor.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.HOGDescriptor.html#detect!/3","title":"Evision.HOGDescriptor.detect!/3","type":"function"},{"doc":"Performs object detection without a multi-scale window. Positional Arguments img : Evision.Mat . Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected. Keyword Arguments hitThreshold : double . Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here. winStride : Size . Window stride. It must be a multiple of block stride. padding : Size . Padding searchLocations : [Point] . Vector of Point includes set of requested locations to be evaluated. Return foundLocations : [Point] . Vector of point where each point contains left-top corner point of detected object boundaries. weights : [double] . Vector that will contain confidence values for each detected object. Python prototype (for reference): detect(img[, hitThreshold[, winStride[, padding[, searchLocations]]]]) -&gt; foundLocations, weights","ref":"Evision.HOGDescriptor.html#detect/2","title":"Evision.HOGDescriptor.detect/2","type":"function"},{"doc":"Performs object detection without a multi-scale window. Positional Arguments img : Evision.Mat . Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected. Keyword Arguments hitThreshold : double . Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here. winStride : Size . Window stride. It must be a multiple of block stride. padding : Size . Padding searchLocations : [Point] . Vector of Point includes set of requested locations to be evaluated. Return foundLocations : [Point] . Vector of point where each point contains left-top corner point of detected object boundaries. weights : [double] . Vector that will contain confidence values for each detected object. Python prototype (for reference): detect(img[, hitThreshold[, winStride[, padding[, searchLocations]]]]) -&gt; foundLocations, weights","ref":"Evision.HOGDescriptor.html#detect/3","title":"Evision.HOGDescriptor.detect/3","type":"function"},{"doc":"Raising version of detectMultiScale/2 .","ref":"Evision.HOGDescriptor.html#detectMultiScale!/2","title":"Evision.HOGDescriptor.detectMultiScale!/2","type":"function"},{"doc":"Raising version of detectMultiScale/3 .","ref":"Evision.HOGDescriptor.html#detectMultiScale!/3","title":"Evision.HOGDescriptor.detectMultiScale!/3","type":"function"},{"doc":"Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles. Positional Arguments img : Evision.Mat . Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected. Keyword Arguments hitThreshold : double . Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here. winStride : Size . Window stride. It must be a multiple of block stride. padding : Size . Padding scale : double . Coefficient of the detection window increase. groupThreshold : double . Coefficient to regulate the similarity threshold. When detected, some objects can be covered by many rectangles. 0 means not to perform grouping. useMeanshiftGrouping : bool . indicates grouping algorithm Return foundLocations : [Rect] . Vector of rectangles where each rectangle contains the detected object. foundWeights : [double] . Vector that will contain confidence values for each detected object. Python prototype (for reference): detectMultiScale(img[, hitThreshold[, winStride[, padding[, scale[, groupThreshold[, useMeanshiftGrouping]]]]]]) -&gt; foundLocations, foundWeights","ref":"Evision.HOGDescriptor.html#detectMultiScale/2","title":"Evision.HOGDescriptor.detectMultiScale/2","type":"function"},{"doc":"Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles. Positional Arguments img : Evision.Mat . Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected. Keyword Arguments hitThreshold : double . Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here. winStride : Size . Window stride. It must be a multiple of block stride. padding : Size . Padding scale : double . Coefficient of the detection window increase. groupThreshold : double . Coefficient to regulate the similarity threshold. When detected, some objects can be covered by many rectangles. 0 means not to perform grouping. useMeanshiftGrouping : bool . indicates grouping algorithm Return foundLocations : [Rect] . Vector of rectangles where each rectangle contains the detected object. foundWeights : [double] . Vector that will contain confidence values for each detected object. Python prototype (for reference): detectMultiScale(img[, hitThreshold[, winStride[, padding[, scale[, groupThreshold[, useMeanshiftGrouping]]]]]]) -&gt; foundLocations, foundWeights","ref":"Evision.HOGDescriptor.html#detectMultiScale/3","title":"Evision.HOGDescriptor.detectMultiScale/3","type":"function"},{"doc":"Raising version of get_blockSize/1 .","ref":"Evision.HOGDescriptor.html#get_blockSize!/1","title":"Evision.HOGDescriptor.get_blockSize!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_blockSize/1","title":"Evision.HOGDescriptor.get_blockSize/1","type":"function"},{"doc":"Raising version of get_blockStride/1 .","ref":"Evision.HOGDescriptor.html#get_blockStride!/1","title":"Evision.HOGDescriptor.get_blockStride!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_blockStride/1","title":"Evision.HOGDescriptor.get_blockStride/1","type":"function"},{"doc":"Raising version of get_cellSize/1 .","ref":"Evision.HOGDescriptor.html#get_cellSize!/1","title":"Evision.HOGDescriptor.get_cellSize!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_cellSize/1","title":"Evision.HOGDescriptor.get_cellSize/1","type":"function"},{"doc":"Raising version of get_derivAperture/1 .","ref":"Evision.HOGDescriptor.html#get_derivAperture!/1","title":"Evision.HOGDescriptor.get_derivAperture!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_derivAperture/1","title":"Evision.HOGDescriptor.get_derivAperture/1","type":"function"},{"doc":"Raising version of get_gammaCorrection/1 .","ref":"Evision.HOGDescriptor.html#get_gammaCorrection!/1","title":"Evision.HOGDescriptor.get_gammaCorrection!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_gammaCorrection/1","title":"Evision.HOGDescriptor.get_gammaCorrection/1","type":"function"},{"doc":"Raising version of get_histogramNormType/1 .","ref":"Evision.HOGDescriptor.html#get_histogramNormType!/1","title":"Evision.HOGDescriptor.get_histogramNormType!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_histogramNormType/1","title":"Evision.HOGDescriptor.get_histogramNormType/1","type":"function"},{"doc":"Raising version of get_L2HysThreshold/1 .","ref":"Evision.HOGDescriptor.html#get_L2HysThreshold!/1","title":"Evision.HOGDescriptor.get_L2HysThreshold!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_L2HysThreshold/1","title":"Evision.HOGDescriptor.get_L2HysThreshold/1","type":"function"},{"doc":"Raising version of get_nbins/1 .","ref":"Evision.HOGDescriptor.html#get_nbins!/1","title":"Evision.HOGDescriptor.get_nbins!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_nbins/1","title":"Evision.HOGDescriptor.get_nbins/1","type":"function"},{"doc":"Raising version of get_nlevels/1 .","ref":"Evision.HOGDescriptor.html#get_nlevels!/1","title":"Evision.HOGDescriptor.get_nlevels!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_nlevels/1","title":"Evision.HOGDescriptor.get_nlevels/1","type":"function"},{"doc":"Raising version of get_signedGradient/1 .","ref":"Evision.HOGDescriptor.html#get_signedGradient!/1","title":"Evision.HOGDescriptor.get_signedGradient!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_signedGradient/1","title":"Evision.HOGDescriptor.get_signedGradient/1","type":"function"},{"doc":"Raising version of get_svmDetector/1 .","ref":"Evision.HOGDescriptor.html#get_svmDetector!/1","title":"Evision.HOGDescriptor.get_svmDetector!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_svmDetector/1","title":"Evision.HOGDescriptor.get_svmDetector/1","type":"function"},{"doc":"Raising version of get_winSigma/1 .","ref":"Evision.HOGDescriptor.html#get_winSigma!/1","title":"Evision.HOGDescriptor.get_winSigma!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_winSigma/1","title":"Evision.HOGDescriptor.get_winSigma/1","type":"function"},{"doc":"Raising version of get_winSize/1 .","ref":"Evision.HOGDescriptor.html#get_winSize!/1","title":"Evision.HOGDescriptor.get_winSize!/1","type":"function"},{"doc":"","ref":"Evision.HOGDescriptor.html#get_winSize/1","title":"Evision.HOGDescriptor.get_winSize/1","type":"function"},{"doc":"Raising version of getDaimlerPeopleDetector/0 .","ref":"Evision.HOGDescriptor.html#getDaimlerPeopleDetector!/0","title":"Evision.HOGDescriptor.getDaimlerPeopleDetector!/0","type":"function"},{"doc":"Returns coefficients of the classifier trained for people detection (for 48x96 windows). Python prototype (for reference): getDaimlerPeopleDetector() -&gt; retval","ref":"Evision.HOGDescriptor.html#getDaimlerPeopleDetector/0","title":"Evision.HOGDescriptor.getDaimlerPeopleDetector/0","type":"function"},{"doc":"Raising version of getDefaultPeopleDetector/0 .","ref":"Evision.HOGDescriptor.html#getDefaultPeopleDetector!/0","title":"Evision.HOGDescriptor.getDefaultPeopleDetector!/0","type":"function"},{"doc":"Returns coefficients of the classifier trained for people detection (for 64x128 windows). Python prototype (for reference): getDefaultPeopleDetector() -&gt; retval","ref":"Evision.HOGDescriptor.html#getDefaultPeopleDetector/0","title":"Evision.HOGDescriptor.getDefaultPeopleDetector/0","type":"function"},{"doc":"Raising version of getDescriptorSize/1 .","ref":"Evision.HOGDescriptor.html#getDescriptorSize!/1","title":"Evision.HOGDescriptor.getDescriptorSize!/1","type":"function"},{"doc":"Returns the number of coefficients required for the classification. Python prototype (for reference): getDescriptorSize() -&gt; retval","ref":"Evision.HOGDescriptor.html#getDescriptorSize/1","title":"Evision.HOGDescriptor.getDescriptorSize/1","type":"function"},{"doc":"Raising version of getWinSigma/1 .","ref":"Evision.HOGDescriptor.html#getWinSigma!/1","title":"Evision.HOGDescriptor.getWinSigma!/1","type":"function"},{"doc":"Returns winSigma value Python prototype (for reference): getWinSigma() -&gt; retval","ref":"Evision.HOGDescriptor.html#getWinSigma/1","title":"Evision.HOGDescriptor.getWinSigma/1","type":"function"},{"doc":"Raising version of hogDescriptor/0 .","ref":"Evision.HOGDescriptor.html#hogDescriptor!/0","title":"Evision.HOGDescriptor.hogDescriptor!/0","type":"function"},{"doc":"Raising version of hogDescriptor/1 .","ref":"Evision.HOGDescriptor.html#hogDescriptor!/1","title":"Evision.HOGDescriptor.hogDescriptor!/1","type":"function"},{"doc":"Raising version of hogDescriptor/5 .","ref":"Evision.HOGDescriptor.html#hogDescriptor!/5","title":"Evision.HOGDescriptor.hogDescriptor!/5","type":"function"},{"doc":"Raising version of hogDescriptor/6 .","ref":"Evision.HOGDescriptor.html#hogDescriptor!/6","title":"Evision.HOGDescriptor.hogDescriptor!/6","type":"function"},{"doc":"Creates the HOG descriptor and detector with default parameters. aqual to HOGDescriptor(Size(64,128), Size(16,16), Size(8,8), Size(8,8), 9 ) Python prototype (for reference): HOGDescriptor() -&gt; &lt;HOGDescriptor object&gt;","ref":"Evision.HOGDescriptor.html#hogDescriptor/0","title":"Evision.HOGDescriptor.hogDescriptor/0","type":"function"},{"doc":"Positional Arguments filename : String . The file name containing HOGDescriptor properties and coefficients for the linear SVM classifier. Has overloading in C++ Creates the HOG descriptor and detector and loads HOGDescriptor parameters and coefficients for the linear SVM classifier from a file. Python prototype (for reference): HOGDescriptor(filename) -&gt; &lt;HOGDescriptor object&gt;","ref":"Evision.HOGDescriptor.html#hogDescriptor/1","title":"Evision.HOGDescriptor.hogDescriptor/1","type":"function"},{"doc":"Positional Arguments winSize : Size . sets winSize with given value. blockSize : Size . sets blockSize with given value. blockStride : Size . sets blockStride with given value. cellSize : Size . sets cellSize with given value. nbins : int . sets nbins with given value. Keyword Arguments derivAperture : int . sets derivAperture with given value. winSigma : double . sets winSigma with given value. histogramNormType : HOGDescriptor_HistogramNormType . sets histogramNormType with given value. l2HysThreshold : double . sets L2HysThreshold with given value. gammaCorrection : bool . sets gammaCorrection with given value. nlevels : int . sets nlevels with given value. signedGradient : bool . sets signedGradient with given value. Has overloading in C++ Python prototype (for reference): HOGDescriptor(_winSize, _blockSize, _blockStride, _cellSize, _nbins[, _derivAperture[, _winSigma[, _histogramNormType[, _L2HysThreshold[, _gammaCorrection[, _nlevels[, _signedGradient]]]]]]]) -&gt; &lt;HOGDescriptor object&gt;","ref":"Evision.HOGDescriptor.html#hogDescriptor/5","title":"Evision.HOGDescriptor.hogDescriptor/5","type":"function"},{"doc":"Positional Arguments winSize : Size . sets winSize with given value. blockSize : Size . sets blockSize with given value. blockStride : Size . sets blockStride with given value. cellSize : Size . sets cellSize with given value. nbins : int . sets nbins with given value. Keyword Arguments derivAperture : int . sets derivAperture with given value. winSigma : double . sets winSigma with given value. histogramNormType : HOGDescriptor_HistogramNormType . sets histogramNormType with given value. l2HysThreshold : double . sets L2HysThreshold with given value. gammaCorrection : bool . sets gammaCorrection with given value. nlevels : int . sets nlevels with given value. signedGradient : bool . sets signedGradient with given value. Has overloading in C++ Python prototype (for reference): HOGDescriptor(_winSize, _blockSize, _blockStride, _cellSize, _nbins[, _derivAperture[, _winSigma[, _histogramNormType[, _L2HysThreshold[, _gammaCorrection[, _nlevels[, _signedGradient]]]]]]]) -&gt; &lt;HOGDescriptor object&gt;","ref":"Evision.HOGDescriptor.html#hogDescriptor/6","title":"Evision.HOGDescriptor.hogDescriptor/6","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.HOGDescriptor.html#load!/2","title":"Evision.HOGDescriptor.load!/2","type":"function"},{"doc":"Raising version of load/3 .","ref":"Evision.HOGDescriptor.html#load!/3","title":"Evision.HOGDescriptor.load!/3","type":"function"},{"doc":"loads HOGDescriptor parameters and coefficients for the linear SVM classifier from a file Positional Arguments filename : String . Name of the file to read. Keyword Arguments objname : String . The optional name of the node to read (if empty, the first top-level node will be used). Python prototype (for reference): load(filename[, objname]) -&gt; retval","ref":"Evision.HOGDescriptor.html#load/2","title":"Evision.HOGDescriptor.load/2","type":"function"},{"doc":"loads HOGDescriptor parameters and coefficients for the linear SVM classifier from a file Positional Arguments filename : String . Name of the file to read. Keyword Arguments objname : String . The optional name of the node to read (if empty, the first top-level node will be used). Python prototype (for reference): load(filename[, objname]) -&gt; retval","ref":"Evision.HOGDescriptor.html#load/3","title":"Evision.HOGDescriptor.load/3","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.HOGDescriptor.html#save!/2","title":"Evision.HOGDescriptor.save!/2","type":"function"},{"doc":"Raising version of save/3 .","ref":"Evision.HOGDescriptor.html#save!/3","title":"Evision.HOGDescriptor.save!/3","type":"function"},{"doc":"saves HOGDescriptor parameters and coefficients for the linear SVM classifier to a file Positional Arguments filename : String . File name Keyword Arguments objname : String . Object name Python prototype (for reference): save(filename[, objname]) -&gt; None","ref":"Evision.HOGDescriptor.html#save/2","title":"Evision.HOGDescriptor.save/2","type":"function"},{"doc":"saves HOGDescriptor parameters and coefficients for the linear SVM classifier to a file Positional Arguments filename : String . File name Keyword Arguments objname : String . Object name Python prototype (for reference): save(filename[, objname]) -&gt; None","ref":"Evision.HOGDescriptor.html#save/3","title":"Evision.HOGDescriptor.save/3","type":"function"},{"doc":"Raising version of setSVMDetector/2 .","ref":"Evision.HOGDescriptor.html#setSVMDetector!/2","title":"Evision.HOGDescriptor.setSVMDetector!/2","type":"function"},{"doc":"Sets coefficients for the linear SVM classifier. Positional Arguments svmdetector : Evision.Mat . coefficients for the linear SVM classifier. Python prototype (for reference): setSVMDetector(svmdetector) -&gt; None","ref":"Evision.HOGDescriptor.html#setSVMDetector/2","title":"Evision.HOGDescriptor.setSVMDetector/2","type":"function"},{"doc":"OpenCV High-level Graphical User Interface","ref":"Evision.HighGui.html","title":"Evision.HighGui","type":"module"},{"doc":"Raising version of destroyAllWindows/0 .","ref":"Evision.HighGui.html#destroyAllWindows!/0","title":"Evision.HighGui.destroyAllWindows!/0","type":"function"},{"doc":"close all windows","ref":"Evision.HighGui.html#destroyAllWindows/0","title":"Evision.HighGui.destroyAllWindows/0","type":"function"},{"doc":"Raising version of destroyWindow/1 .","ref":"Evision.HighGui.html#destroyWindow!/1","title":"Evision.HighGui.destroyWindow!/1","type":"function"},{"doc":"close a named window","ref":"Evision.HighGui.html#destroyWindow/1","title":"Evision.HighGui.destroyWindow/1","type":"function"},{"doc":"Raising version of imshow/2 .","ref":"Evision.HighGui.html#imshow!/2","title":"Evision.HighGui.imshow!/2","type":"function"},{"doc":"Show a mat in a named window winname . The name of the window. mat . The image. Example { :ok , mat } = Evision . imread ( &quot;example.jpg&quot; ) Evision . imshow ( &quot;OpenCV&quot; , mat ) # the following line may be necessary on your system # will try to improve this later Evision . waitkey ( 0 )","ref":"Evision.HighGui.html#imshow/2","title":"Evision.HighGui.imshow/2","type":"function"},{"doc":"Raising version of waitkey/1 .","ref":"Evision.HighGui.html#waitkey!/1","title":"Evision.HighGui.waitkey!/1","type":"function"},{"doc":"wait for user keyboard event for a delay amount of time (ms)","ref":"Evision.HighGui.html#waitkey/1","title":"Evision.HighGui.waitkey/1","type":"function"},{"doc":"","ref":"Evision.IPP.html","title":"Evision.IPP","type":"module"},{"doc":"Raising version of getIppVersion/0 .","ref":"Evision.IPP.html#getIppVersion!/0","title":"Evision.IPP.getIppVersion!/0","type":"function"},{"doc":"Python prototype (for reference): getIppVersion() -&gt; retval","ref":"Evision.IPP.html#getIppVersion/0","title":"Evision.IPP.getIppVersion/0","type":"function"},{"doc":"Raising version of setUseIPP/1 .","ref":"Evision.IPP.html#setUseIPP!/1","title":"Evision.IPP.setUseIPP!/1","type":"function"},{"doc":"Positional Arguments flag : bool Python prototype (for reference): setUseIPP(flag) -&gt; None","ref":"Evision.IPP.html#setUseIPP/1","title":"Evision.IPP.setUseIPP/1","type":"function"},{"doc":"Raising version of useIPP/0 .","ref":"Evision.IPP.html#useIPP!/0","title":"Evision.IPP.useIPP!/0","type":"function"},{"doc":"proxy for hal::Cholesky Python prototype (for reference): useIPP() -&gt; retval","ref":"Evision.IPP.html#useIPP/0","title":"Evision.IPP.useIPP/0","type":"function"},{"doc":"","ref":"Evision.Internal.Structurise.html","title":"Evision.Internal.Structurise","type":"module"},{"doc":"","ref":"Evision.Internal.Structurise.html#from_struct/1","title":"Evision.Internal.Structurise.from_struct/1","type":"function"},{"doc":"","ref":"Evision.Internal.Structurise.html#to_struct/1","title":"Evision.Internal.Structurise.to_struct/1","type":"function"},{"doc":"","ref":"Evision.Internal.Structurise.html#to_struct_ok/1","title":"Evision.Internal.Structurise.to_struct_ok/1","type":"function"},{"doc":"","ref":"Evision.KAZE.html","title":"Evision.KAZE","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.KAZE.html#compute!/3","title":"Evision.KAZE.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.KAZE.html#compute!/4","title":"Evision.KAZE.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.KAZE.html#compute/3","title":"Evision.KAZE.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.KAZE.html#compute/4","title":"Evision.KAZE.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.KAZE.html#create!/0","title":"Evision.KAZE.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.KAZE.html#create!/1","title":"Evision.KAZE.create!/1","type":"function"},{"doc":"The KAZE constructor Keyword Arguments extended : bool . Set to enable extraction of extended (128-byte) descriptor. upright : bool . Set to enable use of upright descriptors (non rotation-invariant). threshold : float . Detector response threshold to accept point nOctaves : int . Maximum octave evolution of the image nOctaveLayers : int . Default number of sublevels per scale level diffusivity : KAZE_DiffusivityType . Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or DIFF_CHARBONNIER Python prototype (for reference): create([, extended[, upright[, threshold[, nOctaves[, nOctaveLayers[, diffusivity]]]]]]) -&gt; retval","ref":"Evision.KAZE.html#create/0","title":"Evision.KAZE.create/0","type":"function"},{"doc":"The KAZE constructor Keyword Arguments extended : bool . Set to enable extraction of extended (128-byte) descriptor. upright : bool . Set to enable use of upright descriptors (non rotation-invariant). threshold : float . Detector response threshold to accept point nOctaves : int . Maximum octave evolution of the image nOctaveLayers : int . Default number of sublevels per scale level diffusivity : KAZE_DiffusivityType . Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or DIFF_CHARBONNIER Python prototype (for reference): create([, extended[, upright[, threshold[, nOctaves[, nOctaveLayers[, diffusivity]]]]]]) -&gt; retval","ref":"Evision.KAZE.html#create/1","title":"Evision.KAZE.create/1","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.KAZE.html#defaultNorm!/1","title":"Evision.KAZE.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.KAZE.html#defaultNorm/1","title":"Evision.KAZE.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.KAZE.html#descriptorSize!/1","title":"Evision.KAZE.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.KAZE.html#descriptorSize/1","title":"Evision.KAZE.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.KAZE.html#descriptorType!/1","title":"Evision.KAZE.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.KAZE.html#descriptorType/1","title":"Evision.KAZE.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.KAZE.html#detect!/2","title":"Evision.KAZE.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.KAZE.html#detect!/3","title":"Evision.KAZE.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.KAZE.html#detect/2","title":"Evision.KAZE.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.KAZE.html#detect/3","title":"Evision.KAZE.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.KAZE.html#detectAndCompute!/3","title":"Evision.KAZE.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.KAZE.html#detectAndCompute!/4","title":"Evision.KAZE.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.KAZE.html#detectAndCompute/3","title":"Evision.KAZE.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.KAZE.html#detectAndCompute/4","title":"Evision.KAZE.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.KAZE.html#empty!/1","title":"Evision.KAZE.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.KAZE.html#empty/1","title":"Evision.KAZE.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.KAZE.html#getDefaultName!/1","title":"Evision.KAZE.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.KAZE.html#getDefaultName/1","title":"Evision.KAZE.getDefaultName/1","type":"function"},{"doc":"Raising version of getDiffusivity/1 .","ref":"Evision.KAZE.html#getDiffusivity!/1","title":"Evision.KAZE.getDiffusivity!/1","type":"function"},{"doc":"Python prototype (for reference): getDiffusivity() -&gt; retval","ref":"Evision.KAZE.html#getDiffusivity/1","title":"Evision.KAZE.getDiffusivity/1","type":"function"},{"doc":"Raising version of getExtended/1 .","ref":"Evision.KAZE.html#getExtended!/1","title":"Evision.KAZE.getExtended!/1","type":"function"},{"doc":"Python prototype (for reference): getExtended() -&gt; retval","ref":"Evision.KAZE.html#getExtended/1","title":"Evision.KAZE.getExtended/1","type":"function"},{"doc":"Raising version of getNOctaveLayers/1 .","ref":"Evision.KAZE.html#getNOctaveLayers!/1","title":"Evision.KAZE.getNOctaveLayers!/1","type":"function"},{"doc":"Python prototype (for reference): getNOctaveLayers() -&gt; retval","ref":"Evision.KAZE.html#getNOctaveLayers/1","title":"Evision.KAZE.getNOctaveLayers/1","type":"function"},{"doc":"Raising version of getNOctaves/1 .","ref":"Evision.KAZE.html#getNOctaves!/1","title":"Evision.KAZE.getNOctaves!/1","type":"function"},{"doc":"Python prototype (for reference): getNOctaves() -&gt; retval","ref":"Evision.KAZE.html#getNOctaves/1","title":"Evision.KAZE.getNOctaves/1","type":"function"},{"doc":"Raising version of getThreshold/1 .","ref":"Evision.KAZE.html#getThreshold!/1","title":"Evision.KAZE.getThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getThreshold() -&gt; retval","ref":"Evision.KAZE.html#getThreshold/1","title":"Evision.KAZE.getThreshold/1","type":"function"},{"doc":"Raising version of getUpright/1 .","ref":"Evision.KAZE.html#getUpright!/1","title":"Evision.KAZE.getUpright!/1","type":"function"},{"doc":"Python prototype (for reference): getUpright() -&gt; retval","ref":"Evision.KAZE.html#getUpright/1","title":"Evision.KAZE.getUpright/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.KAZE.html#read!/2","title":"Evision.KAZE.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.KAZE.html#read/2","title":"Evision.KAZE.read/2","type":"function"},{"doc":"Raising version of setDiffusivity/2 .","ref":"Evision.KAZE.html#setDiffusivity!/2","title":"Evision.KAZE.setDiffusivity!/2","type":"function"},{"doc":"Positional Arguments diff : KAZE_DiffusivityType Python prototype (for reference): setDiffusivity(diff) -&gt; None","ref":"Evision.KAZE.html#setDiffusivity/2","title":"Evision.KAZE.setDiffusivity/2","type":"function"},{"doc":"Raising version of setExtended/2 .","ref":"Evision.KAZE.html#setExtended!/2","title":"Evision.KAZE.setExtended!/2","type":"function"},{"doc":"Positional Arguments extended : bool Python prototype (for reference): setExtended(extended) -&gt; None","ref":"Evision.KAZE.html#setExtended/2","title":"Evision.KAZE.setExtended/2","type":"function"},{"doc":"Raising version of setNOctaveLayers/2 .","ref":"Evision.KAZE.html#setNOctaveLayers!/2","title":"Evision.KAZE.setNOctaveLayers!/2","type":"function"},{"doc":"Positional Arguments octaveLayers : int Python prototype (for reference): setNOctaveLayers(octaveLayers) -&gt; None","ref":"Evision.KAZE.html#setNOctaveLayers/2","title":"Evision.KAZE.setNOctaveLayers/2","type":"function"},{"doc":"Raising version of setNOctaves/2 .","ref":"Evision.KAZE.html#setNOctaves!/2","title":"Evision.KAZE.setNOctaves!/2","type":"function"},{"doc":"Positional Arguments octaves : int Python prototype (for reference): setNOctaves(octaves) -&gt; None","ref":"Evision.KAZE.html#setNOctaves/2","title":"Evision.KAZE.setNOctaves/2","type":"function"},{"doc":"Raising version of setThreshold/2 .","ref":"Evision.KAZE.html#setThreshold!/2","title":"Evision.KAZE.setThreshold!/2","type":"function"},{"doc":"Positional Arguments threshold : double Python prototype (for reference): setThreshold(threshold) -&gt; None","ref":"Evision.KAZE.html#setThreshold/2","title":"Evision.KAZE.setThreshold/2","type":"function"},{"doc":"Raising version of setUpright/2 .","ref":"Evision.KAZE.html#setUpright!/2","title":"Evision.KAZE.setUpright!/2","type":"function"},{"doc":"Positional Arguments upright : bool Python prototype (for reference): setUpright(upright) -&gt; None","ref":"Evision.KAZE.html#setUpright/2","title":"Evision.KAZE.setUpright/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.KAZE.html#write!/2","title":"Evision.KAZE.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.KAZE.html#write!/3","title":"Evision.KAZE.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.KAZE.html#write/2","title":"Evision.KAZE.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.KAZE.html#write/3","title":"Evision.KAZE.write/3","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html","title":"Evision.KalmanFilter","type":"module"},{"doc":"Raising version of correct/2 .","ref":"Evision.KalmanFilter.html#correct!/2","title":"Evision.KalmanFilter.correct!/2","type":"function"},{"doc":"Updates the predicted state from the measurement. Positional Arguments measurement : Evision.Mat . The measured system parameters Python prototype (for reference): correct(measurement) -&gt; retval","ref":"Evision.KalmanFilter.html#correct/2","title":"Evision.KalmanFilter.correct/2","type":"function"},{"doc":"Raising version of get_controlMatrix/1 .","ref":"Evision.KalmanFilter.html#get_controlMatrix!/1","title":"Evision.KalmanFilter.get_controlMatrix!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_controlMatrix/1","title":"Evision.KalmanFilter.get_controlMatrix/1","type":"function"},{"doc":"Raising version of get_errorCovPost/1 .","ref":"Evision.KalmanFilter.html#get_errorCovPost!/1","title":"Evision.KalmanFilter.get_errorCovPost!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_errorCovPost/1","title":"Evision.KalmanFilter.get_errorCovPost/1","type":"function"},{"doc":"Raising version of get_errorCovPre/1 .","ref":"Evision.KalmanFilter.html#get_errorCovPre!/1","title":"Evision.KalmanFilter.get_errorCovPre!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_errorCovPre/1","title":"Evision.KalmanFilter.get_errorCovPre/1","type":"function"},{"doc":"Raising version of get_gain/1 .","ref":"Evision.KalmanFilter.html#get_gain!/1","title":"Evision.KalmanFilter.get_gain!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_gain/1","title":"Evision.KalmanFilter.get_gain/1","type":"function"},{"doc":"Raising version of get_measurementMatrix/1 .","ref":"Evision.KalmanFilter.html#get_measurementMatrix!/1","title":"Evision.KalmanFilter.get_measurementMatrix!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_measurementMatrix/1","title":"Evision.KalmanFilter.get_measurementMatrix/1","type":"function"},{"doc":"Raising version of get_measurementNoiseCov/1 .","ref":"Evision.KalmanFilter.html#get_measurementNoiseCov!/1","title":"Evision.KalmanFilter.get_measurementNoiseCov!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_measurementNoiseCov/1","title":"Evision.KalmanFilter.get_measurementNoiseCov/1","type":"function"},{"doc":"Raising version of get_processNoiseCov/1 .","ref":"Evision.KalmanFilter.html#get_processNoiseCov!/1","title":"Evision.KalmanFilter.get_processNoiseCov!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_processNoiseCov/1","title":"Evision.KalmanFilter.get_processNoiseCov/1","type":"function"},{"doc":"Raising version of get_statePost/1 .","ref":"Evision.KalmanFilter.html#get_statePost!/1","title":"Evision.KalmanFilter.get_statePost!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_statePost/1","title":"Evision.KalmanFilter.get_statePost/1","type":"function"},{"doc":"Raising version of get_statePre/1 .","ref":"Evision.KalmanFilter.html#get_statePre!/1","title":"Evision.KalmanFilter.get_statePre!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_statePre/1","title":"Evision.KalmanFilter.get_statePre/1","type":"function"},{"doc":"Raising version of get_transitionMatrix/1 .","ref":"Evision.KalmanFilter.html#get_transitionMatrix!/1","title":"Evision.KalmanFilter.get_transitionMatrix!/1","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#get_transitionMatrix/1","title":"Evision.KalmanFilter.get_transitionMatrix/1","type":"function"},{"doc":"Raising version of kalmanFilter/0 .","ref":"Evision.KalmanFilter.html#kalmanFilter!/0","title":"Evision.KalmanFilter.kalmanFilter!/0","type":"function"},{"doc":"Raising version of kalmanFilter/2 .","ref":"Evision.KalmanFilter.html#kalmanFilter!/2","title":"Evision.KalmanFilter.kalmanFilter!/2","type":"function"},{"doc":"Raising version of kalmanFilter/3 .","ref":"Evision.KalmanFilter.html#kalmanFilter!/3","title":"Evision.KalmanFilter.kalmanFilter!/3","type":"function"},{"doc":"Python prototype (for reference): KalmanFilter() -&gt; &lt;KalmanFilter object&gt;","ref":"Evision.KalmanFilter.html#kalmanFilter/0","title":"Evision.KalmanFilter.kalmanFilter/0","type":"function"},{"doc":"Positional Arguments dynamParams : int . Dimensionality of the state. measureParams : int . Dimensionality of the measurement. Keyword Arguments controlParams : int . Dimensionality of the control vector. type : int . Type of the created matrices that should be CV_32F or CV_64F. Has overloading in C++ Python prototype (for reference): KalmanFilter(dynamParams, measureParams[, controlParams[, type]]) -&gt; &lt;KalmanFilter object&gt;","ref":"Evision.KalmanFilter.html#kalmanFilter/2","title":"Evision.KalmanFilter.kalmanFilter/2","type":"function"},{"doc":"Positional Arguments dynamParams : int . Dimensionality of the state. measureParams : int . Dimensionality of the measurement. Keyword Arguments controlParams : int . Dimensionality of the control vector. type : int . Type of the created matrices that should be CV_32F or CV_64F. Has overloading in C++ Python prototype (for reference): KalmanFilter(dynamParams, measureParams[, controlParams[, type]]) -&gt; &lt;KalmanFilter object&gt;","ref":"Evision.KalmanFilter.html#kalmanFilter/3","title":"Evision.KalmanFilter.kalmanFilter/3","type":"function"},{"doc":"Raising version of predict/1 .","ref":"Evision.KalmanFilter.html#predict!/1","title":"Evision.KalmanFilter.predict!/1","type":"function"},{"doc":"Computes a predicted state. Keyword Arguments control : Evision.Mat . The optional input control Python prototype (for reference): predict([, control]) -&gt; retval","ref":"Evision.KalmanFilter.html#predict/1","title":"Evision.KalmanFilter.predict/1","type":"function"},{"doc":"Raising version of set_controlMatrix/2 .","ref":"Evision.KalmanFilter.html#set_controlMatrix!/2","title":"Evision.KalmanFilter.set_controlMatrix!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_controlMatrix/2","title":"Evision.KalmanFilter.set_controlMatrix/2","type":"function"},{"doc":"Raising version of set_errorCovPost/2 .","ref":"Evision.KalmanFilter.html#set_errorCovPost!/2","title":"Evision.KalmanFilter.set_errorCovPost!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_errorCovPost/2","title":"Evision.KalmanFilter.set_errorCovPost/2","type":"function"},{"doc":"Raising version of set_errorCovPre/2 .","ref":"Evision.KalmanFilter.html#set_errorCovPre!/2","title":"Evision.KalmanFilter.set_errorCovPre!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_errorCovPre/2","title":"Evision.KalmanFilter.set_errorCovPre/2","type":"function"},{"doc":"Raising version of set_gain/2 .","ref":"Evision.KalmanFilter.html#set_gain!/2","title":"Evision.KalmanFilter.set_gain!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_gain/2","title":"Evision.KalmanFilter.set_gain/2","type":"function"},{"doc":"Raising version of set_measurementMatrix/2 .","ref":"Evision.KalmanFilter.html#set_measurementMatrix!/2","title":"Evision.KalmanFilter.set_measurementMatrix!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_measurementMatrix/2","title":"Evision.KalmanFilter.set_measurementMatrix/2","type":"function"},{"doc":"Raising version of set_measurementNoiseCov/2 .","ref":"Evision.KalmanFilter.html#set_measurementNoiseCov!/2","title":"Evision.KalmanFilter.set_measurementNoiseCov!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_measurementNoiseCov/2","title":"Evision.KalmanFilter.set_measurementNoiseCov/2","type":"function"},{"doc":"Raising version of set_processNoiseCov/2 .","ref":"Evision.KalmanFilter.html#set_processNoiseCov!/2","title":"Evision.KalmanFilter.set_processNoiseCov!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_processNoiseCov/2","title":"Evision.KalmanFilter.set_processNoiseCov/2","type":"function"},{"doc":"Raising version of set_statePost/2 .","ref":"Evision.KalmanFilter.html#set_statePost!/2","title":"Evision.KalmanFilter.set_statePost!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_statePost/2","title":"Evision.KalmanFilter.set_statePost/2","type":"function"},{"doc":"Raising version of set_statePre/2 .","ref":"Evision.KalmanFilter.html#set_statePre!/2","title":"Evision.KalmanFilter.set_statePre!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_statePre/2","title":"Evision.KalmanFilter.set_statePre/2","type":"function"},{"doc":"Raising version of set_transitionMatrix/2 .","ref":"Evision.KalmanFilter.html#set_transitionMatrix!/2","title":"Evision.KalmanFilter.set_transitionMatrix!/2","type":"function"},{"doc":"","ref":"Evision.KalmanFilter.html#set_transitionMatrix/2","title":"Evision.KalmanFilter.set_transitionMatrix/2","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html","title":"Evision.KeyPoint","type":"module"},{"doc":"Raising version of convert/1 .","ref":"Evision.KeyPoint.html#convert!/1","title":"Evision.KeyPoint.convert!/1","type":"function"},{"doc":"Raising version of convert/2 .","ref":"Evision.KeyPoint.html#convert!/2","title":"Evision.KeyPoint.convert!/2","type":"function"},{"doc":"Positional Arguments points2f : [Point2f] . Array of (x,y) coordinates of each keypoint Keyword Arguments size : float . keypoint diameter response : float . keypoint detector response on the keypoint (that is, strength of the keypoint) octave : int . pyramid octave in which the keypoint has been detected class_id : int . object id Return keypoints : [KeyPoint] . Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB Has overloading in C++ Python prototype (for reference): convert(points2f[, size[, response[, octave[, class_id]]]]) -&gt; keypoints","ref":"Evision.KeyPoint.html#convert/1","title":"Evision.KeyPoint.convert/1","type":"function"},{"doc":"Positional Arguments points2f : [Point2f] . Array of (x,y) coordinates of each keypoint Keyword Arguments size : float . keypoint diameter response : float . keypoint detector response on the keypoint (that is, strength of the keypoint) octave : int . pyramid octave in which the keypoint has been detected class_id : int . object id Return keypoints : [KeyPoint] . Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB Has overloading in C++ Python prototype (for reference): convert(points2f[, size[, response[, octave[, class_id]]]]) -&gt; keypoints","ref":"Evision.KeyPoint.html#convert/2","title":"Evision.KeyPoint.convert/2","type":"function"},{"doc":"Raising version of get_angle/1 .","ref":"Evision.KeyPoint.html#get_angle!/1","title":"Evision.KeyPoint.get_angle!/1","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#get_angle/1","title":"Evision.KeyPoint.get_angle/1","type":"function"},{"doc":"Raising version of get_class_id/1 .","ref":"Evision.KeyPoint.html#get_class_id!/1","title":"Evision.KeyPoint.get_class_id!/1","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#get_class_id/1","title":"Evision.KeyPoint.get_class_id/1","type":"function"},{"doc":"Raising version of get_octave/1 .","ref":"Evision.KeyPoint.html#get_octave!/1","title":"Evision.KeyPoint.get_octave!/1","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#get_octave/1","title":"Evision.KeyPoint.get_octave/1","type":"function"},{"doc":"Raising version of get_pt/1 .","ref":"Evision.KeyPoint.html#get_pt!/1","title":"Evision.KeyPoint.get_pt!/1","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#get_pt/1","title":"Evision.KeyPoint.get_pt/1","type":"function"},{"doc":"Raising version of get_response/1 .","ref":"Evision.KeyPoint.html#get_response!/1","title":"Evision.KeyPoint.get_response!/1","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#get_response/1","title":"Evision.KeyPoint.get_response/1","type":"function"},{"doc":"Raising version of get_size/1 .","ref":"Evision.KeyPoint.html#get_size!/1","title":"Evision.KeyPoint.get_size!/1","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#get_size/1","title":"Evision.KeyPoint.get_size/1","type":"function"},{"doc":"Raising version of keyPoint/0 .","ref":"Evision.KeyPoint.html#keyPoint!/0","title":"Evision.KeyPoint.keyPoint!/0","type":"function"},{"doc":"Raising version of keyPoint/3 .","ref":"Evision.KeyPoint.html#keyPoint!/3","title":"Evision.KeyPoint.keyPoint!/3","type":"function"},{"doc":"Raising version of keyPoint/4 .","ref":"Evision.KeyPoint.html#keyPoint!/4","title":"Evision.KeyPoint.keyPoint!/4","type":"function"},{"doc":"Python prototype (for reference): KeyPoint() -&gt; &lt;KeyPoint object&gt;","ref":"Evision.KeyPoint.html#keyPoint/0","title":"Evision.KeyPoint.keyPoint/0","type":"function"},{"doc":"Positional Arguments x : float . x-coordinate of the keypoint y : float . y-coordinate of the keypoint size : float . keypoint diameter Keyword Arguments angle : float . keypoint orientation response : float . keypoint detector response on the keypoint (that is, strength of the keypoint) octave : int . pyramid octave in which the keypoint has been detected class_id : int . object id Python prototype (for reference): KeyPoint(x, y, size[, angle[, response[, octave[, class_id]]]]) -&gt; &lt;KeyPoint object&gt;","ref":"Evision.KeyPoint.html#keyPoint/3","title":"Evision.KeyPoint.keyPoint/3","type":"function"},{"doc":"Positional Arguments x : float . x-coordinate of the keypoint y : float . y-coordinate of the keypoint size : float . keypoint diameter Keyword Arguments angle : float . keypoint orientation response : float . keypoint detector response on the keypoint (that is, strength of the keypoint) octave : int . pyramid octave in which the keypoint has been detected class_id : int . object id Python prototype (for reference): KeyPoint(x, y, size[, angle[, response[, octave[, class_id]]]]) -&gt; &lt;KeyPoint object&gt;","ref":"Evision.KeyPoint.html#keyPoint/4","title":"Evision.KeyPoint.keyPoint/4","type":"function"},{"doc":"Raising version of overlap/2 .","ref":"Evision.KeyPoint.html#overlap!/2","title":"Evision.KeyPoint.overlap!/2","type":"function"},{"doc":"Positional Arguments kp1 : KeyPoint . First keypoint kp2 : KeyPoint . Second keypoint This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint regions' intersection and area of keypoint regions' union (considering keypoint region as circle). If they don't overlap, we get zero. If they coincide at same location with same size, we get 1. Python prototype (for reference): overlap(kp1, kp2) -&gt; retval","ref":"Evision.KeyPoint.html#overlap/2","title":"Evision.KeyPoint.overlap/2","type":"function"},{"doc":"Raising version of set_angle/2 .","ref":"Evision.KeyPoint.html#set_angle!/2","title":"Evision.KeyPoint.set_angle!/2","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#set_angle/2","title":"Evision.KeyPoint.set_angle/2","type":"function"},{"doc":"Raising version of set_class_id/2 .","ref":"Evision.KeyPoint.html#set_class_id!/2","title":"Evision.KeyPoint.set_class_id!/2","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#set_class_id/2","title":"Evision.KeyPoint.set_class_id/2","type":"function"},{"doc":"Raising version of set_octave/2 .","ref":"Evision.KeyPoint.html#set_octave!/2","title":"Evision.KeyPoint.set_octave!/2","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#set_octave/2","title":"Evision.KeyPoint.set_octave/2","type":"function"},{"doc":"Raising version of set_pt/2 .","ref":"Evision.KeyPoint.html#set_pt!/2","title":"Evision.KeyPoint.set_pt!/2","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#set_pt/2","title":"Evision.KeyPoint.set_pt/2","type":"function"},{"doc":"Raising version of set_response/2 .","ref":"Evision.KeyPoint.html#set_response!/2","title":"Evision.KeyPoint.set_response!/2","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#set_response/2","title":"Evision.KeyPoint.set_response/2","type":"function"},{"doc":"Raising version of set_size/2 .","ref":"Evision.KeyPoint.html#set_size!/2","title":"Evision.KeyPoint.set_size!/2","type":"function"},{"doc":"","ref":"Evision.KeyPoint.html#set_size/2","title":"Evision.KeyPoint.set_size/2","type":"function"},{"doc":"","ref":"Evision.LineSegmentDetector.html","title":"Evision.LineSegmentDetector","type":"module"},{"doc":"Raising version of compareSegments/4 .","ref":"Evision.LineSegmentDetector.html#compareSegments!/4","title":"Evision.LineSegmentDetector.compareSegments!/4","type":"function"},{"doc":"Raising version of compareSegments/5 .","ref":"Evision.LineSegmentDetector.html#compareSegments!/5","title":"Evision.LineSegmentDetector.compareSegments!/5","type":"function"},{"doc":"Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels. Positional Arguments size : Size . The size of the image, where lines1 and lines2 were found. lines1 : Evision.Mat . The first group of lines that needs to be drawn. It is visualized in blue color. lines2 : Evision.Mat . The second group of lines. They visualized in red color. Return image : Evision.Mat . Optional image, where the lines will be drawn. The image should be color(3-channel) in order for lines1 and lines2 to be drawn in the above mentioned colors. Python prototype (for reference): compareSegments(size, lines1, lines2[, image]) -&gt; retval, image","ref":"Evision.LineSegmentDetector.html#compareSegments/4","title":"Evision.LineSegmentDetector.compareSegments/4","type":"function"},{"doc":"Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels. Positional Arguments size : Size . The size of the image, where lines1 and lines2 were found. lines1 : Evision.Mat . The first group of lines that needs to be drawn. It is visualized in blue color. lines2 : Evision.Mat . The second group of lines. They visualized in red color. Return image : Evision.Mat . Optional image, where the lines will be drawn. The image should be color(3-channel) in order for lines1 and lines2 to be drawn in the above mentioned colors. Python prototype (for reference): compareSegments(size, lines1, lines2[, image]) -&gt; retval, image","ref":"Evision.LineSegmentDetector.html#compareSegments/5","title":"Evision.LineSegmentDetector.compareSegments/5","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.LineSegmentDetector.html#detect!/2","title":"Evision.LineSegmentDetector.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.LineSegmentDetector.html#detect!/3","title":"Evision.LineSegmentDetector.detect!/3","type":"function"},{"doc":"Finds lines in the input image. Positional Arguments image : Evision.Mat . A grayscale (CV_8UC1) input image. If only a roi needs to be selected, use: lsd_ptr-\\&gt;detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, roi.x, roi.y); Return lines : Evision.Mat . A vector of Vec4f elements specifying the beginning and ending point of a line. Where Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly oriented depending on the gradient. width : Evision.Mat . Vector of widths of the regions, where the lines are found. E.g. Width of line. prec : Evision.Mat . Vector of precisions with which the lines are found. nfa : Evision.Mat . Vector containing number of false alarms in the line region, with precision of 10%. The bigger the value, logarithmically better the detection. -1 corresponds to 10 mean false alarms 0 corresponds to 1 mean false alarm 1 corresponds to 0.1 mean false alarms This vector will be calculated only when the objects type is #LSD_REFINE_ADV. This is the output of the default parameters of the algorithm on the above shown image. Python prototype (for reference): detect(image[, lines[, width[, prec[, nfa]]]]) -&gt; lines, width, prec, nfa","ref":"Evision.LineSegmentDetector.html#detect/2","title":"Evision.LineSegmentDetector.detect/2","type":"function"},{"doc":"Finds lines in the input image. Positional Arguments image : Evision.Mat . A grayscale (CV_8UC1) input image. If only a roi needs to be selected, use: lsd_ptr-\\&gt;detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, roi.x, roi.y); Return lines : Evision.Mat . A vector of Vec4f elements specifying the beginning and ending point of a line. Where Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly oriented depending on the gradient. width : Evision.Mat . Vector of widths of the regions, where the lines are found. E.g. Width of line. prec : Evision.Mat . Vector of precisions with which the lines are found. nfa : Evision.Mat . Vector containing number of false alarms in the line region, with precision of 10%. The bigger the value, logarithmically better the detection. -1 corresponds to 10 mean false alarms 0 corresponds to 1 mean false alarm 1 corresponds to 0.1 mean false alarms This vector will be calculated only when the objects type is #LSD_REFINE_ADV. This is the output of the default parameters of the algorithm on the above shown image. Python prototype (for reference): detect(image[, lines[, width[, prec[, nfa]]]]) -&gt; lines, width, prec, nfa","ref":"Evision.LineSegmentDetector.html#detect/3","title":"Evision.LineSegmentDetector.detect/3","type":"function"},{"doc":"Raising version of drawSegments/3 .","ref":"Evision.LineSegmentDetector.html#drawSegments!/3","title":"Evision.LineSegmentDetector.drawSegments!/3","type":"function"},{"doc":"Draws the line segments on a given image. Positional Arguments lines : Evision.Mat . A vector of the lines that needed to be drawn. Return image : Evision.Mat . The image, where the lines will be drawn. Should be bigger or equal to the image, where the lines were found. Python prototype (for reference): drawSegments(image, lines) -&gt; image","ref":"Evision.LineSegmentDetector.html#drawSegments/3","title":"Evision.LineSegmentDetector.drawSegments/3","type":"function"},{"doc":"","ref":"Evision.ML.html","title":"Evision.ML","type":"module"},{"doc":"","ref":"Evision.ML.ANNMLP.html","title":"Evision.ML.ANNMLP","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.ANNMLP.html#calcError!/3","title":"Evision.ML.ANNMLP.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.ANNMLP.html#calcError!/4","title":"Evision.ML.ANNMLP.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.ANNMLP.html#calcError/3","title":"Evision.ML.ANNMLP.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.ANNMLP.html#calcError/4","title":"Evision.ML.ANNMLP.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.ANNMLP.html#clear!/1","title":"Evision.ML.ANNMLP.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.ANNMLP.html#clear/1","title":"Evision.ML.ANNMLP.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.ANNMLP.html#create!/0","title":"Evision.ML.ANNMLP.create!/0","type":"function"},{"doc":"Creates empty model Use StatModel::train to train the model, Algorithm::load\\&lt;ANN_MLP&gt;(filename) to load the pre-trained model. Note that the train method has optional flags: ANN_MLP::TrainFlags. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.ANNMLP.html#create/0","title":"Evision.ML.ANNMLP.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.ANNMLP.html#empty!/1","title":"Evision.ML.ANNMLP.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.ANNMLP.html#empty/1","title":"Evision.ML.ANNMLP.empty/1","type":"function"},{"doc":"Raising version of getAnnealCoolingRatio/1 .","ref":"Evision.ML.ANNMLP.html#getAnnealCoolingRatio!/1","title":"Evision.ML.ANNMLP.getAnnealCoolingRatio!/1","type":"function"},{"doc":"@see setAnnealCoolingRatio Python prototype (for reference): getAnnealCoolingRatio() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getAnnealCoolingRatio/1","title":"Evision.ML.ANNMLP.getAnnealCoolingRatio/1","type":"function"},{"doc":"Raising version of getAnnealFinalT/1 .","ref":"Evision.ML.ANNMLP.html#getAnnealFinalT!/1","title":"Evision.ML.ANNMLP.getAnnealFinalT!/1","type":"function"},{"doc":"@see setAnnealFinalT Python prototype (for reference): getAnnealFinalT() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getAnnealFinalT/1","title":"Evision.ML.ANNMLP.getAnnealFinalT/1","type":"function"},{"doc":"Raising version of getAnnealInitialT/1 .","ref":"Evision.ML.ANNMLP.html#getAnnealInitialT!/1","title":"Evision.ML.ANNMLP.getAnnealInitialT!/1","type":"function"},{"doc":"@see setAnnealInitialT Python prototype (for reference): getAnnealInitialT() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getAnnealInitialT/1","title":"Evision.ML.ANNMLP.getAnnealInitialT/1","type":"function"},{"doc":"Raising version of getAnnealItePerStep/1 .","ref":"Evision.ML.ANNMLP.html#getAnnealItePerStep!/1","title":"Evision.ML.ANNMLP.getAnnealItePerStep!/1","type":"function"},{"doc":"@see setAnnealItePerStep Python prototype (for reference): getAnnealItePerStep() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getAnnealItePerStep/1","title":"Evision.ML.ANNMLP.getAnnealItePerStep/1","type":"function"},{"doc":"Raising version of getBackpropMomentumScale/1 .","ref":"Evision.ML.ANNMLP.html#getBackpropMomentumScale!/1","title":"Evision.ML.ANNMLP.getBackpropMomentumScale!/1","type":"function"},{"doc":"@see setBackpropMomentumScale Python prototype (for reference): getBackpropMomentumScale() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getBackpropMomentumScale/1","title":"Evision.ML.ANNMLP.getBackpropMomentumScale/1","type":"function"},{"doc":"Raising version of getBackpropWeightScale/1 .","ref":"Evision.ML.ANNMLP.html#getBackpropWeightScale!/1","title":"Evision.ML.ANNMLP.getBackpropWeightScale!/1","type":"function"},{"doc":"@see setBackpropWeightScale Python prototype (for reference): getBackpropWeightScale() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getBackpropWeightScale/1","title":"Evision.ML.ANNMLP.getBackpropWeightScale/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.ANNMLP.html#getDefaultName!/1","title":"Evision.ML.ANNMLP.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getDefaultName/1","title":"Evision.ML.ANNMLP.getDefaultName/1","type":"function"},{"doc":"Raising version of getLayerSizes/1 .","ref":"Evision.ML.ANNMLP.html#getLayerSizes!/1","title":"Evision.ML.ANNMLP.getLayerSizes!/1","type":"function"},{"doc":"Integer vector specifying the number of neurons in each layer including the input and output layers. The very first element specifies the number of elements in the input layer. The last element - number of elements in the output layer. @sa setLayerSizes Python prototype (for reference): getLayerSizes() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getLayerSizes/1","title":"Evision.ML.ANNMLP.getLayerSizes/1","type":"function"},{"doc":"Raising version of getRpropDW0/1 .","ref":"Evision.ML.ANNMLP.html#getRpropDW0!/1","title":"Evision.ML.ANNMLP.getRpropDW0!/1","type":"function"},{"doc":"@see setRpropDW0 Python prototype (for reference): getRpropDW0() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getRpropDW0/1","title":"Evision.ML.ANNMLP.getRpropDW0/1","type":"function"},{"doc":"Raising version of getRpropDWMax/1 .","ref":"Evision.ML.ANNMLP.html#getRpropDWMax!/1","title":"Evision.ML.ANNMLP.getRpropDWMax!/1","type":"function"},{"doc":"@see setRpropDWMax Python prototype (for reference): getRpropDWMax() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getRpropDWMax/1","title":"Evision.ML.ANNMLP.getRpropDWMax/1","type":"function"},{"doc":"Raising version of getRpropDWMin/1 .","ref":"Evision.ML.ANNMLP.html#getRpropDWMin!/1","title":"Evision.ML.ANNMLP.getRpropDWMin!/1","type":"function"},{"doc":"@see setRpropDWMin Python prototype (for reference): getRpropDWMin() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getRpropDWMin/1","title":"Evision.ML.ANNMLP.getRpropDWMin/1","type":"function"},{"doc":"Raising version of getRpropDWMinus/1 .","ref":"Evision.ML.ANNMLP.html#getRpropDWMinus!/1","title":"Evision.ML.ANNMLP.getRpropDWMinus!/1","type":"function"},{"doc":"@see setRpropDWMinus Python prototype (for reference): getRpropDWMinus() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getRpropDWMinus/1","title":"Evision.ML.ANNMLP.getRpropDWMinus/1","type":"function"},{"doc":"Raising version of getRpropDWPlus/1 .","ref":"Evision.ML.ANNMLP.html#getRpropDWPlus!/1","title":"Evision.ML.ANNMLP.getRpropDWPlus!/1","type":"function"},{"doc":"@see setRpropDWPlus Python prototype (for reference): getRpropDWPlus() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getRpropDWPlus/1","title":"Evision.ML.ANNMLP.getRpropDWPlus/1","type":"function"},{"doc":"Raising version of getTermCriteria/1 .","ref":"Evision.ML.ANNMLP.html#getTermCriteria!/1","title":"Evision.ML.ANNMLP.getTermCriteria!/1","type":"function"},{"doc":"@see setTermCriteria Python prototype (for reference): getTermCriteria() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getTermCriteria/1","title":"Evision.ML.ANNMLP.getTermCriteria/1","type":"function"},{"doc":"Raising version of getTrainMethod/1 .","ref":"Evision.ML.ANNMLP.html#getTrainMethod!/1","title":"Evision.ML.ANNMLP.getTrainMethod!/1","type":"function"},{"doc":"Returns current training method Python prototype (for reference): getTrainMethod() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getTrainMethod/1","title":"Evision.ML.ANNMLP.getTrainMethod/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.ANNMLP.html#getVarCount!/1","title":"Evision.ML.ANNMLP.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.ANNMLP.html#getVarCount/1","title":"Evision.ML.ANNMLP.getVarCount/1","type":"function"},{"doc":"Raising version of getWeights/2 .","ref":"Evision.ML.ANNMLP.html#getWeights!/2","title":"Evision.ML.ANNMLP.getWeights!/2","type":"function"},{"doc":"Positional Arguments layerIdx : int Python prototype (for reference): getWeights(layerIdx) -&gt; retval","ref":"Evision.ML.ANNMLP.html#getWeights/2","title":"Evision.ML.ANNMLP.getWeights/2","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.ANNMLP.html#isClassifier!/1","title":"Evision.ML.ANNMLP.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.ANNMLP.html#isClassifier/1","title":"Evision.ML.ANNMLP.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.ANNMLP.html#isTrained!/1","title":"Evision.ML.ANNMLP.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.ANNMLP.html#isTrained/1","title":"Evision.ML.ANNMLP.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.ANNMLP.html#load!/1","title":"Evision.ML.ANNMLP.load!/1","type":"function"},{"doc":"Loads and creates a serialized ANN from a file Positional Arguments filepath : String . path to serialized ANN Use ANN::save to serialize and store an ANN to disk. Load the ANN from this file again, by calling this function with the path to the file. Python prototype (for reference): load(filepath) -&gt; retval","ref":"Evision.ML.ANNMLP.html#load/1","title":"Evision.ML.ANNMLP.load/1","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.ANNMLP.html#predict!/2","title":"Evision.ML.ANNMLP.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.ANNMLP.html#predict!/3","title":"Evision.ML.ANNMLP.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.ANNMLP.html#predict/2","title":"Evision.ML.ANNMLP.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.ANNMLP.html#predict/3","title":"Evision.ML.ANNMLP.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.ANNMLP.html#read!/2","title":"Evision.ML.ANNMLP.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.ANNMLP.html#read/2","title":"Evision.ML.ANNMLP.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.ANNMLP.html#save!/2","title":"Evision.ML.ANNMLP.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.ANNMLP.html#save/2","title":"Evision.ML.ANNMLP.save/2","type":"function"},{"doc":"Raising version of setActivationFunction/2 .","ref":"Evision.ML.ANNMLP.html#setActivationFunction!/2","title":"Evision.ML.ANNMLP.setActivationFunction!/2","type":"function"},{"doc":"Raising version of setActivationFunction/3 .","ref":"Evision.ML.ANNMLP.html#setActivationFunction!/3","title":"Evision.ML.ANNMLP.setActivationFunction!/3","type":"function"},{"doc":"Positional Arguments type : int . The type of activation function. See ANN_MLP::ActivationFunctions. Keyword Arguments param1 : double . The first parameter of the activation function, \\f$\\alpha\\f$. Default value is 0. param2 : double . The second parameter of the activation function, \\f$\\beta\\f$. Default value is 0. Initialize the activation function for each neuron. Currently the default and the only fully supported activation function is ANN_MLP::SIGMOID_SYM. Python prototype (for reference): setActivationFunction(type[, param1[, param2]]) -&gt; None","ref":"Evision.ML.ANNMLP.html#setActivationFunction/2","title":"Evision.ML.ANNMLP.setActivationFunction/2","type":"function"},{"doc":"Positional Arguments type : int . The type of activation function. See ANN_MLP::ActivationFunctions. Keyword Arguments param1 : double . The first parameter of the activation function, \\f$\\alpha\\f$. Default value is 0. param2 : double . The second parameter of the activation function, \\f$\\beta\\f$. Default value is 0. Initialize the activation function for each neuron. Currently the default and the only fully supported activation function is ANN_MLP::SIGMOID_SYM. Python prototype (for reference): setActivationFunction(type[, param1[, param2]]) -&gt; None","ref":"Evision.ML.ANNMLP.html#setActivationFunction/3","title":"Evision.ML.ANNMLP.setActivationFunction/3","type":"function"},{"doc":"Raising version of setAnnealCoolingRatio/2 .","ref":"Evision.ML.ANNMLP.html#setAnnealCoolingRatio!/2","title":"Evision.ML.ANNMLP.setAnnealCoolingRatio!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getAnnealCoolingRatio @see getAnnealCoolingRatio Python prototype (for reference): setAnnealCoolingRatio(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setAnnealCoolingRatio/2","title":"Evision.ML.ANNMLP.setAnnealCoolingRatio/2","type":"function"},{"doc":"Raising version of setAnnealFinalT/2 .","ref":"Evision.ML.ANNMLP.html#setAnnealFinalT!/2","title":"Evision.ML.ANNMLP.setAnnealFinalT!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getAnnealFinalT @see getAnnealFinalT Python prototype (for reference): setAnnealFinalT(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setAnnealFinalT/2","title":"Evision.ML.ANNMLP.setAnnealFinalT/2","type":"function"},{"doc":"Raising version of setAnnealInitialT/2 .","ref":"Evision.ML.ANNMLP.html#setAnnealInitialT!/2","title":"Evision.ML.ANNMLP.setAnnealInitialT!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getAnnealInitialT @see getAnnealInitialT Python prototype (for reference): setAnnealInitialT(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setAnnealInitialT/2","title":"Evision.ML.ANNMLP.setAnnealInitialT/2","type":"function"},{"doc":"Raising version of setAnnealItePerStep/2 .","ref":"Evision.ML.ANNMLP.html#setAnnealItePerStep!/2","title":"Evision.ML.ANNMLP.setAnnealItePerStep!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getAnnealItePerStep @see getAnnealItePerStep Python prototype (for reference): setAnnealItePerStep(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setAnnealItePerStep/2","title":"Evision.ML.ANNMLP.setAnnealItePerStep/2","type":"function"},{"doc":"Raising version of setBackpropMomentumScale/2 .","ref":"Evision.ML.ANNMLP.html#setBackpropMomentumScale!/2","title":"Evision.ML.ANNMLP.setBackpropMomentumScale!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getBackpropMomentumScale @see getBackpropMomentumScale Python prototype (for reference): setBackpropMomentumScale(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setBackpropMomentumScale/2","title":"Evision.ML.ANNMLP.setBackpropMomentumScale/2","type":"function"},{"doc":"Raising version of setBackpropWeightScale/2 .","ref":"Evision.ML.ANNMLP.html#setBackpropWeightScale!/2","title":"Evision.ML.ANNMLP.setBackpropWeightScale!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getBackpropWeightScale @see getBackpropWeightScale Python prototype (for reference): setBackpropWeightScale(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setBackpropWeightScale/2","title":"Evision.ML.ANNMLP.setBackpropWeightScale/2","type":"function"},{"doc":"Raising version of setLayerSizes/2 .","ref":"Evision.ML.ANNMLP.html#setLayerSizes!/2","title":"Evision.ML.ANNMLP.setLayerSizes!/2","type":"function"},{"doc":"Positional Arguments layer_sizes : Evision.Mat Integer vector specifying the number of neurons in each layer including the input and output layers. The very first element specifies the number of elements in the input layer. The last element - number of elements in the output layer. Default value is empty Mat. @sa getLayerSizes Python prototype (for reference): setLayerSizes(_layer_sizes) -&gt; None","ref":"Evision.ML.ANNMLP.html#setLayerSizes/2","title":"Evision.ML.ANNMLP.setLayerSizes/2","type":"function"},{"doc":"Raising version of setRpropDW0/2 .","ref":"Evision.ML.ANNMLP.html#setRpropDW0!/2","title":"Evision.ML.ANNMLP.setRpropDW0!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getRpropDW0 @see getRpropDW0 Python prototype (for reference): setRpropDW0(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setRpropDW0/2","title":"Evision.ML.ANNMLP.setRpropDW0/2","type":"function"},{"doc":"Raising version of setRpropDWMax/2 .","ref":"Evision.ML.ANNMLP.html#setRpropDWMax!/2","title":"Evision.ML.ANNMLP.setRpropDWMax!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getRpropDWMax @see getRpropDWMax Python prototype (for reference): setRpropDWMax(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setRpropDWMax/2","title":"Evision.ML.ANNMLP.setRpropDWMax/2","type":"function"},{"doc":"Raising version of setRpropDWMin/2 .","ref":"Evision.ML.ANNMLP.html#setRpropDWMin!/2","title":"Evision.ML.ANNMLP.setRpropDWMin!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getRpropDWMin @see getRpropDWMin Python prototype (for reference): setRpropDWMin(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setRpropDWMin/2","title":"Evision.ML.ANNMLP.setRpropDWMin/2","type":"function"},{"doc":"Raising version of setRpropDWMinus/2 .","ref":"Evision.ML.ANNMLP.html#setRpropDWMinus!/2","title":"Evision.ML.ANNMLP.setRpropDWMinus!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getRpropDWMinus @see getRpropDWMinus Python prototype (for reference): setRpropDWMinus(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setRpropDWMinus/2","title":"Evision.ML.ANNMLP.setRpropDWMinus/2","type":"function"},{"doc":"Raising version of setRpropDWPlus/2 .","ref":"Evision.ML.ANNMLP.html#setRpropDWPlus!/2","title":"Evision.ML.ANNMLP.setRpropDWPlus!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getRpropDWPlus @see getRpropDWPlus Python prototype (for reference): setRpropDWPlus(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setRpropDWPlus/2","title":"Evision.ML.ANNMLP.setRpropDWPlus/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.ML.ANNMLP.html#setTermCriteria!/2","title":"Evision.ML.ANNMLP.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments val : TermCriteria @copybrief getTermCriteria @see getTermCriteria Python prototype (for reference): setTermCriteria(val) -&gt; None","ref":"Evision.ML.ANNMLP.html#setTermCriteria/2","title":"Evision.ML.ANNMLP.setTermCriteria/2","type":"function"},{"doc":"Raising version of setTrainMethod/2 .","ref":"Evision.ML.ANNMLP.html#setTrainMethod!/2","title":"Evision.ML.ANNMLP.setTrainMethod!/2","type":"function"},{"doc":"Raising version of setTrainMethod/3 .","ref":"Evision.ML.ANNMLP.html#setTrainMethod!/3","title":"Evision.ML.ANNMLP.setTrainMethod!/3","type":"function"},{"doc":"Positional Arguments method : int . Default value is ANN_MLP::RPROP. See ANN_MLP::TrainingMethods. Keyword Arguments param1 : double . passed to setRpropDW0 for ANN_MLP::RPROP and to setBackpropWeightScale for ANN_MLP::BACKPROP and to initialT for ANN_MLP::ANNEAL. param2 : double . passed to setRpropDWMin for ANN_MLP::RPROP and to setBackpropMomentumScale for ANN_MLP::BACKPROP and to finalT for ANN_MLP::ANNEAL. Sets training method and common parameters. Python prototype (for reference): setTrainMethod(method[, param1[, param2]]) -&gt; None","ref":"Evision.ML.ANNMLP.html#setTrainMethod/2","title":"Evision.ML.ANNMLP.setTrainMethod/2","type":"function"},{"doc":"Positional Arguments method : int . Default value is ANN_MLP::RPROP. See ANN_MLP::TrainingMethods. Keyword Arguments param1 : double . passed to setRpropDW0 for ANN_MLP::RPROP and to setBackpropWeightScale for ANN_MLP::BACKPROP and to initialT for ANN_MLP::ANNEAL. param2 : double . passed to setRpropDWMin for ANN_MLP::RPROP and to setBackpropMomentumScale for ANN_MLP::BACKPROP and to finalT for ANN_MLP::ANNEAL. Sets training method and common parameters. Python prototype (for reference): setTrainMethod(method[, param1[, param2]]) -&gt; None","ref":"Evision.ML.ANNMLP.html#setTrainMethod/3","title":"Evision.ML.ANNMLP.setTrainMethod/3","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.ANNMLP.html#train!/2","title":"Evision.ML.ANNMLP.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.ANNMLP.html#train!/3","title":"Evision.ML.ANNMLP.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.ANNMLP.html#train!/4","title":"Evision.ML.ANNMLP.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.ANNMLP.html#train/2","title":"Evision.ML.ANNMLP.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.ANNMLP.html#train/3","title":"Evision.ML.ANNMLP.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.ANNMLP.html#train/4","title":"Evision.ML.ANNMLP.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.ANNMLP.html#write!/2","title":"Evision.ML.ANNMLP.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.ANNMLP.html#write!/3","title":"Evision.ML.ANNMLP.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.ANNMLP.html#write/2","title":"Evision.ML.ANNMLP.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.ANNMLP.html#write/3","title":"Evision.ML.ANNMLP.write/3","type":"function"},{"doc":"","ref":"Evision.ML.Boost.html","title":"Evision.ML.Boost","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.Boost.html#calcError!/3","title":"Evision.ML.Boost.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.Boost.html#calcError!/4","title":"Evision.ML.Boost.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.Boost.html#calcError/3","title":"Evision.ML.Boost.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.Boost.html#calcError/4","title":"Evision.ML.Boost.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.Boost.html#clear!/1","title":"Evision.ML.Boost.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.Boost.html#clear/1","title":"Evision.ML.Boost.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.Boost.html#create!/0","title":"Evision.ML.Boost.create!/0","type":"function"},{"doc":"Creates the empty model. Use StatModel::train to train the model, Algorithm::load\\&lt;Boost&gt;(filename) to load the pre-trained model. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.Boost.html#create/0","title":"Evision.ML.Boost.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.Boost.html#empty!/1","title":"Evision.ML.Boost.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.Boost.html#empty/1","title":"Evision.ML.Boost.empty/1","type":"function"},{"doc":"Raising version of getBoostType/1 .","ref":"Evision.ML.Boost.html#getBoostType!/1","title":"Evision.ML.Boost.getBoostType!/1","type":"function"},{"doc":"@see setBoostType Python prototype (for reference): getBoostType() -&gt; retval","ref":"Evision.ML.Boost.html#getBoostType/1","title":"Evision.ML.Boost.getBoostType/1","type":"function"},{"doc":"Raising version of getCVFolds/1 .","ref":"Evision.ML.Boost.html#getCVFolds!/1","title":"Evision.ML.Boost.getCVFolds!/1","type":"function"},{"doc":"@see setCVFolds Python prototype (for reference): getCVFolds() -&gt; retval","ref":"Evision.ML.Boost.html#getCVFolds/1","title":"Evision.ML.Boost.getCVFolds/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.Boost.html#getDefaultName!/1","title":"Evision.ML.Boost.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.Boost.html#getDefaultName/1","title":"Evision.ML.Boost.getDefaultName/1","type":"function"},{"doc":"Raising version of getMaxCategories/1 .","ref":"Evision.ML.Boost.html#getMaxCategories!/1","title":"Evision.ML.Boost.getMaxCategories!/1","type":"function"},{"doc":"@see setMaxCategories Python prototype (for reference): getMaxCategories() -&gt; retval","ref":"Evision.ML.Boost.html#getMaxCategories/1","title":"Evision.ML.Boost.getMaxCategories/1","type":"function"},{"doc":"Raising version of getMaxDepth/1 .","ref":"Evision.ML.Boost.html#getMaxDepth!/1","title":"Evision.ML.Boost.getMaxDepth!/1","type":"function"},{"doc":"@see setMaxDepth Python prototype (for reference): getMaxDepth() -&gt; retval","ref":"Evision.ML.Boost.html#getMaxDepth/1","title":"Evision.ML.Boost.getMaxDepth/1","type":"function"},{"doc":"Raising version of getMinSampleCount/1 .","ref":"Evision.ML.Boost.html#getMinSampleCount!/1","title":"Evision.ML.Boost.getMinSampleCount!/1","type":"function"},{"doc":"@see setMinSampleCount Python prototype (for reference): getMinSampleCount() -&gt; retval","ref":"Evision.ML.Boost.html#getMinSampleCount/1","title":"Evision.ML.Boost.getMinSampleCount/1","type":"function"},{"doc":"Raising version of getPriors/1 .","ref":"Evision.ML.Boost.html#getPriors!/1","title":"Evision.ML.Boost.getPriors!/1","type":"function"},{"doc":"@see setPriors Python prototype (for reference): getPriors() -&gt; retval","ref":"Evision.ML.Boost.html#getPriors/1","title":"Evision.ML.Boost.getPriors/1","type":"function"},{"doc":"Raising version of getRegressionAccuracy/1 .","ref":"Evision.ML.Boost.html#getRegressionAccuracy!/1","title":"Evision.ML.Boost.getRegressionAccuracy!/1","type":"function"},{"doc":"@see setRegressionAccuracy Python prototype (for reference): getRegressionAccuracy() -&gt; retval","ref":"Evision.ML.Boost.html#getRegressionAccuracy/1","title":"Evision.ML.Boost.getRegressionAccuracy/1","type":"function"},{"doc":"Raising version of getTruncatePrunedTree/1 .","ref":"Evision.ML.Boost.html#getTruncatePrunedTree!/1","title":"Evision.ML.Boost.getTruncatePrunedTree!/1","type":"function"},{"doc":"@see setTruncatePrunedTree Python prototype (for reference): getTruncatePrunedTree() -&gt; retval","ref":"Evision.ML.Boost.html#getTruncatePrunedTree/1","title":"Evision.ML.Boost.getTruncatePrunedTree/1","type":"function"},{"doc":"Raising version of getUse1SERule/1 .","ref":"Evision.ML.Boost.html#getUse1SERule!/1","title":"Evision.ML.Boost.getUse1SERule!/1","type":"function"},{"doc":"@see setUse1SERule Python prototype (for reference): getUse1SERule() -&gt; retval","ref":"Evision.ML.Boost.html#getUse1SERule/1","title":"Evision.ML.Boost.getUse1SERule/1","type":"function"},{"doc":"Raising version of getUseSurrogates/1 .","ref":"Evision.ML.Boost.html#getUseSurrogates!/1","title":"Evision.ML.Boost.getUseSurrogates!/1","type":"function"},{"doc":"@see setUseSurrogates Python prototype (for reference): getUseSurrogates() -&gt; retval","ref":"Evision.ML.Boost.html#getUseSurrogates/1","title":"Evision.ML.Boost.getUseSurrogates/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.Boost.html#getVarCount!/1","title":"Evision.ML.Boost.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.Boost.html#getVarCount/1","title":"Evision.ML.Boost.getVarCount/1","type":"function"},{"doc":"Raising version of getWeakCount/1 .","ref":"Evision.ML.Boost.html#getWeakCount!/1","title":"Evision.ML.Boost.getWeakCount!/1","type":"function"},{"doc":"@see setWeakCount Python prototype (for reference): getWeakCount() -&gt; retval","ref":"Evision.ML.Boost.html#getWeakCount/1","title":"Evision.ML.Boost.getWeakCount/1","type":"function"},{"doc":"Raising version of getWeightTrimRate/1 .","ref":"Evision.ML.Boost.html#getWeightTrimRate!/1","title":"Evision.ML.Boost.getWeightTrimRate!/1","type":"function"},{"doc":"@see setWeightTrimRate Python prototype (for reference): getWeightTrimRate() -&gt; retval","ref":"Evision.ML.Boost.html#getWeightTrimRate/1","title":"Evision.ML.Boost.getWeightTrimRate/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.Boost.html#isClassifier!/1","title":"Evision.ML.Boost.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.Boost.html#isClassifier/1","title":"Evision.ML.Boost.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.Boost.html#isTrained!/1","title":"Evision.ML.Boost.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.Boost.html#isTrained/1","title":"Evision.ML.Boost.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.Boost.html#load!/1","title":"Evision.ML.Boost.load!/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.ML.Boost.html#load!/2","title":"Evision.ML.Boost.load!/2","type":"function"},{"doc":"Loads and creates a serialized Boost from a file Positional Arguments filepath : String . path to serialized Boost Keyword Arguments nodeName : String . name of node containing the classifier Use Boost::save to serialize and store an RTree to disk. Load the Boost from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.Boost.html#load/1","title":"Evision.ML.Boost.load/1","type":"function"},{"doc":"Loads and creates a serialized Boost from a file Positional Arguments filepath : String . path to serialized Boost Keyword Arguments nodeName : String . name of node containing the classifier Use Boost::save to serialize and store an RTree to disk. Load the Boost from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.Boost.html#load/2","title":"Evision.ML.Boost.load/2","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.Boost.html#predict!/2","title":"Evision.ML.Boost.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.Boost.html#predict!/3","title":"Evision.ML.Boost.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.Boost.html#predict/2","title":"Evision.ML.Boost.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.Boost.html#predict/3","title":"Evision.ML.Boost.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.Boost.html#read!/2","title":"Evision.ML.Boost.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.Boost.html#read/2","title":"Evision.ML.Boost.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.Boost.html#save!/2","title":"Evision.ML.Boost.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.Boost.html#save/2","title":"Evision.ML.Boost.save/2","type":"function"},{"doc":"Raising version of setBoostType/2 .","ref":"Evision.ML.Boost.html#setBoostType!/2","title":"Evision.ML.Boost.setBoostType!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getBoostType @see getBoostType Python prototype (for reference): setBoostType(val) -&gt; None","ref":"Evision.ML.Boost.html#setBoostType/2","title":"Evision.ML.Boost.setBoostType/2","type":"function"},{"doc":"Raising version of setCVFolds/2 .","ref":"Evision.ML.Boost.html#setCVFolds!/2","title":"Evision.ML.Boost.setCVFolds!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getCVFolds @see getCVFolds Python prototype (for reference): setCVFolds(val) -&gt; None","ref":"Evision.ML.Boost.html#setCVFolds/2","title":"Evision.ML.Boost.setCVFolds/2","type":"function"},{"doc":"Raising version of setMaxCategories/2 .","ref":"Evision.ML.Boost.html#setMaxCategories!/2","title":"Evision.ML.Boost.setMaxCategories!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMaxCategories @see getMaxCategories Python prototype (for reference): setMaxCategories(val) -&gt; None","ref":"Evision.ML.Boost.html#setMaxCategories/2","title":"Evision.ML.Boost.setMaxCategories/2","type":"function"},{"doc":"Raising version of setMaxDepth/2 .","ref":"Evision.ML.Boost.html#setMaxDepth!/2","title":"Evision.ML.Boost.setMaxDepth!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMaxDepth @see getMaxDepth Python prototype (for reference): setMaxDepth(val) -&gt; None","ref":"Evision.ML.Boost.html#setMaxDepth/2","title":"Evision.ML.Boost.setMaxDepth/2","type":"function"},{"doc":"Raising version of setMinSampleCount/2 .","ref":"Evision.ML.Boost.html#setMinSampleCount!/2","title":"Evision.ML.Boost.setMinSampleCount!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMinSampleCount @see getMinSampleCount Python prototype (for reference): setMinSampleCount(val) -&gt; None","ref":"Evision.ML.Boost.html#setMinSampleCount/2","title":"Evision.ML.Boost.setMinSampleCount/2","type":"function"},{"doc":"Raising version of setPriors/2 .","ref":"Evision.ML.Boost.html#setPriors!/2","title":"Evision.ML.Boost.setPriors!/2","type":"function"},{"doc":"Positional Arguments val : Evision.Mat @copybrief getPriors @see getPriors Python prototype (for reference): setPriors(val) -&gt; None","ref":"Evision.ML.Boost.html#setPriors/2","title":"Evision.ML.Boost.setPriors/2","type":"function"},{"doc":"Raising version of setRegressionAccuracy/2 .","ref":"Evision.ML.Boost.html#setRegressionAccuracy!/2","title":"Evision.ML.Boost.setRegressionAccuracy!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getRegressionAccuracy @see getRegressionAccuracy Python prototype (for reference): setRegressionAccuracy(val) -&gt; None","ref":"Evision.ML.Boost.html#setRegressionAccuracy/2","title":"Evision.ML.Boost.setRegressionAccuracy/2","type":"function"},{"doc":"Raising version of setTruncatePrunedTree/2 .","ref":"Evision.ML.Boost.html#setTruncatePrunedTree!/2","title":"Evision.ML.Boost.setTruncatePrunedTree!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getTruncatePrunedTree @see getTruncatePrunedTree Python prototype (for reference): setTruncatePrunedTree(val) -&gt; None","ref":"Evision.ML.Boost.html#setTruncatePrunedTree/2","title":"Evision.ML.Boost.setTruncatePrunedTree/2","type":"function"},{"doc":"Raising version of setUse1SERule/2 .","ref":"Evision.ML.Boost.html#setUse1SERule!/2","title":"Evision.ML.Boost.setUse1SERule!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUse1SERule @see getUse1SERule Python prototype (for reference): setUse1SERule(val) -&gt; None","ref":"Evision.ML.Boost.html#setUse1SERule/2","title":"Evision.ML.Boost.setUse1SERule/2","type":"function"},{"doc":"Raising version of setUseSurrogates/2 .","ref":"Evision.ML.Boost.html#setUseSurrogates!/2","title":"Evision.ML.Boost.setUseSurrogates!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUseSurrogates @see getUseSurrogates Python prototype (for reference): setUseSurrogates(val) -&gt; None","ref":"Evision.ML.Boost.html#setUseSurrogates/2","title":"Evision.ML.Boost.setUseSurrogates/2","type":"function"},{"doc":"Raising version of setWeakCount/2 .","ref":"Evision.ML.Boost.html#setWeakCount!/2","title":"Evision.ML.Boost.setWeakCount!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getWeakCount @see getWeakCount Python prototype (for reference): setWeakCount(val) -&gt; None","ref":"Evision.ML.Boost.html#setWeakCount/2","title":"Evision.ML.Boost.setWeakCount/2","type":"function"},{"doc":"Raising version of setWeightTrimRate/2 .","ref":"Evision.ML.Boost.html#setWeightTrimRate!/2","title":"Evision.ML.Boost.setWeightTrimRate!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getWeightTrimRate @see getWeightTrimRate Python prototype (for reference): setWeightTrimRate(val) -&gt; None","ref":"Evision.ML.Boost.html#setWeightTrimRate/2","title":"Evision.ML.Boost.setWeightTrimRate/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.Boost.html#train!/2","title":"Evision.ML.Boost.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.Boost.html#train!/3","title":"Evision.ML.Boost.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.Boost.html#train!/4","title":"Evision.ML.Boost.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.Boost.html#train/2","title":"Evision.ML.Boost.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.Boost.html#train/3","title":"Evision.ML.Boost.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.Boost.html#train/4","title":"Evision.ML.Boost.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.Boost.html#write!/2","title":"Evision.ML.Boost.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.Boost.html#write!/3","title":"Evision.ML.Boost.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.Boost.html#write/2","title":"Evision.ML.Boost.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.Boost.html#write/3","title":"Evision.ML.Boost.write/3","type":"function"},{"doc":"","ref":"Evision.ML.DTrees.html","title":"Evision.ML.DTrees","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.DTrees.html#calcError!/3","title":"Evision.ML.DTrees.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.DTrees.html#calcError!/4","title":"Evision.ML.DTrees.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.DTrees.html#calcError/3","title":"Evision.ML.DTrees.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.DTrees.html#calcError/4","title":"Evision.ML.DTrees.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.DTrees.html#clear!/1","title":"Evision.ML.DTrees.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.DTrees.html#clear/1","title":"Evision.ML.DTrees.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.DTrees.html#create!/0","title":"Evision.ML.DTrees.create!/0","type":"function"},{"doc":"Creates the empty model The static method creates empty decision tree with the specified parameters. It should be then trained using train method (see StatModel::train). Alternatively, you can load the model from file using Algorithm::load\\&lt;DTrees&gt;(filename). Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.DTrees.html#create/0","title":"Evision.ML.DTrees.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.DTrees.html#empty!/1","title":"Evision.ML.DTrees.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.DTrees.html#empty/1","title":"Evision.ML.DTrees.empty/1","type":"function"},{"doc":"Raising version of getCVFolds/1 .","ref":"Evision.ML.DTrees.html#getCVFolds!/1","title":"Evision.ML.DTrees.getCVFolds!/1","type":"function"},{"doc":"@see setCVFolds Python prototype (for reference): getCVFolds() -&gt; retval","ref":"Evision.ML.DTrees.html#getCVFolds/1","title":"Evision.ML.DTrees.getCVFolds/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.DTrees.html#getDefaultName!/1","title":"Evision.ML.DTrees.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.DTrees.html#getDefaultName/1","title":"Evision.ML.DTrees.getDefaultName/1","type":"function"},{"doc":"Raising version of getMaxCategories/1 .","ref":"Evision.ML.DTrees.html#getMaxCategories!/1","title":"Evision.ML.DTrees.getMaxCategories!/1","type":"function"},{"doc":"@see setMaxCategories Python prototype (for reference): getMaxCategories() -&gt; retval","ref":"Evision.ML.DTrees.html#getMaxCategories/1","title":"Evision.ML.DTrees.getMaxCategories/1","type":"function"},{"doc":"Raising version of getMaxDepth/1 .","ref":"Evision.ML.DTrees.html#getMaxDepth!/1","title":"Evision.ML.DTrees.getMaxDepth!/1","type":"function"},{"doc":"@see setMaxDepth Python prototype (for reference): getMaxDepth() -&gt; retval","ref":"Evision.ML.DTrees.html#getMaxDepth/1","title":"Evision.ML.DTrees.getMaxDepth/1","type":"function"},{"doc":"Raising version of getMinSampleCount/1 .","ref":"Evision.ML.DTrees.html#getMinSampleCount!/1","title":"Evision.ML.DTrees.getMinSampleCount!/1","type":"function"},{"doc":"@see setMinSampleCount Python prototype (for reference): getMinSampleCount() -&gt; retval","ref":"Evision.ML.DTrees.html#getMinSampleCount/1","title":"Evision.ML.DTrees.getMinSampleCount/1","type":"function"},{"doc":"Raising version of getPriors/1 .","ref":"Evision.ML.DTrees.html#getPriors!/1","title":"Evision.ML.DTrees.getPriors!/1","type":"function"},{"doc":"@see setPriors Python prototype (for reference): getPriors() -&gt; retval","ref":"Evision.ML.DTrees.html#getPriors/1","title":"Evision.ML.DTrees.getPriors/1","type":"function"},{"doc":"Raising version of getRegressionAccuracy/1 .","ref":"Evision.ML.DTrees.html#getRegressionAccuracy!/1","title":"Evision.ML.DTrees.getRegressionAccuracy!/1","type":"function"},{"doc":"@see setRegressionAccuracy Python prototype (for reference): getRegressionAccuracy() -&gt; retval","ref":"Evision.ML.DTrees.html#getRegressionAccuracy/1","title":"Evision.ML.DTrees.getRegressionAccuracy/1","type":"function"},{"doc":"Raising version of getTruncatePrunedTree/1 .","ref":"Evision.ML.DTrees.html#getTruncatePrunedTree!/1","title":"Evision.ML.DTrees.getTruncatePrunedTree!/1","type":"function"},{"doc":"@see setTruncatePrunedTree Python prototype (for reference): getTruncatePrunedTree() -&gt; retval","ref":"Evision.ML.DTrees.html#getTruncatePrunedTree/1","title":"Evision.ML.DTrees.getTruncatePrunedTree/1","type":"function"},{"doc":"Raising version of getUse1SERule/1 .","ref":"Evision.ML.DTrees.html#getUse1SERule!/1","title":"Evision.ML.DTrees.getUse1SERule!/1","type":"function"},{"doc":"@see setUse1SERule Python prototype (for reference): getUse1SERule() -&gt; retval","ref":"Evision.ML.DTrees.html#getUse1SERule/1","title":"Evision.ML.DTrees.getUse1SERule/1","type":"function"},{"doc":"Raising version of getUseSurrogates/1 .","ref":"Evision.ML.DTrees.html#getUseSurrogates!/1","title":"Evision.ML.DTrees.getUseSurrogates!/1","type":"function"},{"doc":"@see setUseSurrogates Python prototype (for reference): getUseSurrogates() -&gt; retval","ref":"Evision.ML.DTrees.html#getUseSurrogates/1","title":"Evision.ML.DTrees.getUseSurrogates/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.DTrees.html#getVarCount!/1","title":"Evision.ML.DTrees.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.DTrees.html#getVarCount/1","title":"Evision.ML.DTrees.getVarCount/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.DTrees.html#isClassifier!/1","title":"Evision.ML.DTrees.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.DTrees.html#isClassifier/1","title":"Evision.ML.DTrees.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.DTrees.html#isTrained!/1","title":"Evision.ML.DTrees.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.DTrees.html#isTrained/1","title":"Evision.ML.DTrees.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.DTrees.html#load!/1","title":"Evision.ML.DTrees.load!/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.ML.DTrees.html#load!/2","title":"Evision.ML.DTrees.load!/2","type":"function"},{"doc":"Loads and creates a serialized DTrees from a file Positional Arguments filepath : String . path to serialized DTree Keyword Arguments nodeName : String . name of node containing the classifier Use DTree::save to serialize and store an DTree to disk. Load the DTree from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.DTrees.html#load/1","title":"Evision.ML.DTrees.load/1","type":"function"},{"doc":"Loads and creates a serialized DTrees from a file Positional Arguments filepath : String . path to serialized DTree Keyword Arguments nodeName : String . name of node containing the classifier Use DTree::save to serialize and store an DTree to disk. Load the DTree from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.DTrees.html#load/2","title":"Evision.ML.DTrees.load/2","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.DTrees.html#predict!/2","title":"Evision.ML.DTrees.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.DTrees.html#predict!/3","title":"Evision.ML.DTrees.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.DTrees.html#predict/2","title":"Evision.ML.DTrees.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.DTrees.html#predict/3","title":"Evision.ML.DTrees.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.DTrees.html#read!/2","title":"Evision.ML.DTrees.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.DTrees.html#read/2","title":"Evision.ML.DTrees.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.DTrees.html#save!/2","title":"Evision.ML.DTrees.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.DTrees.html#save/2","title":"Evision.ML.DTrees.save/2","type":"function"},{"doc":"Raising version of setCVFolds/2 .","ref":"Evision.ML.DTrees.html#setCVFolds!/2","title":"Evision.ML.DTrees.setCVFolds!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getCVFolds @see getCVFolds Python prototype (for reference): setCVFolds(val) -&gt; None","ref":"Evision.ML.DTrees.html#setCVFolds/2","title":"Evision.ML.DTrees.setCVFolds/2","type":"function"},{"doc":"Raising version of setMaxCategories/2 .","ref":"Evision.ML.DTrees.html#setMaxCategories!/2","title":"Evision.ML.DTrees.setMaxCategories!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMaxCategories @see getMaxCategories Python prototype (for reference): setMaxCategories(val) -&gt; None","ref":"Evision.ML.DTrees.html#setMaxCategories/2","title":"Evision.ML.DTrees.setMaxCategories/2","type":"function"},{"doc":"Raising version of setMaxDepth/2 .","ref":"Evision.ML.DTrees.html#setMaxDepth!/2","title":"Evision.ML.DTrees.setMaxDepth!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMaxDepth @see getMaxDepth Python prototype (for reference): setMaxDepth(val) -&gt; None","ref":"Evision.ML.DTrees.html#setMaxDepth/2","title":"Evision.ML.DTrees.setMaxDepth/2","type":"function"},{"doc":"Raising version of setMinSampleCount/2 .","ref":"Evision.ML.DTrees.html#setMinSampleCount!/2","title":"Evision.ML.DTrees.setMinSampleCount!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMinSampleCount @see getMinSampleCount Python prototype (for reference): setMinSampleCount(val) -&gt; None","ref":"Evision.ML.DTrees.html#setMinSampleCount/2","title":"Evision.ML.DTrees.setMinSampleCount/2","type":"function"},{"doc":"Raising version of setPriors/2 .","ref":"Evision.ML.DTrees.html#setPriors!/2","title":"Evision.ML.DTrees.setPriors!/2","type":"function"},{"doc":"Positional Arguments val : Evision.Mat @copybrief getPriors @see getPriors Python prototype (for reference): setPriors(val) -&gt; None","ref":"Evision.ML.DTrees.html#setPriors/2","title":"Evision.ML.DTrees.setPriors/2","type":"function"},{"doc":"Raising version of setRegressionAccuracy/2 .","ref":"Evision.ML.DTrees.html#setRegressionAccuracy!/2","title":"Evision.ML.DTrees.setRegressionAccuracy!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getRegressionAccuracy @see getRegressionAccuracy Python prototype (for reference): setRegressionAccuracy(val) -&gt; None","ref":"Evision.ML.DTrees.html#setRegressionAccuracy/2","title":"Evision.ML.DTrees.setRegressionAccuracy/2","type":"function"},{"doc":"Raising version of setTruncatePrunedTree/2 .","ref":"Evision.ML.DTrees.html#setTruncatePrunedTree!/2","title":"Evision.ML.DTrees.setTruncatePrunedTree!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getTruncatePrunedTree @see getTruncatePrunedTree Python prototype (for reference): setTruncatePrunedTree(val) -&gt; None","ref":"Evision.ML.DTrees.html#setTruncatePrunedTree/2","title":"Evision.ML.DTrees.setTruncatePrunedTree/2","type":"function"},{"doc":"Raising version of setUse1SERule/2 .","ref":"Evision.ML.DTrees.html#setUse1SERule!/2","title":"Evision.ML.DTrees.setUse1SERule!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUse1SERule @see getUse1SERule Python prototype (for reference): setUse1SERule(val) -&gt; None","ref":"Evision.ML.DTrees.html#setUse1SERule/2","title":"Evision.ML.DTrees.setUse1SERule/2","type":"function"},{"doc":"Raising version of setUseSurrogates/2 .","ref":"Evision.ML.DTrees.html#setUseSurrogates!/2","title":"Evision.ML.DTrees.setUseSurrogates!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUseSurrogates @see getUseSurrogates Python prototype (for reference): setUseSurrogates(val) -&gt; None","ref":"Evision.ML.DTrees.html#setUseSurrogates/2","title":"Evision.ML.DTrees.setUseSurrogates/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.DTrees.html#train!/2","title":"Evision.ML.DTrees.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.DTrees.html#train!/3","title":"Evision.ML.DTrees.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.DTrees.html#train!/4","title":"Evision.ML.DTrees.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.DTrees.html#train/2","title":"Evision.ML.DTrees.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.DTrees.html#train/3","title":"Evision.ML.DTrees.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.DTrees.html#train/4","title":"Evision.ML.DTrees.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.DTrees.html#write!/2","title":"Evision.ML.DTrees.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.DTrees.html#write!/3","title":"Evision.ML.DTrees.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.DTrees.html#write/2","title":"Evision.ML.DTrees.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.DTrees.html#write/3","title":"Evision.ML.DTrees.write/3","type":"function"},{"doc":"","ref":"Evision.ML.EM.html","title":"Evision.ML.EM","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.EM.html#calcError!/3","title":"Evision.ML.EM.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.EM.html#calcError!/4","title":"Evision.ML.EM.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.EM.html#calcError/3","title":"Evision.ML.EM.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.EM.html#calcError/4","title":"Evision.ML.EM.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.EM.html#clear!/1","title":"Evision.ML.EM.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.EM.html#clear/1","title":"Evision.ML.EM.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.EM.html#create!/0","title":"Evision.ML.EM.create!/0","type":"function"},{"doc":"Creates empty %EM model. The model should be trained then using StatModel::train(traindata, flags) method. Alternatively, you can use one of the EM::train* methods or load it from file using Algorithm::load\\&lt;EM&gt;(filename). Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.EM.html#create/0","title":"Evision.ML.EM.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.EM.html#empty!/1","title":"Evision.ML.EM.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.EM.html#empty/1","title":"Evision.ML.EM.empty/1","type":"function"},{"doc":"Raising version of getClustersNumber/1 .","ref":"Evision.ML.EM.html#getClustersNumber!/1","title":"Evision.ML.EM.getClustersNumber!/1","type":"function"},{"doc":"@see setClustersNumber Python prototype (for reference): getClustersNumber() -&gt; retval","ref":"Evision.ML.EM.html#getClustersNumber/1","title":"Evision.ML.EM.getClustersNumber/1","type":"function"},{"doc":"Raising version of getCovarianceMatrixType/1 .","ref":"Evision.ML.EM.html#getCovarianceMatrixType!/1","title":"Evision.ML.EM.getCovarianceMatrixType!/1","type":"function"},{"doc":"@see setCovarianceMatrixType Python prototype (for reference): getCovarianceMatrixType() -&gt; retval","ref":"Evision.ML.EM.html#getCovarianceMatrixType/1","title":"Evision.ML.EM.getCovarianceMatrixType/1","type":"function"},{"doc":"Raising version of getCovs/1 .","ref":"Evision.ML.EM.html#getCovs!/1","title":"Evision.ML.EM.getCovs!/1","type":"function"},{"doc":"Returns covariation matrices Return covs : [Evision.Mat] . Returns vector of covariation matrices. Number of matrices is the number of gaussian mixtures, each matrix is a square floating-point matrix NxN, where N is the space dimensionality. Python prototype (for reference): getCovs([, covs]) -&gt; covs","ref":"Evision.ML.EM.html#getCovs/1","title":"Evision.ML.EM.getCovs/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.EM.html#getDefaultName!/1","title":"Evision.ML.EM.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.EM.html#getDefaultName/1","title":"Evision.ML.EM.getDefaultName/1","type":"function"},{"doc":"Raising version of getMeans/1 .","ref":"Evision.ML.EM.html#getMeans!/1","title":"Evision.ML.EM.getMeans!/1","type":"function"},{"doc":"Returns the cluster centers (means of the Gaussian mixture) Returns matrix with the number of rows equal to the number of mixtures and number of columns equal to the space dimensionality. Python prototype (for reference): getMeans() -&gt; retval","ref":"Evision.ML.EM.html#getMeans/1","title":"Evision.ML.EM.getMeans/1","type":"function"},{"doc":"Raising version of getTermCriteria/1 .","ref":"Evision.ML.EM.html#getTermCriteria!/1","title":"Evision.ML.EM.getTermCriteria!/1","type":"function"},{"doc":"@see setTermCriteria Python prototype (for reference): getTermCriteria() -&gt; retval","ref":"Evision.ML.EM.html#getTermCriteria/1","title":"Evision.ML.EM.getTermCriteria/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.EM.html#getVarCount!/1","title":"Evision.ML.EM.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.EM.html#getVarCount/1","title":"Evision.ML.EM.getVarCount/1","type":"function"},{"doc":"Raising version of getWeights/1 .","ref":"Evision.ML.EM.html#getWeights!/1","title":"Evision.ML.EM.getWeights!/1","type":"function"},{"doc":"Returns weights of the mixtures Returns vector with the number of elements equal to the number of mixtures. Python prototype (for reference): getWeights() -&gt; retval","ref":"Evision.ML.EM.html#getWeights/1","title":"Evision.ML.EM.getWeights/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.EM.html#isClassifier!/1","title":"Evision.ML.EM.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.EM.html#isClassifier/1","title":"Evision.ML.EM.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.EM.html#isTrained!/1","title":"Evision.ML.EM.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.EM.html#isTrained/1","title":"Evision.ML.EM.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.EM.html#load!/1","title":"Evision.ML.EM.load!/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.ML.EM.html#load!/2","title":"Evision.ML.EM.load!/2","type":"function"},{"doc":"Loads and creates a serialized EM from a file Positional Arguments filepath : String . path to serialized EM Keyword Arguments nodeName : String . name of node containing the classifier Use EM::save to serialize and store an EM to disk. Load the EM from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.EM.html#load/1","title":"Evision.ML.EM.load/1","type":"function"},{"doc":"Loads and creates a serialized EM from a file Positional Arguments filepath : String . path to serialized EM Keyword Arguments nodeName : String . name of node containing the classifier Use EM::save to serialize and store an EM to disk. Load the EM from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.EM.html#load/2","title":"Evision.ML.EM.load/2","type":"function"},{"doc":"Raising version of predict2/2 .","ref":"Evision.ML.EM.html#predict2!/2","title":"Evision.ML.EM.predict2!/2","type":"function"},{"doc":"Raising version of predict2/3 .","ref":"Evision.ML.EM.html#predict2!/3","title":"Evision.ML.EM.predict2!/3","type":"function"},{"doc":"Returns a likelihood logarithm value and an index of the most probable mixture component for the given sample. Positional Arguments sample : Evision.Mat . A sample for classification. It should be a one-channel matrix of \\f$1 \\times dims\\f$ or \\f$dims \\times 1\\f$ size. Return probs : Evision.Mat . Optional output matrix that contains posterior probabilities of each component given the sample. It has \\f$1 \\times nclusters\\f$ size and CV_64FC1 type. The method returns a two-element double vector. Zero element is a likelihood logarithm value for the sample. First element is an index of the most probable mixture component for the given sample. Python prototype (for reference): predict2(sample[, probs]) -&gt; retval, probs","ref":"Evision.ML.EM.html#predict2/2","title":"Evision.ML.EM.predict2/2","type":"function"},{"doc":"Returns a likelihood logarithm value and an index of the most probable mixture component for the given sample. Positional Arguments sample : Evision.Mat . A sample for classification. It should be a one-channel matrix of \\f$1 \\times dims\\f$ or \\f$dims \\times 1\\f$ size. Return probs : Evision.Mat . Optional output matrix that contains posterior probabilities of each component given the sample. It has \\f$1 \\times nclusters\\f$ size and CV_64FC1 type. The method returns a two-element double vector. Zero element is a likelihood logarithm value for the sample. First element is an index of the most probable mixture component for the given sample. Python prototype (for reference): predict2(sample[, probs]) -&gt; retval, probs","ref":"Evision.ML.EM.html#predict2/3","title":"Evision.ML.EM.predict2/3","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.EM.html#predict!/2","title":"Evision.ML.EM.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.EM.html#predict!/3","title":"Evision.ML.EM.predict!/3","type":"function"},{"doc":"Returns posterior probabilities for the provided samples Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . This parameter will be ignored Return results : Evision.Mat . The optional output \\f$ nSamples \\times nClusters\\f$ matrix of results. It contains posterior probabilities for each sample from the input Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.EM.html#predict/2","title":"Evision.ML.EM.predict/2","type":"function"},{"doc":"Returns posterior probabilities for the provided samples Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . This parameter will be ignored Return results : Evision.Mat . The optional output \\f$ nSamples \\times nClusters\\f$ matrix of results. It contains posterior probabilities for each sample from the input Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.EM.html#predict/3","title":"Evision.ML.EM.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.EM.html#read!/2","title":"Evision.ML.EM.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.EM.html#read/2","title":"Evision.ML.EM.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.EM.html#save!/2","title":"Evision.ML.EM.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.EM.html#save/2","title":"Evision.ML.EM.save/2","type":"function"},{"doc":"Raising version of setClustersNumber/2 .","ref":"Evision.ML.EM.html#setClustersNumber!/2","title":"Evision.ML.EM.setClustersNumber!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getClustersNumber @see getClustersNumber Python prototype (for reference): setClustersNumber(val) -&gt; None","ref":"Evision.ML.EM.html#setClustersNumber/2","title":"Evision.ML.EM.setClustersNumber/2","type":"function"},{"doc":"Raising version of setCovarianceMatrixType/2 .","ref":"Evision.ML.EM.html#setCovarianceMatrixType!/2","title":"Evision.ML.EM.setCovarianceMatrixType!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getCovarianceMatrixType @see getCovarianceMatrixType Python prototype (for reference): setCovarianceMatrixType(val) -&gt; None","ref":"Evision.ML.EM.html#setCovarianceMatrixType/2","title":"Evision.ML.EM.setCovarianceMatrixType/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.ML.EM.html#setTermCriteria!/2","title":"Evision.ML.EM.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments val : TermCriteria @copybrief getTermCriteria @see getTermCriteria Python prototype (for reference): setTermCriteria(val) -&gt; None","ref":"Evision.ML.EM.html#setTermCriteria/2","title":"Evision.ML.EM.setTermCriteria/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.EM.html#train!/2","title":"Evision.ML.EM.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.EM.html#train!/3","title":"Evision.ML.EM.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.EM.html#train!/4","title":"Evision.ML.EM.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.EM.html#train/2","title":"Evision.ML.EM.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.EM.html#train/3","title":"Evision.ML.EM.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.EM.html#train/4","title":"Evision.ML.EM.train/4","type":"function"},{"doc":"Raising version of trainE/3 .","ref":"Evision.ML.EM.html#trainE!/3","title":"Evision.ML.EM.trainE!/3","type":"function"},{"doc":"Raising version of trainE/4 .","ref":"Evision.ML.EM.html#trainE!/4","title":"Evision.ML.EM.trainE!/4","type":"function"},{"doc":"Estimate the Gaussian mixture parameters from a samples set. Positional Arguments samples : Evision.Mat . Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. means0 : Evision.Mat . Initial means \\f$a_k\\f$ of mixture components. It is a one-channel matrix of \\f$nclusters \\times dims\\f$ size. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. Keyword Arguments covs0 : Evision.Mat . The vector of initial covariance matrices \\f$S_k\\f$ of mixture components. Each of covariance matrices is a one-channel matrix of \\f$dims \\times dims\\f$ size. If the matrices do not have CV_64F type they will be converted to the inner matrices of such type for the further computing. weights0 : Evision.Mat . Initial weights \\f$\\pi_k\\f$ of mixture components. It should be a one-channel floating-point matrix with \\f$1 \\times nclusters\\f$ or \\f$nclusters \\times 1\\f$ size. Return logLikelihoods : Evision.Mat . The optional output matrix that contains a likelihood logarithm value for each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type. labels : Evision.Mat . The optional output &quot;class label&quot; for each sample: \\f$\\texttt{labels} i=\\texttt{arg max}_k(p {i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type. probs : Evision.Mat . The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and CV_64FC1 type. This variation starts with Expectation step. You need to provide initial means \\f$a_k\\f$ of mixture components. Optionally you can pass initial weights \\f$\\pi_k\\f$ and covariance matrices \\f$S_k\\f$ of mixture components. Python prototype (for reference): trainE(samples, means0[, covs0[, weights0[, logLikelihoods[, labels[, probs]]]]]) -&gt; retval, logLikelihoods, labels, probs","ref":"Evision.ML.EM.html#trainE/3","title":"Evision.ML.EM.trainE/3","type":"function"},{"doc":"Estimate the Gaussian mixture parameters from a samples set. Positional Arguments samples : Evision.Mat . Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. means0 : Evision.Mat . Initial means \\f$a_k\\f$ of mixture components. It is a one-channel matrix of \\f$nclusters \\times dims\\f$ size. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. Keyword Arguments covs0 : Evision.Mat . The vector of initial covariance matrices \\f$S_k\\f$ of mixture components. Each of covariance matrices is a one-channel matrix of \\f$dims \\times dims\\f$ size. If the matrices do not have CV_64F type they will be converted to the inner matrices of such type for the further computing. weights0 : Evision.Mat . Initial weights \\f$\\pi_k\\f$ of mixture components. It should be a one-channel floating-point matrix with \\f$1 \\times nclusters\\f$ or \\f$nclusters \\times 1\\f$ size. Return logLikelihoods : Evision.Mat . The optional output matrix that contains a likelihood logarithm value for each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type. labels : Evision.Mat . The optional output &quot;class label&quot; for each sample: \\f$\\texttt{labels} i=\\texttt{arg max}_k(p {i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type. probs : Evision.Mat . The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and CV_64FC1 type. This variation starts with Expectation step. You need to provide initial means \\f$a_k\\f$ of mixture components. Optionally you can pass initial weights \\f$\\pi_k\\f$ and covariance matrices \\f$S_k\\f$ of mixture components. Python prototype (for reference): trainE(samples, means0[, covs0[, weights0[, logLikelihoods[, labels[, probs]]]]]) -&gt; retval, logLikelihoods, labels, probs","ref":"Evision.ML.EM.html#trainE/4","title":"Evision.ML.EM.trainE/4","type":"function"},{"doc":"Raising version of trainEM/2 .","ref":"Evision.ML.EM.html#trainEM!/2","title":"Evision.ML.EM.trainEM!/2","type":"function"},{"doc":"Raising version of trainEM/3 .","ref":"Evision.ML.EM.html#trainEM!/3","title":"Evision.ML.EM.trainEM!/3","type":"function"},{"doc":"Estimate the Gaussian mixture parameters from a samples set. Positional Arguments samples : Evision.Mat . Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. Return logLikelihoods : Evision.Mat . The optional output matrix that contains a likelihood logarithm value for each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type. labels : Evision.Mat . The optional output &quot;class label&quot; for each sample: \\f$\\texttt{labels} i=\\texttt{arg max}_k(p {i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type. probs : Evision.Mat . The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and CV_64FC1 type. This variation starts with Expectation step. Initial values of the model parameters will be estimated by the k-means algorithm. Unlike many of the ML models, %EM is an unsupervised learning algorithm and it does not take responses (class labels or function values) as input. Instead, it computes the Maximum Likelihood Estimate of the Gaussian mixture parameters from an input sample set, stores all the parameters inside the structure: \\f$p_{i,k}\\f$ in probs, \\f$a_k\\f$ in means , \\f$S_k\\f$ in covs[k], \\f$\\pi_k\\f$ in weights , and optionally computes the output &quot;class label&quot; for each sample: \\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). The trained model can be used further for prediction, just like any other classifier. The trained model is similar to the NormalBayesClassifier. Python prototype (for reference): trainEM(samples[, logLikelihoods[, labels[, probs]]]) -&gt; retval, logLikelihoods, labels, probs","ref":"Evision.ML.EM.html#trainEM/2","title":"Evision.ML.EM.trainEM/2","type":"function"},{"doc":"Estimate the Gaussian mixture parameters from a samples set. Positional Arguments samples : Evision.Mat . Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. Return logLikelihoods : Evision.Mat . The optional output matrix that contains a likelihood logarithm value for each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type. labels : Evision.Mat . The optional output &quot;class label&quot; for each sample: \\f$\\texttt{labels} i=\\texttt{arg max}_k(p {i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type. probs : Evision.Mat . The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and CV_64FC1 type. This variation starts with Expectation step. Initial values of the model parameters will be estimated by the k-means algorithm. Unlike many of the ML models, %EM is an unsupervised learning algorithm and it does not take responses (class labels or function values) as input. Instead, it computes the Maximum Likelihood Estimate of the Gaussian mixture parameters from an input sample set, stores all the parameters inside the structure: \\f$p_{i,k}\\f$ in probs, \\f$a_k\\f$ in means , \\f$S_k\\f$ in covs[k], \\f$\\pi_k\\f$ in weights , and optionally computes the output &quot;class label&quot; for each sample: \\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). The trained model can be used further for prediction, just like any other classifier. The trained model is similar to the NormalBayesClassifier. Python prototype (for reference): trainEM(samples[, logLikelihoods[, labels[, probs]]]) -&gt; retval, logLikelihoods, labels, probs","ref":"Evision.ML.EM.html#trainEM/3","title":"Evision.ML.EM.trainEM/3","type":"function"},{"doc":"Raising version of trainM/3 .","ref":"Evision.ML.EM.html#trainM!/3","title":"Evision.ML.EM.trainM!/3","type":"function"},{"doc":"Raising version of trainM/4 .","ref":"Evision.ML.EM.html#trainM!/4","title":"Evision.ML.EM.trainM!/4","type":"function"},{"doc":"Estimate the Gaussian mixture parameters from a samples set. Positional Arguments samples : Evision.Mat . Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. probs0 : Evision.Mat . the probabilities Return logLikelihoods : Evision.Mat . The optional output matrix that contains a likelihood logarithm value for each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type. labels : Evision.Mat . The optional output &quot;class label&quot; for each sample: \\f$\\texttt{labels} i=\\texttt{arg max}_k(p {i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type. probs : Evision.Mat . The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and CV_64FC1 type. This variation starts with Maximization step. You need to provide initial probabilities \\f$p_{i,k}\\f$ to use this option. Python prototype (for reference): trainM(samples, probs0[, logLikelihoods[, labels[, probs]]]) -&gt; retval, logLikelihoods, labels, probs","ref":"Evision.ML.EM.html#trainM/3","title":"Evision.ML.EM.trainM/3","type":"function"},{"doc":"Estimate the Gaussian mixture parameters from a samples set. Positional Arguments samples : Evision.Mat . Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing. probs0 : Evision.Mat . the probabilities Return logLikelihoods : Evision.Mat . The optional output matrix that contains a likelihood logarithm value for each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type. labels : Evision.Mat . The optional output &quot;class label&quot; for each sample: \\f$\\texttt{labels} i=\\texttt{arg max}_k(p {i,k}), i=1..N\\f$ (indices of the most probable mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type. probs : Evision.Mat . The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and CV_64FC1 type. This variation starts with Maximization step. You need to provide initial probabilities \\f$p_{i,k}\\f$ to use this option. Python prototype (for reference): trainM(samples, probs0[, logLikelihoods[, labels[, probs]]]) -&gt; retval, logLikelihoods, labels, probs","ref":"Evision.ML.EM.html#trainM/4","title":"Evision.ML.EM.trainM/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.EM.html#write!/2","title":"Evision.ML.EM.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.EM.html#write!/3","title":"Evision.ML.EM.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.EM.html#write/2","title":"Evision.ML.EM.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.EM.html#write/3","title":"Evision.ML.EM.write/3","type":"function"},{"doc":"","ref":"Evision.ML.KNearest.html","title":"Evision.ML.KNearest","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.KNearest.html#calcError!/3","title":"Evision.ML.KNearest.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.KNearest.html#calcError!/4","title":"Evision.ML.KNearest.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.KNearest.html#calcError/3","title":"Evision.ML.KNearest.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.KNearest.html#calcError/4","title":"Evision.ML.KNearest.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.KNearest.html#clear!/1","title":"Evision.ML.KNearest.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.KNearest.html#clear/1","title":"Evision.ML.KNearest.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.KNearest.html#create!/0","title":"Evision.ML.KNearest.create!/0","type":"function"},{"doc":"Creates the empty model The static method creates empty %KNearest classifier. It should be then trained using StatModel::train method. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.KNearest.html#create/0","title":"Evision.ML.KNearest.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.KNearest.html#empty!/1","title":"Evision.ML.KNearest.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.KNearest.html#empty/1","title":"Evision.ML.KNearest.empty/1","type":"function"},{"doc":"Raising version of findNearest/3 .","ref":"Evision.ML.KNearest.html#findNearest!/3","title":"Evision.ML.KNearest.findNearest!/3","type":"function"},{"doc":"Raising version of findNearest/4 .","ref":"Evision.ML.KNearest.html#findNearest!/4","title":"Evision.ML.KNearest.findNearest!/4","type":"function"},{"doc":"Finds the neighbors and predicts responses for input vectors. Positional Arguments samples : Evision.Mat . Input samples stored by rows. It is a single-precision floating-point matrix of &lt;number_of_samples&gt; * k size. k : int . Number of used nearest neighbors. Should be greater than 1. Return results : Evision.Mat . Vector with results of prediction (regression or classification) for each input sample. It is a single-precision floating-point vector with &lt;number_of_samples&gt; elements. neighborResponses : Evision.Mat . Optional output values for corresponding neighbors. It is a single- precision floating-point matrix of &lt;number_of_samples&gt; * k size. dist : Evision.Mat . Optional output distances from the input vectors to the corresponding neighbors. It is a single-precision floating-point matrix of &lt;number_of_samples&gt; * k size. For each input vector (a row of the matrix samples), the method finds the k nearest neighbors. In case of regression, the predicted result is a mean value of the particular vector's neighbor responses. In case of classification, the class is determined by voting. For each input vector, the neighbors are sorted by their distances to the vector. In case of C++ interface you can use output pointers to empty matrices and the function will allocate memory itself. If only a single input vector is passed, all output matrices are optional and the predicted value is returned by the method. The function is parallelized with the TBB library. Python prototype (for reference): findNearest(samples, k[, results[, neighborResponses[, dist]]]) -&gt; retval, results, neighborResponses, dist","ref":"Evision.ML.KNearest.html#findNearest/3","title":"Evision.ML.KNearest.findNearest/3","type":"function"},{"doc":"Finds the neighbors and predicts responses for input vectors. Positional Arguments samples : Evision.Mat . Input samples stored by rows. It is a single-precision floating-point matrix of &lt;number_of_samples&gt; * k size. k : int . Number of used nearest neighbors. Should be greater than 1. Return results : Evision.Mat . Vector with results of prediction (regression or classification) for each input sample. It is a single-precision floating-point vector with &lt;number_of_samples&gt; elements. neighborResponses : Evision.Mat . Optional output values for corresponding neighbors. It is a single- precision floating-point matrix of &lt;number_of_samples&gt; * k size. dist : Evision.Mat . Optional output distances from the input vectors to the corresponding neighbors. It is a single-precision floating-point matrix of &lt;number_of_samples&gt; * k size. For each input vector (a row of the matrix samples), the method finds the k nearest neighbors. In case of regression, the predicted result is a mean value of the particular vector's neighbor responses. In case of classification, the class is determined by voting. For each input vector, the neighbors are sorted by their distances to the vector. In case of C++ interface you can use output pointers to empty matrices and the function will allocate memory itself. If only a single input vector is passed, all output matrices are optional and the predicted value is returned by the method. The function is parallelized with the TBB library. Python prototype (for reference): findNearest(samples, k[, results[, neighborResponses[, dist]]]) -&gt; retval, results, neighborResponses, dist","ref":"Evision.ML.KNearest.html#findNearest/4","title":"Evision.ML.KNearest.findNearest/4","type":"function"},{"doc":"Raising version of getAlgorithmType/1 .","ref":"Evision.ML.KNearest.html#getAlgorithmType!/1","title":"Evision.ML.KNearest.getAlgorithmType!/1","type":"function"},{"doc":"@see setAlgorithmType Python prototype (for reference): getAlgorithmType() -&gt; retval","ref":"Evision.ML.KNearest.html#getAlgorithmType/1","title":"Evision.ML.KNearest.getAlgorithmType/1","type":"function"},{"doc":"Raising version of getDefaultK/1 .","ref":"Evision.ML.KNearest.html#getDefaultK!/1","title":"Evision.ML.KNearest.getDefaultK!/1","type":"function"},{"doc":"@see setDefaultK Python prototype (for reference): getDefaultK() -&gt; retval","ref":"Evision.ML.KNearest.html#getDefaultK/1","title":"Evision.ML.KNearest.getDefaultK/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.KNearest.html#getDefaultName!/1","title":"Evision.ML.KNearest.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.KNearest.html#getDefaultName/1","title":"Evision.ML.KNearest.getDefaultName/1","type":"function"},{"doc":"Raising version of getEmax/1 .","ref":"Evision.ML.KNearest.html#getEmax!/1","title":"Evision.ML.KNearest.getEmax!/1","type":"function"},{"doc":"@see setEmax Python prototype (for reference): getEmax() -&gt; retval","ref":"Evision.ML.KNearest.html#getEmax/1","title":"Evision.ML.KNearest.getEmax/1","type":"function"},{"doc":"Raising version of getIsClassifier/1 .","ref":"Evision.ML.KNearest.html#getIsClassifier!/1","title":"Evision.ML.KNearest.getIsClassifier!/1","type":"function"},{"doc":"@see setIsClassifier Python prototype (for reference): getIsClassifier() -&gt; retval","ref":"Evision.ML.KNearest.html#getIsClassifier/1","title":"Evision.ML.KNearest.getIsClassifier/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.KNearest.html#getVarCount!/1","title":"Evision.ML.KNearest.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.KNearest.html#getVarCount/1","title":"Evision.ML.KNearest.getVarCount/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.KNearest.html#isClassifier!/1","title":"Evision.ML.KNearest.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.KNearest.html#isClassifier/1","title":"Evision.ML.KNearest.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.KNearest.html#isTrained!/1","title":"Evision.ML.KNearest.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.KNearest.html#isTrained/1","title":"Evision.ML.KNearest.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.KNearest.html#load!/1","title":"Evision.ML.KNearest.load!/1","type":"function"},{"doc":"Loads and creates a serialized knearest from a file Positional Arguments filepath : String . path to serialized KNearest Use KNearest::save to serialize and store an KNearest to disk. Load the KNearest from this file again, by calling this function with the path to the file. Python prototype (for reference): load(filepath) -&gt; retval","ref":"Evision.ML.KNearest.html#load/1","title":"Evision.ML.KNearest.load/1","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.KNearest.html#predict!/2","title":"Evision.ML.KNearest.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.KNearest.html#predict!/3","title":"Evision.ML.KNearest.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.KNearest.html#predict/2","title":"Evision.ML.KNearest.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.KNearest.html#predict/3","title":"Evision.ML.KNearest.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.KNearest.html#read!/2","title":"Evision.ML.KNearest.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.KNearest.html#read/2","title":"Evision.ML.KNearest.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.KNearest.html#save!/2","title":"Evision.ML.KNearest.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.KNearest.html#save/2","title":"Evision.ML.KNearest.save/2","type":"function"},{"doc":"Raising version of setAlgorithmType/2 .","ref":"Evision.ML.KNearest.html#setAlgorithmType!/2","title":"Evision.ML.KNearest.setAlgorithmType!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getAlgorithmType @see getAlgorithmType Python prototype (for reference): setAlgorithmType(val) -&gt; None","ref":"Evision.ML.KNearest.html#setAlgorithmType/2","title":"Evision.ML.KNearest.setAlgorithmType/2","type":"function"},{"doc":"Raising version of setDefaultK/2 .","ref":"Evision.ML.KNearest.html#setDefaultK!/2","title":"Evision.ML.KNearest.setDefaultK!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getDefaultK @see getDefaultK Python prototype (for reference): setDefaultK(val) -&gt; None","ref":"Evision.ML.KNearest.html#setDefaultK/2","title":"Evision.ML.KNearest.setDefaultK/2","type":"function"},{"doc":"Raising version of setEmax/2 .","ref":"Evision.ML.KNearest.html#setEmax!/2","title":"Evision.ML.KNearest.setEmax!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getEmax @see getEmax Python prototype (for reference): setEmax(val) -&gt; None","ref":"Evision.ML.KNearest.html#setEmax/2","title":"Evision.ML.KNearest.setEmax/2","type":"function"},{"doc":"Raising version of setIsClassifier/2 .","ref":"Evision.ML.KNearest.html#setIsClassifier!/2","title":"Evision.ML.KNearest.setIsClassifier!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getIsClassifier @see getIsClassifier Python prototype (for reference): setIsClassifier(val) -&gt; None","ref":"Evision.ML.KNearest.html#setIsClassifier/2","title":"Evision.ML.KNearest.setIsClassifier/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.KNearest.html#train!/2","title":"Evision.ML.KNearest.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.KNearest.html#train!/3","title":"Evision.ML.KNearest.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.KNearest.html#train!/4","title":"Evision.ML.KNearest.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.KNearest.html#train/2","title":"Evision.ML.KNearest.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.KNearest.html#train/3","title":"Evision.ML.KNearest.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.KNearest.html#train/4","title":"Evision.ML.KNearest.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.KNearest.html#write!/2","title":"Evision.ML.KNearest.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.KNearest.html#write!/3","title":"Evision.ML.KNearest.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.KNearest.html#write/2","title":"Evision.ML.KNearest.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.KNearest.html#write/3","title":"Evision.ML.KNearest.write/3","type":"function"},{"doc":"","ref":"Evision.ML.LogisticRegression.html","title":"Evision.ML.LogisticRegression","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.LogisticRegression.html#calcError!/3","title":"Evision.ML.LogisticRegression.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.LogisticRegression.html#calcError!/4","title":"Evision.ML.LogisticRegression.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.LogisticRegression.html#calcError/3","title":"Evision.ML.LogisticRegression.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.LogisticRegression.html#calcError/4","title":"Evision.ML.LogisticRegression.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.LogisticRegression.html#clear!/1","title":"Evision.ML.LogisticRegression.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.LogisticRegression.html#clear/1","title":"Evision.ML.LogisticRegression.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.LogisticRegression.html#create!/0","title":"Evision.ML.LogisticRegression.create!/0","type":"function"},{"doc":"Creates empty model. Creates Logistic Regression model with parameters given. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#create/0","title":"Evision.ML.LogisticRegression.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.LogisticRegression.html#empty!/1","title":"Evision.ML.LogisticRegression.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#empty/1","title":"Evision.ML.LogisticRegression.empty/1","type":"function"},{"doc":"Raising version of get_learnt_thetas/1 .","ref":"Evision.ML.LogisticRegression.html#get_learnt_thetas!/1","title":"Evision.ML.LogisticRegression.get_learnt_thetas!/1","type":"function"},{"doc":"This function returns the trained parameters arranged across rows. For a two class classification problem, it returns a row matrix. It returns learnt parameters of the Logistic Regression as a matrix of type CV_32F. Python prototype (for reference): get_learnt_thetas() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#get_learnt_thetas/1","title":"Evision.ML.LogisticRegression.get_learnt_thetas/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.LogisticRegression.html#getDefaultName!/1","title":"Evision.ML.LogisticRegression.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getDefaultName/1","title":"Evision.ML.LogisticRegression.getDefaultName/1","type":"function"},{"doc":"Raising version of getIterations/1 .","ref":"Evision.ML.LogisticRegression.html#getIterations!/1","title":"Evision.ML.LogisticRegression.getIterations!/1","type":"function"},{"doc":"@see setIterations Python prototype (for reference): getIterations() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getIterations/1","title":"Evision.ML.LogisticRegression.getIterations/1","type":"function"},{"doc":"Raising version of getLearningRate/1 .","ref":"Evision.ML.LogisticRegression.html#getLearningRate!/1","title":"Evision.ML.LogisticRegression.getLearningRate!/1","type":"function"},{"doc":"@see setLearningRate Python prototype (for reference): getLearningRate() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getLearningRate/1","title":"Evision.ML.LogisticRegression.getLearningRate/1","type":"function"},{"doc":"Raising version of getMiniBatchSize/1 .","ref":"Evision.ML.LogisticRegression.html#getMiniBatchSize!/1","title":"Evision.ML.LogisticRegression.getMiniBatchSize!/1","type":"function"},{"doc":"@see setMiniBatchSize Python prototype (for reference): getMiniBatchSize() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getMiniBatchSize/1","title":"Evision.ML.LogisticRegression.getMiniBatchSize/1","type":"function"},{"doc":"Raising version of getRegularization/1 .","ref":"Evision.ML.LogisticRegression.html#getRegularization!/1","title":"Evision.ML.LogisticRegression.getRegularization!/1","type":"function"},{"doc":"@see setRegularization Python prototype (for reference): getRegularization() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getRegularization/1","title":"Evision.ML.LogisticRegression.getRegularization/1","type":"function"},{"doc":"Raising version of getTermCriteria/1 .","ref":"Evision.ML.LogisticRegression.html#getTermCriteria!/1","title":"Evision.ML.LogisticRegression.getTermCriteria!/1","type":"function"},{"doc":"@see setTermCriteria Python prototype (for reference): getTermCriteria() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getTermCriteria/1","title":"Evision.ML.LogisticRegression.getTermCriteria/1","type":"function"},{"doc":"Raising version of getTrainMethod/1 .","ref":"Evision.ML.LogisticRegression.html#getTrainMethod!/1","title":"Evision.ML.LogisticRegression.getTrainMethod!/1","type":"function"},{"doc":"@see setTrainMethod Python prototype (for reference): getTrainMethod() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getTrainMethod/1","title":"Evision.ML.LogisticRegression.getTrainMethod/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.LogisticRegression.html#getVarCount!/1","title":"Evision.ML.LogisticRegression.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#getVarCount/1","title":"Evision.ML.LogisticRegression.getVarCount/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.LogisticRegression.html#isClassifier!/1","title":"Evision.ML.LogisticRegression.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#isClassifier/1","title":"Evision.ML.LogisticRegression.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.LogisticRegression.html#isTrained!/1","title":"Evision.ML.LogisticRegression.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.LogisticRegression.html#isTrained/1","title":"Evision.ML.LogisticRegression.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.LogisticRegression.html#load!/1","title":"Evision.ML.LogisticRegression.load!/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.ML.LogisticRegression.html#load!/2","title":"Evision.ML.LogisticRegression.load!/2","type":"function"},{"doc":"Loads and creates a serialized LogisticRegression from a file Positional Arguments filepath : String . path to serialized LogisticRegression Keyword Arguments nodeName : String . name of node containing the classifier Use LogisticRegression::save to serialize and store an LogisticRegression to disk. Load the LogisticRegression from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.LogisticRegression.html#load/1","title":"Evision.ML.LogisticRegression.load/1","type":"function"},{"doc":"Loads and creates a serialized LogisticRegression from a file Positional Arguments filepath : String . path to serialized LogisticRegression Keyword Arguments nodeName : String . name of node containing the classifier Use LogisticRegression::save to serialize and store an LogisticRegression to disk. Load the LogisticRegression from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.LogisticRegression.html#load/2","title":"Evision.ML.LogisticRegression.load/2","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.LogisticRegression.html#predict!/2","title":"Evision.ML.LogisticRegression.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.LogisticRegression.html#predict!/3","title":"Evision.ML.LogisticRegression.predict!/3","type":"function"},{"doc":"Predicts responses for input samples and returns a float type. Positional Arguments samples : Evision.Mat . The input data for the prediction algorithm. Matrix [m x n], where each row contains variables (features) of one object being classified. Should have data type CV_32F. Keyword Arguments flags : int . Not used. Return results : Evision.Mat . Predicted labels as a column matrix of type CV_32S. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.LogisticRegression.html#predict/2","title":"Evision.ML.LogisticRegression.predict/2","type":"function"},{"doc":"Predicts responses for input samples and returns a float type. Positional Arguments samples : Evision.Mat . The input data for the prediction algorithm. Matrix [m x n], where each row contains variables (features) of one object being classified. Should have data type CV_32F. Keyword Arguments flags : int . Not used. Return results : Evision.Mat . Predicted labels as a column matrix of type CV_32S. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.LogisticRegression.html#predict/3","title":"Evision.ML.LogisticRegression.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.LogisticRegression.html#read!/2","title":"Evision.ML.LogisticRegression.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.LogisticRegression.html#read/2","title":"Evision.ML.LogisticRegression.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.LogisticRegression.html#save!/2","title":"Evision.ML.LogisticRegression.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.LogisticRegression.html#save/2","title":"Evision.ML.LogisticRegression.save/2","type":"function"},{"doc":"Raising version of setIterations/2 .","ref":"Evision.ML.LogisticRegression.html#setIterations!/2","title":"Evision.ML.LogisticRegression.setIterations!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getIterations @see getIterations Python prototype (for reference): setIterations(val) -&gt; None","ref":"Evision.ML.LogisticRegression.html#setIterations/2","title":"Evision.ML.LogisticRegression.setIterations/2","type":"function"},{"doc":"Raising version of setLearningRate/2 .","ref":"Evision.ML.LogisticRegression.html#setLearningRate!/2","title":"Evision.ML.LogisticRegression.setLearningRate!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getLearningRate @see getLearningRate Python prototype (for reference): setLearningRate(val) -&gt; None","ref":"Evision.ML.LogisticRegression.html#setLearningRate/2","title":"Evision.ML.LogisticRegression.setLearningRate/2","type":"function"},{"doc":"Raising version of setMiniBatchSize/2 .","ref":"Evision.ML.LogisticRegression.html#setMiniBatchSize!/2","title":"Evision.ML.LogisticRegression.setMiniBatchSize!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMiniBatchSize @see getMiniBatchSize Python prototype (for reference): setMiniBatchSize(val) -&gt; None","ref":"Evision.ML.LogisticRegression.html#setMiniBatchSize/2","title":"Evision.ML.LogisticRegression.setMiniBatchSize/2","type":"function"},{"doc":"Raising version of setRegularization/2 .","ref":"Evision.ML.LogisticRegression.html#setRegularization!/2","title":"Evision.ML.LogisticRegression.setRegularization!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getRegularization @see getRegularization Python prototype (for reference): setRegularization(val) -&gt; None","ref":"Evision.ML.LogisticRegression.html#setRegularization/2","title":"Evision.ML.LogisticRegression.setRegularization/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.ML.LogisticRegression.html#setTermCriteria!/2","title":"Evision.ML.LogisticRegression.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments val : TermCriteria @copybrief getTermCriteria @see getTermCriteria Python prototype (for reference): setTermCriteria(val) -&gt; None","ref":"Evision.ML.LogisticRegression.html#setTermCriteria/2","title":"Evision.ML.LogisticRegression.setTermCriteria/2","type":"function"},{"doc":"Raising version of setTrainMethod/2 .","ref":"Evision.ML.LogisticRegression.html#setTrainMethod!/2","title":"Evision.ML.LogisticRegression.setTrainMethod!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getTrainMethod @see getTrainMethod Python prototype (for reference): setTrainMethod(val) -&gt; None","ref":"Evision.ML.LogisticRegression.html#setTrainMethod/2","title":"Evision.ML.LogisticRegression.setTrainMethod/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.LogisticRegression.html#train!/2","title":"Evision.ML.LogisticRegression.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.LogisticRegression.html#train!/3","title":"Evision.ML.LogisticRegression.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.LogisticRegression.html#train!/4","title":"Evision.ML.LogisticRegression.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.LogisticRegression.html#train/2","title":"Evision.ML.LogisticRegression.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.LogisticRegression.html#train/3","title":"Evision.ML.LogisticRegression.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.LogisticRegression.html#train/4","title":"Evision.ML.LogisticRegression.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.LogisticRegression.html#write!/2","title":"Evision.ML.LogisticRegression.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.LogisticRegression.html#write!/3","title":"Evision.ML.LogisticRegression.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.LogisticRegression.html#write/2","title":"Evision.ML.LogisticRegression.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.LogisticRegression.html#write/3","title":"Evision.ML.LogisticRegression.write/3","type":"function"},{"doc":"","ref":"Evision.ML.NormalBayesClassifier.html","title":"Evision.ML.NormalBayesClassifier","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.NormalBayesClassifier.html#calcError!/3","title":"Evision.ML.NormalBayesClassifier.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.NormalBayesClassifier.html#calcError!/4","title":"Evision.ML.NormalBayesClassifier.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.NormalBayesClassifier.html#calcError/3","title":"Evision.ML.NormalBayesClassifier.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.NormalBayesClassifier.html#calcError/4","title":"Evision.ML.NormalBayesClassifier.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.NormalBayesClassifier.html#clear!/1","title":"Evision.ML.NormalBayesClassifier.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.NormalBayesClassifier.html#clear/1","title":"Evision.ML.NormalBayesClassifier.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.NormalBayesClassifier.html#create!/0","title":"Evision.ML.NormalBayesClassifier.create!/0","type":"function"},{"doc":"Creates empty model Use StatModel::train to train the model after creation. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#create/0","title":"Evision.ML.NormalBayesClassifier.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.NormalBayesClassifier.html#empty!/1","title":"Evision.ML.NormalBayesClassifier.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#empty/1","title":"Evision.ML.NormalBayesClassifier.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.NormalBayesClassifier.html#getDefaultName!/1","title":"Evision.ML.NormalBayesClassifier.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#getDefaultName/1","title":"Evision.ML.NormalBayesClassifier.getDefaultName/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.NormalBayesClassifier.html#getVarCount!/1","title":"Evision.ML.NormalBayesClassifier.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#getVarCount/1","title":"Evision.ML.NormalBayesClassifier.getVarCount/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.NormalBayesClassifier.html#isClassifier!/1","title":"Evision.ML.NormalBayesClassifier.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#isClassifier/1","title":"Evision.ML.NormalBayesClassifier.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.NormalBayesClassifier.html#isTrained!/1","title":"Evision.ML.NormalBayesClassifier.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#isTrained/1","title":"Evision.ML.NormalBayesClassifier.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.NormalBayesClassifier.html#load!/1","title":"Evision.ML.NormalBayesClassifier.load!/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.ML.NormalBayesClassifier.html#load!/2","title":"Evision.ML.NormalBayesClassifier.load!/2","type":"function"},{"doc":"Loads and creates a serialized NormalBayesClassifier from a file Positional Arguments filepath : String . path to serialized NormalBayesClassifier Keyword Arguments nodeName : String . name of node containing the classifier Use NormalBayesClassifier::save to serialize and store an NormalBayesClassifier to disk. Load the NormalBayesClassifier from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#load/1","title":"Evision.ML.NormalBayesClassifier.load/1","type":"function"},{"doc":"Loads and creates a serialized NormalBayesClassifier from a file Positional Arguments filepath : String . path to serialized NormalBayesClassifier Keyword Arguments nodeName : String . name of node containing the classifier Use NormalBayesClassifier::save to serialize and store an NormalBayesClassifier to disk. Load the NormalBayesClassifier from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#load/2","title":"Evision.ML.NormalBayesClassifier.load/2","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.NormalBayesClassifier.html#predict!/2","title":"Evision.ML.NormalBayesClassifier.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.NormalBayesClassifier.html#predict!/3","title":"Evision.ML.NormalBayesClassifier.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.NormalBayesClassifier.html#predict/2","title":"Evision.ML.NormalBayesClassifier.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.NormalBayesClassifier.html#predict/3","title":"Evision.ML.NormalBayesClassifier.predict/3","type":"function"},{"doc":"Raising version of predictProb/2 .","ref":"Evision.ML.NormalBayesClassifier.html#predictProb!/2","title":"Evision.ML.NormalBayesClassifier.predictProb!/2","type":"function"},{"doc":"Raising version of predictProb/3 .","ref":"Evision.ML.NormalBayesClassifier.html#predictProb!/3","title":"Evision.ML.NormalBayesClassifier.predictProb!/3","type":"function"},{"doc":"Predicts the response for sample(s). Positional Arguments inputs : Evision.Mat Keyword Arguments flags : int . Return outputs : Evision.Mat . outputProbs : Evision.Mat . The method estimates the most probable classes for input vectors. Input vectors (one or more) are stored as rows of the matrix inputs. In case of multiple input vectors, there should be one output vector outputs. The predicted class for a single input vector is returned by the method. The vector outputProbs contains the output probabilities corresponding to each element of result. Python prototype (for reference): predictProb(inputs[, outputs[, outputProbs[, flags]]]) -&gt; retval, outputs, outputProbs","ref":"Evision.ML.NormalBayesClassifier.html#predictProb/2","title":"Evision.ML.NormalBayesClassifier.predictProb/2","type":"function"},{"doc":"Predicts the response for sample(s). Positional Arguments inputs : Evision.Mat Keyword Arguments flags : int . Return outputs : Evision.Mat . outputProbs : Evision.Mat . The method estimates the most probable classes for input vectors. Input vectors (one or more) are stored as rows of the matrix inputs. In case of multiple input vectors, there should be one output vector outputs. The predicted class for a single input vector is returned by the method. The vector outputProbs contains the output probabilities corresponding to each element of result. Python prototype (for reference): predictProb(inputs[, outputs[, outputProbs[, flags]]]) -&gt; retval, outputs, outputProbs","ref":"Evision.ML.NormalBayesClassifier.html#predictProb/3","title":"Evision.ML.NormalBayesClassifier.predictProb/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.NormalBayesClassifier.html#read!/2","title":"Evision.ML.NormalBayesClassifier.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.NormalBayesClassifier.html#read/2","title":"Evision.ML.NormalBayesClassifier.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.NormalBayesClassifier.html#save!/2","title":"Evision.ML.NormalBayesClassifier.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.NormalBayesClassifier.html#save/2","title":"Evision.ML.NormalBayesClassifier.save/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.NormalBayesClassifier.html#train!/2","title":"Evision.ML.NormalBayesClassifier.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.NormalBayesClassifier.html#train!/3","title":"Evision.ML.NormalBayesClassifier.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.NormalBayesClassifier.html#train!/4","title":"Evision.ML.NormalBayesClassifier.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#train/2","title":"Evision.ML.NormalBayesClassifier.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#train/3","title":"Evision.ML.NormalBayesClassifier.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.NormalBayesClassifier.html#train/4","title":"Evision.ML.NormalBayesClassifier.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.NormalBayesClassifier.html#write!/2","title":"Evision.ML.NormalBayesClassifier.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.NormalBayesClassifier.html#write!/3","title":"Evision.ML.NormalBayesClassifier.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.NormalBayesClassifier.html#write/2","title":"Evision.ML.NormalBayesClassifier.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.NormalBayesClassifier.html#write/3","title":"Evision.ML.NormalBayesClassifier.write/3","type":"function"},{"doc":"","ref":"Evision.ML.ParamGrid.html","title":"Evision.ML.ParamGrid","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.ParamGrid.html#create!/0","title":"Evision.ML.ParamGrid.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.ML.ParamGrid.html#create!/1","title":"Evision.ML.ParamGrid.create!/1","type":"function"},{"doc":"Creates a ParamGrid Ptr that can be given to the %SVM::trainAuto method Keyword Arguments minVal : double . minimum value of the parameter grid maxVal : double . maximum value of the parameter grid logstep : double . Logarithmic step for iterating the statmodel parameter Python prototype (for reference): create([, minVal[, maxVal[, logstep]]]) -&gt; retval","ref":"Evision.ML.ParamGrid.html#create/0","title":"Evision.ML.ParamGrid.create/0","type":"function"},{"doc":"Creates a ParamGrid Ptr that can be given to the %SVM::trainAuto method Keyword Arguments minVal : double . minimum value of the parameter grid maxVal : double . maximum value of the parameter grid logstep : double . Logarithmic step for iterating the statmodel parameter Python prototype (for reference): create([, minVal[, maxVal[, logstep]]]) -&gt; retval","ref":"Evision.ML.ParamGrid.html#create/1","title":"Evision.ML.ParamGrid.create/1","type":"function"},{"doc":"Raising version of get_logStep/1 .","ref":"Evision.ML.ParamGrid.html#get_logStep!/1","title":"Evision.ML.ParamGrid.get_logStep!/1","type":"function"},{"doc":"","ref":"Evision.ML.ParamGrid.html#get_logStep/1","title":"Evision.ML.ParamGrid.get_logStep/1","type":"function"},{"doc":"Raising version of get_maxVal/1 .","ref":"Evision.ML.ParamGrid.html#get_maxVal!/1","title":"Evision.ML.ParamGrid.get_maxVal!/1","type":"function"},{"doc":"","ref":"Evision.ML.ParamGrid.html#get_maxVal/1","title":"Evision.ML.ParamGrid.get_maxVal/1","type":"function"},{"doc":"Raising version of get_minVal/1 .","ref":"Evision.ML.ParamGrid.html#get_minVal!/1","title":"Evision.ML.ParamGrid.get_minVal!/1","type":"function"},{"doc":"","ref":"Evision.ML.ParamGrid.html#get_minVal/1","title":"Evision.ML.ParamGrid.get_minVal/1","type":"function"},{"doc":"Raising version of set_logStep/2 .","ref":"Evision.ML.ParamGrid.html#set_logStep!/2","title":"Evision.ML.ParamGrid.set_logStep!/2","type":"function"},{"doc":"","ref":"Evision.ML.ParamGrid.html#set_logStep/2","title":"Evision.ML.ParamGrid.set_logStep/2","type":"function"},{"doc":"Raising version of set_maxVal/2 .","ref":"Evision.ML.ParamGrid.html#set_maxVal!/2","title":"Evision.ML.ParamGrid.set_maxVal!/2","type":"function"},{"doc":"","ref":"Evision.ML.ParamGrid.html#set_maxVal/2","title":"Evision.ML.ParamGrid.set_maxVal/2","type":"function"},{"doc":"Raising version of set_minVal/2 .","ref":"Evision.ML.ParamGrid.html#set_minVal!/2","title":"Evision.ML.ParamGrid.set_minVal!/2","type":"function"},{"doc":"","ref":"Evision.ML.ParamGrid.html#set_minVal/2","title":"Evision.ML.ParamGrid.set_minVal/2","type":"function"},{"doc":"","ref":"Evision.ML.RTrees.html","title":"Evision.ML.RTrees","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.RTrees.html#calcError!/3","title":"Evision.ML.RTrees.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.RTrees.html#calcError!/4","title":"Evision.ML.RTrees.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.RTrees.html#calcError/3","title":"Evision.ML.RTrees.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.RTrees.html#calcError/4","title":"Evision.ML.RTrees.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.RTrees.html#clear!/1","title":"Evision.ML.RTrees.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.RTrees.html#clear/1","title":"Evision.ML.RTrees.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.RTrees.html#create!/0","title":"Evision.ML.RTrees.create!/0","type":"function"},{"doc":"Creates the empty model. Use StatModel::train to train the model, StatModel::train to create and train the model, Algorithm::load to load the pre-trained model. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.RTrees.html#create/0","title":"Evision.ML.RTrees.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.RTrees.html#empty!/1","title":"Evision.ML.RTrees.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.RTrees.html#empty/1","title":"Evision.ML.RTrees.empty/1","type":"function"},{"doc":"Raising version of getActiveVarCount/1 .","ref":"Evision.ML.RTrees.html#getActiveVarCount!/1","title":"Evision.ML.RTrees.getActiveVarCount!/1","type":"function"},{"doc":"@see setActiveVarCount Python prototype (for reference): getActiveVarCount() -&gt; retval","ref":"Evision.ML.RTrees.html#getActiveVarCount/1","title":"Evision.ML.RTrees.getActiveVarCount/1","type":"function"},{"doc":"Raising version of getCalculateVarImportance/1 .","ref":"Evision.ML.RTrees.html#getCalculateVarImportance!/1","title":"Evision.ML.RTrees.getCalculateVarImportance!/1","type":"function"},{"doc":"@see setCalculateVarImportance Python prototype (for reference): getCalculateVarImportance() -&gt; retval","ref":"Evision.ML.RTrees.html#getCalculateVarImportance/1","title":"Evision.ML.RTrees.getCalculateVarImportance/1","type":"function"},{"doc":"Raising version of getCVFolds/1 .","ref":"Evision.ML.RTrees.html#getCVFolds!/1","title":"Evision.ML.RTrees.getCVFolds!/1","type":"function"},{"doc":"@see setCVFolds Python prototype (for reference): getCVFolds() -&gt; retval","ref":"Evision.ML.RTrees.html#getCVFolds/1","title":"Evision.ML.RTrees.getCVFolds/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.RTrees.html#getDefaultName!/1","title":"Evision.ML.RTrees.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.RTrees.html#getDefaultName/1","title":"Evision.ML.RTrees.getDefaultName/1","type":"function"},{"doc":"Raising version of getMaxCategories/1 .","ref":"Evision.ML.RTrees.html#getMaxCategories!/1","title":"Evision.ML.RTrees.getMaxCategories!/1","type":"function"},{"doc":"@see setMaxCategories Python prototype (for reference): getMaxCategories() -&gt; retval","ref":"Evision.ML.RTrees.html#getMaxCategories/1","title":"Evision.ML.RTrees.getMaxCategories/1","type":"function"},{"doc":"Raising version of getMaxDepth/1 .","ref":"Evision.ML.RTrees.html#getMaxDepth!/1","title":"Evision.ML.RTrees.getMaxDepth!/1","type":"function"},{"doc":"@see setMaxDepth Python prototype (for reference): getMaxDepth() -&gt; retval","ref":"Evision.ML.RTrees.html#getMaxDepth/1","title":"Evision.ML.RTrees.getMaxDepth/1","type":"function"},{"doc":"Raising version of getMinSampleCount/1 .","ref":"Evision.ML.RTrees.html#getMinSampleCount!/1","title":"Evision.ML.RTrees.getMinSampleCount!/1","type":"function"},{"doc":"@see setMinSampleCount Python prototype (for reference): getMinSampleCount() -&gt; retval","ref":"Evision.ML.RTrees.html#getMinSampleCount/1","title":"Evision.ML.RTrees.getMinSampleCount/1","type":"function"},{"doc":"Raising version of getOOBError/1 .","ref":"Evision.ML.RTrees.html#getOOBError!/1","title":"Evision.ML.RTrees.getOOBError!/1","type":"function"},{"doc":"Returns the OOB error value, computed at the training stage when calcOOBError is set to true. If this flag was set to false, 0 is returned. The OOB error is also scaled by sample weighting. Python prototype (for reference): getOOBError() -&gt; retval","ref":"Evision.ML.RTrees.html#getOOBError/1","title":"Evision.ML.RTrees.getOOBError/1","type":"function"},{"doc":"Raising version of getPriors/1 .","ref":"Evision.ML.RTrees.html#getPriors!/1","title":"Evision.ML.RTrees.getPriors!/1","type":"function"},{"doc":"@see setPriors Python prototype (for reference): getPriors() -&gt; retval","ref":"Evision.ML.RTrees.html#getPriors/1","title":"Evision.ML.RTrees.getPriors/1","type":"function"},{"doc":"Raising version of getRegressionAccuracy/1 .","ref":"Evision.ML.RTrees.html#getRegressionAccuracy!/1","title":"Evision.ML.RTrees.getRegressionAccuracy!/1","type":"function"},{"doc":"@see setRegressionAccuracy Python prototype (for reference): getRegressionAccuracy() -&gt; retval","ref":"Evision.ML.RTrees.html#getRegressionAccuracy/1","title":"Evision.ML.RTrees.getRegressionAccuracy/1","type":"function"},{"doc":"Raising version of getTermCriteria/1 .","ref":"Evision.ML.RTrees.html#getTermCriteria!/1","title":"Evision.ML.RTrees.getTermCriteria!/1","type":"function"},{"doc":"@see setTermCriteria Python prototype (for reference): getTermCriteria() -&gt; retval","ref":"Evision.ML.RTrees.html#getTermCriteria/1","title":"Evision.ML.RTrees.getTermCriteria/1","type":"function"},{"doc":"Raising version of getTruncatePrunedTree/1 .","ref":"Evision.ML.RTrees.html#getTruncatePrunedTree!/1","title":"Evision.ML.RTrees.getTruncatePrunedTree!/1","type":"function"},{"doc":"@see setTruncatePrunedTree Python prototype (for reference): getTruncatePrunedTree() -&gt; retval","ref":"Evision.ML.RTrees.html#getTruncatePrunedTree/1","title":"Evision.ML.RTrees.getTruncatePrunedTree/1","type":"function"},{"doc":"Raising version of getUse1SERule/1 .","ref":"Evision.ML.RTrees.html#getUse1SERule!/1","title":"Evision.ML.RTrees.getUse1SERule!/1","type":"function"},{"doc":"@see setUse1SERule Python prototype (for reference): getUse1SERule() -&gt; retval","ref":"Evision.ML.RTrees.html#getUse1SERule/1","title":"Evision.ML.RTrees.getUse1SERule/1","type":"function"},{"doc":"Raising version of getUseSurrogates/1 .","ref":"Evision.ML.RTrees.html#getUseSurrogates!/1","title":"Evision.ML.RTrees.getUseSurrogates!/1","type":"function"},{"doc":"@see setUseSurrogates Python prototype (for reference): getUseSurrogates() -&gt; retval","ref":"Evision.ML.RTrees.html#getUseSurrogates/1","title":"Evision.ML.RTrees.getUseSurrogates/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.RTrees.html#getVarCount!/1","title":"Evision.ML.RTrees.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.RTrees.html#getVarCount/1","title":"Evision.ML.RTrees.getVarCount/1","type":"function"},{"doc":"Raising version of getVarImportance/1 .","ref":"Evision.ML.RTrees.html#getVarImportance!/1","title":"Evision.ML.RTrees.getVarImportance!/1","type":"function"},{"doc":"Returns the variable importance array. The method returns the variable importance vector, computed at the training stage when CalculateVarImportance is set to true. If this flag was set to false, the empty matrix is returned. Python prototype (for reference): getVarImportance() -&gt; retval","ref":"Evision.ML.RTrees.html#getVarImportance/1","title":"Evision.ML.RTrees.getVarImportance/1","type":"function"},{"doc":"Raising version of getVotes/3 .","ref":"Evision.ML.RTrees.html#getVotes!/3","title":"Evision.ML.RTrees.getVotes!/3","type":"function"},{"doc":"Raising version of getVotes/4 .","ref":"Evision.ML.RTrees.html#getVotes!/4","title":"Evision.ML.RTrees.getVotes!/4","type":"function"},{"doc":"Positional Arguments samples : Evision.Mat . Array containing the samples for which votes will be calculated. flags : int . Flags for defining the type of RTrees. Return results : Evision.Mat . Array where the result of the calculation will be written. Returns the result of each individual tree in the forest. In case the model is a regression problem, the method will return each of the trees' results for each of the sample cases. If the model is a classifier, it will return a Mat with samples + 1 rows, where the first row gives the class number and the following rows return the votes each class had for each sample. Python prototype (for reference): getVotes(samples, flags[, results]) -&gt; results","ref":"Evision.ML.RTrees.html#getVotes/3","title":"Evision.ML.RTrees.getVotes/3","type":"function"},{"doc":"Positional Arguments samples : Evision.Mat . Array containing the samples for which votes will be calculated. flags : int . Flags for defining the type of RTrees. Return results : Evision.Mat . Array where the result of the calculation will be written. Returns the result of each individual tree in the forest. In case the model is a regression problem, the method will return each of the trees' results for each of the sample cases. If the model is a classifier, it will return a Mat with samples + 1 rows, where the first row gives the class number and the following rows return the votes each class had for each sample. Python prototype (for reference): getVotes(samples, flags[, results]) -&gt; results","ref":"Evision.ML.RTrees.html#getVotes/4","title":"Evision.ML.RTrees.getVotes/4","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.RTrees.html#isClassifier!/1","title":"Evision.ML.RTrees.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.RTrees.html#isClassifier/1","title":"Evision.ML.RTrees.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.RTrees.html#isTrained!/1","title":"Evision.ML.RTrees.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.RTrees.html#isTrained/1","title":"Evision.ML.RTrees.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.RTrees.html#load!/1","title":"Evision.ML.RTrees.load!/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.ML.RTrees.html#load!/2","title":"Evision.ML.RTrees.load!/2","type":"function"},{"doc":"Loads and creates a serialized RTree from a file Positional Arguments filepath : String . path to serialized RTree Keyword Arguments nodeName : String . name of node containing the classifier Use RTree::save to serialize and store an RTree to disk. Load the RTree from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.RTrees.html#load/1","title":"Evision.ML.RTrees.load/1","type":"function"},{"doc":"Loads and creates a serialized RTree from a file Positional Arguments filepath : String . path to serialized RTree Keyword Arguments nodeName : String . name of node containing the classifier Use RTree::save to serialize and store an RTree to disk. Load the RTree from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.RTrees.html#load/2","title":"Evision.ML.RTrees.load/2","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.RTrees.html#predict!/2","title":"Evision.ML.RTrees.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.RTrees.html#predict!/3","title":"Evision.ML.RTrees.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.RTrees.html#predict/2","title":"Evision.ML.RTrees.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.RTrees.html#predict/3","title":"Evision.ML.RTrees.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.RTrees.html#read!/2","title":"Evision.ML.RTrees.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.RTrees.html#read/2","title":"Evision.ML.RTrees.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.RTrees.html#save!/2","title":"Evision.ML.RTrees.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.RTrees.html#save/2","title":"Evision.ML.RTrees.save/2","type":"function"},{"doc":"Raising version of setActiveVarCount/2 .","ref":"Evision.ML.RTrees.html#setActiveVarCount!/2","title":"Evision.ML.RTrees.setActiveVarCount!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getActiveVarCount @see getActiveVarCount Python prototype (for reference): setActiveVarCount(val) -&gt; None","ref":"Evision.ML.RTrees.html#setActiveVarCount/2","title":"Evision.ML.RTrees.setActiveVarCount/2","type":"function"},{"doc":"Raising version of setCalculateVarImportance/2 .","ref":"Evision.ML.RTrees.html#setCalculateVarImportance!/2","title":"Evision.ML.RTrees.setCalculateVarImportance!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getCalculateVarImportance @see getCalculateVarImportance Python prototype (for reference): setCalculateVarImportance(val) -&gt; None","ref":"Evision.ML.RTrees.html#setCalculateVarImportance/2","title":"Evision.ML.RTrees.setCalculateVarImportance/2","type":"function"},{"doc":"Raising version of setCVFolds/2 .","ref":"Evision.ML.RTrees.html#setCVFolds!/2","title":"Evision.ML.RTrees.setCVFolds!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getCVFolds @see getCVFolds Python prototype (for reference): setCVFolds(val) -&gt; None","ref":"Evision.ML.RTrees.html#setCVFolds/2","title":"Evision.ML.RTrees.setCVFolds/2","type":"function"},{"doc":"Raising version of setMaxCategories/2 .","ref":"Evision.ML.RTrees.html#setMaxCategories!/2","title":"Evision.ML.RTrees.setMaxCategories!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMaxCategories @see getMaxCategories Python prototype (for reference): setMaxCategories(val) -&gt; None","ref":"Evision.ML.RTrees.html#setMaxCategories/2","title":"Evision.ML.RTrees.setMaxCategories/2","type":"function"},{"doc":"Raising version of setMaxDepth/2 .","ref":"Evision.ML.RTrees.html#setMaxDepth!/2","title":"Evision.ML.RTrees.setMaxDepth!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMaxDepth @see getMaxDepth Python prototype (for reference): setMaxDepth(val) -&gt; None","ref":"Evision.ML.RTrees.html#setMaxDepth/2","title":"Evision.ML.RTrees.setMaxDepth/2","type":"function"},{"doc":"Raising version of setMinSampleCount/2 .","ref":"Evision.ML.RTrees.html#setMinSampleCount!/2","title":"Evision.ML.RTrees.setMinSampleCount!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getMinSampleCount @see getMinSampleCount Python prototype (for reference): setMinSampleCount(val) -&gt; None","ref":"Evision.ML.RTrees.html#setMinSampleCount/2","title":"Evision.ML.RTrees.setMinSampleCount/2","type":"function"},{"doc":"Raising version of setPriors/2 .","ref":"Evision.ML.RTrees.html#setPriors!/2","title":"Evision.ML.RTrees.setPriors!/2","type":"function"},{"doc":"Positional Arguments val : Evision.Mat @copybrief getPriors @see getPriors Python prototype (for reference): setPriors(val) -&gt; None","ref":"Evision.ML.RTrees.html#setPriors/2","title":"Evision.ML.RTrees.setPriors/2","type":"function"},{"doc":"Raising version of setRegressionAccuracy/2 .","ref":"Evision.ML.RTrees.html#setRegressionAccuracy!/2","title":"Evision.ML.RTrees.setRegressionAccuracy!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getRegressionAccuracy @see getRegressionAccuracy Python prototype (for reference): setRegressionAccuracy(val) -&gt; None","ref":"Evision.ML.RTrees.html#setRegressionAccuracy/2","title":"Evision.ML.RTrees.setRegressionAccuracy/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.ML.RTrees.html#setTermCriteria!/2","title":"Evision.ML.RTrees.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments val : TermCriteria @copybrief getTermCriteria @see getTermCriteria Python prototype (for reference): setTermCriteria(val) -&gt; None","ref":"Evision.ML.RTrees.html#setTermCriteria/2","title":"Evision.ML.RTrees.setTermCriteria/2","type":"function"},{"doc":"Raising version of setTruncatePrunedTree/2 .","ref":"Evision.ML.RTrees.html#setTruncatePrunedTree!/2","title":"Evision.ML.RTrees.setTruncatePrunedTree!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getTruncatePrunedTree @see getTruncatePrunedTree Python prototype (for reference): setTruncatePrunedTree(val) -&gt; None","ref":"Evision.ML.RTrees.html#setTruncatePrunedTree/2","title":"Evision.ML.RTrees.setTruncatePrunedTree/2","type":"function"},{"doc":"Raising version of setUse1SERule/2 .","ref":"Evision.ML.RTrees.html#setUse1SERule!/2","title":"Evision.ML.RTrees.setUse1SERule!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUse1SERule @see getUse1SERule Python prototype (for reference): setUse1SERule(val) -&gt; None","ref":"Evision.ML.RTrees.html#setUse1SERule/2","title":"Evision.ML.RTrees.setUse1SERule/2","type":"function"},{"doc":"Raising version of setUseSurrogates/2 .","ref":"Evision.ML.RTrees.html#setUseSurrogates!/2","title":"Evision.ML.RTrees.setUseSurrogates!/2","type":"function"},{"doc":"Positional Arguments val : bool @copybrief getUseSurrogates @see getUseSurrogates Python prototype (for reference): setUseSurrogates(val) -&gt; None","ref":"Evision.ML.RTrees.html#setUseSurrogates/2","title":"Evision.ML.RTrees.setUseSurrogates/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.RTrees.html#train!/2","title":"Evision.ML.RTrees.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.RTrees.html#train!/3","title":"Evision.ML.RTrees.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.RTrees.html#train!/4","title":"Evision.ML.RTrees.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.RTrees.html#train/2","title":"Evision.ML.RTrees.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.RTrees.html#train/3","title":"Evision.ML.RTrees.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.RTrees.html#train/4","title":"Evision.ML.RTrees.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.RTrees.html#write!/2","title":"Evision.ML.RTrees.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.RTrees.html#write!/3","title":"Evision.ML.RTrees.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.RTrees.html#write/2","title":"Evision.ML.RTrees.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.RTrees.html#write/3","title":"Evision.ML.RTrees.write/3","type":"function"},{"doc":"","ref":"Evision.ML.SVM.html","title":"Evision.ML.SVM","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.SVM.html#calcError!/3","title":"Evision.ML.SVM.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.SVM.html#calcError!/4","title":"Evision.ML.SVM.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.SVM.html#calcError/3","title":"Evision.ML.SVM.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.SVM.html#calcError/4","title":"Evision.ML.SVM.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.SVM.html#clear!/1","title":"Evision.ML.SVM.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.SVM.html#clear/1","title":"Evision.ML.SVM.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.SVM.html#create!/0","title":"Evision.ML.SVM.create!/0","type":"function"},{"doc":"Creates empty model. Use StatModel::train to train the model. Since %SVM has several parameters, you may want to find the best parameters for your problem, it can be done with SVM::trainAuto. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.SVM.html#create/0","title":"Evision.ML.SVM.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.SVM.html#empty!/1","title":"Evision.ML.SVM.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.SVM.html#empty/1","title":"Evision.ML.SVM.empty/1","type":"function"},{"doc":"Raising version of getC/1 .","ref":"Evision.ML.SVM.html#getC!/1","title":"Evision.ML.SVM.getC!/1","type":"function"},{"doc":"@see setC Python prototype (for reference): getC() -&gt; retval","ref":"Evision.ML.SVM.html#getC/1","title":"Evision.ML.SVM.getC/1","type":"function"},{"doc":"Raising version of getClassWeights/1 .","ref":"Evision.ML.SVM.html#getClassWeights!/1","title":"Evision.ML.SVM.getClassWeights!/1","type":"function"},{"doc":"@see setClassWeights Python prototype (for reference): getClassWeights() -&gt; retval","ref":"Evision.ML.SVM.html#getClassWeights/1","title":"Evision.ML.SVM.getClassWeights/1","type":"function"},{"doc":"Raising version of getCoef0/1 .","ref":"Evision.ML.SVM.html#getCoef0!/1","title":"Evision.ML.SVM.getCoef0!/1","type":"function"},{"doc":"@see setCoef0 Python prototype (for reference): getCoef0() -&gt; retval","ref":"Evision.ML.SVM.html#getCoef0/1","title":"Evision.ML.SVM.getCoef0/1","type":"function"},{"doc":"Raising version of getDecisionFunction/2 .","ref":"Evision.ML.SVM.html#getDecisionFunction!/2","title":"Evision.ML.SVM.getDecisionFunction!/2","type":"function"},{"doc":"Raising version of getDecisionFunction/3 .","ref":"Evision.ML.SVM.html#getDecisionFunction!/3","title":"Evision.ML.SVM.getDecisionFunction!/3","type":"function"},{"doc":"Retrieves the decision function Positional Arguments i : int . the index of the decision function. If the problem solved is regression, 1-class or 2-class classification, then there will be just one decision function and the index should always be 0. Otherwise, in the case of N-class classification, there will be \\f$N(N-1)/2\\f$ decision functions. Return alpha : Evision.Mat . the optional output vector for weights, corresponding to different support vectors. In the case of linear %SVM all the alpha's will be 1's. svidx : Evision.Mat . the optional output vector of indices of support vectors within the matrix of support vectors (which can be retrieved by SVM::getSupportVectors). In the case of linear %SVM each decision function consists of a single &quot;compressed&quot; support vector. The method returns rho parameter of the decision function, a scalar subtracted from the weighted sum of kernel responses. Python prototype (for reference): getDecisionFunction(i[, alpha[, svidx]]) -&gt; retval, alpha, svidx","ref":"Evision.ML.SVM.html#getDecisionFunction/2","title":"Evision.ML.SVM.getDecisionFunction/2","type":"function"},{"doc":"Retrieves the decision function Positional Arguments i : int . the index of the decision function. If the problem solved is regression, 1-class or 2-class classification, then there will be just one decision function and the index should always be 0. Otherwise, in the case of N-class classification, there will be \\f$N(N-1)/2\\f$ decision functions. Return alpha : Evision.Mat . the optional output vector for weights, corresponding to different support vectors. In the case of linear %SVM all the alpha's will be 1's. svidx : Evision.Mat . the optional output vector of indices of support vectors within the matrix of support vectors (which can be retrieved by SVM::getSupportVectors). In the case of linear %SVM each decision function consists of a single &quot;compressed&quot; support vector. The method returns rho parameter of the decision function, a scalar subtracted from the weighted sum of kernel responses. Python prototype (for reference): getDecisionFunction(i[, alpha[, svidx]]) -&gt; retval, alpha, svidx","ref":"Evision.ML.SVM.html#getDecisionFunction/3","title":"Evision.ML.SVM.getDecisionFunction/3","type":"function"},{"doc":"Raising version of getDefaultGridPtr/1 .","ref":"Evision.ML.SVM.html#getDefaultGridPtr!/1","title":"Evision.ML.SVM.getDefaultGridPtr!/1","type":"function"},{"doc":"Generates a grid for %SVM parameters. Positional Arguments param_id : int . %SVM parameters IDs that must be one of the SVM::ParamTypes. The grid is generated for the parameter with this ID. The function generates a grid pointer for the specified parameter of the %SVM algorithm. The grid may be passed to the function SVM::trainAuto. Python prototype (for reference): getDefaultGridPtr(param_id) -&gt; retval","ref":"Evision.ML.SVM.html#getDefaultGridPtr/1","title":"Evision.ML.SVM.getDefaultGridPtr/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.SVM.html#getDefaultName!/1","title":"Evision.ML.SVM.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.SVM.html#getDefaultName/1","title":"Evision.ML.SVM.getDefaultName/1","type":"function"},{"doc":"Raising version of getDegree/1 .","ref":"Evision.ML.SVM.html#getDegree!/1","title":"Evision.ML.SVM.getDegree!/1","type":"function"},{"doc":"@see setDegree Python prototype (for reference): getDegree() -&gt; retval","ref":"Evision.ML.SVM.html#getDegree/1","title":"Evision.ML.SVM.getDegree/1","type":"function"},{"doc":"Raising version of getGamma/1 .","ref":"Evision.ML.SVM.html#getGamma!/1","title":"Evision.ML.SVM.getGamma!/1","type":"function"},{"doc":"@see setGamma Python prototype (for reference): getGamma() -&gt; retval","ref":"Evision.ML.SVM.html#getGamma/1","title":"Evision.ML.SVM.getGamma/1","type":"function"},{"doc":"Raising version of getKernelType/1 .","ref":"Evision.ML.SVM.html#getKernelType!/1","title":"Evision.ML.SVM.getKernelType!/1","type":"function"},{"doc":"Type of a %SVM kernel. See SVM::KernelTypes. Default value is SVM::RBF. Python prototype (for reference): getKernelType() -&gt; retval","ref":"Evision.ML.SVM.html#getKernelType/1","title":"Evision.ML.SVM.getKernelType/1","type":"function"},{"doc":"Raising version of getNu/1 .","ref":"Evision.ML.SVM.html#getNu!/1","title":"Evision.ML.SVM.getNu!/1","type":"function"},{"doc":"@see setNu Python prototype (for reference): getNu() -&gt; retval","ref":"Evision.ML.SVM.html#getNu/1","title":"Evision.ML.SVM.getNu/1","type":"function"},{"doc":"Raising version of getP/1 .","ref":"Evision.ML.SVM.html#getP!/1","title":"Evision.ML.SVM.getP!/1","type":"function"},{"doc":"@see setP Python prototype (for reference): getP() -&gt; retval","ref":"Evision.ML.SVM.html#getP/1","title":"Evision.ML.SVM.getP/1","type":"function"},{"doc":"Raising version of getSupportVectors/1 .","ref":"Evision.ML.SVM.html#getSupportVectors!/1","title":"Evision.ML.SVM.getSupportVectors!/1","type":"function"},{"doc":"Retrieves all the support vectors The method returns all the support vectors as a floating-point matrix, where support vectors are stored as matrix rows. Python prototype (for reference): getSupportVectors() -&gt; retval","ref":"Evision.ML.SVM.html#getSupportVectors/1","title":"Evision.ML.SVM.getSupportVectors/1","type":"function"},{"doc":"Raising version of getTermCriteria/1 .","ref":"Evision.ML.SVM.html#getTermCriteria!/1","title":"Evision.ML.SVM.getTermCriteria!/1","type":"function"},{"doc":"@see setTermCriteria Python prototype (for reference): getTermCriteria() -&gt; retval","ref":"Evision.ML.SVM.html#getTermCriteria/1","title":"Evision.ML.SVM.getTermCriteria/1","type":"function"},{"doc":"Raising version of getType/1 .","ref":"Evision.ML.SVM.html#getType!/1","title":"Evision.ML.SVM.getType!/1","type":"function"},{"doc":"@see setType Python prototype (for reference): getType() -&gt; retval","ref":"Evision.ML.SVM.html#getType/1","title":"Evision.ML.SVM.getType/1","type":"function"},{"doc":"Raising version of getUncompressedSupportVectors/1 .","ref":"Evision.ML.SVM.html#getUncompressedSupportVectors!/1","title":"Evision.ML.SVM.getUncompressedSupportVectors!/1","type":"function"},{"doc":"Retrieves all the uncompressed support vectors of a linear %SVM The method returns all the uncompressed support vectors of a linear %SVM that the compressed support vector, used for prediction, was derived from. They are returned in a floating-point matrix, where the support vectors are stored as matrix rows. Python prototype (for reference): getUncompressedSupportVectors() -&gt; retval","ref":"Evision.ML.SVM.html#getUncompressedSupportVectors/1","title":"Evision.ML.SVM.getUncompressedSupportVectors/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.SVM.html#getVarCount!/1","title":"Evision.ML.SVM.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.SVM.html#getVarCount/1","title":"Evision.ML.SVM.getVarCount/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.SVM.html#isClassifier!/1","title":"Evision.ML.SVM.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.SVM.html#isClassifier/1","title":"Evision.ML.SVM.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.SVM.html#isTrained!/1","title":"Evision.ML.SVM.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.SVM.html#isTrained/1","title":"Evision.ML.SVM.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.SVM.html#load!/1","title":"Evision.ML.SVM.load!/1","type":"function"},{"doc":"Loads and creates a serialized svm from a file Positional Arguments filepath : String . path to serialized svm Use SVM::save to serialize and store an SVM to disk. Load the SVM from this file again, by calling this function with the path to the file. Python prototype (for reference): load(filepath) -&gt; retval","ref":"Evision.ML.SVM.html#load/1","title":"Evision.ML.SVM.load/1","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.SVM.html#predict!/2","title":"Evision.ML.SVM.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.SVM.html#predict!/3","title":"Evision.ML.SVM.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.SVM.html#predict/2","title":"Evision.ML.SVM.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.SVM.html#predict/3","title":"Evision.ML.SVM.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.SVM.html#read!/2","title":"Evision.ML.SVM.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.SVM.html#read/2","title":"Evision.ML.SVM.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.SVM.html#save!/2","title":"Evision.ML.SVM.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.SVM.html#save/2","title":"Evision.ML.SVM.save/2","type":"function"},{"doc":"Raising version of setC/2 .","ref":"Evision.ML.SVM.html#setC!/2","title":"Evision.ML.SVM.setC!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getC @see getC Python prototype (for reference): setC(val) -&gt; None","ref":"Evision.ML.SVM.html#setC/2","title":"Evision.ML.SVM.setC/2","type":"function"},{"doc":"Raising version of setClassWeights/2 .","ref":"Evision.ML.SVM.html#setClassWeights!/2","title":"Evision.ML.SVM.setClassWeights!/2","type":"function"},{"doc":"Positional Arguments val : Evision.Mat @copybrief getClassWeights @see getClassWeights Python prototype (for reference): setClassWeights(val) -&gt; None","ref":"Evision.ML.SVM.html#setClassWeights/2","title":"Evision.ML.SVM.setClassWeights/2","type":"function"},{"doc":"Raising version of setCoef0/2 .","ref":"Evision.ML.SVM.html#setCoef0!/2","title":"Evision.ML.SVM.setCoef0!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getCoef0 @see getCoef0 Python prototype (for reference): setCoef0(val) -&gt; None","ref":"Evision.ML.SVM.html#setCoef0/2","title":"Evision.ML.SVM.setCoef0/2","type":"function"},{"doc":"Raising version of setDegree/2 .","ref":"Evision.ML.SVM.html#setDegree!/2","title":"Evision.ML.SVM.setDegree!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getDegree @see getDegree Python prototype (for reference): setDegree(val) -&gt; None","ref":"Evision.ML.SVM.html#setDegree/2","title":"Evision.ML.SVM.setDegree/2","type":"function"},{"doc":"Raising version of setGamma/2 .","ref":"Evision.ML.SVM.html#setGamma!/2","title":"Evision.ML.SVM.setGamma!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getGamma @see getGamma Python prototype (for reference): setGamma(val) -&gt; None","ref":"Evision.ML.SVM.html#setGamma/2","title":"Evision.ML.SVM.setGamma/2","type":"function"},{"doc":"Raising version of setKernel/2 .","ref":"Evision.ML.SVM.html#setKernel!/2","title":"Evision.ML.SVM.setKernel!/2","type":"function"},{"doc":"Positional Arguments kernelType : int Initialize with one of predefined kernels. See SVM::KernelTypes. Python prototype (for reference): setKernel(kernelType) -&gt; None","ref":"Evision.ML.SVM.html#setKernel/2","title":"Evision.ML.SVM.setKernel/2","type":"function"},{"doc":"Raising version of setNu/2 .","ref":"Evision.ML.SVM.html#setNu!/2","title":"Evision.ML.SVM.setNu!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getNu @see getNu Python prototype (for reference): setNu(val) -&gt; None","ref":"Evision.ML.SVM.html#setNu/2","title":"Evision.ML.SVM.setNu/2","type":"function"},{"doc":"Raising version of setP/2 .","ref":"Evision.ML.SVM.html#setP!/2","title":"Evision.ML.SVM.setP!/2","type":"function"},{"doc":"Positional Arguments val : double @copybrief getP @see getP Python prototype (for reference): setP(val) -&gt; None","ref":"Evision.ML.SVM.html#setP/2","title":"Evision.ML.SVM.setP/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.ML.SVM.html#setTermCriteria!/2","title":"Evision.ML.SVM.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments val : TermCriteria @copybrief getTermCriteria @see getTermCriteria Python prototype (for reference): setTermCriteria(val) -&gt; None","ref":"Evision.ML.SVM.html#setTermCriteria/2","title":"Evision.ML.SVM.setTermCriteria/2","type":"function"},{"doc":"Raising version of setType/2 .","ref":"Evision.ML.SVM.html#setType!/2","title":"Evision.ML.SVM.setType!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getType @see getType Python prototype (for reference): setType(val) -&gt; None","ref":"Evision.ML.SVM.html#setType/2","title":"Evision.ML.SVM.setType/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.SVM.html#train!/2","title":"Evision.ML.SVM.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.SVM.html#train!/3","title":"Evision.ML.SVM.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.SVM.html#train!/4","title":"Evision.ML.SVM.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.SVM.html#train/2","title":"Evision.ML.SVM.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.SVM.html#train/3","title":"Evision.ML.SVM.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.SVM.html#train/4","title":"Evision.ML.SVM.train/4","type":"function"},{"doc":"Raising version of trainAuto/4 .","ref":"Evision.ML.SVM.html#trainAuto!/4","title":"Evision.ML.SVM.trainAuto!/4","type":"function"},{"doc":"Raising version of trainAuto/5 .","ref":"Evision.ML.SVM.html#trainAuto!/5","title":"Evision.ML.SVM.trainAuto!/5","type":"function"},{"doc":"Trains an %SVM with optimal parameters Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Keyword Arguments kFold : int . Cross-validation parameter. The training set is divided into kFold subsets. One subset is used to test the model, the others form the train set. So, the %SVM algorithm is cgrid : Ptr&lt;ParamGrid&gt; . gammaGrid : Ptr&lt;ParamGrid&gt; . grid for gamma pGrid : Ptr&lt;ParamGrid&gt; . nuGrid : Ptr&lt;ParamGrid&gt; . coeffGrid : Ptr&lt;ParamGrid&gt; . grid for coeff degreeGrid : Ptr&lt;ParamGrid&gt; . grid for degree balanced : bool . If true and the problem is 2-class classification then the method creates more balanced cross-validation subsets that is proportions between classes in subsets are close to such proportion in the whole train dataset. The method trains the %SVM model automatically by choosing the optimal parameters C, gamma, p, nu, coef0, degree. Parameters are considered optimal when the cross-validation estimate of the test set error is minimal. This function only makes use of SVM::getDefaultGrid for parameter optimization and thus only offers rudimentary parameter options. This function works for the classification (SVM::C_SVC or SVM::NU_SVC) as well as for the regression (SVM::EPS_SVR or SVM::NU_SVR). If it is SVM::ONE_CLASS, no optimization is made and the usual %SVM with parameters specified in params is executed. Python prototype (for reference): trainAuto(samples, layout, responses[, kFold[, Cgrid[, gammaGrid[, pGrid[, nuGrid[, coeffGrid[, degreeGrid[, balanced]]]]]]]]) -&gt; retval","ref":"Evision.ML.SVM.html#trainAuto/4","title":"Evision.ML.SVM.trainAuto/4","type":"function"},{"doc":"Trains an %SVM with optimal parameters Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Keyword Arguments kFold : int . Cross-validation parameter. The training set is divided into kFold subsets. One subset is used to test the model, the others form the train set. So, the %SVM algorithm is cgrid : Ptr&lt;ParamGrid&gt; . gammaGrid : Ptr&lt;ParamGrid&gt; . grid for gamma pGrid : Ptr&lt;ParamGrid&gt; . nuGrid : Ptr&lt;ParamGrid&gt; . coeffGrid : Ptr&lt;ParamGrid&gt; . grid for coeff degreeGrid : Ptr&lt;ParamGrid&gt; . grid for degree balanced : bool . If true and the problem is 2-class classification then the method creates more balanced cross-validation subsets that is proportions between classes in subsets are close to such proportion in the whole train dataset. The method trains the %SVM model automatically by choosing the optimal parameters C, gamma, p, nu, coef0, degree. Parameters are considered optimal when the cross-validation estimate of the test set error is minimal. This function only makes use of SVM::getDefaultGrid for parameter optimization and thus only offers rudimentary parameter options. This function works for the classification (SVM::C_SVC or SVM::NU_SVC) as well as for the regression (SVM::EPS_SVR or SVM::NU_SVR). If it is SVM::ONE_CLASS, no optimization is made and the usual %SVM with parameters specified in params is executed. Python prototype (for reference): trainAuto(samples, layout, responses[, kFold[, Cgrid[, gammaGrid[, pGrid[, nuGrid[, coeffGrid[, degreeGrid[, balanced]]]]]]]]) -&gt; retval","ref":"Evision.ML.SVM.html#trainAuto/5","title":"Evision.ML.SVM.trainAuto/5","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.SVM.html#write!/2","title":"Evision.ML.SVM.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.SVM.html#write!/3","title":"Evision.ML.SVM.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.SVM.html#write/2","title":"Evision.ML.SVM.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.SVM.html#write/3","title":"Evision.ML.SVM.write/3","type":"function"},{"doc":"","ref":"Evision.ML.SVMSGD.html","title":"Evision.ML.SVMSGD","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.SVMSGD.html#calcError!/3","title":"Evision.ML.SVMSGD.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.SVMSGD.html#calcError!/4","title":"Evision.ML.SVMSGD.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.SVMSGD.html#calcError/3","title":"Evision.ML.SVMSGD.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.SVMSGD.html#calcError/4","title":"Evision.ML.SVMSGD.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.SVMSGD.html#clear!/1","title":"Evision.ML.SVMSGD.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.SVMSGD.html#clear/1","title":"Evision.ML.SVMSGD.clear/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ML.SVMSGD.html#create!/0","title":"Evision.ML.SVMSGD.create!/0","type":"function"},{"doc":"Creates empty model. Use StatModel::train to train the model. Since %SVMSGD has several parameters, you may want to find the best parameters for your problem or use setOptimalParameters() to set some default parameters. Python prototype (for reference): create() -&gt; retval","ref":"Evision.ML.SVMSGD.html#create/0","title":"Evision.ML.SVMSGD.create/0","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.SVMSGD.html#empty!/1","title":"Evision.ML.SVMSGD.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.SVMSGD.html#empty/1","title":"Evision.ML.SVMSGD.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.SVMSGD.html#getDefaultName!/1","title":"Evision.ML.SVMSGD.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getDefaultName/1","title":"Evision.ML.SVMSGD.getDefaultName/1","type":"function"},{"doc":"Raising version of getInitialStepSize/1 .","ref":"Evision.ML.SVMSGD.html#getInitialStepSize!/1","title":"Evision.ML.SVMSGD.getInitialStepSize!/1","type":"function"},{"doc":"@see setInitialStepSize Python prototype (for reference): getInitialStepSize() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getInitialStepSize/1","title":"Evision.ML.SVMSGD.getInitialStepSize/1","type":"function"},{"doc":"Raising version of getMarginRegularization/1 .","ref":"Evision.ML.SVMSGD.html#getMarginRegularization!/1","title":"Evision.ML.SVMSGD.getMarginRegularization!/1","type":"function"},{"doc":"@see setMarginRegularization Python prototype (for reference): getMarginRegularization() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getMarginRegularization/1","title":"Evision.ML.SVMSGD.getMarginRegularization/1","type":"function"},{"doc":"Raising version of getMarginType/1 .","ref":"Evision.ML.SVMSGD.html#getMarginType!/1","title":"Evision.ML.SVMSGD.getMarginType!/1","type":"function"},{"doc":"@see setMarginType Python prototype (for reference): getMarginType() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getMarginType/1","title":"Evision.ML.SVMSGD.getMarginType/1","type":"function"},{"doc":"Raising version of getShift/1 .","ref":"Evision.ML.SVMSGD.html#getShift!/1","title":"Evision.ML.SVMSGD.getShift!/1","type":"function"},{"doc":"@return the shift of the trained model (decision function f(x) = weights * x + shift). Python prototype (for reference): getShift() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getShift/1","title":"Evision.ML.SVMSGD.getShift/1","type":"function"},{"doc":"Raising version of getStepDecreasingPower/1 .","ref":"Evision.ML.SVMSGD.html#getStepDecreasingPower!/1","title":"Evision.ML.SVMSGD.getStepDecreasingPower!/1","type":"function"},{"doc":"@see setStepDecreasingPower Python prototype (for reference): getStepDecreasingPower() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getStepDecreasingPower/1","title":"Evision.ML.SVMSGD.getStepDecreasingPower/1","type":"function"},{"doc":"Raising version of getSvmsgdType/1 .","ref":"Evision.ML.SVMSGD.html#getSvmsgdType!/1","title":"Evision.ML.SVMSGD.getSvmsgdType!/1","type":"function"},{"doc":"@see setSvmsgdType Python prototype (for reference): getSvmsgdType() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getSvmsgdType/1","title":"Evision.ML.SVMSGD.getSvmsgdType/1","type":"function"},{"doc":"Raising version of getTermCriteria/1 .","ref":"Evision.ML.SVMSGD.html#getTermCriteria!/1","title":"Evision.ML.SVMSGD.getTermCriteria!/1","type":"function"},{"doc":"@see setTermCriteria Python prototype (for reference): getTermCriteria() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getTermCriteria/1","title":"Evision.ML.SVMSGD.getTermCriteria/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.SVMSGD.html#getVarCount!/1","title":"Evision.ML.SVMSGD.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getVarCount/1","title":"Evision.ML.SVMSGD.getVarCount/1","type":"function"},{"doc":"Raising version of getWeights/1 .","ref":"Evision.ML.SVMSGD.html#getWeights!/1","title":"Evision.ML.SVMSGD.getWeights!/1","type":"function"},{"doc":"@return the weights of the trained model (decision function f(x) = weights * x + shift). Python prototype (for reference): getWeights() -&gt; retval","ref":"Evision.ML.SVMSGD.html#getWeights/1","title":"Evision.ML.SVMSGD.getWeights/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.SVMSGD.html#isClassifier!/1","title":"Evision.ML.SVMSGD.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.SVMSGD.html#isClassifier/1","title":"Evision.ML.SVMSGD.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.SVMSGD.html#isTrained!/1","title":"Evision.ML.SVMSGD.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.SVMSGD.html#isTrained/1","title":"Evision.ML.SVMSGD.isTrained/1","type":"function"},{"doc":"Raising version of load/1 .","ref":"Evision.ML.SVMSGD.html#load!/1","title":"Evision.ML.SVMSGD.load!/1","type":"function"},{"doc":"Raising version of load/2 .","ref":"Evision.ML.SVMSGD.html#load!/2","title":"Evision.ML.SVMSGD.load!/2","type":"function"},{"doc":"Loads and creates a serialized SVMSGD from a file Positional Arguments filepath : String . path to serialized SVMSGD Keyword Arguments nodeName : String . name of node containing the classifier Use SVMSGD::save to serialize and store an SVMSGD to disk. Load the SVMSGD from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.SVMSGD.html#load/1","title":"Evision.ML.SVMSGD.load/1","type":"function"},{"doc":"Loads and creates a serialized SVMSGD from a file Positional Arguments filepath : String . path to serialized SVMSGD Keyword Arguments nodeName : String . name of node containing the classifier Use SVMSGD::save to serialize and store an SVMSGD to disk. Load the SVMSGD from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier Python prototype (for reference): load(filepath[, nodeName]) -&gt; retval","ref":"Evision.ML.SVMSGD.html#load/2","title":"Evision.ML.SVMSGD.load/2","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.SVMSGD.html#predict!/2","title":"Evision.ML.SVMSGD.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.SVMSGD.html#predict!/3","title":"Evision.ML.SVMSGD.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.SVMSGD.html#predict/2","title":"Evision.ML.SVMSGD.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.SVMSGD.html#predict/3","title":"Evision.ML.SVMSGD.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.SVMSGD.html#read!/2","title":"Evision.ML.SVMSGD.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.SVMSGD.html#read/2","title":"Evision.ML.SVMSGD.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.SVMSGD.html#save!/2","title":"Evision.ML.SVMSGD.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.SVMSGD.html#save/2","title":"Evision.ML.SVMSGD.save/2","type":"function"},{"doc":"Raising version of setInitialStepSize/2 .","ref":"Evision.ML.SVMSGD.html#setInitialStepSize!/2","title":"Evision.ML.SVMSGD.setInitialStepSize!/2","type":"function"},{"doc":"Positional Arguments initialStepSize : float @copybrief getInitialStepSize @see getInitialStepSize Python prototype (for reference): setInitialStepSize(InitialStepSize) -&gt; None","ref":"Evision.ML.SVMSGD.html#setInitialStepSize/2","title":"Evision.ML.SVMSGD.setInitialStepSize/2","type":"function"},{"doc":"Raising version of setMarginRegularization/2 .","ref":"Evision.ML.SVMSGD.html#setMarginRegularization!/2","title":"Evision.ML.SVMSGD.setMarginRegularization!/2","type":"function"},{"doc":"Positional Arguments marginRegularization : float @copybrief getMarginRegularization @see getMarginRegularization Python prototype (for reference): setMarginRegularization(marginRegularization) -&gt; None","ref":"Evision.ML.SVMSGD.html#setMarginRegularization/2","title":"Evision.ML.SVMSGD.setMarginRegularization/2","type":"function"},{"doc":"Raising version of setMarginType/2 .","ref":"Evision.ML.SVMSGD.html#setMarginType!/2","title":"Evision.ML.SVMSGD.setMarginType!/2","type":"function"},{"doc":"Positional Arguments marginType : int @copybrief getMarginType @see getMarginType Python prototype (for reference): setMarginType(marginType) -&gt; None","ref":"Evision.ML.SVMSGD.html#setMarginType/2","title":"Evision.ML.SVMSGD.setMarginType/2","type":"function"},{"doc":"Raising version of setOptimalParameters/1 .","ref":"Evision.ML.SVMSGD.html#setOptimalParameters!/1","title":"Evision.ML.SVMSGD.setOptimalParameters!/1","type":"function"},{"doc":"Function sets optimal parameters values for chosen SVM SGD model. Keyword Arguments svmsgdType : int . is the type of SVMSGD classifier. marginType : int . is the type of margin constraint. Python prototype (for reference): setOptimalParameters([, svmsgdType[, marginType]]) -&gt; None","ref":"Evision.ML.SVMSGD.html#setOptimalParameters/1","title":"Evision.ML.SVMSGD.setOptimalParameters/1","type":"function"},{"doc":"Raising version of setStepDecreasingPower/2 .","ref":"Evision.ML.SVMSGD.html#setStepDecreasingPower!/2","title":"Evision.ML.SVMSGD.setStepDecreasingPower!/2","type":"function"},{"doc":"Positional Arguments stepDecreasingPower : float @copybrief getStepDecreasingPower @see getStepDecreasingPower Python prototype (for reference): setStepDecreasingPower(stepDecreasingPower) -&gt; None","ref":"Evision.ML.SVMSGD.html#setStepDecreasingPower/2","title":"Evision.ML.SVMSGD.setStepDecreasingPower/2","type":"function"},{"doc":"Raising version of setSvmsgdType/2 .","ref":"Evision.ML.SVMSGD.html#setSvmsgdType!/2","title":"Evision.ML.SVMSGD.setSvmsgdType!/2","type":"function"},{"doc":"Positional Arguments svmsgdType : int @copybrief getSvmsgdType @see getSvmsgdType Python prototype (for reference): setSvmsgdType(svmsgdType) -&gt; None","ref":"Evision.ML.SVMSGD.html#setSvmsgdType/2","title":"Evision.ML.SVMSGD.setSvmsgdType/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.ML.SVMSGD.html#setTermCriteria!/2","title":"Evision.ML.SVMSGD.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments val : TermCriteria @copybrief getTermCriteria @see getTermCriteria Python prototype (for reference): setTermCriteria(val) -&gt; None","ref":"Evision.ML.SVMSGD.html#setTermCriteria/2","title":"Evision.ML.SVMSGD.setTermCriteria/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.SVMSGD.html#train!/2","title":"Evision.ML.SVMSGD.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.SVMSGD.html#train!/3","title":"Evision.ML.SVMSGD.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.SVMSGD.html#train!/4","title":"Evision.ML.SVMSGD.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.SVMSGD.html#train/2","title":"Evision.ML.SVMSGD.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.SVMSGD.html#train/3","title":"Evision.ML.SVMSGD.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.SVMSGD.html#train/4","title":"Evision.ML.SVMSGD.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.SVMSGD.html#write!/2","title":"Evision.ML.SVMSGD.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.SVMSGD.html#write!/3","title":"Evision.ML.SVMSGD.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.SVMSGD.html#write/2","title":"Evision.ML.SVMSGD.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.SVMSGD.html#write/3","title":"Evision.ML.SVMSGD.write/3","type":"function"},{"doc":"","ref":"Evision.ML.StatModel.html","title":"Evision.ML.StatModel","type":"module"},{"doc":"Raising version of calcError/3 .","ref":"Evision.ML.StatModel.html#calcError!/3","title":"Evision.ML.StatModel.calcError!/3","type":"function"},{"doc":"Raising version of calcError/4 .","ref":"Evision.ML.StatModel.html#calcError!/4","title":"Evision.ML.StatModel.calcError!/4","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.StatModel.html#calcError/3","title":"Evision.ML.StatModel.calcError/3","type":"function"},{"doc":"Computes error on the training or test dataset Positional Arguments data : Ptr&lt;TrainData&gt; . the training data test : bool . if true, the error is computed over the test subset of the data, otherwise it's computed over the training subset of the data. Please note that if you loaded a completely different dataset to evaluate already trained classifier, you will probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so that the error is computed for the whole new set. Yes, this sounds a bit confusing. Return resp : Evision.Mat . the optional output responses. The method uses StatModel::predict to compute the error. For regression models the error is computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%). Python prototype (for reference): calcError(data, test[, resp]) -&gt; retval, resp","ref":"Evision.ML.StatModel.html#calcError/4","title":"Evision.ML.StatModel.calcError/4","type":"function"},{"doc":"Raising version of clear/1 .","ref":"Evision.ML.StatModel.html#clear!/1","title":"Evision.ML.StatModel.clear!/1","type":"function"},{"doc":"Clears the algorithm state Python prototype (for reference): clear() -&gt; None","ref":"Evision.ML.StatModel.html#clear/1","title":"Evision.ML.StatModel.clear/1","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ML.StatModel.html#empty!/1","title":"Evision.ML.StatModel.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ML.StatModel.html#empty/1","title":"Evision.ML.StatModel.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ML.StatModel.html#getDefaultName!/1","title":"Evision.ML.StatModel.getDefaultName!/1","type":"function"},{"doc":"Returns the algorithm string identifier. This string is used as top level xml/yml node tag when the object is saved to a file or string. Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ML.StatModel.html#getDefaultName/1","title":"Evision.ML.StatModel.getDefaultName/1","type":"function"},{"doc":"Raising version of getVarCount/1 .","ref":"Evision.ML.StatModel.html#getVarCount!/1","title":"Evision.ML.StatModel.getVarCount!/1","type":"function"},{"doc":"Returns the number of variables in training samples Python prototype (for reference): getVarCount() -&gt; retval","ref":"Evision.ML.StatModel.html#getVarCount/1","title":"Evision.ML.StatModel.getVarCount/1","type":"function"},{"doc":"Raising version of isClassifier/1 .","ref":"Evision.ML.StatModel.html#isClassifier!/1","title":"Evision.ML.StatModel.isClassifier!/1","type":"function"},{"doc":"Returns true if the model is classifier Python prototype (for reference): isClassifier() -&gt; retval","ref":"Evision.ML.StatModel.html#isClassifier/1","title":"Evision.ML.StatModel.isClassifier/1","type":"function"},{"doc":"Raising version of isTrained/1 .","ref":"Evision.ML.StatModel.html#isTrained!/1","title":"Evision.ML.StatModel.isTrained!/1","type":"function"},{"doc":"Returns true if the model is trained Python prototype (for reference): isTrained() -&gt; retval","ref":"Evision.ML.StatModel.html#isTrained/1","title":"Evision.ML.StatModel.isTrained/1","type":"function"},{"doc":"Raising version of predict/2 .","ref":"Evision.ML.StatModel.html#predict!/2","title":"Evision.ML.StatModel.predict!/2","type":"function"},{"doc":"Raising version of predict/3 .","ref":"Evision.ML.StatModel.html#predict!/3","title":"Evision.ML.StatModel.predict!/3","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.StatModel.html#predict/2","title":"Evision.ML.StatModel.predict/2","type":"function"},{"doc":"Predicts response(s) for the provided sample(s) Positional Arguments samples : Evision.Mat . The input samples, floating-point matrix Keyword Arguments flags : int . The optional flags, model-dependent. See cv::ml::StatModel::Flags. Return results : Evision.Mat . The optional output matrix of results. Python prototype (for reference): predict(samples[, results[, flags]]) -&gt; retval, results","ref":"Evision.ML.StatModel.html#predict/3","title":"Evision.ML.StatModel.predict/3","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ML.StatModel.html#read!/2","title":"Evision.ML.StatModel.read!/2","type":"function"},{"doc":"Reads algorithm parameters from a file storage Positional Arguments fn_ : FileNode Python prototype (for reference): read(fn_) -&gt; None","ref":"Evision.ML.StatModel.html#read/2","title":"Evision.ML.StatModel.read/2","type":"function"},{"doc":"Raising version of save/2 .","ref":"Evision.ML.StatModel.html#save!/2","title":"Evision.ML.StatModel.save!/2","type":"function"},{"doc":"Positional Arguments filename : String Saves the algorithm to a file. In order to make this method work, the derived class must implement Algorithm::write(FileStorage&amp; fs). Python prototype (for reference): save(filename) -&gt; None","ref":"Evision.ML.StatModel.html#save/2","title":"Evision.ML.StatModel.save/2","type":"function"},{"doc":"Raising version of train/2 .","ref":"Evision.ML.StatModel.html#train!/2","title":"Evision.ML.StatModel.train!/2","type":"function"},{"doc":"Raising version of train/3 .","ref":"Evision.ML.StatModel.html#train!/3","title":"Evision.ML.StatModel.train!/3","type":"function"},{"doc":"Raising version of train/4 .","ref":"Evision.ML.StatModel.html#train!/4","title":"Evision.ML.StatModel.train!/4","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.StatModel.html#train/2","title":"Evision.ML.StatModel.train/2","type":"function"},{"doc":"Trains the statistical model Positional Arguments trainData : Ptr&lt;TrainData&gt; . training data that can be loaded from file using TrainData::loadFromCSV or created with TrainData::create. Keyword Arguments flags : int . optional flags, depending on the model. Some of the models can be updated with the new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP). Python prototype (for reference): train(trainData[, flags]) -&gt; retval","ref":"Evision.ML.StatModel.html#train/3","title":"Evision.ML.StatModel.train/3","type":"function"},{"doc":"Trains the statistical model Positional Arguments samples : Evision.Mat . training samples layout : int . See ml::SampleTypes. responses : Evision.Mat . vector of responses associated with the training samples. Python prototype (for reference): train(samples, layout, responses) -&gt; retval","ref":"Evision.ML.StatModel.html#train/4","title":"Evision.ML.StatModel.train/4","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ML.StatModel.html#write!/2","title":"Evision.ML.StatModel.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ML.StatModel.html#write!/3","title":"Evision.ML.StatModel.write!/3","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.StatModel.html#write/2","title":"Evision.ML.StatModel.write/2","type":"function"},{"doc":"simplified API for language bindings Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Has overloading in C++ Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ML.StatModel.html#write/3","title":"Evision.ML.StatModel.write/3","type":"function"},{"doc":"","ref":"Evision.ML.TrainData.html","title":"Evision.ML.TrainData","type":"module"},{"doc":"Raising version of create/3 .","ref":"Evision.ML.TrainData.html#create!/3","title":"Evision.ML.TrainData.create!/3","type":"function"},{"doc":"Raising version of create/4 .","ref":"Evision.ML.TrainData.html#create!/4","title":"Evision.ML.TrainData.create!/4","type":"function"},{"doc":"Creates training data from in-memory arrays. Positional Arguments samples : Evision.Mat . matrix of samples. It should have CV_32F type. layout : int . see ml::SampleTypes. responses : Evision.Mat . matrix of responses. If the responses are scalar, they should be stored as a single row or as a single column. The matrix should have type CV_32F or CV_32S (in the former case the responses are considered as ordered by default; in the latter case - as categorical) Keyword Arguments varIdx : Evision.Mat . vector specifying which variables to use for training. It can be an integer vector (CV_32S) containing 0-based variable indices or byte vector (CV_8U) containing a mask of active variables. sampleIdx : Evision.Mat . vector specifying which samples to use for training. It can be an integer vector (CV_32S) containing 0-based sample indices or byte vector (CV_8U) containing a mask of training samples. sampleWeights : Evision.Mat . optional vector with weights for each sample. It should have CV_32F type. varType : Evision.Mat . optional vector of type CV_8U and size &lt;number_of_variables_in_samples&gt; + &lt;number_of_variables_in_responses&gt; , containing types of each input and output variable. See ml::VariableTypes. Python prototype (for reference): create(samples, layout, responses[, varIdx[, sampleIdx[, sampleWeights[, varType]]]]) -&gt; retval","ref":"Evision.ML.TrainData.html#create/3","title":"Evision.ML.TrainData.create/3","type":"function"},{"doc":"Creates training data from in-memory arrays. Positional Arguments samples : Evision.Mat . matrix of samples. It should have CV_32F type. layout : int . see ml::SampleTypes. responses : Evision.Mat . matrix of responses. If the responses are scalar, they should be stored as a single row or as a single column. The matrix should have type CV_32F or CV_32S (in the former case the responses are considered as ordered by default; in the latter case - as categorical) Keyword Arguments varIdx : Evision.Mat . vector specifying which variables to use for training. It can be an integer vector (CV_32S) containing 0-based variable indices or byte vector (CV_8U) containing a mask of active variables. sampleIdx : Evision.Mat . vector specifying which samples to use for training. It can be an integer vector (CV_32S) containing 0-based sample indices or byte vector (CV_8U) containing a mask of training samples. sampleWeights : Evision.Mat . optional vector with weights for each sample. It should have CV_32F type. varType : Evision.Mat . optional vector of type CV_8U and size &lt;number_of_variables_in_samples&gt; + &lt;number_of_variables_in_responses&gt; , containing types of each input and output variable. See ml::VariableTypes. Python prototype (for reference): create(samples, layout, responses[, varIdx[, sampleIdx[, sampleWeights[, varType]]]]) -&gt; retval","ref":"Evision.ML.TrainData.html#create/4","title":"Evision.ML.TrainData.create/4","type":"function"},{"doc":"Raising version of getCatCount/2 .","ref":"Evision.ML.TrainData.html#getCatCount!/2","title":"Evision.ML.TrainData.getCatCount!/2","type":"function"},{"doc":"Positional Arguments vi : int Python prototype (for reference): getCatCount(vi) -&gt; retval","ref":"Evision.ML.TrainData.html#getCatCount/2","title":"Evision.ML.TrainData.getCatCount/2","type":"function"},{"doc":"Raising version of getCatMap/1 .","ref":"Evision.ML.TrainData.html#getCatMap!/1","title":"Evision.ML.TrainData.getCatMap!/1","type":"function"},{"doc":"Python prototype (for reference): getCatMap() -&gt; retval","ref":"Evision.ML.TrainData.html#getCatMap/1","title":"Evision.ML.TrainData.getCatMap/1","type":"function"},{"doc":"Raising version of getCatOfs/1 .","ref":"Evision.ML.TrainData.html#getCatOfs!/1","title":"Evision.ML.TrainData.getCatOfs!/1","type":"function"},{"doc":"Python prototype (for reference): getCatOfs() -&gt; retval","ref":"Evision.ML.TrainData.html#getCatOfs/1","title":"Evision.ML.TrainData.getCatOfs/1","type":"function"},{"doc":"Raising version of getClassLabels/1 .","ref":"Evision.ML.TrainData.html#getClassLabels!/1","title":"Evision.ML.TrainData.getClassLabels!/1","type":"function"},{"doc":"Returns the vector of class labels The function returns vector of unique labels occurred in the responses. Python prototype (for reference): getClassLabels() -&gt; retval","ref":"Evision.ML.TrainData.html#getClassLabels/1","title":"Evision.ML.TrainData.getClassLabels/1","type":"function"},{"doc":"Raising version of getDefaultSubstValues/1 .","ref":"Evision.ML.TrainData.html#getDefaultSubstValues!/1","title":"Evision.ML.TrainData.getDefaultSubstValues!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultSubstValues() -&gt; retval","ref":"Evision.ML.TrainData.html#getDefaultSubstValues/1","title":"Evision.ML.TrainData.getDefaultSubstValues/1","type":"function"},{"doc":"Raising version of getLayout/1 .","ref":"Evision.ML.TrainData.html#getLayout!/1","title":"Evision.ML.TrainData.getLayout!/1","type":"function"},{"doc":"Python prototype (for reference): getLayout() -&gt; retval","ref":"Evision.ML.TrainData.html#getLayout/1","title":"Evision.ML.TrainData.getLayout/1","type":"function"},{"doc":"Raising version of getMissing/1 .","ref":"Evision.ML.TrainData.html#getMissing!/1","title":"Evision.ML.TrainData.getMissing!/1","type":"function"},{"doc":"Python prototype (for reference): getMissing() -&gt; retval","ref":"Evision.ML.TrainData.html#getMissing/1","title":"Evision.ML.TrainData.getMissing/1","type":"function"},{"doc":"Raising version of getNAllVars/1 .","ref":"Evision.ML.TrainData.html#getNAllVars!/1","title":"Evision.ML.TrainData.getNAllVars!/1","type":"function"},{"doc":"Python prototype (for reference): getNAllVars() -&gt; retval","ref":"Evision.ML.TrainData.html#getNAllVars/1","title":"Evision.ML.TrainData.getNAllVars/1","type":"function"},{"doc":"Raising version of getNames/2 .","ref":"Evision.ML.TrainData.html#getNames!/2","title":"Evision.ML.TrainData.getNames!/2","type":"function"},{"doc":"Returns vector of symbolic names captured in loadFromCSV() Positional Arguments names : [String] Python prototype (for reference): getNames(names) -&gt; None","ref":"Evision.ML.TrainData.html#getNames/2","title":"Evision.ML.TrainData.getNames/2","type":"function"},{"doc":"Raising version of getNormCatResponses/1 .","ref":"Evision.ML.TrainData.html#getNormCatResponses!/1","title":"Evision.ML.TrainData.getNormCatResponses!/1","type":"function"},{"doc":"Python prototype (for reference): getNormCatResponses() -&gt; retval","ref":"Evision.ML.TrainData.html#getNormCatResponses/1","title":"Evision.ML.TrainData.getNormCatResponses/1","type":"function"},{"doc":"Raising version of getNSamples/1 .","ref":"Evision.ML.TrainData.html#getNSamples!/1","title":"Evision.ML.TrainData.getNSamples!/1","type":"function"},{"doc":"Python prototype (for reference): getNSamples() -&gt; retval","ref":"Evision.ML.TrainData.html#getNSamples/1","title":"Evision.ML.TrainData.getNSamples/1","type":"function"},{"doc":"Raising version of getNTestSamples/1 .","ref":"Evision.ML.TrainData.html#getNTestSamples!/1","title":"Evision.ML.TrainData.getNTestSamples!/1","type":"function"},{"doc":"Python prototype (for reference): getNTestSamples() -&gt; retval","ref":"Evision.ML.TrainData.html#getNTestSamples/1","title":"Evision.ML.TrainData.getNTestSamples/1","type":"function"},{"doc":"Raising version of getNTrainSamples/1 .","ref":"Evision.ML.TrainData.html#getNTrainSamples!/1","title":"Evision.ML.TrainData.getNTrainSamples!/1","type":"function"},{"doc":"Python prototype (for reference): getNTrainSamples() -&gt; retval","ref":"Evision.ML.TrainData.html#getNTrainSamples/1","title":"Evision.ML.TrainData.getNTrainSamples/1","type":"function"},{"doc":"Raising version of getNVars/1 .","ref":"Evision.ML.TrainData.html#getNVars!/1","title":"Evision.ML.TrainData.getNVars!/1","type":"function"},{"doc":"Python prototype (for reference): getNVars() -&gt; retval","ref":"Evision.ML.TrainData.html#getNVars/1","title":"Evision.ML.TrainData.getNVars/1","type":"function"},{"doc":"Raising version of getResponses/1 .","ref":"Evision.ML.TrainData.html#getResponses!/1","title":"Evision.ML.TrainData.getResponses!/1","type":"function"},{"doc":"Python prototype (for reference): getResponses() -&gt; retval","ref":"Evision.ML.TrainData.html#getResponses/1","title":"Evision.ML.TrainData.getResponses/1","type":"function"},{"doc":"Raising version of getResponseType/1 .","ref":"Evision.ML.TrainData.html#getResponseType!/1","title":"Evision.ML.TrainData.getResponseType!/1","type":"function"},{"doc":"Python prototype (for reference): getResponseType() -&gt; retval","ref":"Evision.ML.TrainData.html#getResponseType/1","title":"Evision.ML.TrainData.getResponseType/1","type":"function"},{"doc":"Raising version of getSample/4 .","ref":"Evision.ML.TrainData.html#getSample!/4","title":"Evision.ML.TrainData.getSample!/4","type":"function"},{"doc":"Positional Arguments varIdx : Evision.Mat sidx : int buf : float* Python prototype (for reference): getSample(varIdx, sidx, buf) -&gt; None","ref":"Evision.ML.TrainData.html#getSample/4","title":"Evision.ML.TrainData.getSample/4","type":"function"},{"doc":"Raising version of getSamples/1 .","ref":"Evision.ML.TrainData.html#getSamples!/1","title":"Evision.ML.TrainData.getSamples!/1","type":"function"},{"doc":"Python prototype (for reference): getSamples() -&gt; retval","ref":"Evision.ML.TrainData.html#getSamples/1","title":"Evision.ML.TrainData.getSamples/1","type":"function"},{"doc":"Raising version of getSampleWeights/1 .","ref":"Evision.ML.TrainData.html#getSampleWeights!/1","title":"Evision.ML.TrainData.getSampleWeights!/1","type":"function"},{"doc":"Python prototype (for reference): getSampleWeights() -&gt; retval","ref":"Evision.ML.TrainData.html#getSampleWeights/1","title":"Evision.ML.TrainData.getSampleWeights/1","type":"function"},{"doc":"Raising version of getSubMatrix/3 .","ref":"Evision.ML.TrainData.html#getSubMatrix!/3","title":"Evision.ML.TrainData.getSubMatrix!/3","type":"function"},{"doc":"Extract from matrix rows/cols specified by passed indexes. Positional Arguments matrix : Evision.Mat . input matrix (supported types: CV_32S, CV_32F, CV_64F) idx : Evision.Mat . 1D index vector layout : int . specifies to extract rows (cv::ml::ROW_SAMPLES) or to extract columns (cv::ml::COL_SAMPLES) Python prototype (for reference): getSubMatrix(matrix, idx, layout) -&gt; retval","ref":"Evision.ML.TrainData.html#getSubMatrix/3","title":"Evision.ML.TrainData.getSubMatrix/3","type":"function"},{"doc":"Raising version of getSubVector/2 .","ref":"Evision.ML.TrainData.html#getSubVector!/2","title":"Evision.ML.TrainData.getSubVector!/2","type":"function"},{"doc":"Extract from 1D vector elements specified by passed indexes. Positional Arguments vec : Evision.Mat . input vector (supported types: CV_32S, CV_32F, CV_64F) idx : Evision.Mat . 1D index vector Python prototype (for reference): getSubVector(vec, idx) -&gt; retval","ref":"Evision.ML.TrainData.html#getSubVector/2","title":"Evision.ML.TrainData.getSubVector/2","type":"function"},{"doc":"Raising version of getTestNormCatResponses/1 .","ref":"Evision.ML.TrainData.html#getTestNormCatResponses!/1","title":"Evision.ML.TrainData.getTestNormCatResponses!/1","type":"function"},{"doc":"Python prototype (for reference): getTestNormCatResponses() -&gt; retval","ref":"Evision.ML.TrainData.html#getTestNormCatResponses/1","title":"Evision.ML.TrainData.getTestNormCatResponses/1","type":"function"},{"doc":"Raising version of getTestResponses/1 .","ref":"Evision.ML.TrainData.html#getTestResponses!/1","title":"Evision.ML.TrainData.getTestResponses!/1","type":"function"},{"doc":"Python prototype (for reference): getTestResponses() -&gt; retval","ref":"Evision.ML.TrainData.html#getTestResponses/1","title":"Evision.ML.TrainData.getTestResponses/1","type":"function"},{"doc":"Raising version of getTestSampleIdx/1 .","ref":"Evision.ML.TrainData.html#getTestSampleIdx!/1","title":"Evision.ML.TrainData.getTestSampleIdx!/1","type":"function"},{"doc":"Python prototype (for reference): getTestSampleIdx() -&gt; retval","ref":"Evision.ML.TrainData.html#getTestSampleIdx/1","title":"Evision.ML.TrainData.getTestSampleIdx/1","type":"function"},{"doc":"Raising version of getTestSamples/1 .","ref":"Evision.ML.TrainData.html#getTestSamples!/1","title":"Evision.ML.TrainData.getTestSamples!/1","type":"function"},{"doc":"Returns matrix of test samples Python prototype (for reference): getTestSamples() -&gt; retval","ref":"Evision.ML.TrainData.html#getTestSamples/1","title":"Evision.ML.TrainData.getTestSamples/1","type":"function"},{"doc":"Raising version of getTestSampleWeights/1 .","ref":"Evision.ML.TrainData.html#getTestSampleWeights!/1","title":"Evision.ML.TrainData.getTestSampleWeights!/1","type":"function"},{"doc":"Python prototype (for reference): getTestSampleWeights() -&gt; retval","ref":"Evision.ML.TrainData.html#getTestSampleWeights/1","title":"Evision.ML.TrainData.getTestSampleWeights/1","type":"function"},{"doc":"Raising version of getTrainNormCatResponses/1 .","ref":"Evision.ML.TrainData.html#getTrainNormCatResponses!/1","title":"Evision.ML.TrainData.getTrainNormCatResponses!/1","type":"function"},{"doc":"Returns the vector of normalized categorical responses The function returns vector of responses. Each response is integer from 0 to &lt;number of classes&gt;-1 . The actual label value can be retrieved then from the class label vector, see TrainData::getClassLabels. Python prototype (for reference): getTrainNormCatResponses() -&gt; retval","ref":"Evision.ML.TrainData.html#getTrainNormCatResponses/1","title":"Evision.ML.TrainData.getTrainNormCatResponses/1","type":"function"},{"doc":"Raising version of getTrainResponses/1 .","ref":"Evision.ML.TrainData.html#getTrainResponses!/1","title":"Evision.ML.TrainData.getTrainResponses!/1","type":"function"},{"doc":"Returns the vector of responses The function returns ordered or the original categorical responses. Usually it's used in regression algorithms. Python prototype (for reference): getTrainResponses() -&gt; retval","ref":"Evision.ML.TrainData.html#getTrainResponses/1","title":"Evision.ML.TrainData.getTrainResponses/1","type":"function"},{"doc":"Raising version of getTrainSampleIdx/1 .","ref":"Evision.ML.TrainData.html#getTrainSampleIdx!/1","title":"Evision.ML.TrainData.getTrainSampleIdx!/1","type":"function"},{"doc":"Python prototype (for reference): getTrainSampleIdx() -&gt; retval","ref":"Evision.ML.TrainData.html#getTrainSampleIdx/1","title":"Evision.ML.TrainData.getTrainSampleIdx/1","type":"function"},{"doc":"Raising version of getTrainSamples/1 .","ref":"Evision.ML.TrainData.html#getTrainSamples!/1","title":"Evision.ML.TrainData.getTrainSamples!/1","type":"function"},{"doc":"Returns matrix of train samples Keyword Arguments layout : int . The requested layout. If it's different from the initial one, the matrix is transposed. See ml::SampleTypes. compressSamples : bool . if true, the function returns only the training samples (specified by sampleIdx) compressVars : bool . if true, the function returns the shorter training samples, containing only the active variables. In current implementation the function tries to avoid physical data copying and returns the matrix stored inside TrainData (unless the transposition or compression is needed). Python prototype (for reference): getTrainSamples([, layout[, compressSamples[, compressVars]]]) -&gt; retval","ref":"Evision.ML.TrainData.html#getTrainSamples/1","title":"Evision.ML.TrainData.getTrainSamples/1","type":"function"},{"doc":"Raising version of getTrainSampleWeights/1 .","ref":"Evision.ML.TrainData.html#getTrainSampleWeights!/1","title":"Evision.ML.TrainData.getTrainSampleWeights!/1","type":"function"},{"doc":"Python prototype (for reference): getTrainSampleWeights() -&gt; retval","ref":"Evision.ML.TrainData.html#getTrainSampleWeights/1","title":"Evision.ML.TrainData.getTrainSampleWeights/1","type":"function"},{"doc":"Raising version of getValues/4 .","ref":"Evision.ML.TrainData.html#getValues!/4","title":"Evision.ML.TrainData.getValues!/4","type":"function"},{"doc":"Positional Arguments vi : int sidx : Evision.Mat values : float* Python prototype (for reference): getValues(vi, sidx, values) -&gt; None","ref":"Evision.ML.TrainData.html#getValues/4","title":"Evision.ML.TrainData.getValues/4","type":"function"},{"doc":"Raising version of getVarIdx/1 .","ref":"Evision.ML.TrainData.html#getVarIdx!/1","title":"Evision.ML.TrainData.getVarIdx!/1","type":"function"},{"doc":"Python prototype (for reference): getVarIdx() -&gt; retval","ref":"Evision.ML.TrainData.html#getVarIdx/1","title":"Evision.ML.TrainData.getVarIdx/1","type":"function"},{"doc":"Raising version of getVarSymbolFlags/1 .","ref":"Evision.ML.TrainData.html#getVarSymbolFlags!/1","title":"Evision.ML.TrainData.getVarSymbolFlags!/1","type":"function"},{"doc":"Python prototype (for reference): getVarSymbolFlags() -&gt; retval","ref":"Evision.ML.TrainData.html#getVarSymbolFlags/1","title":"Evision.ML.TrainData.getVarSymbolFlags/1","type":"function"},{"doc":"Raising version of getVarType/1 .","ref":"Evision.ML.TrainData.html#getVarType!/1","title":"Evision.ML.TrainData.getVarType!/1","type":"function"},{"doc":"Python prototype (for reference): getVarType() -&gt; retval","ref":"Evision.ML.TrainData.html#getVarType/1","title":"Evision.ML.TrainData.getVarType/1","type":"function"},{"doc":"Raising version of setTrainTestSplit/2 .","ref":"Evision.ML.TrainData.html#setTrainTestSplit!/2","title":"Evision.ML.TrainData.setTrainTestSplit!/2","type":"function"},{"doc":"Raising version of setTrainTestSplit/3 .","ref":"Evision.ML.TrainData.html#setTrainTestSplit!/3","title":"Evision.ML.TrainData.setTrainTestSplit!/3","type":"function"},{"doc":"Splits the training data into the training and test parts Positional Arguments count : int Keyword Arguments shuffle : bool . @sa TrainData::setTrainTestSplitRatio Python prototype (for reference): setTrainTestSplit(count[, shuffle]) -&gt; None","ref":"Evision.ML.TrainData.html#setTrainTestSplit/2","title":"Evision.ML.TrainData.setTrainTestSplit/2","type":"function"},{"doc":"Splits the training data into the training and test parts Positional Arguments count : int Keyword Arguments shuffle : bool . @sa TrainData::setTrainTestSplitRatio Python prototype (for reference): setTrainTestSplit(count[, shuffle]) -&gt; None","ref":"Evision.ML.TrainData.html#setTrainTestSplit/3","title":"Evision.ML.TrainData.setTrainTestSplit/3","type":"function"},{"doc":"Raising version of setTrainTestSplitRatio/2 .","ref":"Evision.ML.TrainData.html#setTrainTestSplitRatio!/2","title":"Evision.ML.TrainData.setTrainTestSplitRatio!/2","type":"function"},{"doc":"Raising version of setTrainTestSplitRatio/3 .","ref":"Evision.ML.TrainData.html#setTrainTestSplitRatio!/3","title":"Evision.ML.TrainData.setTrainTestSplitRatio!/3","type":"function"},{"doc":"Splits the training data into the training and test parts Positional Arguments ratio : double Keyword Arguments shuffle : bool . The function selects a subset of specified relative size and then returns it as the training set. If the function is not called, all the data is used for training. Please, note that for each of TrainData::getTrain* there is corresponding TrainData::getTest*, so that the test subset can be retrieved and processed as well. @sa TrainData::setTrainTestSplit Python prototype (for reference): setTrainTestSplitRatio(ratio[, shuffle]) -&gt; None","ref":"Evision.ML.TrainData.html#setTrainTestSplitRatio/2","title":"Evision.ML.TrainData.setTrainTestSplitRatio/2","type":"function"},{"doc":"Splits the training data into the training and test parts Positional Arguments ratio : double Keyword Arguments shuffle : bool . The function selects a subset of specified relative size and then returns it as the training set. If the function is not called, all the data is used for training. Please, note that for each of TrainData::getTrain* there is corresponding TrainData::getTest*, so that the test subset can be retrieved and processed as well. @sa TrainData::setTrainTestSplit Python prototype (for reference): setTrainTestSplitRatio(ratio[, shuffle]) -&gt; None","ref":"Evision.ML.TrainData.html#setTrainTestSplitRatio/3","title":"Evision.ML.TrainData.setTrainTestSplitRatio/3","type":"function"},{"doc":"Raising version of shuffleTrainTest/1 .","ref":"Evision.ML.TrainData.html#shuffleTrainTest!/1","title":"Evision.ML.TrainData.shuffleTrainTest!/1","type":"function"},{"doc":"Python prototype (for reference): shuffleTrainTest() -&gt; None","ref":"Evision.ML.TrainData.html#shuffleTrainTest/1","title":"Evision.ML.TrainData.shuffleTrainTest/1","type":"function"},{"doc":"","ref":"Evision.MSER.html","title":"Evision.MSER","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.MSER.html#compute!/3","title":"Evision.MSER.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.MSER.html#compute!/4","title":"Evision.MSER.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.MSER.html#compute/3","title":"Evision.MSER.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.MSER.html#compute/4","title":"Evision.MSER.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.MSER.html#create!/0","title":"Evision.MSER.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.MSER.html#create!/1","title":"Evision.MSER.create!/1","type":"function"},{"doc":"Full constructor for %MSER detector Keyword Arguments delta : int . it compares \\f$(size {i}-size {i-delta})/size_{i-delta}\\f$ min_area : int . prune the area which smaller than minArea max_area : int . prune the area which bigger than maxArea max_variation : double . prune the area have similar size to its children min_diversity : double . for color image, trace back to cut off mser with diversity less than min_diversity max_evolution : int . for color image, the evolution steps area_threshold : double . for color image, the area threshold to cause re-initialize min_margin : double . for color image, ignore too small margin edge_blur_size : int . for color image, the aperture size for edge blur Python prototype (for reference): create([, delta[, min_area[, max_area[, max_variation[, min_diversity[, max_evolution[, area_threshold[, min_margin[, edge_blur_size]]]]]]]]]) -&gt; retval","ref":"Evision.MSER.html#create/0","title":"Evision.MSER.create/0","type":"function"},{"doc":"Full constructor for %MSER detector Keyword Arguments delta : int . it compares \\f$(size {i}-size {i-delta})/size_{i-delta}\\f$ min_area : int . prune the area which smaller than minArea max_area : int . prune the area which bigger than maxArea max_variation : double . prune the area have similar size to its children min_diversity : double . for color image, trace back to cut off mser with diversity less than min_diversity max_evolution : int . for color image, the evolution steps area_threshold : double . for color image, the area threshold to cause re-initialize min_margin : double . for color image, ignore too small margin edge_blur_size : int . for color image, the aperture size for edge blur Python prototype (for reference): create([, delta[, min_area[, max_area[, max_variation[, min_diversity[, max_evolution[, area_threshold[, min_margin[, edge_blur_size]]]]]]]]]) -&gt; retval","ref":"Evision.MSER.html#create/1","title":"Evision.MSER.create/1","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.MSER.html#defaultNorm!/1","title":"Evision.MSER.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.MSER.html#defaultNorm/1","title":"Evision.MSER.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.MSER.html#descriptorSize!/1","title":"Evision.MSER.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.MSER.html#descriptorSize/1","title":"Evision.MSER.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.MSER.html#descriptorType!/1","title":"Evision.MSER.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.MSER.html#descriptorType/1","title":"Evision.MSER.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.MSER.html#detect!/2","title":"Evision.MSER.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.MSER.html#detect!/3","title":"Evision.MSER.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.MSER.html#detect/2","title":"Evision.MSER.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.MSER.html#detect/3","title":"Evision.MSER.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.MSER.html#detectAndCompute!/3","title":"Evision.MSER.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.MSER.html#detectAndCompute!/4","title":"Evision.MSER.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.MSER.html#detectAndCompute/3","title":"Evision.MSER.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.MSER.html#detectAndCompute/4","title":"Evision.MSER.detectAndCompute/4","type":"function"},{"doc":"Raising version of detectRegions/2 .","ref":"Evision.MSER.html#detectRegions!/2","title":"Evision.MSER.detectRegions!/2","type":"function"},{"doc":"Detect %MSER regions Positional Arguments image : Evision.Mat . input image (8UC1, 8UC3 or 8UC4, must be greater or equal than 3x3) Return msers : [vector_Point] . resulting list of point sets bboxes : [Rect] . resulting bounding boxes Python prototype (for reference): detectRegions(image) -&gt; msers, bboxes","ref":"Evision.MSER.html#detectRegions/2","title":"Evision.MSER.detectRegions/2","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.MSER.html#empty!/1","title":"Evision.MSER.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.MSER.html#empty/1","title":"Evision.MSER.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.MSER.html#getDefaultName!/1","title":"Evision.MSER.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.MSER.html#getDefaultName/1","title":"Evision.MSER.getDefaultName/1","type":"function"},{"doc":"Raising version of getDelta/1 .","ref":"Evision.MSER.html#getDelta!/1","title":"Evision.MSER.getDelta!/1","type":"function"},{"doc":"Python prototype (for reference): getDelta() -&gt; retval","ref":"Evision.MSER.html#getDelta/1","title":"Evision.MSER.getDelta/1","type":"function"},{"doc":"Raising version of getMaxArea/1 .","ref":"Evision.MSER.html#getMaxArea!/1","title":"Evision.MSER.getMaxArea!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxArea() -&gt; retval","ref":"Evision.MSER.html#getMaxArea/1","title":"Evision.MSER.getMaxArea/1","type":"function"},{"doc":"Raising version of getMinArea/1 .","ref":"Evision.MSER.html#getMinArea!/1","title":"Evision.MSER.getMinArea!/1","type":"function"},{"doc":"Python prototype (for reference): getMinArea() -&gt; retval","ref":"Evision.MSER.html#getMinArea/1","title":"Evision.MSER.getMinArea/1","type":"function"},{"doc":"Raising version of getPass2Only/1 .","ref":"Evision.MSER.html#getPass2Only!/1","title":"Evision.MSER.getPass2Only!/1","type":"function"},{"doc":"Python prototype (for reference): getPass2Only() -&gt; retval","ref":"Evision.MSER.html#getPass2Only/1","title":"Evision.MSER.getPass2Only/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.MSER.html#read!/2","title":"Evision.MSER.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.MSER.html#read/2","title":"Evision.MSER.read/2","type":"function"},{"doc":"Raising version of setDelta/2 .","ref":"Evision.MSER.html#setDelta!/2","title":"Evision.MSER.setDelta!/2","type":"function"},{"doc":"Positional Arguments delta : int Python prototype (for reference): setDelta(delta) -&gt; None","ref":"Evision.MSER.html#setDelta/2","title":"Evision.MSER.setDelta/2","type":"function"},{"doc":"Raising version of setMaxArea/2 .","ref":"Evision.MSER.html#setMaxArea!/2","title":"Evision.MSER.setMaxArea!/2","type":"function"},{"doc":"Positional Arguments maxArea : int Python prototype (for reference): setMaxArea(maxArea) -&gt; None","ref":"Evision.MSER.html#setMaxArea/2","title":"Evision.MSER.setMaxArea/2","type":"function"},{"doc":"Raising version of setMinArea/2 .","ref":"Evision.MSER.html#setMinArea!/2","title":"Evision.MSER.setMinArea!/2","type":"function"},{"doc":"Positional Arguments minArea : int Python prototype (for reference): setMinArea(minArea) -&gt; None","ref":"Evision.MSER.html#setMinArea/2","title":"Evision.MSER.setMinArea/2","type":"function"},{"doc":"Raising version of setPass2Only/2 .","ref":"Evision.MSER.html#setPass2Only!/2","title":"Evision.MSER.setPass2Only!/2","type":"function"},{"doc":"Positional Arguments f : bool Python prototype (for reference): setPass2Only(f) -&gt; None","ref":"Evision.MSER.html#setPass2Only/2","title":"Evision.MSER.setPass2Only/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.MSER.html#write!/2","title":"Evision.MSER.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.MSER.html#write!/3","title":"Evision.MSER.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.MSER.html#write/2","title":"Evision.MSER.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.MSER.html#write/3","title":"Evision.MSER.write/3","type":"function"},{"doc":"OpenCV Mat","ref":"Evision.Mat.html","title":"Evision.Mat","type":"module"},{"doc":"Raising version of abs/1 .","ref":"Evision.Mat.html#abs!/1","title":"Evision.Mat.abs!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#abs/1","title":"Evision.Mat.abs/1","type":"function"},{"doc":"Raising version of add/2 .","ref":"Evision.Mat.html#add!/2","title":"Evision.Mat.add!/2","type":"function"},{"doc":"Raising version of add/3 .","ref":"Evision.Mat.html#add!/3","title":"Evision.Mat.add!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#add/2","title":"Evision.Mat.add/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#add/3","title":"Evision.Mat.add/3","type":"function"},{"doc":"Raising version of arange/4 .","ref":"Evision.Mat.html#arange!/4","title":"Evision.Mat.arange!/4","type":"function"},{"doc":"Raising version of arange/5 .","ref":"Evision.Mat.html#arange!/5","title":"Evision.Mat.arange!/5","type":"function"},{"doc":"","ref":"Evision.Mat.html#arange/4","title":"Evision.Mat.arange/4","type":"function"},{"doc":"","ref":"Evision.Mat.html#arange/5","title":"Evision.Mat.arange/5","type":"function"},{"doc":"Raising version of as_shape/2 .","ref":"Evision.Mat.html#as_shape!/2","title":"Evision.Mat.as_shape!/2","type":"function"},{"doc":"This method does not change the underlying data. It only changes the steps when accessing the matrix. If intended to change the underlying data to the new shape, please use Evision.Mat.reshape/2 .","ref":"Evision.Mat.html#as_shape/2","title":"Evision.Mat.as_shape/2","type":"function"},{"doc":"Raising version of as_type/2 .","ref":"Evision.Mat.html#as_type!/2","title":"Evision.Mat.as_type!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#as_type/2","title":"Evision.Mat.as_type/2","type":"function"},{"doc":"Raising version of at/2 .","ref":"Evision.Mat.html#at!/2","title":"Evision.Mat.at!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#at/2","title":"Evision.Mat.at/2","type":"function"},{"doc":"Raising version of bitwise_and/2 .","ref":"Evision.Mat.html#bitwise_and!/2","title":"Evision.Mat.bitwise_and!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#bitwise_and/2","title":"Evision.Mat.bitwise_and/2","type":"function"},{"doc":"Raising version of bitwise_not/1 .","ref":"Evision.Mat.html#bitwise_not!/1","title":"Evision.Mat.bitwise_not!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#bitwise_not/1","title":"Evision.Mat.bitwise_not/1","type":"function"},{"doc":"Raising version of bitwise_or/2 .","ref":"Evision.Mat.html#bitwise_or!/2","title":"Evision.Mat.bitwise_or!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#bitwise_or/2","title":"Evision.Mat.bitwise_or/2","type":"function"},{"doc":"Raising version of bitwise_xor/2 .","ref":"Evision.Mat.html#bitwise_xor!/2","title":"Evision.Mat.bitwise_xor!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#bitwise_xor/2","title":"Evision.Mat.bitwise_xor/2","type":"function"},{"doc":"Raising version of broadcast_to/2 .","ref":"Evision.Mat.html#broadcast_to!/2","title":"Evision.Mat.broadcast_to!/2","type":"function"},{"doc":"Raising version of broadcast_to/3 .","ref":"Evision.Mat.html#broadcast_to!/3","title":"Evision.Mat.broadcast_to!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#broadcast_to/2","title":"Evision.Mat.broadcast_to/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#broadcast_to/3","title":"Evision.Mat.broadcast_to/3","type":"function"},{"doc":"Raising version of ceil/1 .","ref":"Evision.Mat.html#ceil!/1","title":"Evision.Mat.ceil!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#ceil/1","title":"Evision.Mat.ceil/1","type":"function"},{"doc":"Raising version of channel_as_last_dim/1 .","ref":"Evision.Mat.html#channel_as_last_dim!/1","title":"Evision.Mat.channel_as_last_dim!/1","type":"function"},{"doc":"This function does the opposite as to Evision.Mat.last_dim_as_channel/1 . If the number of channels of the input Evision.Mat is greater than 1, then this function would convert the input Evision.Mat with dims dims=list(int()) to a 1 -channel Evision.Mat with dims [dims | channels] . If the number of channels of the input Evision.Mat is equal to 1, if dims == shape, then nothing happens otherwise, a new Evision.Mat that has dims= [dims | channels] will be returned","ref":"Evision.Mat.html#channel_as_last_dim/1","title":"Evision.Mat.channel_as_last_dim/1","type":"function"},{"doc":"Raising version of channels/1 .","ref":"Evision.Mat.html#channels!/1","title":"Evision.Mat.channels!/1","type":"function"},{"doc":"The method returns the number of matrix channels.","ref":"Evision.Mat.html#channels/1","title":"Evision.Mat.channels/1","type":"function"},{"doc":"Raising version of clip/3 .","ref":"Evision.Mat.html#clip!/3","title":"Evision.Mat.clip!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#clip/3","title":"Evision.Mat.clip/3","type":"function"},{"doc":"Raising version of clone/1 .","ref":"Evision.Mat.html#clone!/1","title":"Evision.Mat.clone!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#clone/1","title":"Evision.Mat.clone/1","type":"function"},{"doc":"Raising version of cmp/3 .","ref":"Evision.Mat.html#cmp!/3","title":"Evision.Mat.cmp!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#cmp/3","title":"Evision.Mat.cmp/3","type":"function"},{"doc":"Raising version of depth/1 .","ref":"Evision.Mat.html#depth!/1","title":"Evision.Mat.depth!/1","type":"function"},{"doc":"Returns the depth of a matrix element. The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-bit signed element array, the method returns CV_16S. A complete list of matrix types contains the following values: CV_8U - 8-bit unsigned integers ( 0..255 ) CV_8S - 8-bit signed integers ( -128..127 ) CV_16U - 16-bit unsigned integers ( 0..65535 ) CV_16S - 16-bit signed integers ( -32768..32767 ) CV_32S - 32-bit signed integers ( -2147483648..2147483647 ) CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN ) CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )","ref":"Evision.Mat.html#depth/1","title":"Evision.Mat.depth/1","type":"function"},{"doc":"Raising version of divide/2 .","ref":"Evision.Mat.html#divide!/2","title":"Evision.Mat.divide!/2","type":"function"},{"doc":"Raising version of divide/3 .","ref":"Evision.Mat.html#divide!/3","title":"Evision.Mat.divide!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#divide/2","title":"Evision.Mat.divide/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#divide/3","title":"Evision.Mat.divide/3","type":"function"},{"doc":"Raising version of dot/2 .","ref":"Evision.Mat.html#dot!/2","title":"Evision.Mat.dot!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#dot/2","title":"Evision.Mat.dot/2","type":"function"},{"doc":"Raising version of elemSize1/1 .","ref":"Evision.Mat.html#elemSize1!/1","title":"Evision.Mat.elemSize1!/1","type":"function"},{"doc":"Returns the size of each matrix element channel in bytes. The method returns the matrix element channel size in bytes, that is, it ignores the number of channels. For example, if the matrix type is CV_16SC3 , the method returns sizeof(short) or 2.","ref":"Evision.Mat.html#elemSize1/1","title":"Evision.Mat.elemSize1/1","type":"function"},{"doc":"Raising version of elemSize/1 .","ref":"Evision.Mat.html#elemSize!/1","title":"Evision.Mat.elemSize!/1","type":"function"},{"doc":"Returns the matrix element size in bytes. The method returns the matrix element size in bytes. For example, if the matrix type is CV_16SC3, the method returns 3*sizeof(short) or 6.","ref":"Evision.Mat.html#elemSize/1","title":"Evision.Mat.elemSize/1","type":"function"},{"doc":"Raising version of empty/0 .","ref":"Evision.Mat.html#empty!/0","title":"Evision.Mat.empty!/0","type":"function"},{"doc":"","ref":"Evision.Mat.html#empty/0","title":"Evision.Mat.empty/0","type":"function"},{"doc":"Raising version of expm1/1 .","ref":"Evision.Mat.html#expm1!/1","title":"Evision.Mat.expm1!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#expm1/1","title":"Evision.Mat.expm1/1","type":"function"},{"doc":"Raising version of eye/2 .","ref":"Evision.Mat.html#eye!/2","title":"Evision.Mat.eye!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#eye/2","title":"Evision.Mat.eye/2","type":"function"},{"doc":"Raising version of floor/1 .","ref":"Evision.Mat.html#floor!/1","title":"Evision.Mat.floor!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#floor/1","title":"Evision.Mat.floor/1","type":"function"},{"doc":"Raising version of from_binary/5 .","ref":"Evision.Mat.html#from_binary!/5","title":"Evision.Mat.from_binary!/5","type":"function"},{"doc":"Create Mat from binary (pixel) data binary . The binary pixel data type . type={t, l} is one of [{:u, 8}, {:s, 8}, {:u, 16}, {:s, 16}, {:s, 32}, {:f, 32}, {:f, 64}] rows . Number of rows (i.e., the height of the image) cols . Number of cols (i.e., the width of the image) channels . Number of channels, only valid if in [1, 3, 4]","ref":"Evision.Mat.html#from_binary/5","title":"Evision.Mat.from_binary/5","type":"function"},{"doc":"Raising version of from_binary_by_shape/3 .","ref":"Evision.Mat.html#from_binary_by_shape!/3","title":"Evision.Mat.from_binary_by_shape!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#from_binary_by_shape/3","title":"Evision.Mat.from_binary_by_shape/3","type":"function"},{"doc":"Raising version of full/3 .","ref":"Evision.Mat.html#full!/3","title":"Evision.Mat.full!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#full/3","title":"Evision.Mat.full/3","type":"function"},{"doc":"Raising version of isContinuous/1 .","ref":"Evision.Mat.html#isContinuous!/1","title":"Evision.Mat.isContinuous!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#isContinuous/1","title":"Evision.Mat.isContinuous/1","type":"function"},{"doc":"Raising version of isSubmatrix/1 .","ref":"Evision.Mat.html#isSubmatrix!/1","title":"Evision.Mat.isSubmatrix!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#isSubmatrix/1","title":"Evision.Mat.isSubmatrix/1","type":"function"},{"doc":"Raising version of last_dim_as_channel/1 .","ref":"Evision.Mat.html#last_dim_as_channel!/1","title":"Evision.Mat.last_dim_as_channel!/1","type":"function"},{"doc":"This function would convert the input tensor with dims [height, width, dims] to a dims -channel image with dims [height, width] . Note that OpenCV has limitation on the number of channels. Currently the maximum number of channels is 512 .","ref":"Evision.Mat.html#last_dim_as_channel/1","title":"Evision.Mat.last_dim_as_channel/1","type":"function"},{"doc":"Raising version of literal/1 .","ref":"Evision.Mat.html#literal!/1","title":"Evision.Mat.literal!/1","type":"function"},{"doc":"Raising version of literal/2 .","ref":"Evision.Mat.html#literal!/2","title":"Evision.Mat.literal!/2","type":"function"},{"doc":"Raising version of literal/3 .","ref":"Evision.Mat.html#literal!/3","title":"Evision.Mat.literal!/3","type":"function"},{"doc":"Create an Evision.Mat from list literals. Example Creating Evision.Mat from empty list literal ( [] ) is the same as calling Evision.Mat.empty() . iex&gt; Evision.Mat . literal! ( [ ] ) % Evision.Mat { channels : 1 , dims : 0 , type : { :u , 8 } , raw_type : 0 , shape : { } , ref : # Reference &lt; 0.1204050731 . 2031747092.46781 &gt; } By default, the shape of the Mat will stay as is. iex&gt; Evision.Mat . literal! ( [ [ [ 1 , 1 , 1 ] , [ 2 , 2 , 2 ] , [ 3 , 3 , 3 ] ] ] , :u8 ) % Evision.Mat { channels : 1 , dims : 3 , type : { :u , 8 } , raw_type : 0 , shape : { 1 , 3 , 3 } , ref : # Reference &lt; 0.512519210 . 691404819.106300 &gt; } Evision.Mat.literal/3 will return a vaild 2D image if the keyword argument, as_2d , is set to true and if the list literal can be represented as a 2D image. iex&gt; Evision.Mat . literal! ( [ [ [ 1 , 1 , 1 ] , [ 2 , 2 , 2 ] , [ 3 , 3 , 3 ] ] ] , :u8 , as_2d : true ) % Evision.Mat { channels : 3 , dims : 2 , type : { :u , 8 } , raw_type : 16 , shape : { 1 , 3 , 3 } , ref : # Reference &lt; 0.512519210 . 691404820.106293 &gt; }","ref":"Evision.Mat.html#literal/1","title":"Evision.Mat.literal/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#literal/3","title":"Evision.Mat.literal/3","type":"function"},{"doc":"Raising version of logical_and/2 .","ref":"Evision.Mat.html#logical_and!/2","title":"Evision.Mat.logical_and!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#logical_and/2","title":"Evision.Mat.logical_and/2","type":"function"},{"doc":"Raising version of logical_or/2 .","ref":"Evision.Mat.html#logical_or!/2","title":"Evision.Mat.logical_or!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#logical_or/2","title":"Evision.Mat.logical_or/2","type":"function"},{"doc":"Raising version of logical_xor/2 .","ref":"Evision.Mat.html#logical_xor!/2","title":"Evision.Mat.logical_xor!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#logical_xor/2","title":"Evision.Mat.logical_xor/2","type":"function"},{"doc":"Raising version of matrix_multiply/2 .","ref":"Evision.Mat.html#matrix_multiply!/2","title":"Evision.Mat.matrix_multiply!/2","type":"function"},{"doc":"Raising version of matrix_multiply/3 .","ref":"Evision.Mat.html#matrix_multiply!/3","title":"Evision.Mat.matrix_multiply!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#matrix_multiply/3","title":"Evision.Mat.matrix_multiply/3","type":"function"},{"doc":"Raising version of multiply/2 .","ref":"Evision.Mat.html#multiply!/2","title":"Evision.Mat.multiply!/2","type":"function"},{"doc":"Raising version of multiply/3 .","ref":"Evision.Mat.html#multiply!/3","title":"Evision.Mat.multiply!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#multiply/2","title":"Evision.Mat.multiply/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#multiply/3","title":"Evision.Mat.multiply/3","type":"function"},{"doc":"Raising version of negate/1 .","ref":"Evision.Mat.html#negate!/1","title":"Evision.Mat.negate!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#negate/1","title":"Evision.Mat.negate/1","type":"function"},{"doc":"Raising version of number/2 .","ref":"Evision.Mat.html#number!/2","title":"Evision.Mat.number!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#number/2","title":"Evision.Mat.number/2","type":"function"},{"doc":"Raising version of ones/2 .","ref":"Evision.Mat.html#ones!/2","title":"Evision.Mat.ones!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#ones/2","title":"Evision.Mat.ones/2","type":"function"},{"doc":"Raising version of raw_type/1 .","ref":"Evision.Mat.html#raw_type!/1","title":"Evision.Mat.raw_type!/1","type":"function"},{"doc":"Returns the type of a matrix. As Evision.Mat.type/1 returns the type used by Nx, this method gives the raw value of cv::Mat.type()","ref":"Evision.Mat.html#raw_type/1","title":"Evision.Mat.raw_type/1","type":"function"},{"doc":"Raising version of reshape/2 .","ref":"Evision.Mat.html#reshape!/2","title":"Evision.Mat.reshape!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#reshape/2","title":"Evision.Mat.reshape/2","type":"function"},{"doc":"Raising version of round/1 .","ref":"Evision.Mat.html#round!/1","title":"Evision.Mat.round!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#round/1","title":"Evision.Mat.round/1","type":"function"},{"doc":"Raising version of setTo/3 .","ref":"Evision.Mat.html#setTo!/3","title":"Evision.Mat.setTo!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#setTo/3","title":"Evision.Mat.setTo/3","type":"function"},{"doc":"Raising version of shape/1 .","ref":"Evision.Mat.html#shape!/1","title":"Evision.Mat.shape!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#shape/1","title":"Evision.Mat.shape/1","type":"function"},{"doc":"Raising version of sign/1 .","ref":"Evision.Mat.html#sign!/1","title":"Evision.Mat.sign!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#sign/1","title":"Evision.Mat.sign/1","type":"function"},{"doc":"Raising version of size/1 .","ref":"Evision.Mat.html#size!/1","title":"Evision.Mat.size!/1","type":"function"},{"doc":"Returns the cv::MatSize of the matrix. The method returns a tuple {dims, p} where dims is the number of dimensions, and p is a list with dims elements.","ref":"Evision.Mat.html#size/1","title":"Evision.Mat.size/1","type":"function"},{"doc":"Raising version of squeeze/1 .","ref":"Evision.Mat.html#squeeze!/1","title":"Evision.Mat.squeeze!/1","type":"function"},{"doc":"","ref":"Evision.Mat.html#squeeze/1","title":"Evision.Mat.squeeze/1","type":"function"},{"doc":"Raising version of subtract/2 .","ref":"Evision.Mat.html#subtract!/2","title":"Evision.Mat.subtract!/2","type":"function"},{"doc":"Raising version of subtract/3 .","ref":"Evision.Mat.html#subtract!/3","title":"Evision.Mat.subtract!/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#subtract/2","title":"Evision.Mat.subtract/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#subtract/3","title":"Evision.Mat.subtract/3","type":"function"},{"doc":"Raising version of to_batched/3 .","ref":"Evision.Mat.html#to_batched!/3","title":"Evision.Mat.to_batched!/3","type":"function"},{"doc":"Raising version of to_batched/4 .","ref":"Evision.Mat.html#to_batched!/4","title":"Evision.Mat.to_batched!/4","type":"function"},{"doc":"","ref":"Evision.Mat.html#to_batched/3","title":"Evision.Mat.to_batched/3","type":"function"},{"doc":"","ref":"Evision.Mat.html#to_batched/4","title":"Evision.Mat.to_batched/4","type":"function"},{"doc":"Raising version of to_binary/1 .","ref":"Evision.Mat.html#to_binary!/1","title":"Evision.Mat.to_binary!/1","type":"function"},{"doc":"Raising version of to_binary/2 .","ref":"Evision.Mat.html#to_binary!/2","title":"Evision.Mat.to_binary!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#to_binary/2","title":"Evision.Mat.to_binary/2","type":"function"},{"doc":"Raising version of total/1 .","ref":"Evision.Mat.html#total!/1","title":"Evision.Mat.total!/1","type":"function"},{"doc":"Raising version of total/2 .","ref":"Evision.Mat.html#total!/2","title":"Evision.Mat.total!/2","type":"function"},{"doc":"Raising version of total/3 .","ref":"Evision.Mat.html#total!/3","title":"Evision.Mat.total!/3","type":"function"},{"doc":"Returns the total number of array elements. The method returns the number of array elements (a number of pixels if the array represents an image).","ref":"Evision.Mat.html#total/1","title":"Evision.Mat.total/1","type":"function"},{"doc":"Returns the total number of array elements. The method returns the number of elements within a certain sub-array slice with start_dim &lt;= dim &lt; end_dim","ref":"Evision.Mat.html#total/3","title":"Evision.Mat.total/3","type":"function"},{"doc":"Raising version of transpose/1 .","ref":"Evision.Mat.html#transpose!/1","title":"Evision.Mat.transpose!/1","type":"function"},{"doc":"Raising version of transpose/2 .","ref":"Evision.Mat.html#transpose!/2","title":"Evision.Mat.transpose!/2","type":"function"},{"doc":"Raising version of transpose/3 .","ref":"Evision.Mat.html#transpose!/3","title":"Evision.Mat.transpose!/3","type":"function"},{"doc":"Transpose a matrix Parameters mat . The matrix. by default it reverses the order of the axes.","ref":"Evision.Mat.html#transpose/1","title":"Evision.Mat.transpose/1","type":"function"},{"doc":"Transpose a matrix Parameters mat . The matrix. axes . list of ints. It must be a list which contains a permutation of [0,1,..,N-1] where N is the number of axes of mat . The ith axis of the returned array will correspond to the axis numbered axes[i] of the input. opts . Keyword options. as_shape . A tuple or list which overwrites the shape of the matrix (the total number of elements must be equal to the one as in its original shape). For example, a 4x4 matrix can be treated as a 2x2x2x2 matrix and transposed with axes=[2,1,3,0] in a single call. When specified, it combines the reshape and transpose operation in a single NIF call.","ref":"Evision.Mat.html#transpose/3","title":"Evision.Mat.transpose/3","type":"function"},{"doc":"Raising version of type/1 .","ref":"Evision.Mat.html#type!/1","title":"Evision.Mat.type!/1","type":"function"},{"doc":"This method returns the type-tuple used by Nx. To get the raw value of cv::Mat.type() , please use Evision.Mat.raw_type/1 .","ref":"Evision.Mat.html#type/1","title":"Evision.Mat.type/1","type":"function"},{"doc":"Raising version of zeros/2 .","ref":"Evision.Mat.html#zeros!/2","title":"Evision.Mat.zeros!/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#zeros/2","title":"Evision.Mat.zeros/2","type":"function"},{"doc":"","ref":"Evision.Mat.html#t:channels_from_binary/0","title":"Evision.Mat.channels_from_binary/0","type":"type"},{"doc":"Types for mat","ref":"Evision.Mat.html#t:mat_type/0","title":"Evision.Mat.mat_type/0","type":"type"},{"doc":"","ref":"Evision.Mat.html#t:t/0","title":"Evision.Mat.t/0","type":"type"},{"doc":"","ref":"Evision.MergeDebevec.html","title":"Evision.MergeDebevec","type":"module"},{"doc":"Raising version of process/3 .","ref":"Evision.MergeDebevec.html#process!/3","title":"Evision.MergeDebevec.process!/3","type":"function"},{"doc":"Raising version of process/4 .","ref":"Evision.MergeDebevec.html#process!/4","title":"Evision.MergeDebevec.process!/4","type":"function"},{"doc":"Raising version of process/5 .","ref":"Evision.MergeDebevec.html#process!/5","title":"Evision.MergeDebevec.process!/5","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] times : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.MergeDebevec.html#process/3","title":"Evision.MergeDebevec.process/3","type":"function"},{"doc":"Variant 1: Positional Arguments src : [Evision.Mat] times : Evision.Mat response : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst Variant 2: Positional Arguments src : [Evision.Mat] times : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.MergeDebevec.html#process/4","title":"Evision.MergeDebevec.process/4","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] times : Evision.Mat response : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst","ref":"Evision.MergeDebevec.html#process/5","title":"Evision.MergeDebevec.process/5","type":"function"},{"doc":"","ref":"Evision.MergeExposures.html","title":"Evision.MergeExposures","type":"module"},{"doc":"Raising version of process/4 .","ref":"Evision.MergeExposures.html#process!/4","title":"Evision.MergeExposures.process!/4","type":"function"},{"doc":"Raising version of process/5 .","ref":"Evision.MergeExposures.html#process!/5","title":"Evision.MergeExposures.process!/5","type":"function"},{"doc":"Merges images. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image response : Evision.Mat . 256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images. Return dst : Evision.Mat . result image Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst","ref":"Evision.MergeExposures.html#process/4","title":"Evision.MergeExposures.process/4","type":"function"},{"doc":"Merges images. Positional Arguments src : [Evision.Mat] . vector of input images times : Evision.Mat . vector of exposure time values for each image response : Evision.Mat . 256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images. Return dst : Evision.Mat . result image Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst","ref":"Evision.MergeExposures.html#process/5","title":"Evision.MergeExposures.process/5","type":"function"},{"doc":"","ref":"Evision.MergeMertens.html","title":"Evision.MergeMertens","type":"module"},{"doc":"Raising version of getContrastWeight/1 .","ref":"Evision.MergeMertens.html#getContrastWeight!/1","title":"Evision.MergeMertens.getContrastWeight!/1","type":"function"},{"doc":"Python prototype (for reference): getContrastWeight() -&gt; retval","ref":"Evision.MergeMertens.html#getContrastWeight/1","title":"Evision.MergeMertens.getContrastWeight/1","type":"function"},{"doc":"Raising version of getExposureWeight/1 .","ref":"Evision.MergeMertens.html#getExposureWeight!/1","title":"Evision.MergeMertens.getExposureWeight!/1","type":"function"},{"doc":"Python prototype (for reference): getExposureWeight() -&gt; retval","ref":"Evision.MergeMertens.html#getExposureWeight/1","title":"Evision.MergeMertens.getExposureWeight/1","type":"function"},{"doc":"Raising version of getSaturationWeight/1 .","ref":"Evision.MergeMertens.html#getSaturationWeight!/1","title":"Evision.MergeMertens.getSaturationWeight!/1","type":"function"},{"doc":"Python prototype (for reference): getSaturationWeight() -&gt; retval","ref":"Evision.MergeMertens.html#getSaturationWeight/1","title":"Evision.MergeMertens.getSaturationWeight/1","type":"function"},{"doc":"Raising version of process/2 .","ref":"Evision.MergeMertens.html#process!/2","title":"Evision.MergeMertens.process!/2","type":"function"},{"doc":"Raising version of process/3 .","ref":"Evision.MergeMertens.html#process!/3","title":"Evision.MergeMertens.process!/3","type":"function"},{"doc":"Raising version of process/4 .","ref":"Evision.MergeMertens.html#process!/4","title":"Evision.MergeMertens.process!/4","type":"function"},{"doc":"Raising version of process/5 .","ref":"Evision.MergeMertens.html#process!/5","title":"Evision.MergeMertens.process!/5","type":"function"},{"doc":"Short version of process, that doesn't take extra arguments. Positional Arguments src : [Evision.Mat] . vector of input images Return dst : Evision.Mat . result image Python prototype (for reference): process(src[, dst]) -&gt; dst","ref":"Evision.MergeMertens.html#process/2","title":"Evision.MergeMertens.process/2","type":"function"},{"doc":"Short version of process, that doesn't take extra arguments. Positional Arguments src : [Evision.Mat] . vector of input images Return dst : Evision.Mat . result image Python prototype (for reference): process(src[, dst]) -&gt; dst","ref":"Evision.MergeMertens.html#process/3","title":"Evision.MergeMertens.process/3","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] times : Evision.Mat response : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst","ref":"Evision.MergeMertens.html#process/4","title":"Evision.MergeMertens.process/4","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] times : Evision.Mat response : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst","ref":"Evision.MergeMertens.html#process/5","title":"Evision.MergeMertens.process/5","type":"function"},{"doc":"Raising version of setContrastWeight/2 .","ref":"Evision.MergeMertens.html#setContrastWeight!/2","title":"Evision.MergeMertens.setContrastWeight!/2","type":"function"},{"doc":"Positional Arguments contrast_weiht : float Python prototype (for reference): setContrastWeight(contrast_weiht) -&gt; None","ref":"Evision.MergeMertens.html#setContrastWeight/2","title":"Evision.MergeMertens.setContrastWeight/2","type":"function"},{"doc":"Raising version of setExposureWeight/2 .","ref":"Evision.MergeMertens.html#setExposureWeight!/2","title":"Evision.MergeMertens.setExposureWeight!/2","type":"function"},{"doc":"Positional Arguments exposure_weight : float Python prototype (for reference): setExposureWeight(exposure_weight) -&gt; None","ref":"Evision.MergeMertens.html#setExposureWeight/2","title":"Evision.MergeMertens.setExposureWeight/2","type":"function"},{"doc":"Raising version of setSaturationWeight/2 .","ref":"Evision.MergeMertens.html#setSaturationWeight!/2","title":"Evision.MergeMertens.setSaturationWeight!/2","type":"function"},{"doc":"Positional Arguments saturation_weight : float Python prototype (for reference): setSaturationWeight(saturation_weight) -&gt; None","ref":"Evision.MergeMertens.html#setSaturationWeight/2","title":"Evision.MergeMertens.setSaturationWeight/2","type":"function"},{"doc":"","ref":"Evision.MergeRobertson.html","title":"Evision.MergeRobertson","type":"module"},{"doc":"Raising version of process/3 .","ref":"Evision.MergeRobertson.html#process!/3","title":"Evision.MergeRobertson.process!/3","type":"function"},{"doc":"Raising version of process/4 .","ref":"Evision.MergeRobertson.html#process!/4","title":"Evision.MergeRobertson.process!/4","type":"function"},{"doc":"Raising version of process/5 .","ref":"Evision.MergeRobertson.html#process!/5","title":"Evision.MergeRobertson.process!/5","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] times : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.MergeRobertson.html#process/3","title":"Evision.MergeRobertson.process/3","type":"function"},{"doc":"Variant 1: Positional Arguments src : [Evision.Mat] times : Evision.Mat response : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst Variant 2: Positional Arguments src : [Evision.Mat] times : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times[, dst]) -&gt; dst","ref":"Evision.MergeRobertson.html#process/4","title":"Evision.MergeRobertson.process/4","type":"function"},{"doc":"Positional Arguments src : [Evision.Mat] times : Evision.Mat response : Evision.Mat Return dst : Evision.Mat . Python prototype (for reference): process(src, times, response[, dst]) -&gt; dst","ref":"Evision.MergeRobertson.html#process/5","title":"Evision.MergeRobertson.process/5","type":"function"},{"doc":"OpenCV's cv::mat to Nx tensor.","ref":"Evision.Nx.html","title":"Evision.Nx","type":"module"},{"doc":"Raising version of to_mat/1 .","ref":"Evision.Nx.html#to_mat!/1","title":"Evision.Nx.to_mat!/1","type":"function"},{"doc":"Raising version of to_mat/2 .","ref":"Evision.Nx.html#to_mat!/2","title":"Evision.Nx.to_mat!/2","type":"function"},{"doc":"Raising version of to_mat/5 .","ref":"Evision.Nx.html#to_mat!/5","title":"Evision.Nx.to_mat!/5","type":"function"},{"doc":"Converts a tensor of Nx to Mat of evision (OpenCV). If the tensor has three dimensions, it is expected to have shape {height, width, channels} .","ref":"Evision.Nx.html#to_mat/1","title":"Evision.Nx.to_mat/1","type":"function"},{"doc":"","ref":"Evision.Nx.html#to_mat/2","title":"Evision.Nx.to_mat/2","type":"function"},{"doc":"","ref":"Evision.Nx.html#to_mat/5","title":"Evision.Nx.to_mat/5","type":"function"},{"doc":"Raising version of to_mat_2d/1 .","ref":"Evision.Nx.html#to_mat_2d!/1","title":"Evision.Nx.to_mat_2d!/1","type":"function"},{"doc":"","ref":"Evision.Nx.html#to_mat_2d/1","title":"Evision.Nx.to_mat_2d/1","type":"function"},{"doc":"Raising version of to_nx/1 .","ref":"Evision.Nx.html#to_nx!/1","title":"Evision.Nx.to_nx!/1","type":"function"},{"doc":"Raising version of to_nx/2 .","ref":"Evision.Nx.html#to_nx!/2","title":"Evision.Nx.to_nx!/2","type":"function"},{"doc":"Transform an Evision.Mat reference to Nx.tensor . The resulting tensor is in the shape {height, width, channels} . Example iex&gt; { :ok , mat } = Evision . imread ( &quot;/path/to/exist/img.png&quot; ) iex&gt; nx_tensor = Evision.Nx . to_nx ( mat ) ...&gt; # Nx.Tensor &lt; ...&gt; u8 [ 1080 ] [ 1920 ] [ 3 ] ...&gt; [ [ ... pixel data ... ] ] ...&gt; &gt;","ref":"Evision.Nx.html#to_nx/2","title":"Evision.Nx.to_nx/2","type":"function"},{"doc":"","ref":"Evision.OCL.html","title":"Evision.OCL","type":"module"},{"doc":"Raising version of finish/0 .","ref":"Evision.OCL.html#finish!/0","title":"Evision.OCL.finish!/0","type":"function"},{"doc":"Python prototype (for reference): finish() -&gt; None","ref":"Evision.OCL.html#finish/0","title":"Evision.OCL.finish/0","type":"function"},{"doc":"Raising version of haveAmdBlas/0 .","ref":"Evision.OCL.html#haveAmdBlas!/0","title":"Evision.OCL.haveAmdBlas!/0","type":"function"},{"doc":"Python prototype (for reference): haveAmdBlas() -&gt; retval","ref":"Evision.OCL.html#haveAmdBlas/0","title":"Evision.OCL.haveAmdBlas/0","type":"function"},{"doc":"Raising version of haveAmdFft/0 .","ref":"Evision.OCL.html#haveAmdFft!/0","title":"Evision.OCL.haveAmdFft!/0","type":"function"},{"doc":"Python prototype (for reference): haveAmdFft() -&gt; retval","ref":"Evision.OCL.html#haveAmdFft/0","title":"Evision.OCL.haveAmdFft/0","type":"function"},{"doc":"Raising version of haveOpenCL/0 .","ref":"Evision.OCL.html#haveOpenCL!/0","title":"Evision.OCL.haveOpenCL!/0","type":"function"},{"doc":"Python prototype (for reference): haveOpenCL() -&gt; retval","ref":"Evision.OCL.html#haveOpenCL/0","title":"Evision.OCL.haveOpenCL/0","type":"function"},{"doc":"Raising version of setUseOpenCL/1 .","ref":"Evision.OCL.html#setUseOpenCL!/1","title":"Evision.OCL.setUseOpenCL!/1","type":"function"},{"doc":"Positional Arguments flag : bool Python prototype (for reference): setUseOpenCL(flag) -&gt; None","ref":"Evision.OCL.html#setUseOpenCL/1","title":"Evision.OCL.setUseOpenCL/1","type":"function"},{"doc":"Raising version of useOpenCL/0 .","ref":"Evision.OCL.html#useOpenCL!/0","title":"Evision.OCL.useOpenCL!/0","type":"function"},{"doc":"Python prototype (for reference): useOpenCL() -&gt; retval","ref":"Evision.OCL.html#useOpenCL/0","title":"Evision.OCL.useOpenCL/0","type":"function"},{"doc":"","ref":"Evision.OCL.Device.html","title":"Evision.OCL.Device","type":"module"},{"doc":"Raising version of addressBits/1 .","ref":"Evision.OCL.Device.html#addressBits!/1","title":"Evision.OCL.Device.addressBits!/1","type":"function"},{"doc":"Python prototype (for reference): addressBits() -&gt; retval","ref":"Evision.OCL.Device.html#addressBits/1","title":"Evision.OCL.Device.addressBits/1","type":"function"},{"doc":"Raising version of available/1 .","ref":"Evision.OCL.Device.html#available!/1","title":"Evision.OCL.Device.available!/1","type":"function"},{"doc":"Python prototype (for reference): available() -&gt; retval","ref":"Evision.OCL.Device.html#available/1","title":"Evision.OCL.Device.available/1","type":"function"},{"doc":"Raising version of compilerAvailable/1 .","ref":"Evision.OCL.Device.html#compilerAvailable!/1","title":"Evision.OCL.Device.compilerAvailable!/1","type":"function"},{"doc":"Python prototype (for reference): compilerAvailable() -&gt; retval","ref":"Evision.OCL.Device.html#compilerAvailable/1","title":"Evision.OCL.Device.compilerAvailable/1","type":"function"},{"doc":"Raising version of deviceVersionMajor/1 .","ref":"Evision.OCL.Device.html#deviceVersionMajor!/1","title":"Evision.OCL.Device.deviceVersionMajor!/1","type":"function"},{"doc":"Python prototype (for reference): deviceVersionMajor() -&gt; retval","ref":"Evision.OCL.Device.html#deviceVersionMajor/1","title":"Evision.OCL.Device.deviceVersionMajor/1","type":"function"},{"doc":"Raising version of deviceVersionMinor/1 .","ref":"Evision.OCL.Device.html#deviceVersionMinor!/1","title":"Evision.OCL.Device.deviceVersionMinor!/1","type":"function"},{"doc":"Python prototype (for reference): deviceVersionMinor() -&gt; retval","ref":"Evision.OCL.Device.html#deviceVersionMinor/1","title":"Evision.OCL.Device.deviceVersionMinor/1","type":"function"},{"doc":"Raising version of doubleFPConfig/1 .","ref":"Evision.OCL.Device.html#doubleFPConfig!/1","title":"Evision.OCL.Device.doubleFPConfig!/1","type":"function"},{"doc":"Python prototype (for reference): doubleFPConfig() -&gt; retval","ref":"Evision.OCL.Device.html#doubleFPConfig/1","title":"Evision.OCL.Device.doubleFPConfig/1","type":"function"},{"doc":"Raising version of driverVersion/1 .","ref":"Evision.OCL.Device.html#driverVersion!/1","title":"Evision.OCL.Device.driverVersion!/1","type":"function"},{"doc":"Python prototype (for reference): driverVersion() -&gt; retval","ref":"Evision.OCL.Device.html#driverVersion/1","title":"Evision.OCL.Device.driverVersion/1","type":"function"},{"doc":"Raising version of endianLittle/1 .","ref":"Evision.OCL.Device.html#endianLittle!/1","title":"Evision.OCL.Device.endianLittle!/1","type":"function"},{"doc":"Python prototype (for reference): endianLittle() -&gt; retval","ref":"Evision.OCL.Device.html#endianLittle/1","title":"Evision.OCL.Device.endianLittle/1","type":"function"},{"doc":"Raising version of errorCorrectionSupport/1 .","ref":"Evision.OCL.Device.html#errorCorrectionSupport!/1","title":"Evision.OCL.Device.errorCorrectionSupport!/1","type":"function"},{"doc":"Python prototype (for reference): errorCorrectionSupport() -&gt; retval","ref":"Evision.OCL.Device.html#errorCorrectionSupport/1","title":"Evision.OCL.Device.errorCorrectionSupport/1","type":"function"},{"doc":"Raising version of executionCapabilities/1 .","ref":"Evision.OCL.Device.html#executionCapabilities!/1","title":"Evision.OCL.Device.executionCapabilities!/1","type":"function"},{"doc":"Python prototype (for reference): executionCapabilities() -&gt; retval","ref":"Evision.OCL.Device.html#executionCapabilities/1","title":"Evision.OCL.Device.executionCapabilities/1","type":"function"},{"doc":"Raising version of extensions/1 .","ref":"Evision.OCL.Device.html#extensions!/1","title":"Evision.OCL.Device.extensions!/1","type":"function"},{"doc":"Python prototype (for reference): extensions() -&gt; retval","ref":"Evision.OCL.Device.html#extensions/1","title":"Evision.OCL.Device.extensions/1","type":"function"},{"doc":"Raising version of getDefault/0 .","ref":"Evision.OCL.Device.html#getDefault!/0","title":"Evision.OCL.Device.getDefault!/0","type":"function"},{"doc":"Python prototype (for reference): getDefault() -&gt; retval","ref":"Evision.OCL.Device.html#getDefault/0","title":"Evision.OCL.Device.getDefault/0","type":"function"},{"doc":"Raising version of globalMemCacheLineSize/1 .","ref":"Evision.OCL.Device.html#globalMemCacheLineSize!/1","title":"Evision.OCL.Device.globalMemCacheLineSize!/1","type":"function"},{"doc":"Python prototype (for reference): globalMemCacheLineSize() -&gt; retval","ref":"Evision.OCL.Device.html#globalMemCacheLineSize/1","title":"Evision.OCL.Device.globalMemCacheLineSize/1","type":"function"},{"doc":"Raising version of globalMemCacheSize/1 .","ref":"Evision.OCL.Device.html#globalMemCacheSize!/1","title":"Evision.OCL.Device.globalMemCacheSize!/1","type":"function"},{"doc":"Python prototype (for reference): globalMemCacheSize() -&gt; retval","ref":"Evision.OCL.Device.html#globalMemCacheSize/1","title":"Evision.OCL.Device.globalMemCacheSize/1","type":"function"},{"doc":"Raising version of globalMemCacheType/1 .","ref":"Evision.OCL.Device.html#globalMemCacheType!/1","title":"Evision.OCL.Device.globalMemCacheType!/1","type":"function"},{"doc":"Python prototype (for reference): globalMemCacheType() -&gt; retval","ref":"Evision.OCL.Device.html#globalMemCacheType/1","title":"Evision.OCL.Device.globalMemCacheType/1","type":"function"},{"doc":"Raising version of globalMemSize/1 .","ref":"Evision.OCL.Device.html#globalMemSize!/1","title":"Evision.OCL.Device.globalMemSize!/1","type":"function"},{"doc":"Python prototype (for reference): globalMemSize() -&gt; retval","ref":"Evision.OCL.Device.html#globalMemSize/1","title":"Evision.OCL.Device.globalMemSize/1","type":"function"},{"doc":"Raising version of halfFPConfig/1 .","ref":"Evision.OCL.Device.html#halfFPConfig!/1","title":"Evision.OCL.Device.halfFPConfig!/1","type":"function"},{"doc":"Python prototype (for reference): halfFPConfig() -&gt; retval","ref":"Evision.OCL.Device.html#halfFPConfig/1","title":"Evision.OCL.Device.halfFPConfig/1","type":"function"},{"doc":"Raising version of hostUnifiedMemory/1 .","ref":"Evision.OCL.Device.html#hostUnifiedMemory!/1","title":"Evision.OCL.Device.hostUnifiedMemory!/1","type":"function"},{"doc":"Python prototype (for reference): hostUnifiedMemory() -&gt; retval","ref":"Evision.OCL.Device.html#hostUnifiedMemory/1","title":"Evision.OCL.Device.hostUnifiedMemory/1","type":"function"},{"doc":"Raising version of image2DMaxHeight/1 .","ref":"Evision.OCL.Device.html#image2DMaxHeight!/1","title":"Evision.OCL.Device.image2DMaxHeight!/1","type":"function"},{"doc":"Python prototype (for reference): image2DMaxHeight() -&gt; retval","ref":"Evision.OCL.Device.html#image2DMaxHeight/1","title":"Evision.OCL.Device.image2DMaxHeight/1","type":"function"},{"doc":"Raising version of image2DMaxWidth/1 .","ref":"Evision.OCL.Device.html#image2DMaxWidth!/1","title":"Evision.OCL.Device.image2DMaxWidth!/1","type":"function"},{"doc":"Python prototype (for reference): image2DMaxWidth() -&gt; retval","ref":"Evision.OCL.Device.html#image2DMaxWidth/1","title":"Evision.OCL.Device.image2DMaxWidth/1","type":"function"},{"doc":"Raising version of image3DMaxDepth/1 .","ref":"Evision.OCL.Device.html#image3DMaxDepth!/1","title":"Evision.OCL.Device.image3DMaxDepth!/1","type":"function"},{"doc":"Python prototype (for reference): image3DMaxDepth() -&gt; retval","ref":"Evision.OCL.Device.html#image3DMaxDepth/1","title":"Evision.OCL.Device.image3DMaxDepth/1","type":"function"},{"doc":"Raising version of image3DMaxHeight/1 .","ref":"Evision.OCL.Device.html#image3DMaxHeight!/1","title":"Evision.OCL.Device.image3DMaxHeight!/1","type":"function"},{"doc":"Python prototype (for reference): image3DMaxHeight() -&gt; retval","ref":"Evision.OCL.Device.html#image3DMaxHeight/1","title":"Evision.OCL.Device.image3DMaxHeight/1","type":"function"},{"doc":"Raising version of image3DMaxWidth/1 .","ref":"Evision.OCL.Device.html#image3DMaxWidth!/1","title":"Evision.OCL.Device.image3DMaxWidth!/1","type":"function"},{"doc":"Python prototype (for reference): image3DMaxWidth() -&gt; retval","ref":"Evision.OCL.Device.html#image3DMaxWidth/1","title":"Evision.OCL.Device.image3DMaxWidth/1","type":"function"},{"doc":"Raising version of imageFromBufferSupport/1 .","ref":"Evision.OCL.Device.html#imageFromBufferSupport!/1","title":"Evision.OCL.Device.imageFromBufferSupport!/1","type":"function"},{"doc":"Python prototype (for reference): imageFromBufferSupport() -&gt; retval","ref":"Evision.OCL.Device.html#imageFromBufferSupport/1","title":"Evision.OCL.Device.imageFromBufferSupport/1","type":"function"},{"doc":"Raising version of imageMaxArraySize/1 .","ref":"Evision.OCL.Device.html#imageMaxArraySize!/1","title":"Evision.OCL.Device.imageMaxArraySize!/1","type":"function"},{"doc":"Python prototype (for reference): imageMaxArraySize() -&gt; retval","ref":"Evision.OCL.Device.html#imageMaxArraySize/1","title":"Evision.OCL.Device.imageMaxArraySize/1","type":"function"},{"doc":"Raising version of imageMaxBufferSize/1 .","ref":"Evision.OCL.Device.html#imageMaxBufferSize!/1","title":"Evision.OCL.Device.imageMaxBufferSize!/1","type":"function"},{"doc":"Python prototype (for reference): imageMaxBufferSize() -&gt; retval","ref":"Evision.OCL.Device.html#imageMaxBufferSize/1","title":"Evision.OCL.Device.imageMaxBufferSize/1","type":"function"},{"doc":"Raising version of imageSupport/1 .","ref":"Evision.OCL.Device.html#imageSupport!/1","title":"Evision.OCL.Device.imageSupport!/1","type":"function"},{"doc":"Python prototype (for reference): imageSupport() -&gt; retval","ref":"Evision.OCL.Device.html#imageSupport/1","title":"Evision.OCL.Device.imageSupport/1","type":"function"},{"doc":"Raising version of intelSubgroupsSupport/1 .","ref":"Evision.OCL.Device.html#intelSubgroupsSupport!/1","title":"Evision.OCL.Device.intelSubgroupsSupport!/1","type":"function"},{"doc":"Python prototype (for reference): intelSubgroupsSupport() -&gt; retval","ref":"Evision.OCL.Device.html#intelSubgroupsSupport/1","title":"Evision.OCL.Device.intelSubgroupsSupport/1","type":"function"},{"doc":"Raising version of isAMD/1 .","ref":"Evision.OCL.Device.html#isAMD!/1","title":"Evision.OCL.Device.isAMD!/1","type":"function"},{"doc":"Python prototype (for reference): isAMD() -&gt; retval","ref":"Evision.OCL.Device.html#isAMD/1","title":"Evision.OCL.Device.isAMD/1","type":"function"},{"doc":"Raising version of isExtensionSupported/2 .","ref":"Evision.OCL.Device.html#isExtensionSupported!/2","title":"Evision.OCL.Device.isExtensionSupported!/2","type":"function"},{"doc":"Positional Arguments extensionName : String Python prototype (for reference): isExtensionSupported(extensionName) -&gt; retval","ref":"Evision.OCL.Device.html#isExtensionSupported/2","title":"Evision.OCL.Device.isExtensionSupported/2","type":"function"},{"doc":"Raising version of isIntel/1 .","ref":"Evision.OCL.Device.html#isIntel!/1","title":"Evision.OCL.Device.isIntel!/1","type":"function"},{"doc":"Python prototype (for reference): isIntel() -&gt; retval","ref":"Evision.OCL.Device.html#isIntel/1","title":"Evision.OCL.Device.isIntel/1","type":"function"},{"doc":"Raising version of isNVidia/1 .","ref":"Evision.OCL.Device.html#isNVidia!/1","title":"Evision.OCL.Device.isNVidia!/1","type":"function"},{"doc":"Python prototype (for reference): isNVidia() -&gt; retval","ref":"Evision.OCL.Device.html#isNVidia/1","title":"Evision.OCL.Device.isNVidia/1","type":"function"},{"doc":"Raising version of linkerAvailable/1 .","ref":"Evision.OCL.Device.html#linkerAvailable!/1","title":"Evision.OCL.Device.linkerAvailable!/1","type":"function"},{"doc":"Python prototype (for reference): linkerAvailable() -&gt; retval","ref":"Evision.OCL.Device.html#linkerAvailable/1","title":"Evision.OCL.Device.linkerAvailable/1","type":"function"},{"doc":"Raising version of localMemSize/1 .","ref":"Evision.OCL.Device.html#localMemSize!/1","title":"Evision.OCL.Device.localMemSize!/1","type":"function"},{"doc":"Python prototype (for reference): localMemSize() -&gt; retval","ref":"Evision.OCL.Device.html#localMemSize/1","title":"Evision.OCL.Device.localMemSize/1","type":"function"},{"doc":"Raising version of localMemType/1 .","ref":"Evision.OCL.Device.html#localMemType!/1","title":"Evision.OCL.Device.localMemType!/1","type":"function"},{"doc":"Python prototype (for reference): localMemType() -&gt; retval","ref":"Evision.OCL.Device.html#localMemType/1","title":"Evision.OCL.Device.localMemType/1","type":"function"},{"doc":"Raising version of maxClockFrequency/1 .","ref":"Evision.OCL.Device.html#maxClockFrequency!/1","title":"Evision.OCL.Device.maxClockFrequency!/1","type":"function"},{"doc":"Python prototype (for reference): maxClockFrequency() -&gt; retval","ref":"Evision.OCL.Device.html#maxClockFrequency/1","title":"Evision.OCL.Device.maxClockFrequency/1","type":"function"},{"doc":"Raising version of maxComputeUnits/1 .","ref":"Evision.OCL.Device.html#maxComputeUnits!/1","title":"Evision.OCL.Device.maxComputeUnits!/1","type":"function"},{"doc":"Python prototype (for reference): maxComputeUnits() -&gt; retval","ref":"Evision.OCL.Device.html#maxComputeUnits/1","title":"Evision.OCL.Device.maxComputeUnits/1","type":"function"},{"doc":"Raising version of maxConstantArgs/1 .","ref":"Evision.OCL.Device.html#maxConstantArgs!/1","title":"Evision.OCL.Device.maxConstantArgs!/1","type":"function"},{"doc":"Python prototype (for reference): maxConstantArgs() -&gt; retval","ref":"Evision.OCL.Device.html#maxConstantArgs/1","title":"Evision.OCL.Device.maxConstantArgs/1","type":"function"},{"doc":"Raising version of maxConstantBufferSize/1 .","ref":"Evision.OCL.Device.html#maxConstantBufferSize!/1","title":"Evision.OCL.Device.maxConstantBufferSize!/1","type":"function"},{"doc":"Python prototype (for reference): maxConstantBufferSize() -&gt; retval","ref":"Evision.OCL.Device.html#maxConstantBufferSize/1","title":"Evision.OCL.Device.maxConstantBufferSize/1","type":"function"},{"doc":"Raising version of maxMemAllocSize/1 .","ref":"Evision.OCL.Device.html#maxMemAllocSize!/1","title":"Evision.OCL.Device.maxMemAllocSize!/1","type":"function"},{"doc":"Python prototype (for reference): maxMemAllocSize() -&gt; retval","ref":"Evision.OCL.Device.html#maxMemAllocSize/1","title":"Evision.OCL.Device.maxMemAllocSize/1","type":"function"},{"doc":"Raising version of maxParameterSize/1 .","ref":"Evision.OCL.Device.html#maxParameterSize!/1","title":"Evision.OCL.Device.maxParameterSize!/1","type":"function"},{"doc":"Python prototype (for reference): maxParameterSize() -&gt; retval","ref":"Evision.OCL.Device.html#maxParameterSize/1","title":"Evision.OCL.Device.maxParameterSize/1","type":"function"},{"doc":"Raising version of maxReadImageArgs/1 .","ref":"Evision.OCL.Device.html#maxReadImageArgs!/1","title":"Evision.OCL.Device.maxReadImageArgs!/1","type":"function"},{"doc":"Python prototype (for reference): maxReadImageArgs() -&gt; retval","ref":"Evision.OCL.Device.html#maxReadImageArgs/1","title":"Evision.OCL.Device.maxReadImageArgs/1","type":"function"},{"doc":"Raising version of maxSamplers/1 .","ref":"Evision.OCL.Device.html#maxSamplers!/1","title":"Evision.OCL.Device.maxSamplers!/1","type":"function"},{"doc":"Python prototype (for reference): maxSamplers() -&gt; retval","ref":"Evision.OCL.Device.html#maxSamplers/1","title":"Evision.OCL.Device.maxSamplers/1","type":"function"},{"doc":"Raising version of maxWorkGroupSize/1 .","ref":"Evision.OCL.Device.html#maxWorkGroupSize!/1","title":"Evision.OCL.Device.maxWorkGroupSize!/1","type":"function"},{"doc":"Python prototype (for reference): maxWorkGroupSize() -&gt; retval","ref":"Evision.OCL.Device.html#maxWorkGroupSize/1","title":"Evision.OCL.Device.maxWorkGroupSize/1","type":"function"},{"doc":"Raising version of maxWorkItemDims/1 .","ref":"Evision.OCL.Device.html#maxWorkItemDims!/1","title":"Evision.OCL.Device.maxWorkItemDims!/1","type":"function"},{"doc":"Python prototype (for reference): maxWorkItemDims() -&gt; retval","ref":"Evision.OCL.Device.html#maxWorkItemDims/1","title":"Evision.OCL.Device.maxWorkItemDims/1","type":"function"},{"doc":"Raising version of maxWriteImageArgs/1 .","ref":"Evision.OCL.Device.html#maxWriteImageArgs!/1","title":"Evision.OCL.Device.maxWriteImageArgs!/1","type":"function"},{"doc":"Python prototype (for reference): maxWriteImageArgs() -&gt; retval","ref":"Evision.OCL.Device.html#maxWriteImageArgs/1","title":"Evision.OCL.Device.maxWriteImageArgs/1","type":"function"},{"doc":"Raising version of memBaseAddrAlign/1 .","ref":"Evision.OCL.Device.html#memBaseAddrAlign!/1","title":"Evision.OCL.Device.memBaseAddrAlign!/1","type":"function"},{"doc":"Python prototype (for reference): memBaseAddrAlign() -&gt; retval","ref":"Evision.OCL.Device.html#memBaseAddrAlign/1","title":"Evision.OCL.Device.memBaseAddrAlign/1","type":"function"},{"doc":"Raising version of name/1 .","ref":"Evision.OCL.Device.html#name!/1","title":"Evision.OCL.Device.name!/1","type":"function"},{"doc":"Python prototype (for reference): name() -&gt; retval","ref":"Evision.OCL.Device.html#name/1","title":"Evision.OCL.Device.name/1","type":"function"},{"doc":"Raising version of nativeVectorWidthChar/1 .","ref":"Evision.OCL.Device.html#nativeVectorWidthChar!/1","title":"Evision.OCL.Device.nativeVectorWidthChar!/1","type":"function"},{"doc":"Python prototype (for reference): nativeVectorWidthChar() -&gt; retval","ref":"Evision.OCL.Device.html#nativeVectorWidthChar/1","title":"Evision.OCL.Device.nativeVectorWidthChar/1","type":"function"},{"doc":"Raising version of nativeVectorWidthDouble/1 .","ref":"Evision.OCL.Device.html#nativeVectorWidthDouble!/1","title":"Evision.OCL.Device.nativeVectorWidthDouble!/1","type":"function"},{"doc":"Python prototype (for reference): nativeVectorWidthDouble() -&gt; retval","ref":"Evision.OCL.Device.html#nativeVectorWidthDouble/1","title":"Evision.OCL.Device.nativeVectorWidthDouble/1","type":"function"},{"doc":"Raising version of nativeVectorWidthFloat/1 .","ref":"Evision.OCL.Device.html#nativeVectorWidthFloat!/1","title":"Evision.OCL.Device.nativeVectorWidthFloat!/1","type":"function"},{"doc":"Python prototype (for reference): nativeVectorWidthFloat() -&gt; retval","ref":"Evision.OCL.Device.html#nativeVectorWidthFloat/1","title":"Evision.OCL.Device.nativeVectorWidthFloat/1","type":"function"},{"doc":"Raising version of nativeVectorWidthHalf/1 .","ref":"Evision.OCL.Device.html#nativeVectorWidthHalf!/1","title":"Evision.OCL.Device.nativeVectorWidthHalf!/1","type":"function"},{"doc":"Python prototype (for reference): nativeVectorWidthHalf() -&gt; retval","ref":"Evision.OCL.Device.html#nativeVectorWidthHalf/1","title":"Evision.OCL.Device.nativeVectorWidthHalf/1","type":"function"},{"doc":"Raising version of nativeVectorWidthInt/1 .","ref":"Evision.OCL.Device.html#nativeVectorWidthInt!/1","title":"Evision.OCL.Device.nativeVectorWidthInt!/1","type":"function"},{"doc":"Python prototype (for reference): nativeVectorWidthInt() -&gt; retval","ref":"Evision.OCL.Device.html#nativeVectorWidthInt/1","title":"Evision.OCL.Device.nativeVectorWidthInt/1","type":"function"},{"doc":"Raising version of nativeVectorWidthLong/1 .","ref":"Evision.OCL.Device.html#nativeVectorWidthLong!/1","title":"Evision.OCL.Device.nativeVectorWidthLong!/1","type":"function"},{"doc":"Python prototype (for reference): nativeVectorWidthLong() -&gt; retval","ref":"Evision.OCL.Device.html#nativeVectorWidthLong/1","title":"Evision.OCL.Device.nativeVectorWidthLong/1","type":"function"},{"doc":"Raising version of nativeVectorWidthShort/1 .","ref":"Evision.OCL.Device.html#nativeVectorWidthShort!/1","title":"Evision.OCL.Device.nativeVectorWidthShort!/1","type":"function"},{"doc":"Python prototype (for reference): nativeVectorWidthShort() -&gt; retval","ref":"Evision.OCL.Device.html#nativeVectorWidthShort/1","title":"Evision.OCL.Device.nativeVectorWidthShort/1","type":"function"},{"doc":"Raising version of ocl_Device/0 .","ref":"Evision.OCL.Device.html#ocl_Device!/0","title":"Evision.OCL.Device.ocl_Device!/0","type":"function"},{"doc":"Python prototype (for reference): Device() -&gt; &lt;ocl_Device object&gt;","ref":"Evision.OCL.Device.html#ocl_Device/0","title":"Evision.OCL.Device.ocl_Device/0","type":"function"},{"doc":"Raising version of openCL_C_Version/1 .","ref":"Evision.OCL.Device.html#openCL_C_Version!/1","title":"Evision.OCL.Device.openCL_C_Version!/1","type":"function"},{"doc":"Python prototype (for reference): OpenCL_C_Version() -&gt; retval","ref":"Evision.OCL.Device.html#openCL_C_Version/1","title":"Evision.OCL.Device.openCL_C_Version/1","type":"function"},{"doc":"Raising version of openCLVersion/1 .","ref":"Evision.OCL.Device.html#openCLVersion!/1","title":"Evision.OCL.Device.openCLVersion!/1","type":"function"},{"doc":"Python prototype (for reference): OpenCLVersion() -&gt; retval","ref":"Evision.OCL.Device.html#openCLVersion/1","title":"Evision.OCL.Device.openCLVersion/1","type":"function"},{"doc":"Raising version of preferredVectorWidthChar/1 .","ref":"Evision.OCL.Device.html#preferredVectorWidthChar!/1","title":"Evision.OCL.Device.preferredVectorWidthChar!/1","type":"function"},{"doc":"Python prototype (for reference): preferredVectorWidthChar() -&gt; retval","ref":"Evision.OCL.Device.html#preferredVectorWidthChar/1","title":"Evision.OCL.Device.preferredVectorWidthChar/1","type":"function"},{"doc":"Raising version of preferredVectorWidthDouble/1 .","ref":"Evision.OCL.Device.html#preferredVectorWidthDouble!/1","title":"Evision.OCL.Device.preferredVectorWidthDouble!/1","type":"function"},{"doc":"Python prototype (for reference): preferredVectorWidthDouble() -&gt; retval","ref":"Evision.OCL.Device.html#preferredVectorWidthDouble/1","title":"Evision.OCL.Device.preferredVectorWidthDouble/1","type":"function"},{"doc":"Raising version of preferredVectorWidthFloat/1 .","ref":"Evision.OCL.Device.html#preferredVectorWidthFloat!/1","title":"Evision.OCL.Device.preferredVectorWidthFloat!/1","type":"function"},{"doc":"Python prototype (for reference): preferredVectorWidthFloat() -&gt; retval","ref":"Evision.OCL.Device.html#preferredVectorWidthFloat/1","title":"Evision.OCL.Device.preferredVectorWidthFloat/1","type":"function"},{"doc":"Raising version of preferredVectorWidthHalf/1 .","ref":"Evision.OCL.Device.html#preferredVectorWidthHalf!/1","title":"Evision.OCL.Device.preferredVectorWidthHalf!/1","type":"function"},{"doc":"Python prototype (for reference): preferredVectorWidthHalf() -&gt; retval","ref":"Evision.OCL.Device.html#preferredVectorWidthHalf/1","title":"Evision.OCL.Device.preferredVectorWidthHalf/1","type":"function"},{"doc":"Raising version of preferredVectorWidthInt/1 .","ref":"Evision.OCL.Device.html#preferredVectorWidthInt!/1","title":"Evision.OCL.Device.preferredVectorWidthInt!/1","type":"function"},{"doc":"Python prototype (for reference): preferredVectorWidthInt() -&gt; retval","ref":"Evision.OCL.Device.html#preferredVectorWidthInt/1","title":"Evision.OCL.Device.preferredVectorWidthInt/1","type":"function"},{"doc":"Raising version of preferredVectorWidthLong/1 .","ref":"Evision.OCL.Device.html#preferredVectorWidthLong!/1","title":"Evision.OCL.Device.preferredVectorWidthLong!/1","type":"function"},{"doc":"Python prototype (for reference): preferredVectorWidthLong() -&gt; retval","ref":"Evision.OCL.Device.html#preferredVectorWidthLong/1","title":"Evision.OCL.Device.preferredVectorWidthLong/1","type":"function"},{"doc":"Raising version of preferredVectorWidthShort/1 .","ref":"Evision.OCL.Device.html#preferredVectorWidthShort!/1","title":"Evision.OCL.Device.preferredVectorWidthShort!/1","type":"function"},{"doc":"Python prototype (for reference): preferredVectorWidthShort() -&gt; retval","ref":"Evision.OCL.Device.html#preferredVectorWidthShort/1","title":"Evision.OCL.Device.preferredVectorWidthShort/1","type":"function"},{"doc":"Raising version of printfBufferSize/1 .","ref":"Evision.OCL.Device.html#printfBufferSize!/1","title":"Evision.OCL.Device.printfBufferSize!/1","type":"function"},{"doc":"Python prototype (for reference): printfBufferSize() -&gt; retval","ref":"Evision.OCL.Device.html#printfBufferSize/1","title":"Evision.OCL.Device.printfBufferSize/1","type":"function"},{"doc":"Raising version of profilingTimerResolution/1 .","ref":"Evision.OCL.Device.html#profilingTimerResolution!/1","title":"Evision.OCL.Device.profilingTimerResolution!/1","type":"function"},{"doc":"Python prototype (for reference): profilingTimerResolution() -&gt; retval","ref":"Evision.OCL.Device.html#profilingTimerResolution/1","title":"Evision.OCL.Device.profilingTimerResolution/1","type":"function"},{"doc":"Raising version of singleFPConfig/1 .","ref":"Evision.OCL.Device.html#singleFPConfig!/1","title":"Evision.OCL.Device.singleFPConfig!/1","type":"function"},{"doc":"Python prototype (for reference): singleFPConfig() -&gt; retval","ref":"Evision.OCL.Device.html#singleFPConfig/1","title":"Evision.OCL.Device.singleFPConfig/1","type":"function"},{"doc":"Raising version of type/1 .","ref":"Evision.OCL.Device.html#type!/1","title":"Evision.OCL.Device.type!/1","type":"function"},{"doc":"Python prototype (for reference): type() -&gt; retval","ref":"Evision.OCL.Device.html#type/1","title":"Evision.OCL.Device.type/1","type":"function"},{"doc":"Raising version of vendorID/1 .","ref":"Evision.OCL.Device.html#vendorID!/1","title":"Evision.OCL.Device.vendorID!/1","type":"function"},{"doc":"Python prototype (for reference): vendorID() -&gt; retval","ref":"Evision.OCL.Device.html#vendorID/1","title":"Evision.OCL.Device.vendorID/1","type":"function"},{"doc":"Raising version of vendorName/1 .","ref":"Evision.OCL.Device.html#vendorName!/1","title":"Evision.OCL.Device.vendorName!/1","type":"function"},{"doc":"Python prototype (for reference): vendorName() -&gt; retval","ref":"Evision.OCL.Device.html#vendorName/1","title":"Evision.OCL.Device.vendorName/1","type":"function"},{"doc":"Raising version of version/1 .","ref":"Evision.OCL.Device.html#version!/1","title":"Evision.OCL.Device.version!/1","type":"function"},{"doc":"Python prototype (for reference): version() -&gt; retval","ref":"Evision.OCL.Device.html#version/1","title":"Evision.OCL.Device.version/1","type":"function"},{"doc":"","ref":"Evision.ORB.html","title":"Evision.ORB","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.ORB.html#compute!/3","title":"Evision.ORB.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.ORB.html#compute!/4","title":"Evision.ORB.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.ORB.html#compute/3","title":"Evision.ORB.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.ORB.html#compute/4","title":"Evision.ORB.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.ORB.html#create!/0","title":"Evision.ORB.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.ORB.html#create!/1","title":"Evision.ORB.create!/1","type":"function"},{"doc":"The ORB constructor Keyword Arguments nfeatures : int . The maximum number of features to retain. scaleFactor : float . Pyramid decimation ratio, greater than 1. scaleFactor==2 means the classical pyramid, where each next level has 4x less pixels than the previous, but such a big scale factor will degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor will mean that to cover certain scale range you will need more pyramid levels and so the speed will suffer. nlevels : int . The number of pyramid levels. The smallest level will have linear size equal to input_image_linear_size/pow(scaleFactor, nlevels - firstLevel). edgeThreshold : int . This is size of the border where the features are not detected. It should roughly match the patchSize parameter. firstLevel : int . The level of pyramid to put source image to. Previous layers are filled with upscaled source image. wTA_K : int . The number of points that produce each element of the oriented BRIEF descriptor. The default value 2 means the BRIEF where we take a random point pair and compare their brightnesses, so we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3 random points (of course, those point coordinates are random, but they are generated from the pre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel rectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such output will occupy 2 bits, and therefore it will need a special variant of Hamming distance, denoted as NORM_HAMMING2 (2 bits per bin). When WTA_K=4, we take 4 random points to compute each bin (that will also occupy 2 bits with possible values 0, 1, 2 or 3). scoreType : ORB_ScoreType . The default HARRIS_SCORE means that Harris algorithm is used to rank features (the score is written to KeyPoint::score and is used to retain best nfeatures features); FAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints, but it is a little faster to compute. patchSize : int . size of the patch used by the oriented BRIEF descriptor. Of course, on smaller pyramid layers the perceived image area covered by a feature will be larger. fastThreshold : int . the fast threshold Python prototype (for reference): create([, nfeatures[, scaleFactor[, nlevels[, edgeThreshold[, firstLevel[, WTA_K[, scoreType[, patchSize[, fastThreshold]]]]]]]]]) -&gt; retval","ref":"Evision.ORB.html#create/0","title":"Evision.ORB.create/0","type":"function"},{"doc":"The ORB constructor Keyword Arguments nfeatures : int . The maximum number of features to retain. scaleFactor : float . Pyramid decimation ratio, greater than 1. scaleFactor==2 means the classical pyramid, where each next level has 4x less pixels than the previous, but such a big scale factor will degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor will mean that to cover certain scale range you will need more pyramid levels and so the speed will suffer. nlevels : int . The number of pyramid levels. The smallest level will have linear size equal to input_image_linear_size/pow(scaleFactor, nlevels - firstLevel). edgeThreshold : int . This is size of the border where the features are not detected. It should roughly match the patchSize parameter. firstLevel : int . The level of pyramid to put source image to. Previous layers are filled with upscaled source image. wTA_K : int . The number of points that produce each element of the oriented BRIEF descriptor. The default value 2 means the BRIEF where we take a random point pair and compare their brightnesses, so we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3 random points (of course, those point coordinates are random, but they are generated from the pre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel rectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such output will occupy 2 bits, and therefore it will need a special variant of Hamming distance, denoted as NORM_HAMMING2 (2 bits per bin). When WTA_K=4, we take 4 random points to compute each bin (that will also occupy 2 bits with possible values 0, 1, 2 or 3). scoreType : ORB_ScoreType . The default HARRIS_SCORE means that Harris algorithm is used to rank features (the score is written to KeyPoint::score and is used to retain best nfeatures features); FAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints, but it is a little faster to compute. patchSize : int . size of the patch used by the oriented BRIEF descriptor. Of course, on smaller pyramid layers the perceived image area covered by a feature will be larger. fastThreshold : int . the fast threshold Python prototype (for reference): create([, nfeatures[, scaleFactor[, nlevels[, edgeThreshold[, firstLevel[, WTA_K[, scoreType[, patchSize[, fastThreshold]]]]]]]]]) -&gt; retval","ref":"Evision.ORB.html#create/1","title":"Evision.ORB.create/1","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.ORB.html#defaultNorm!/1","title":"Evision.ORB.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.ORB.html#defaultNorm/1","title":"Evision.ORB.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.ORB.html#descriptorSize!/1","title":"Evision.ORB.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.ORB.html#descriptorSize/1","title":"Evision.ORB.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.ORB.html#descriptorType!/1","title":"Evision.ORB.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.ORB.html#descriptorType/1","title":"Evision.ORB.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.ORB.html#detect!/2","title":"Evision.ORB.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.ORB.html#detect!/3","title":"Evision.ORB.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.ORB.html#detect/2","title":"Evision.ORB.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.ORB.html#detect/3","title":"Evision.ORB.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.ORB.html#detectAndCompute!/3","title":"Evision.ORB.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.ORB.html#detectAndCompute!/4","title":"Evision.ORB.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.ORB.html#detectAndCompute/3","title":"Evision.ORB.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.ORB.html#detectAndCompute/4","title":"Evision.ORB.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.ORB.html#empty!/1","title":"Evision.ORB.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.ORB.html#empty/1","title":"Evision.ORB.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.ORB.html#getDefaultName!/1","title":"Evision.ORB.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.ORB.html#getDefaultName/1","title":"Evision.ORB.getDefaultName/1","type":"function"},{"doc":"Raising version of getEdgeThreshold/1 .","ref":"Evision.ORB.html#getEdgeThreshold!/1","title":"Evision.ORB.getEdgeThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getEdgeThreshold() -&gt; retval","ref":"Evision.ORB.html#getEdgeThreshold/1","title":"Evision.ORB.getEdgeThreshold/1","type":"function"},{"doc":"Raising version of getFastThreshold/1 .","ref":"Evision.ORB.html#getFastThreshold!/1","title":"Evision.ORB.getFastThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getFastThreshold() -&gt; retval","ref":"Evision.ORB.html#getFastThreshold/1","title":"Evision.ORB.getFastThreshold/1","type":"function"},{"doc":"Raising version of getFirstLevel/1 .","ref":"Evision.ORB.html#getFirstLevel!/1","title":"Evision.ORB.getFirstLevel!/1","type":"function"},{"doc":"Python prototype (for reference): getFirstLevel() -&gt; retval","ref":"Evision.ORB.html#getFirstLevel/1","title":"Evision.ORB.getFirstLevel/1","type":"function"},{"doc":"Raising version of getMaxFeatures/1 .","ref":"Evision.ORB.html#getMaxFeatures!/1","title":"Evision.ORB.getMaxFeatures!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxFeatures() -&gt; retval","ref":"Evision.ORB.html#getMaxFeatures/1","title":"Evision.ORB.getMaxFeatures/1","type":"function"},{"doc":"Raising version of getNLevels/1 .","ref":"Evision.ORB.html#getNLevels!/1","title":"Evision.ORB.getNLevels!/1","type":"function"},{"doc":"Python prototype (for reference): getNLevels() -&gt; retval","ref":"Evision.ORB.html#getNLevels/1","title":"Evision.ORB.getNLevels/1","type":"function"},{"doc":"Raising version of getPatchSize/1 .","ref":"Evision.ORB.html#getPatchSize!/1","title":"Evision.ORB.getPatchSize!/1","type":"function"},{"doc":"Python prototype (for reference): getPatchSize() -&gt; retval","ref":"Evision.ORB.html#getPatchSize/1","title":"Evision.ORB.getPatchSize/1","type":"function"},{"doc":"Raising version of getScaleFactor/1 .","ref":"Evision.ORB.html#getScaleFactor!/1","title":"Evision.ORB.getScaleFactor!/1","type":"function"},{"doc":"Python prototype (for reference): getScaleFactor() -&gt; retval","ref":"Evision.ORB.html#getScaleFactor/1","title":"Evision.ORB.getScaleFactor/1","type":"function"},{"doc":"Raising version of getScoreType/1 .","ref":"Evision.ORB.html#getScoreType!/1","title":"Evision.ORB.getScoreType!/1","type":"function"},{"doc":"Python prototype (for reference): getScoreType() -&gt; retval","ref":"Evision.ORB.html#getScoreType/1","title":"Evision.ORB.getScoreType/1","type":"function"},{"doc":"Raising version of getWTA_K/1 .","ref":"Evision.ORB.html#getWTA_K!/1","title":"Evision.ORB.getWTA_K!/1","type":"function"},{"doc":"Python prototype (for reference): getWTA_K() -&gt; retval","ref":"Evision.ORB.html#getWTA_K/1","title":"Evision.ORB.getWTA_K/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.ORB.html#read!/2","title":"Evision.ORB.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.ORB.html#read/2","title":"Evision.ORB.read/2","type":"function"},{"doc":"Raising version of setEdgeThreshold/2 .","ref":"Evision.ORB.html#setEdgeThreshold!/2","title":"Evision.ORB.setEdgeThreshold!/2","type":"function"},{"doc":"Positional Arguments edgeThreshold : int Python prototype (for reference): setEdgeThreshold(edgeThreshold) -&gt; None","ref":"Evision.ORB.html#setEdgeThreshold/2","title":"Evision.ORB.setEdgeThreshold/2","type":"function"},{"doc":"Raising version of setFastThreshold/2 .","ref":"Evision.ORB.html#setFastThreshold!/2","title":"Evision.ORB.setFastThreshold!/2","type":"function"},{"doc":"Positional Arguments fastThreshold : int Python prototype (for reference): setFastThreshold(fastThreshold) -&gt; None","ref":"Evision.ORB.html#setFastThreshold/2","title":"Evision.ORB.setFastThreshold/2","type":"function"},{"doc":"Raising version of setFirstLevel/2 .","ref":"Evision.ORB.html#setFirstLevel!/2","title":"Evision.ORB.setFirstLevel!/2","type":"function"},{"doc":"Positional Arguments firstLevel : int Python prototype (for reference): setFirstLevel(firstLevel) -&gt; None","ref":"Evision.ORB.html#setFirstLevel/2","title":"Evision.ORB.setFirstLevel/2","type":"function"},{"doc":"Raising version of setMaxFeatures/2 .","ref":"Evision.ORB.html#setMaxFeatures!/2","title":"Evision.ORB.setMaxFeatures!/2","type":"function"},{"doc":"Positional Arguments maxFeatures : int Python prototype (for reference): setMaxFeatures(maxFeatures) -&gt; None","ref":"Evision.ORB.html#setMaxFeatures/2","title":"Evision.ORB.setMaxFeatures/2","type":"function"},{"doc":"Raising version of setNLevels/2 .","ref":"Evision.ORB.html#setNLevels!/2","title":"Evision.ORB.setNLevels!/2","type":"function"},{"doc":"Positional Arguments nlevels : int Python prototype (for reference): setNLevels(nlevels) -&gt; None","ref":"Evision.ORB.html#setNLevels/2","title":"Evision.ORB.setNLevels/2","type":"function"},{"doc":"Raising version of setPatchSize/2 .","ref":"Evision.ORB.html#setPatchSize!/2","title":"Evision.ORB.setPatchSize!/2","type":"function"},{"doc":"Positional Arguments patchSize : int Python prototype (for reference): setPatchSize(patchSize) -&gt; None","ref":"Evision.ORB.html#setPatchSize/2","title":"Evision.ORB.setPatchSize/2","type":"function"},{"doc":"Raising version of setScaleFactor/2 .","ref":"Evision.ORB.html#setScaleFactor!/2","title":"Evision.ORB.setScaleFactor!/2","type":"function"},{"doc":"Positional Arguments scaleFactor : double Python prototype (for reference): setScaleFactor(scaleFactor) -&gt; None","ref":"Evision.ORB.html#setScaleFactor/2","title":"Evision.ORB.setScaleFactor/2","type":"function"},{"doc":"Raising version of setScoreType/2 .","ref":"Evision.ORB.html#setScoreType!/2","title":"Evision.ORB.setScoreType!/2","type":"function"},{"doc":"Positional Arguments scoreType : ORB_ScoreType Python prototype (for reference): setScoreType(scoreType) -&gt; None","ref":"Evision.ORB.html#setScoreType/2","title":"Evision.ORB.setScoreType/2","type":"function"},{"doc":"Raising version of setWTA_K/2 .","ref":"Evision.ORB.html#setWTA_K!/2","title":"Evision.ORB.setWTA_K!/2","type":"function"},{"doc":"Positional Arguments wta_k : int Python prototype (for reference): setWTA_K(wta_k) -&gt; None","ref":"Evision.ORB.html#setWTA_K/2","title":"Evision.ORB.setWTA_K/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.ORB.html#write!/2","title":"Evision.ORB.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.ORB.html#write!/3","title":"Evision.ORB.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.ORB.html#write/2","title":"Evision.ORB.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.ORB.html#write/3","title":"Evision.ORB.write/3","type":"function"},{"doc":"","ref":"Evision.Parallel.html","title":"Evision.Parallel","type":"module"},{"doc":"Raising version of setParallelForBackend/1 .","ref":"Evision.Parallel.html#setParallelForBackend!/1","title":"Evision.Parallel.setParallelForBackend!/1","type":"function"},{"doc":"Raising version of setParallelForBackend/2 .","ref":"Evision.Parallel.html#setParallelForBackend!/2","title":"Evision.Parallel.setParallelForBackend!/2","type":"function"},{"doc":"Change OpenCV parallel_for backend Positional Arguments backendName : string Keyword Arguments propagateNumThreads : bool . Note : This call is not thread-safe. Consider calling this function from the main() before any other OpenCV processing functions (and without any other created threads). Python prototype (for reference): setParallelForBackend(backendName[, propagateNumThreads]) -&gt; retval","ref":"Evision.Parallel.html#setParallelForBackend/1","title":"Evision.Parallel.setParallelForBackend/1","type":"function"},{"doc":"Change OpenCV parallel_for backend Positional Arguments backendName : string Keyword Arguments propagateNumThreads : bool . Note : This call is not thread-safe. Consider calling this function from the main() before any other OpenCV processing functions (and without any other created threads). Python prototype (for reference): setParallelForBackend(backendName[, propagateNumThreads]) -&gt; retval","ref":"Evision.Parallel.html#setParallelForBackend/2","title":"Evision.Parallel.setParallelForBackend/2","type":"function"},{"doc":"","ref":"Evision.PyRotationWarper.html","title":"Evision.PyRotationWarper","type":"module"},{"doc":"Raising version of buildMaps/4 .","ref":"Evision.PyRotationWarper.html#buildMaps!/4","title":"Evision.PyRotationWarper.buildMaps!/4","type":"function"},{"doc":"Raising version of buildMaps/5 .","ref":"Evision.PyRotationWarper.html#buildMaps!/5","title":"Evision.PyRotationWarper.buildMaps!/5","type":"function"},{"doc":"Builds the projection maps according to the given camera data. Positional Arguments src_size : Size . Source image size k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix Return xmap : Evision.Mat . Projection map for the x axis ymap : Evision.Mat . Projection map for the y axis @return Projected image minimum bounding box Python prototype (for reference): buildMaps(src_size, K, R[, xmap[, ymap]]) -&gt; retval, xmap, ymap","ref":"Evision.PyRotationWarper.html#buildMaps/4","title":"Evision.PyRotationWarper.buildMaps/4","type":"function"},{"doc":"Builds the projection maps according to the given camera data. Positional Arguments src_size : Size . Source image size k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix Return xmap : Evision.Mat . Projection map for the x axis ymap : Evision.Mat . Projection map for the y axis @return Projected image minimum bounding box Python prototype (for reference): buildMaps(src_size, K, R[, xmap[, ymap]]) -&gt; retval, xmap, ymap","ref":"Evision.PyRotationWarper.html#buildMaps/5","title":"Evision.PyRotationWarper.buildMaps/5","type":"function"},{"doc":"Raising version of getScale/1 .","ref":"Evision.PyRotationWarper.html#getScale!/1","title":"Evision.PyRotationWarper.getScale!/1","type":"function"},{"doc":"Python prototype (for reference): getScale() -&gt; retval","ref":"Evision.PyRotationWarper.html#getScale/1","title":"Evision.PyRotationWarper.getScale/1","type":"function"},{"doc":"Raising version of pyRotationWarper/0 .","ref":"Evision.PyRotationWarper.html#pyRotationWarper!/0","title":"Evision.PyRotationWarper.pyRotationWarper!/0","type":"function"},{"doc":"Raising version of pyRotationWarper/2 .","ref":"Evision.PyRotationWarper.html#pyRotationWarper!/2","title":"Evision.PyRotationWarper.pyRotationWarper!/2","type":"function"},{"doc":"Python prototype (for reference): PyRotationWarper() -&gt; &lt;PyRotationWarper object&gt;","ref":"Evision.PyRotationWarper.html#pyRotationWarper/0","title":"Evision.PyRotationWarper.pyRotationWarper/0","type":"function"},{"doc":"Positional Arguments type : String scale : float Python prototype (for reference): PyRotationWarper(type, scale) -&gt; &lt;PyRotationWarper object&gt;","ref":"Evision.PyRotationWarper.html#pyRotationWarper/2","title":"Evision.PyRotationWarper.pyRotationWarper/2","type":"function"},{"doc":"Raising version of setScale/2 .","ref":"Evision.PyRotationWarper.html#setScale!/2","title":"Evision.PyRotationWarper.setScale!/2","type":"function"},{"doc":"Positional Arguments arg1 : float Python prototype (for reference): setScale(arg1) -&gt; None","ref":"Evision.PyRotationWarper.html#setScale/2","title":"Evision.PyRotationWarper.setScale/2","type":"function"},{"doc":"Raising version of warp/6 .","ref":"Evision.PyRotationWarper.html#warp!/6","title":"Evision.PyRotationWarper.warp!/6","type":"function"},{"doc":"Raising version of warp/7 .","ref":"Evision.PyRotationWarper.html#warp!/7","title":"Evision.PyRotationWarper.warp!/7","type":"function"},{"doc":"Projects the image. Positional Arguments src : Evision.Mat . Source image k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix interp_mode : int . Interpolation mode border_mode : int . Border extrapolation mode Return dst : Evision.Mat . Projected image @return Project image top-left corner Python prototype (for reference): warp(src, K, R, interp_mode, border_mode[, dst]) -&gt; retval, dst","ref":"Evision.PyRotationWarper.html#warp/6","title":"Evision.PyRotationWarper.warp/6","type":"function"},{"doc":"Projects the image. Positional Arguments src : Evision.Mat . Source image k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix interp_mode : int . Interpolation mode border_mode : int . Border extrapolation mode Return dst : Evision.Mat . Projected image @return Project image top-left corner Python prototype (for reference): warp(src, K, R, interp_mode, border_mode[, dst]) -&gt; retval, dst","ref":"Evision.PyRotationWarper.html#warp/7","title":"Evision.PyRotationWarper.warp/7","type":"function"},{"doc":"Raising version of warpBackward/7 .","ref":"Evision.PyRotationWarper.html#warpBackward!/7","title":"Evision.PyRotationWarper.warpBackward!/7","type":"function"},{"doc":"Raising version of warpBackward/8 .","ref":"Evision.PyRotationWarper.html#warpBackward!/8","title":"Evision.PyRotationWarper.warpBackward!/8","type":"function"},{"doc":"Projects the image backward. Positional Arguments src : Evision.Mat . Projected image k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix interp_mode : int . Interpolation mode border_mode : int . Border extrapolation mode dst_size : Size . Backward-projected image size Return dst : Evision.Mat . Backward-projected image Python prototype (for reference): warpBackward(src, K, R, interp_mode, border_mode, dst_size[, dst]) -&gt; dst","ref":"Evision.PyRotationWarper.html#warpBackward/7","title":"Evision.PyRotationWarper.warpBackward/7","type":"function"},{"doc":"Projects the image backward. Positional Arguments src : Evision.Mat . Projected image k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix interp_mode : int . Interpolation mode border_mode : int . Border extrapolation mode dst_size : Size . Backward-projected image size Return dst : Evision.Mat . Backward-projected image Python prototype (for reference): warpBackward(src, K, R, interp_mode, border_mode, dst_size[, dst]) -&gt; dst","ref":"Evision.PyRotationWarper.html#warpBackward/8","title":"Evision.PyRotationWarper.warpBackward/8","type":"function"},{"doc":"Raising version of warpPoint/4 .","ref":"Evision.PyRotationWarper.html#warpPoint!/4","title":"Evision.PyRotationWarper.warpPoint!/4","type":"function"},{"doc":"Projects the image point. Positional Arguments pt : Point2f . Source point k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix @return Projected point Python prototype (for reference): warpPoint(pt, K, R) -&gt; retval","ref":"Evision.PyRotationWarper.html#warpPoint/4","title":"Evision.PyRotationWarper.warpPoint/4","type":"function"},{"doc":"Raising version of warpPointBackward/4 .","ref":"Evision.PyRotationWarper.html#warpPointBackward!/4","title":"Evision.PyRotationWarper.warpPointBackward!/4","type":"function"},{"doc":"Positional Arguments pt : Point2f k : Evision.Mat r : Evision.Mat Python prototype (for reference): warpPointBackward(pt, K, R) -&gt; retval","ref":"Evision.PyRotationWarper.html#warpPointBackward/4","title":"Evision.PyRotationWarper.warpPointBackward/4","type":"function"},{"doc":"Raising version of warpRoi/4 .","ref":"Evision.PyRotationWarper.html#warpRoi!/4","title":"Evision.PyRotationWarper.warpRoi!/4","type":"function"},{"doc":"Positional Arguments src_size : Size . Source image bounding box k : Evision.Mat . Camera intrinsic parameters r : Evision.Mat . Camera rotation matrix @return Projected image minimum bounding box Python prototype (for reference): warpRoi(src_size, K, R) -&gt; retval","ref":"Evision.PyRotationWarper.html#warpRoi/4","title":"Evision.PyRotationWarper.warpRoi/4","type":"function"},{"doc":"","ref":"Evision.QRCodeDetector.html","title":"Evision.QRCodeDetector","type":"module"},{"doc":"Raising version of decode/3 .","ref":"Evision.QRCodeDetector.html#decode!/3","title":"Evision.QRCodeDetector.decode!/3","type":"function"},{"doc":"Raising version of decode/4 .","ref":"Evision.QRCodeDetector.html#decode!/4","title":"Evision.QRCodeDetector.decode!/4","type":"function"},{"doc":"Decodes QR code in image once it's found by the detect() method. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. points : Evision.Mat . Quadrangle vertices found by detect() method (or some other algorithm). Return straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Returns UTF8-encoded output string or empty string if the code cannot be decoded. Python prototype (for reference): decode(img, points[, straight_qrcode]) -&gt; retval, straight_qrcode","ref":"Evision.QRCodeDetector.html#decode/3","title":"Evision.QRCodeDetector.decode/3","type":"function"},{"doc":"Decodes QR code in image once it's found by the detect() method. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. points : Evision.Mat . Quadrangle vertices found by detect() method (or some other algorithm). Return straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Returns UTF8-encoded output string or empty string if the code cannot be decoded. Python prototype (for reference): decode(img, points[, straight_qrcode]) -&gt; retval, straight_qrcode","ref":"Evision.QRCodeDetector.html#decode/4","title":"Evision.QRCodeDetector.decode/4","type":"function"},{"doc":"Raising version of decodeCurved/3 .","ref":"Evision.QRCodeDetector.html#decodeCurved!/3","title":"Evision.QRCodeDetector.decodeCurved!/3","type":"function"},{"doc":"Raising version of decodeCurved/4 .","ref":"Evision.QRCodeDetector.html#decodeCurved!/4","title":"Evision.QRCodeDetector.decodeCurved!/4","type":"function"},{"doc":"Decodes QR code on a curved surface in image once it's found by the detect() method. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. points : Evision.Mat . Quadrangle vertices found by detect() method (or some other algorithm). Return straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Returns UTF8-encoded output string or empty string if the code cannot be decoded. Python prototype (for reference): decodeCurved(img, points[, straight_qrcode]) -&gt; retval, straight_qrcode","ref":"Evision.QRCodeDetector.html#decodeCurved/3","title":"Evision.QRCodeDetector.decodeCurved/3","type":"function"},{"doc":"Decodes QR code on a curved surface in image once it's found by the detect() method. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. points : Evision.Mat . Quadrangle vertices found by detect() method (or some other algorithm). Return straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Returns UTF8-encoded output string or empty string if the code cannot be decoded. Python prototype (for reference): decodeCurved(img, points[, straight_qrcode]) -&gt; retval, straight_qrcode","ref":"Evision.QRCodeDetector.html#decodeCurved/4","title":"Evision.QRCodeDetector.decodeCurved/4","type":"function"},{"doc":"Raising version of decodeMulti/3 .","ref":"Evision.QRCodeDetector.html#decodeMulti!/3","title":"Evision.QRCodeDetector.decodeMulti!/3","type":"function"},{"doc":"Raising version of decodeMulti/4 .","ref":"Evision.QRCodeDetector.html#decodeMulti!/4","title":"Evision.QRCodeDetector.decodeMulti!/4","type":"function"},{"doc":"Decodes QR codes in image once it's found by the detect() method. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR codes. points : Evision.Mat . vector of Quadrangle vertices found by detect() method (or some other algorithm). Return decoded_info : [string] . UTF8-encoded output vector of string or empty vector of string if the codes cannot be decoded. straight_qrcode : [Evision.Mat] . The optional output vector of images containing rectified and binarized QR codes Python prototype (for reference): decodeMulti(img, points[, straight_qrcode]) -&gt; retval, decoded_info, straight_qrcode","ref":"Evision.QRCodeDetector.html#decodeMulti/3","title":"Evision.QRCodeDetector.decodeMulti/3","type":"function"},{"doc":"Decodes QR codes in image once it's found by the detect() method. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR codes. points : Evision.Mat . vector of Quadrangle vertices found by detect() method (or some other algorithm). Return decoded_info : [string] . UTF8-encoded output vector of string or empty vector of string if the codes cannot be decoded. straight_qrcode : [Evision.Mat] . The optional output vector of images containing rectified and binarized QR codes Python prototype (for reference): decodeMulti(img, points[, straight_qrcode]) -&gt; retval, decoded_info, straight_qrcode","ref":"Evision.QRCodeDetector.html#decodeMulti/4","title":"Evision.QRCodeDetector.decodeMulti/4","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.QRCodeDetector.html#detect!/2","title":"Evision.QRCodeDetector.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.QRCodeDetector.html#detect!/3","title":"Evision.QRCodeDetector.detect!/3","type":"function"},{"doc":"Detects QR code in image and returns the quadrangle containing the code. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing (or not) QR code. Return points : Evision.Mat . Output vector of vertices of the minimum-area quadrangle containing the code. Python prototype (for reference): detect(img[, points]) -&gt; retval, points","ref":"Evision.QRCodeDetector.html#detect/2","title":"Evision.QRCodeDetector.detect/2","type":"function"},{"doc":"Detects QR code in image and returns the quadrangle containing the code. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing (or not) QR code. Return points : Evision.Mat . Output vector of vertices of the minimum-area quadrangle containing the code. Python prototype (for reference): detect(img[, points]) -&gt; retval, points","ref":"Evision.QRCodeDetector.html#detect/3","title":"Evision.QRCodeDetector.detect/3","type":"function"},{"doc":"Raising version of detectAndDecode/2 .","ref":"Evision.QRCodeDetector.html#detectAndDecode!/2","title":"Evision.QRCodeDetector.detectAndDecode!/2","type":"function"},{"doc":"Raising version of detectAndDecode/3 .","ref":"Evision.QRCodeDetector.html#detectAndDecode!/3","title":"Evision.QRCodeDetector.detectAndDecode!/3","type":"function"},{"doc":"Both detects and decodes QR code Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. Return points : Evision.Mat . optional output array of vertices of the found QR code quadrangle. Will be empty if not found. straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Python prototype (for reference): detectAndDecode(img[, points[, straight_qrcode]]) -&gt; retval, points, straight_qrcode","ref":"Evision.QRCodeDetector.html#detectAndDecode/2","title":"Evision.QRCodeDetector.detectAndDecode/2","type":"function"},{"doc":"Both detects and decodes QR code Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. Return points : Evision.Mat . optional output array of vertices of the found QR code quadrangle. Will be empty if not found. straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Python prototype (for reference): detectAndDecode(img[, points[, straight_qrcode]]) -&gt; retval, points, straight_qrcode","ref":"Evision.QRCodeDetector.html#detectAndDecode/3","title":"Evision.QRCodeDetector.detectAndDecode/3","type":"function"},{"doc":"Raising version of detectAndDecodeCurved/2 .","ref":"Evision.QRCodeDetector.html#detectAndDecodeCurved!/2","title":"Evision.QRCodeDetector.detectAndDecodeCurved!/2","type":"function"},{"doc":"Raising version of detectAndDecodeCurved/3 .","ref":"Evision.QRCodeDetector.html#detectAndDecodeCurved!/3","title":"Evision.QRCodeDetector.detectAndDecodeCurved!/3","type":"function"},{"doc":"Both detects and decodes QR code on a curved surface Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. Return points : Evision.Mat . optional output array of vertices of the found QR code quadrangle. Will be empty if not found. straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Python prototype (for reference): detectAndDecodeCurved(img[, points[, straight_qrcode]]) -&gt; retval, points, straight_qrcode","ref":"Evision.QRCodeDetector.html#detectAndDecodeCurved/2","title":"Evision.QRCodeDetector.detectAndDecodeCurved/2","type":"function"},{"doc":"Both detects and decodes QR code on a curved surface Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR code. Return points : Evision.Mat . optional output array of vertices of the found QR code quadrangle. Will be empty if not found. straight_qrcode : Evision.Mat . The optional output image containing rectified and binarized QR code Python prototype (for reference): detectAndDecodeCurved(img[, points[, straight_qrcode]]) -&gt; retval, points, straight_qrcode","ref":"Evision.QRCodeDetector.html#detectAndDecodeCurved/3","title":"Evision.QRCodeDetector.detectAndDecodeCurved/3","type":"function"},{"doc":"Raising version of detectAndDecodeMulti/2 .","ref":"Evision.QRCodeDetector.html#detectAndDecodeMulti!/2","title":"Evision.QRCodeDetector.detectAndDecodeMulti!/2","type":"function"},{"doc":"Raising version of detectAndDecodeMulti/3 .","ref":"Evision.QRCodeDetector.html#detectAndDecodeMulti!/3","title":"Evision.QRCodeDetector.detectAndDecodeMulti!/3","type":"function"},{"doc":"Both detects and decodes QR codes Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR codes. Return decoded_info : [string] . UTF8-encoded output vector of string or empty vector of string if the codes cannot be decoded. points : Evision.Mat . optional output vector of vertices of the found QR code quadrangles. Will be empty if not found. straight_qrcode : [Evision.Mat] . The optional output vector of images containing rectified and binarized QR codes Python prototype (for reference): detectAndDecodeMulti(img[, points[, straight_qrcode]]) -&gt; retval, decoded_info, points, straight_qrcode","ref":"Evision.QRCodeDetector.html#detectAndDecodeMulti/2","title":"Evision.QRCodeDetector.detectAndDecodeMulti/2","type":"function"},{"doc":"Both detects and decodes QR codes Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing QR codes. Return decoded_info : [string] . UTF8-encoded output vector of string or empty vector of string if the codes cannot be decoded. points : Evision.Mat . optional output vector of vertices of the found QR code quadrangles. Will be empty if not found. straight_qrcode : [Evision.Mat] . The optional output vector of images containing rectified and binarized QR codes Python prototype (for reference): detectAndDecodeMulti(img[, points[, straight_qrcode]]) -&gt; retval, decoded_info, points, straight_qrcode","ref":"Evision.QRCodeDetector.html#detectAndDecodeMulti/3","title":"Evision.QRCodeDetector.detectAndDecodeMulti/3","type":"function"},{"doc":"Raising version of detectMulti/2 .","ref":"Evision.QRCodeDetector.html#detectMulti!/2","title":"Evision.QRCodeDetector.detectMulti!/2","type":"function"},{"doc":"Raising version of detectMulti/3 .","ref":"Evision.QRCodeDetector.html#detectMulti!/3","title":"Evision.QRCodeDetector.detectMulti!/3","type":"function"},{"doc":"Detects QR codes in image and returns the vector of the quadrangles containing the codes. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing (or not) QR codes. Return points : Evision.Mat . Output vector of vector of vertices of the minimum-area quadrangle containing the codes. Python prototype (for reference): detectMulti(img[, points]) -&gt; retval, points","ref":"Evision.QRCodeDetector.html#detectMulti/2","title":"Evision.QRCodeDetector.detectMulti/2","type":"function"},{"doc":"Detects QR codes in image and returns the vector of the quadrangles containing the codes. Positional Arguments img : Evision.Mat . grayscale or color (BGR) image containing (or not) QR codes. Return points : Evision.Mat . Output vector of vector of vertices of the minimum-area quadrangle containing the codes. Python prototype (for reference): detectMulti(img[, points]) -&gt; retval, points","ref":"Evision.QRCodeDetector.html#detectMulti/3","title":"Evision.QRCodeDetector.detectMulti/3","type":"function"},{"doc":"Raising version of qrCodeDetector/0 .","ref":"Evision.QRCodeDetector.html#qrCodeDetector!/0","title":"Evision.QRCodeDetector.qrCodeDetector!/0","type":"function"},{"doc":"Python prototype (for reference): QRCodeDetector() -&gt; &lt;QRCodeDetector object&gt;","ref":"Evision.QRCodeDetector.html#qrCodeDetector/0","title":"Evision.QRCodeDetector.qrCodeDetector/0","type":"function"},{"doc":"Raising version of setEpsX/2 .","ref":"Evision.QRCodeDetector.html#setEpsX!/2","title":"Evision.QRCodeDetector.setEpsX!/2","type":"function"},{"doc":"sets the epsilon used during the horizontal scan of QR code stop marker detection. Positional Arguments epsX : double . Epsilon neighborhood, which allows you to determine the horizontal pattern of the scheme 1:1:3:1:1 according to QR code standard. Python prototype (for reference): setEpsX(epsX) -&gt; None","ref":"Evision.QRCodeDetector.html#setEpsX/2","title":"Evision.QRCodeDetector.setEpsX/2","type":"function"},{"doc":"Raising version of setEpsY/2 .","ref":"Evision.QRCodeDetector.html#setEpsY!/2","title":"Evision.QRCodeDetector.setEpsY!/2","type":"function"},{"doc":"sets the epsilon used during the vertical scan of QR code stop marker detection. Positional Arguments epsY : double . Epsilon neighborhood, which allows you to determine the vertical pattern of the scheme 1:1:3:1:1 according to QR code standard. Python prototype (for reference): setEpsY(epsY) -&gt; None","ref":"Evision.QRCodeDetector.html#setEpsY/2","title":"Evision.QRCodeDetector.setEpsY/2","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.html","title":"Evision.QRCodeEncoder","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.QRCodeEncoder.html#create!/0","title":"Evision.QRCodeEncoder.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.QRCodeEncoder.html#create!/1","title":"Evision.QRCodeEncoder.create!/1","type":"function"},{"doc":"Constructor Keyword Arguments parameters : QRCodeEncoder_Params . QR code encoder parameters QRCodeEncoder::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.QRCodeEncoder.html#create/0","title":"Evision.QRCodeEncoder.create/0","type":"function"},{"doc":"Constructor Keyword Arguments parameters : QRCodeEncoder_Params . QR code encoder parameters QRCodeEncoder::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.QRCodeEncoder.html#create/1","title":"Evision.QRCodeEncoder.create/1","type":"function"},{"doc":"Raising version of encode/2 .","ref":"Evision.QRCodeEncoder.html#encode!/2","title":"Evision.QRCodeEncoder.encode!/2","type":"function"},{"doc":"Raising version of encode/3 .","ref":"Evision.QRCodeEncoder.html#encode!/3","title":"Evision.QRCodeEncoder.encode!/3","type":"function"},{"doc":"Generates QR code from input string. Positional Arguments encoded_info : String . Input string to encode. Return qrcode : Evision.Mat . Generated QR code. Python prototype (for reference): encode(encoded_info[, qrcode]) -&gt; qrcode","ref":"Evision.QRCodeEncoder.html#encode/2","title":"Evision.QRCodeEncoder.encode/2","type":"function"},{"doc":"Generates QR code from input string. Positional Arguments encoded_info : String . Input string to encode. Return qrcode : Evision.Mat . Generated QR code. Python prototype (for reference): encode(encoded_info[, qrcode]) -&gt; qrcode","ref":"Evision.QRCodeEncoder.html#encode/3","title":"Evision.QRCodeEncoder.encode/3","type":"function"},{"doc":"Raising version of encodeStructuredAppend/2 .","ref":"Evision.QRCodeEncoder.html#encodeStructuredAppend!/2","title":"Evision.QRCodeEncoder.encodeStructuredAppend!/2","type":"function"},{"doc":"Raising version of encodeStructuredAppend/3 .","ref":"Evision.QRCodeEncoder.html#encodeStructuredAppend!/3","title":"Evision.QRCodeEncoder.encodeStructuredAppend!/3","type":"function"},{"doc":"Generates QR code from input string in Structured Append mode. The encoded message is splitting over a number of QR codes. Positional Arguments encoded_info : String . Input string to encode. Return qrcodes : [Evision.Mat] . Vector of generated QR codes. Python prototype (for reference): encodeStructuredAppend(encoded_info[, qrcodes]) -&gt; qrcodes","ref":"Evision.QRCodeEncoder.html#encodeStructuredAppend/2","title":"Evision.QRCodeEncoder.encodeStructuredAppend/2","type":"function"},{"doc":"Generates QR code from input string in Structured Append mode. The encoded message is splitting over a number of QR codes. Positional Arguments encoded_info : String . Input string to encode. Return qrcodes : [Evision.Mat] . Vector of generated QR codes. Python prototype (for reference): encodeStructuredAppend(encoded_info[, qrcodes]) -&gt; qrcodes","ref":"Evision.QRCodeEncoder.html#encodeStructuredAppend/3","title":"Evision.QRCodeEncoder.encodeStructuredAppend/3","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html","title":"Evision.QRCodeEncoder.Params","type":"module"},{"doc":"Raising version of get_correction_level/1 .","ref":"Evision.QRCodeEncoder.Params.html#get_correction_level!/1","title":"Evision.QRCodeEncoder.Params.get_correction_level!/1","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#get_correction_level/1","title":"Evision.QRCodeEncoder.Params.get_correction_level/1","type":"function"},{"doc":"Raising version of get_mode/1 .","ref":"Evision.QRCodeEncoder.Params.html#get_mode!/1","title":"Evision.QRCodeEncoder.Params.get_mode!/1","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#get_mode/1","title":"Evision.QRCodeEncoder.Params.get_mode/1","type":"function"},{"doc":"Raising version of get_structure_number/1 .","ref":"Evision.QRCodeEncoder.Params.html#get_structure_number!/1","title":"Evision.QRCodeEncoder.Params.get_structure_number!/1","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#get_structure_number/1","title":"Evision.QRCodeEncoder.Params.get_structure_number/1","type":"function"},{"doc":"Raising version of get_version/1 .","ref":"Evision.QRCodeEncoder.Params.html#get_version!/1","title":"Evision.QRCodeEncoder.Params.get_version!/1","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#get_version/1","title":"Evision.QRCodeEncoder.Params.get_version/1","type":"function"},{"doc":"Raising version of qrcodeencoder_params/0 .","ref":"Evision.QRCodeEncoder.Params.html#qrcodeencoder_params!/0","title":"Evision.QRCodeEncoder.Params.qrcodeencoder_params!/0","type":"function"},{"doc":"Python prototype (for reference): QRCodeEncoder_Params() -&gt; &lt;QRCodeEncoder_Params object&gt;","ref":"Evision.QRCodeEncoder.Params.html#qrcodeencoder_params/0","title":"Evision.QRCodeEncoder.Params.qrcodeencoder_params/0","type":"function"},{"doc":"Raising version of set_correction_level/2 .","ref":"Evision.QRCodeEncoder.Params.html#set_correction_level!/2","title":"Evision.QRCodeEncoder.Params.set_correction_level!/2","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#set_correction_level/2","title":"Evision.QRCodeEncoder.Params.set_correction_level/2","type":"function"},{"doc":"Raising version of set_mode/2 .","ref":"Evision.QRCodeEncoder.Params.html#set_mode!/2","title":"Evision.QRCodeEncoder.Params.set_mode!/2","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#set_mode/2","title":"Evision.QRCodeEncoder.Params.set_mode/2","type":"function"},{"doc":"Raising version of set_structure_number/2 .","ref":"Evision.QRCodeEncoder.Params.html#set_structure_number!/2","title":"Evision.QRCodeEncoder.Params.set_structure_number!/2","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#set_structure_number/2","title":"Evision.QRCodeEncoder.Params.set_structure_number/2","type":"function"},{"doc":"Raising version of set_version/2 .","ref":"Evision.QRCodeEncoder.Params.html#set_version!/2","title":"Evision.QRCodeEncoder.Params.set_version!/2","type":"function"},{"doc":"","ref":"Evision.QRCodeEncoder.Params.html#set_version/2","title":"Evision.QRCodeEncoder.Params.set_version/2","type":"function"},{"doc":"","ref":"Evision.SIFT.html","title":"Evision.SIFT","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.SIFT.html#compute!/3","title":"Evision.SIFT.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.SIFT.html#compute!/4","title":"Evision.SIFT.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.SIFT.html#compute/3","title":"Evision.SIFT.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.SIFT.html#compute/4","title":"Evision.SIFT.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.SIFT.html#create!/0","title":"Evision.SIFT.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.SIFT.html#create!/1","title":"Evision.SIFT.create!/1","type":"function"},{"doc":"Raising version of create/6 .","ref":"Evision.SIFT.html#create!/6","title":"Evision.SIFT.create!/6","type":"function"},{"doc":"##### Keyword Arguments nfeatures : int . The number of best features to retain. The features are ranked by their scores (measured in SIFT algorithm as the local contrast) nOctaveLayers : int . The number of layers in each octave. 3 is the value used in D. Lowe paper. The number of octaves is computed automatically from the image resolution. contrastThreshold : double . The contrast threshold used to filter out weak features in semi-uniform (low-contrast) regions. The larger the threshold, the less features are produced by the detector. edgeThreshold : double . The threshold used to filter out edge-like features. Note that the its meaning is different from the contrastThreshold, i.e. the larger the edgeThreshold, the less features are filtered out (more features are retained). sigma : double . The sigma of the Gaussian applied to the input image at the octave #0. If your image is captured with a weak camera with soft lenses, you might want to reduce the number. Note : The contrast threshold will be divided by nOctaveLayers when the filtering is applied. When nOctaveLayers is set to default and if you want to use the value used in D. Lowe paper, 0.03, set this argument to 0.09. Python prototype (for reference): create([, nfeatures[, nOctaveLayers[, contrastThreshold[, edgeThreshold[, sigma]]]]]) -&gt; retval","ref":"Evision.SIFT.html#create/0","title":"Evision.SIFT.create/0","type":"function"},{"doc":"##### Keyword Arguments nfeatures : int . The number of best features to retain. The features are ranked by their scores (measured in SIFT algorithm as the local contrast) nOctaveLayers : int . The number of layers in each octave. 3 is the value used in D. Lowe paper. The number of octaves is computed automatically from the image resolution. contrastThreshold : double . The contrast threshold used to filter out weak features in semi-uniform (low-contrast) regions. The larger the threshold, the less features are produced by the detector. edgeThreshold : double . The threshold used to filter out edge-like features. Note that the its meaning is different from the contrastThreshold, i.e. the larger the edgeThreshold, the less features are filtered out (more features are retained). sigma : double . The sigma of the Gaussian applied to the input image at the octave #0. If your image is captured with a weak camera with soft lenses, you might want to reduce the number. Note : The contrast threshold will be divided by nOctaveLayers when the filtering is applied. When nOctaveLayers is set to default and if you want to use the value used in D. Lowe paper, 0.03, set this argument to 0.09. Python prototype (for reference): create([, nfeatures[, nOctaveLayers[, contrastThreshold[, edgeThreshold[, sigma]]]]]) -&gt; retval","ref":"Evision.SIFT.html#create/1","title":"Evision.SIFT.create/1","type":"function"},{"doc":"Create SIFT with specified descriptorType. Positional Arguments nfeatures : int . The number of best features to retain. The features are ranked by their scores (measured in SIFT algorithm as the local contrast) nOctaveLayers : int . The number of layers in each octave. 3 is the value used in D. Lowe paper. The number of octaves is computed automatically from the image resolution. contrastThreshold : double . The contrast threshold used to filter out weak features in semi-uniform (low-contrast) regions. The larger the threshold, the less features are produced by the detector. edgeThreshold : double . The threshold used to filter out edge-like features. Note that the its meaning is different from the contrastThreshold, i.e. the larger the edgeThreshold, the less features are filtered out (more features are retained). sigma : double . The sigma of the Gaussian applied to the input image at the octave #0. If your image is captured with a weak camera with soft lenses, you might want to reduce the number. descriptorType : int . The type of descriptors. Only CV_32F and CV_8U are supported. Note : The contrast threshold will be divided by nOctaveLayers when the filtering is applied. When nOctaveLayers is set to default and if you want to use the value used in D. Lowe paper, 0.03, set this argument to 0.09. Python prototype (for reference): create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, descriptorType) -&gt; retval","ref":"Evision.SIFT.html#create/6","title":"Evision.SIFT.create/6","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.SIFT.html#defaultNorm!/1","title":"Evision.SIFT.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.SIFT.html#defaultNorm/1","title":"Evision.SIFT.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.SIFT.html#descriptorSize!/1","title":"Evision.SIFT.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.SIFT.html#descriptorSize/1","title":"Evision.SIFT.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.SIFT.html#descriptorType!/1","title":"Evision.SIFT.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.SIFT.html#descriptorType/1","title":"Evision.SIFT.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.SIFT.html#detect!/2","title":"Evision.SIFT.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.SIFT.html#detect!/3","title":"Evision.SIFT.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.SIFT.html#detect/2","title":"Evision.SIFT.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.SIFT.html#detect/3","title":"Evision.SIFT.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.SIFT.html#detectAndCompute!/3","title":"Evision.SIFT.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.SIFT.html#detectAndCompute!/4","title":"Evision.SIFT.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.SIFT.html#detectAndCompute/3","title":"Evision.SIFT.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.SIFT.html#detectAndCompute/4","title":"Evision.SIFT.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.SIFT.html#empty!/1","title":"Evision.SIFT.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.SIFT.html#empty/1","title":"Evision.SIFT.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.SIFT.html#getDefaultName!/1","title":"Evision.SIFT.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.SIFT.html#getDefaultName/1","title":"Evision.SIFT.getDefaultName/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.SIFT.html#read!/2","title":"Evision.SIFT.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.SIFT.html#read/2","title":"Evision.SIFT.read/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.SIFT.html#write!/2","title":"Evision.SIFT.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.SIFT.html#write!/3","title":"Evision.SIFT.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.SIFT.html#write/2","title":"Evision.SIFT.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.SIFT.html#write/3","title":"Evision.SIFT.write/3","type":"function"},{"doc":"","ref":"Evision.Samples.html","title":"Evision.Samples","type":"module"},{"doc":"Raising version of addSamplesDataSearchPath/1 .","ref":"Evision.Samples.html#addSamplesDataSearchPath!/1","title":"Evision.Samples.addSamplesDataSearchPath!/1","type":"function"},{"doc":"Override search data path by adding new search location Positional Arguments path : String . Path to used samples data Use this only to override default behavior Passed paths are used in LIFO order. Python prototype (for reference): addSamplesDataSearchPath(path) -&gt; None","ref":"Evision.Samples.html#addSamplesDataSearchPath/1","title":"Evision.Samples.addSamplesDataSearchPath/1","type":"function"},{"doc":"Raising version of addSamplesDataSearchSubDirectory/1 .","ref":"Evision.Samples.html#addSamplesDataSearchSubDirectory!/1","title":"Evision.Samples.addSamplesDataSearchSubDirectory!/1","type":"function"},{"doc":"Append samples search data sub directory Positional Arguments subdir : String . samples data sub directory General usage is to add OpenCV modules name ( &lt;opencv_contrib&gt;/modules/&lt;name&gt;/samples/data -&gt; &lt;name&gt;/samples/data + modules/&lt;name&gt;/samples/data ). Passed subdirectories are used in LIFO order. Python prototype (for reference): addSamplesDataSearchSubDirectory(subdir) -&gt; None","ref":"Evision.Samples.html#addSamplesDataSearchSubDirectory/1","title":"Evision.Samples.addSamplesDataSearchSubDirectory/1","type":"function"},{"doc":"Raising version of findFile/1 .","ref":"Evision.Samples.html#findFile!/1","title":"Evision.Samples.findFile!/1","type":"function"},{"doc":"Raising version of findFile/2 .","ref":"Evision.Samples.html#findFile!/2","title":"Evision.Samples.findFile!/2","type":"function"},{"doc":"Try to find requested data file Positional Arguments relative_path : String . Relative path to data file Keyword Arguments required : bool . Specify &quot;file not found&quot; handling. If true, function prints information message and raises cv::Exception. If false, function returns empty result silentMode : bool . Disables messages Search directories: Directories passed via addSamplesDataSearchPath() OPENCV_SAMPLES_DATA_PATH_HINT environment variable OPENCV_SAMPLES_DATA_PATH environment variable If parameter value is not empty and nothing is found then stop searching. Detects build/install path based on: a. current working directory (CWD) b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage) Scan &lt;source&gt;/{,data,samples/data} directories if build directory is detected or the current directory is in source tree. Scan &lt;install&gt;/share/OpenCV directory if install directory is detected. @see cv::utils::findDataFile @return Returns path (absolute or relative to the current directory) or empty string if file is not found Python prototype (for reference): findFile(relative_path[, required[, silentMode]]) -&gt; retval","ref":"Evision.Samples.html#findFile/1","title":"Evision.Samples.findFile/1","type":"function"},{"doc":"Try to find requested data file Positional Arguments relative_path : String . Relative path to data file Keyword Arguments required : bool . Specify &quot;file not found&quot; handling. If true, function prints information message and raises cv::Exception. If false, function returns empty result silentMode : bool . Disables messages Search directories: Directories passed via addSamplesDataSearchPath() OPENCV_SAMPLES_DATA_PATH_HINT environment variable OPENCV_SAMPLES_DATA_PATH environment variable If parameter value is not empty and nothing is found then stop searching. Detects build/install path based on: a. current working directory (CWD) b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage) Scan &lt;source&gt;/{,data,samples/data} directories if build directory is detected or the current directory is in source tree. Scan &lt;install&gt;/share/OpenCV directory if install directory is detected. @see cv::utils::findDataFile @return Returns path (absolute or relative to the current directory) or empty string if file is not found Python prototype (for reference): findFile(relative_path[, required[, silentMode]]) -&gt; retval","ref":"Evision.Samples.html#findFile/2","title":"Evision.Samples.findFile/2","type":"function"},{"doc":"Raising version of findFileOrKeep/1 .","ref":"Evision.Samples.html#findFileOrKeep!/1","title":"Evision.Samples.findFileOrKeep!/1","type":"function"},{"doc":"Raising version of findFileOrKeep/2 .","ref":"Evision.Samples.html#findFileOrKeep!/2","title":"Evision.Samples.findFileOrKeep!/2","type":"function"},{"doc":"Positional Arguments relative_path : String Keyword Arguments silentMode : bool . Python prototype (for reference): findFileOrKeep(relative_path[, silentMode]) -&gt; retval","ref":"Evision.Samples.html#findFileOrKeep/1","title":"Evision.Samples.findFileOrKeep/1","type":"function"},{"doc":"Positional Arguments relative_path : String Keyword Arguments silentMode : bool . Python prototype (for reference): findFileOrKeep(relative_path[, silentMode]) -&gt; retval","ref":"Evision.Samples.html#findFileOrKeep/2","title":"Evision.Samples.findFileOrKeep/2","type":"function"},{"doc":"","ref":"Evision.Segmentation.html","title":"Evision.Segmentation","type":"module"},{"doc":"","ref":"Evision.Segmentation.IntelligentScissorsMB.html","title":"Evision.Segmentation.IntelligentScissorsMB","type":"module"},{"doc":"Raising version of applyImage/2 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#applyImage!/2","title":"Evision.Segmentation.IntelligentScissorsMB.applyImage!/2","type":"function"},{"doc":"Specify input image and extract image features Positional Arguments image : Evision.Mat . input image. Type is #CV_8UC1 / #CV_8UC3 Python prototype (for reference): applyImage(image) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#applyImage/2","title":"Evision.Segmentation.IntelligentScissorsMB.applyImage/2","type":"function"},{"doc":"Raising version of applyImageFeatures/4 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#applyImageFeatures!/4","title":"Evision.Segmentation.IntelligentScissorsMB.applyImageFeatures!/4","type":"function"},{"doc":"Raising version of applyImageFeatures/5 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#applyImageFeatures!/5","title":"Evision.Segmentation.IntelligentScissorsMB.applyImageFeatures!/5","type":"function"},{"doc":"Specify custom features of input image Positional Arguments non_edge : Evision.Mat . Specify cost of non-edge pixels. Type is CV_8UC1. Expected values are {0, 1} . gradient_direction : Evision.Mat . Specify gradient direction feature. Type is CV_32FC2. Values are expected to be normalized: x^2 + y^2 == 1 gradient_magnitude : Evision.Mat . Specify cost of gradient magnitude function: Type is CV_32FC1. Values should be in range [0, 1] . Keyword Arguments image : Evision.Mat . Optional parameter . Must be specified if subset of features is specified (non-specified features are calculated internally) Customized advanced variant of applyImage() call. Python prototype (for reference): applyImageFeatures(non_edge, gradient_direction, gradient_magnitude[, image]) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#applyImageFeatures/4","title":"Evision.Segmentation.IntelligentScissorsMB.applyImageFeatures/4","type":"function"},{"doc":"Specify custom features of input image Positional Arguments non_edge : Evision.Mat . Specify cost of non-edge pixels. Type is CV_8UC1. Expected values are {0, 1} . gradient_direction : Evision.Mat . Specify gradient direction feature. Type is CV_32FC2. Values are expected to be normalized: x^2 + y^2 == 1 gradient_magnitude : Evision.Mat . Specify cost of gradient magnitude function: Type is CV_32FC1. Values should be in range [0, 1] . Keyword Arguments image : Evision.Mat . Optional parameter . Must be specified if subset of features is specified (non-specified features are calculated internally) Customized advanced variant of applyImage() call. Python prototype (for reference): applyImageFeatures(non_edge, gradient_direction, gradient_magnitude[, image]) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#applyImageFeatures/5","title":"Evision.Segmentation.IntelligentScissorsMB.applyImageFeatures/5","type":"function"},{"doc":"Raising version of buildMap/2 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#buildMap!/2","title":"Evision.Segmentation.IntelligentScissorsMB.buildMap!/2","type":"function"},{"doc":"Prepares a map of optimal paths for the given source point on the image Positional Arguments sourcePt : Point . The source point used to find the paths Note : applyImage() / applyImageFeatures() must be called before this call Python prototype (for reference): buildMap(sourcePt) -&gt; None","ref":"Evision.Segmentation.IntelligentScissorsMB.html#buildMap/2","title":"Evision.Segmentation.IntelligentScissorsMB.buildMap/2","type":"function"},{"doc":"Raising version of getContour/2 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#getContour!/2","title":"Evision.Segmentation.IntelligentScissorsMB.getContour!/2","type":"function"},{"doc":"Raising version of getContour/3 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#getContour!/3","title":"Evision.Segmentation.IntelligentScissorsMB.getContour!/3","type":"function"},{"doc":"Extracts optimal contour for the given target point on the image Positional Arguments targetPt : Point . The target point Keyword Arguments backward : bool . Flag to indicate reverse order of retrived pixels (use &quot;true&quot; value to fetch points from the target to the source point) Return contour : Evision.Mat . The list of pixels which contains optimal path between the source and the target points of the image. Type is CV_32SC2 (compatible with std::vector&lt;Point&gt; ) Note : buildMap() must be called before this call Python prototype (for reference): getContour(targetPt[, contour[, backward]]) -&gt; contour","ref":"Evision.Segmentation.IntelligentScissorsMB.html#getContour/2","title":"Evision.Segmentation.IntelligentScissorsMB.getContour/2","type":"function"},{"doc":"Extracts optimal contour for the given target point on the image Positional Arguments targetPt : Point . The target point Keyword Arguments backward : bool . Flag to indicate reverse order of retrived pixels (use &quot;true&quot; value to fetch points from the target to the source point) Return contour : Evision.Mat . The list of pixels which contains optimal path between the source and the target points of the image. Type is CV_32SC2 (compatible with std::vector&lt;Point&gt; ) Note : buildMap() must be called before this call Python prototype (for reference): getContour(targetPt[, contour[, backward]]) -&gt; contour","ref":"Evision.Segmentation.IntelligentScissorsMB.html#getContour/3","title":"Evision.Segmentation.IntelligentScissorsMB.getContour/3","type":"function"},{"doc":"Raising version of segmentation_IntelligentScissorsMB/0 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#segmentation_IntelligentScissorsMB!/0","title":"Evision.Segmentation.IntelligentScissorsMB.segmentation_IntelligentScissorsMB!/0","type":"function"},{"doc":"Python prototype (for reference): IntelligentScissorsMB() -&gt; &lt;segmentation_IntelligentScissorsMB object&gt;","ref":"Evision.Segmentation.IntelligentScissorsMB.html#segmentation_IntelligentScissorsMB/0","title":"Evision.Segmentation.IntelligentScissorsMB.segmentation_IntelligentScissorsMB/0","type":"function"},{"doc":"Raising version of setEdgeFeatureCannyParameters/3 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setEdgeFeatureCannyParameters!/3","title":"Evision.Segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters!/3","type":"function"},{"doc":"Raising version of setEdgeFeatureCannyParameters/4 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setEdgeFeatureCannyParameters!/4","title":"Evision.Segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters!/4","type":"function"},{"doc":"Switch edge feature extractor to use Canny edge detector Positional Arguments threshold1 : double threshold2 : double Keyword Arguments apertureSize : int . l2gradient : bool . Note : &quot;Laplacian Zero-Crossing&quot; feature extractor is used by default (following to original article) @sa Canny Python prototype (for reference): setEdgeFeatureCannyParameters(threshold1, threshold2[, apertureSize[, L2gradient]]) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setEdgeFeatureCannyParameters/3","title":"Evision.Segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters/3","type":"function"},{"doc":"Switch edge feature extractor to use Canny edge detector Positional Arguments threshold1 : double threshold2 : double Keyword Arguments apertureSize : int . l2gradient : bool . Note : &quot;Laplacian Zero-Crossing&quot; feature extractor is used by default (following to original article) @sa Canny Python prototype (for reference): setEdgeFeatureCannyParameters(threshold1, threshold2[, apertureSize[, L2gradient]]) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setEdgeFeatureCannyParameters/4","title":"Evision.Segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters/4","type":"function"},{"doc":"Raising version of setEdgeFeatureZeroCrossingParameters/1 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setEdgeFeatureZeroCrossingParameters!/1","title":"Evision.Segmentation.IntelligentScissorsMB.setEdgeFeatureZeroCrossingParameters!/1","type":"function"},{"doc":"Switch to &quot;Laplacian Zero-Crossing&quot; edge feature extractor and specify its parameters Keyword Arguments gradient_magnitude_min_value : float . Minimal gradient magnitude value for edge pixels (default: 0, check is disabled) This feature extractor is used by default according to article. Implementation has additional filtering for regions with low-amplitude noise. This filtering is enabled through parameter of minimal gradient amplitude (use some small value 4, 8, 16). Note : Current implementation of this feature extractor is based on processing of grayscale images (color image is converted to grayscale image first). Note : Canny edge detector is a bit slower, but provides better results (especially on color images): use setEdgeFeatureCannyParameters(). Python prototype (for reference): setEdgeFeatureZeroCrossingParameters([, gradient_magnitude_min_value]) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setEdgeFeatureZeroCrossingParameters/1","title":"Evision.Segmentation.IntelligentScissorsMB.setEdgeFeatureZeroCrossingParameters/1","type":"function"},{"doc":"Raising version of setGradientMagnitudeMaxLimit/1 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setGradientMagnitudeMaxLimit!/1","title":"Evision.Segmentation.IntelligentScissorsMB.setGradientMagnitudeMaxLimit!/1","type":"function"},{"doc":"Specify gradient magnitude max value threshold Keyword Arguments gradient_magnitude_threshold_max : float . Specify gradient magnitude max value threshold (default: 0, disabled) Zero limit value is used to disable gradient magnitude thresholding (default behavior, as described in original article). Otherwize pixels with gradient magnitude &gt;= threshold have zero cost. Note : Thresholding should be used for images with irregular regions (to avoid stuck on parameters from high-contract areas, like embedded logos). Python prototype (for reference): setGradientMagnitudeMaxLimit([, gradient_magnitude_threshold_max]) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setGradientMagnitudeMaxLimit/1","title":"Evision.Segmentation.IntelligentScissorsMB.setGradientMagnitudeMaxLimit/1","type":"function"},{"doc":"Raising version of setWeights/4 .","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setWeights!/4","title":"Evision.Segmentation.IntelligentScissorsMB.setWeights!/4","type":"function"},{"doc":"Specify weights of feature functions Positional Arguments weight_non_edge : float . Specify cost of non-edge pixels (default: 0.43f) weight_gradient_direction : float . Specify cost of gradient direction function (default: 0.43f) weight_gradient_magnitude : float . Specify cost of gradient magnitude function (default: 0.14f) Consider keeping weights normalized (sum of weights equals to 1.0) Discrete dynamic programming (DP) goal is minimization of costs between pixels. Python prototype (for reference): setWeights(weight_non_edge, weight_gradient_direction, weight_gradient_magnitude) -&gt; retval","ref":"Evision.Segmentation.IntelligentScissorsMB.html#setWeights/4","title":"Evision.Segmentation.IntelligentScissorsMB.setWeights/4","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.html","title":"Evision.SimpleBlobDetector","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.SimpleBlobDetector.html#compute!/3","title":"Evision.SimpleBlobDetector.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.SimpleBlobDetector.html#compute!/4","title":"Evision.SimpleBlobDetector.compute!/4","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.SimpleBlobDetector.html#compute/3","title":"Evision.SimpleBlobDetector.compute/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Return keypoints : [vector_KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : [Evision.Mat] . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Has overloading in C++ Python prototype (for reference): compute(images, keypoints[, descriptors]) -&gt; keypoints, descriptors Variant 2: Computes the descriptors for a set of keypoints detected in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Return keypoints : [KeyPoint] . Input collection of keypoints. Keypoints for which a descriptor cannot be computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint with several dominant orientations (for each orientation). descriptors : Evision.Mat . Computed descriptors. In the second variant of the method descriptors[i] are descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the descriptor for keypoint j-th keypoint. Python prototype (for reference): compute(image, keypoints[, descriptors]) -&gt; keypoints, descriptors","ref":"Evision.SimpleBlobDetector.html#compute/4","title":"Evision.SimpleBlobDetector.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.SimpleBlobDetector.html#create!/0","title":"Evision.SimpleBlobDetector.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.SimpleBlobDetector.html#create!/1","title":"Evision.SimpleBlobDetector.create!/1","type":"function"},{"doc":"##### Keyword Arguments parameters : SimpleBlobDetector_Params . Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.SimpleBlobDetector.html#create/0","title":"Evision.SimpleBlobDetector.create/0","type":"function"},{"doc":"##### Keyword Arguments parameters : SimpleBlobDetector_Params . Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.SimpleBlobDetector.html#create/1","title":"Evision.SimpleBlobDetector.create/1","type":"function"},{"doc":"Raising version of defaultNorm/1 .","ref":"Evision.SimpleBlobDetector.html#defaultNorm!/1","title":"Evision.SimpleBlobDetector.defaultNorm!/1","type":"function"},{"doc":"Python prototype (for reference): defaultNorm() -&gt; retval","ref":"Evision.SimpleBlobDetector.html#defaultNorm/1","title":"Evision.SimpleBlobDetector.defaultNorm/1","type":"function"},{"doc":"Raising version of descriptorSize/1 .","ref":"Evision.SimpleBlobDetector.html#descriptorSize!/1","title":"Evision.SimpleBlobDetector.descriptorSize!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorSize() -&gt; retval","ref":"Evision.SimpleBlobDetector.html#descriptorSize/1","title":"Evision.SimpleBlobDetector.descriptorSize/1","type":"function"},{"doc":"Raising version of descriptorType/1 .","ref":"Evision.SimpleBlobDetector.html#descriptorType!/1","title":"Evision.SimpleBlobDetector.descriptorType!/1","type":"function"},{"doc":"Python prototype (for reference): descriptorType() -&gt; retval","ref":"Evision.SimpleBlobDetector.html#descriptorType/1","title":"Evision.SimpleBlobDetector.descriptorType/1","type":"function"},{"doc":"Raising version of detect/2 .","ref":"Evision.SimpleBlobDetector.html#detect!/2","title":"Evision.SimpleBlobDetector.detect!/2","type":"function"},{"doc":"Raising version of detect/3 .","ref":"Evision.SimpleBlobDetector.html#detect!/3","title":"Evision.SimpleBlobDetector.detect!/3","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.SimpleBlobDetector.html#detect/2","title":"Evision.SimpleBlobDetector.detect/2","type":"function"},{"doc":"Variant 1: Positional Arguments images : [Evision.Mat] . Image set. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). masks[i] is a mask for images[i]. Return keypoints : [vector_KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Has overloading in C++ Python prototype (for reference): detect(images[, masks]) -&gt; keypoints Variant 2: Detects keypoints in an image (first variant) or image set (second variant). Positional Arguments image : Evision.Mat . Image. Keyword Arguments mask : Evision.Mat . Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest. Return keypoints : [KeyPoint] . The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] . Python prototype (for reference): detect(image[, mask]) -&gt; keypoints","ref":"Evision.SimpleBlobDetector.html#detect/3","title":"Evision.SimpleBlobDetector.detect/3","type":"function"},{"doc":"Raising version of detectAndCompute/3 .","ref":"Evision.SimpleBlobDetector.html#detectAndCompute!/3","title":"Evision.SimpleBlobDetector.detectAndCompute!/3","type":"function"},{"doc":"Raising version of detectAndCompute/4 .","ref":"Evision.SimpleBlobDetector.html#detectAndCompute!/4","title":"Evision.SimpleBlobDetector.detectAndCompute!/4","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.SimpleBlobDetector.html#detectAndCompute/3","title":"Evision.SimpleBlobDetector.detectAndCompute/3","type":"function"},{"doc":"Positional Arguments image : Evision.Mat mask : Evision.Mat Keyword Arguments useProvidedKeypoints : bool . Return keypoints : [KeyPoint] descriptors : Evision.Mat . Detects keypoints and computes the descriptors Python prototype (for reference): detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -&gt; keypoints, descriptors","ref":"Evision.SimpleBlobDetector.html#detectAndCompute/4","title":"Evision.SimpleBlobDetector.detectAndCompute/4","type":"function"},{"doc":"Raising version of empty/1 .","ref":"Evision.SimpleBlobDetector.html#empty!/1","title":"Evision.SimpleBlobDetector.empty!/1","type":"function"},{"doc":"Python prototype (for reference): empty() -&gt; retval","ref":"Evision.SimpleBlobDetector.html#empty/1","title":"Evision.SimpleBlobDetector.empty/1","type":"function"},{"doc":"Raising version of getDefaultName/1 .","ref":"Evision.SimpleBlobDetector.html#getDefaultName!/1","title":"Evision.SimpleBlobDetector.getDefaultName!/1","type":"function"},{"doc":"Python prototype (for reference): getDefaultName() -&gt; retval","ref":"Evision.SimpleBlobDetector.html#getDefaultName/1","title":"Evision.SimpleBlobDetector.getDefaultName/1","type":"function"},{"doc":"Raising version of read/2 .","ref":"Evision.SimpleBlobDetector.html#read!/2","title":"Evision.SimpleBlobDetector.read!/2","type":"function"},{"doc":"Variant 1: Positional Arguments fileName : String Python prototype (for reference): read(fileName) -&gt; None Variant 2: Positional Arguments arg1 : FileNode Python prototype (for reference): read(arg1) -&gt; None","ref":"Evision.SimpleBlobDetector.html#read/2","title":"Evision.SimpleBlobDetector.read/2","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.SimpleBlobDetector.html#write!/2","title":"Evision.SimpleBlobDetector.write!/2","type":"function"},{"doc":"Raising version of write/3 .","ref":"Evision.SimpleBlobDetector.html#write!/3","title":"Evision.SimpleBlobDetector.write!/3","type":"function"},{"doc":"Variant 1: Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None Variant 2: Positional Arguments fileName : String Python prototype (for reference): write(fileName) -&gt; None","ref":"Evision.SimpleBlobDetector.html#write/2","title":"Evision.SimpleBlobDetector.write/2","type":"function"},{"doc":"Positional Arguments fs : Ptr&lt;FileStorage&gt; Keyword Arguments name : String . Python prototype (for reference): write(fs[, name]) -&gt; None","ref":"Evision.SimpleBlobDetector.html#write/3","title":"Evision.SimpleBlobDetector.write/3","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html","title":"Evision.SimpleBlobDetector.Params","type":"module"},{"doc":"Raising version of get_blobColor/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_blobColor!/1","title":"Evision.SimpleBlobDetector.Params.get_blobColor!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_blobColor/1","title":"Evision.SimpleBlobDetector.Params.get_blobColor/1","type":"function"},{"doc":"Raising version of get_filterByArea/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByArea!/1","title":"Evision.SimpleBlobDetector.Params.get_filterByArea!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByArea/1","title":"Evision.SimpleBlobDetector.Params.get_filterByArea/1","type":"function"},{"doc":"Raising version of get_filterByCircularity/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByCircularity!/1","title":"Evision.SimpleBlobDetector.Params.get_filterByCircularity!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByCircularity/1","title":"Evision.SimpleBlobDetector.Params.get_filterByCircularity/1","type":"function"},{"doc":"Raising version of get_filterByColor/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByColor!/1","title":"Evision.SimpleBlobDetector.Params.get_filterByColor!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByColor/1","title":"Evision.SimpleBlobDetector.Params.get_filterByColor/1","type":"function"},{"doc":"Raising version of get_filterByConvexity/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByConvexity!/1","title":"Evision.SimpleBlobDetector.Params.get_filterByConvexity!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByConvexity/1","title":"Evision.SimpleBlobDetector.Params.get_filterByConvexity/1","type":"function"},{"doc":"Raising version of get_filterByInertia/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByInertia!/1","title":"Evision.SimpleBlobDetector.Params.get_filterByInertia!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_filterByInertia/1","title":"Evision.SimpleBlobDetector.Params.get_filterByInertia/1","type":"function"},{"doc":"Raising version of get_maxArea/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_maxArea!/1","title":"Evision.SimpleBlobDetector.Params.get_maxArea!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_maxArea/1","title":"Evision.SimpleBlobDetector.Params.get_maxArea/1","type":"function"},{"doc":"Raising version of get_maxCircularity/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_maxCircularity!/1","title":"Evision.SimpleBlobDetector.Params.get_maxCircularity!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_maxCircularity/1","title":"Evision.SimpleBlobDetector.Params.get_maxCircularity/1","type":"function"},{"doc":"Raising version of get_maxConvexity/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_maxConvexity!/1","title":"Evision.SimpleBlobDetector.Params.get_maxConvexity!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_maxConvexity/1","title":"Evision.SimpleBlobDetector.Params.get_maxConvexity/1","type":"function"},{"doc":"Raising version of get_maxInertiaRatio/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_maxInertiaRatio!/1","title":"Evision.SimpleBlobDetector.Params.get_maxInertiaRatio!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_maxInertiaRatio/1","title":"Evision.SimpleBlobDetector.Params.get_maxInertiaRatio/1","type":"function"},{"doc":"Raising version of get_maxThreshold/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_maxThreshold!/1","title":"Evision.SimpleBlobDetector.Params.get_maxThreshold!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_maxThreshold/1","title":"Evision.SimpleBlobDetector.Params.get_maxThreshold/1","type":"function"},{"doc":"Raising version of get_minArea/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_minArea!/1","title":"Evision.SimpleBlobDetector.Params.get_minArea!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_minArea/1","title":"Evision.SimpleBlobDetector.Params.get_minArea/1","type":"function"},{"doc":"Raising version of get_minCircularity/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_minCircularity!/1","title":"Evision.SimpleBlobDetector.Params.get_minCircularity!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_minCircularity/1","title":"Evision.SimpleBlobDetector.Params.get_minCircularity/1","type":"function"},{"doc":"Raising version of get_minConvexity/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_minConvexity!/1","title":"Evision.SimpleBlobDetector.Params.get_minConvexity!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_minConvexity/1","title":"Evision.SimpleBlobDetector.Params.get_minConvexity/1","type":"function"},{"doc":"Raising version of get_minDistBetweenBlobs/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_minDistBetweenBlobs!/1","title":"Evision.SimpleBlobDetector.Params.get_minDistBetweenBlobs!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_minDistBetweenBlobs/1","title":"Evision.SimpleBlobDetector.Params.get_minDistBetweenBlobs/1","type":"function"},{"doc":"Raising version of get_minInertiaRatio/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_minInertiaRatio!/1","title":"Evision.SimpleBlobDetector.Params.get_minInertiaRatio!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_minInertiaRatio/1","title":"Evision.SimpleBlobDetector.Params.get_minInertiaRatio/1","type":"function"},{"doc":"Raising version of get_minRepeatability/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_minRepeatability!/1","title":"Evision.SimpleBlobDetector.Params.get_minRepeatability!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_minRepeatability/1","title":"Evision.SimpleBlobDetector.Params.get_minRepeatability/1","type":"function"},{"doc":"Raising version of get_minThreshold/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_minThreshold!/1","title":"Evision.SimpleBlobDetector.Params.get_minThreshold!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_minThreshold/1","title":"Evision.SimpleBlobDetector.Params.get_minThreshold/1","type":"function"},{"doc":"Raising version of get_thresholdStep/1 .","ref":"Evision.SimpleBlobDetector.Params.html#get_thresholdStep!/1","title":"Evision.SimpleBlobDetector.Params.get_thresholdStep!/1","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#get_thresholdStep/1","title":"Evision.SimpleBlobDetector.Params.get_thresholdStep/1","type":"function"},{"doc":"Raising version of set_blobColor/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_blobColor!/2","title":"Evision.SimpleBlobDetector.Params.set_blobColor!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_blobColor/2","title":"Evision.SimpleBlobDetector.Params.set_blobColor/2","type":"function"},{"doc":"Raising version of set_filterByArea/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByArea!/2","title":"Evision.SimpleBlobDetector.Params.set_filterByArea!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByArea/2","title":"Evision.SimpleBlobDetector.Params.set_filterByArea/2","type":"function"},{"doc":"Raising version of set_filterByCircularity/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByCircularity!/2","title":"Evision.SimpleBlobDetector.Params.set_filterByCircularity!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByCircularity/2","title":"Evision.SimpleBlobDetector.Params.set_filterByCircularity/2","type":"function"},{"doc":"Raising version of set_filterByColor/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByColor!/2","title":"Evision.SimpleBlobDetector.Params.set_filterByColor!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByColor/2","title":"Evision.SimpleBlobDetector.Params.set_filterByColor/2","type":"function"},{"doc":"Raising version of set_filterByConvexity/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByConvexity!/2","title":"Evision.SimpleBlobDetector.Params.set_filterByConvexity!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByConvexity/2","title":"Evision.SimpleBlobDetector.Params.set_filterByConvexity/2","type":"function"},{"doc":"Raising version of set_filterByInertia/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByInertia!/2","title":"Evision.SimpleBlobDetector.Params.set_filterByInertia!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_filterByInertia/2","title":"Evision.SimpleBlobDetector.Params.set_filterByInertia/2","type":"function"},{"doc":"Raising version of set_maxArea/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_maxArea!/2","title":"Evision.SimpleBlobDetector.Params.set_maxArea!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_maxArea/2","title":"Evision.SimpleBlobDetector.Params.set_maxArea/2","type":"function"},{"doc":"Raising version of set_maxCircularity/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_maxCircularity!/2","title":"Evision.SimpleBlobDetector.Params.set_maxCircularity!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_maxCircularity/2","title":"Evision.SimpleBlobDetector.Params.set_maxCircularity/2","type":"function"},{"doc":"Raising version of set_maxConvexity/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_maxConvexity!/2","title":"Evision.SimpleBlobDetector.Params.set_maxConvexity!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_maxConvexity/2","title":"Evision.SimpleBlobDetector.Params.set_maxConvexity/2","type":"function"},{"doc":"Raising version of set_maxInertiaRatio/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_maxInertiaRatio!/2","title":"Evision.SimpleBlobDetector.Params.set_maxInertiaRatio!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_maxInertiaRatio/2","title":"Evision.SimpleBlobDetector.Params.set_maxInertiaRatio/2","type":"function"},{"doc":"Raising version of set_maxThreshold/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_maxThreshold!/2","title":"Evision.SimpleBlobDetector.Params.set_maxThreshold!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_maxThreshold/2","title":"Evision.SimpleBlobDetector.Params.set_maxThreshold/2","type":"function"},{"doc":"Raising version of set_minArea/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_minArea!/2","title":"Evision.SimpleBlobDetector.Params.set_minArea!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_minArea/2","title":"Evision.SimpleBlobDetector.Params.set_minArea/2","type":"function"},{"doc":"Raising version of set_minCircularity/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_minCircularity!/2","title":"Evision.SimpleBlobDetector.Params.set_minCircularity!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_minCircularity/2","title":"Evision.SimpleBlobDetector.Params.set_minCircularity/2","type":"function"},{"doc":"Raising version of set_minConvexity/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_minConvexity!/2","title":"Evision.SimpleBlobDetector.Params.set_minConvexity!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_minConvexity/2","title":"Evision.SimpleBlobDetector.Params.set_minConvexity/2","type":"function"},{"doc":"Raising version of set_minDistBetweenBlobs/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_minDistBetweenBlobs!/2","title":"Evision.SimpleBlobDetector.Params.set_minDistBetweenBlobs!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_minDistBetweenBlobs/2","title":"Evision.SimpleBlobDetector.Params.set_minDistBetweenBlobs/2","type":"function"},{"doc":"Raising version of set_minInertiaRatio/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_minInertiaRatio!/2","title":"Evision.SimpleBlobDetector.Params.set_minInertiaRatio!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_minInertiaRatio/2","title":"Evision.SimpleBlobDetector.Params.set_minInertiaRatio/2","type":"function"},{"doc":"Raising version of set_minRepeatability/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_minRepeatability!/2","title":"Evision.SimpleBlobDetector.Params.set_minRepeatability!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_minRepeatability/2","title":"Evision.SimpleBlobDetector.Params.set_minRepeatability/2","type":"function"},{"doc":"Raising version of set_minThreshold/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_minThreshold!/2","title":"Evision.SimpleBlobDetector.Params.set_minThreshold!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_minThreshold/2","title":"Evision.SimpleBlobDetector.Params.set_minThreshold/2","type":"function"},{"doc":"Raising version of set_thresholdStep/2 .","ref":"Evision.SimpleBlobDetector.Params.html#set_thresholdStep!/2","title":"Evision.SimpleBlobDetector.Params.set_thresholdStep!/2","type":"function"},{"doc":"","ref":"Evision.SimpleBlobDetector.Params.html#set_thresholdStep/2","title":"Evision.SimpleBlobDetector.Params.set_thresholdStep/2","type":"function"},{"doc":"Raising version of simpleBlobDetector_Params/0 .","ref":"Evision.SimpleBlobDetector.Params.html#simpleBlobDetector_Params!/0","title":"Evision.SimpleBlobDetector.Params.simpleBlobDetector_Params!/0","type":"function"},{"doc":"Python prototype (for reference): SimpleBlobDetector_Params() -&gt; &lt;SimpleBlobDetector_Params object&gt;","ref":"Evision.SimpleBlobDetector.Params.html#simpleBlobDetector_Params/0","title":"Evision.SimpleBlobDetector.Params.simpleBlobDetector_Params/0","type":"function"},{"doc":"","ref":"Evision.SparseOpticalFlow.html","title":"Evision.SparseOpticalFlow","type":"module"},{"doc":"Raising version of calc/5 .","ref":"Evision.SparseOpticalFlow.html#calc!/5","title":"Evision.SparseOpticalFlow.calc!/5","type":"function"},{"doc":"Raising version of calc/6 .","ref":"Evision.SparseOpticalFlow.html#calc!/6","title":"Evision.SparseOpticalFlow.calc!/6","type":"function"},{"doc":"Calculates a sparse optical flow. Positional Arguments prevImg : Evision.Mat . First input image. nextImg : Evision.Mat . Second input image of the same size and the same type as prevImg. prevPts : Evision.Mat . Vector of 2D points for which the flow needs to be found. Return nextPts : Evision.Mat . Output vector of 2D points containing the calculated new positions of input features in the second image. status : Evision.Mat . Output status vector. Each element of the vector is set to 1 if the flow for the corresponding features has been found. Otherwise, it is set to 0. err : Evision.Mat . Optional output vector that contains error response for each point (inverse confidence). Python prototype (for reference): calc(prevImg, nextImg, prevPts, nextPts[, status[, err]]) -&gt; nextPts, status, err","ref":"Evision.SparseOpticalFlow.html#calc/5","title":"Evision.SparseOpticalFlow.calc/5","type":"function"},{"doc":"Calculates a sparse optical flow. Positional Arguments prevImg : Evision.Mat . First input image. nextImg : Evision.Mat . Second input image of the same size and the same type as prevImg. prevPts : Evision.Mat . Vector of 2D points for which the flow needs to be found. Return nextPts : Evision.Mat . Output vector of 2D points containing the calculated new positions of input features in the second image. status : Evision.Mat . Output status vector. Each element of the vector is set to 1 if the flow for the corresponding features has been found. Otherwise, it is set to 0. err : Evision.Mat . Optional output vector that contains error response for each point (inverse confidence). Python prototype (for reference): calc(prevImg, nextImg, prevPts, nextPts[, status[, err]]) -&gt; nextPts, status, err","ref":"Evision.SparseOpticalFlow.html#calc/6","title":"Evision.SparseOpticalFlow.calc/6","type":"function"},{"doc":"","ref":"Evision.SparsePyrLKOpticalFlow.html","title":"Evision.SparsePyrLKOpticalFlow","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.SparsePyrLKOpticalFlow.html#create!/0","title":"Evision.SparsePyrLKOpticalFlow.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.SparsePyrLKOpticalFlow.html#create!/1","title":"Evision.SparsePyrLKOpticalFlow.create!/1","type":"function"},{"doc":"##### Keyword Arguments winSize : Size . maxLevel : int . crit : TermCriteria . flags : int . minEigThreshold : double . Python prototype (for reference): create([, winSize[, maxLevel[, crit[, flags[, minEigThreshold]]]]]) -&gt; retval","ref":"Evision.SparsePyrLKOpticalFlow.html#create/0","title":"Evision.SparsePyrLKOpticalFlow.create/0","type":"function"},{"doc":"##### Keyword Arguments winSize : Size . maxLevel : int . crit : TermCriteria . flags : int . minEigThreshold : double . Python prototype (for reference): create([, winSize[, maxLevel[, crit[, flags[, minEigThreshold]]]]]) -&gt; retval","ref":"Evision.SparsePyrLKOpticalFlow.html#create/1","title":"Evision.SparsePyrLKOpticalFlow.create/1","type":"function"},{"doc":"Raising version of getFlags/1 .","ref":"Evision.SparsePyrLKOpticalFlow.html#getFlags!/1","title":"Evision.SparsePyrLKOpticalFlow.getFlags!/1","type":"function"},{"doc":"Python prototype (for reference): getFlags() -&gt; retval","ref":"Evision.SparsePyrLKOpticalFlow.html#getFlags/1","title":"Evision.SparsePyrLKOpticalFlow.getFlags/1","type":"function"},{"doc":"Raising version of getMaxLevel/1 .","ref":"Evision.SparsePyrLKOpticalFlow.html#getMaxLevel!/1","title":"Evision.SparsePyrLKOpticalFlow.getMaxLevel!/1","type":"function"},{"doc":"Python prototype (for reference): getMaxLevel() -&gt; retval","ref":"Evision.SparsePyrLKOpticalFlow.html#getMaxLevel/1","title":"Evision.SparsePyrLKOpticalFlow.getMaxLevel/1","type":"function"},{"doc":"Raising version of getMinEigThreshold/1 .","ref":"Evision.SparsePyrLKOpticalFlow.html#getMinEigThreshold!/1","title":"Evision.SparsePyrLKOpticalFlow.getMinEigThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getMinEigThreshold() -&gt; retval","ref":"Evision.SparsePyrLKOpticalFlow.html#getMinEigThreshold/1","title":"Evision.SparsePyrLKOpticalFlow.getMinEigThreshold/1","type":"function"},{"doc":"Raising version of getTermCriteria/1 .","ref":"Evision.SparsePyrLKOpticalFlow.html#getTermCriteria!/1","title":"Evision.SparsePyrLKOpticalFlow.getTermCriteria!/1","type":"function"},{"doc":"Python prototype (for reference): getTermCriteria() -&gt; retval","ref":"Evision.SparsePyrLKOpticalFlow.html#getTermCriteria/1","title":"Evision.SparsePyrLKOpticalFlow.getTermCriteria/1","type":"function"},{"doc":"Raising version of getWinSize/1 .","ref":"Evision.SparsePyrLKOpticalFlow.html#getWinSize!/1","title":"Evision.SparsePyrLKOpticalFlow.getWinSize!/1","type":"function"},{"doc":"Python prototype (for reference): getWinSize() -&gt; retval","ref":"Evision.SparsePyrLKOpticalFlow.html#getWinSize/1","title":"Evision.SparsePyrLKOpticalFlow.getWinSize/1","type":"function"},{"doc":"Raising version of setFlags/2 .","ref":"Evision.SparsePyrLKOpticalFlow.html#setFlags!/2","title":"Evision.SparsePyrLKOpticalFlow.setFlags!/2","type":"function"},{"doc":"Positional Arguments flags : int Python prototype (for reference): setFlags(flags) -&gt; None","ref":"Evision.SparsePyrLKOpticalFlow.html#setFlags/2","title":"Evision.SparsePyrLKOpticalFlow.setFlags/2","type":"function"},{"doc":"Raising version of setMaxLevel/2 .","ref":"Evision.SparsePyrLKOpticalFlow.html#setMaxLevel!/2","title":"Evision.SparsePyrLKOpticalFlow.setMaxLevel!/2","type":"function"},{"doc":"Positional Arguments maxLevel : int Python prototype (for reference): setMaxLevel(maxLevel) -&gt; None","ref":"Evision.SparsePyrLKOpticalFlow.html#setMaxLevel/2","title":"Evision.SparsePyrLKOpticalFlow.setMaxLevel/2","type":"function"},{"doc":"Raising version of setMinEigThreshold/2 .","ref":"Evision.SparsePyrLKOpticalFlow.html#setMinEigThreshold!/2","title":"Evision.SparsePyrLKOpticalFlow.setMinEigThreshold!/2","type":"function"},{"doc":"Positional Arguments minEigThreshold : double Python prototype (for reference): setMinEigThreshold(minEigThreshold) -&gt; None","ref":"Evision.SparsePyrLKOpticalFlow.html#setMinEigThreshold/2","title":"Evision.SparsePyrLKOpticalFlow.setMinEigThreshold/2","type":"function"},{"doc":"Raising version of setTermCriteria/2 .","ref":"Evision.SparsePyrLKOpticalFlow.html#setTermCriteria!/2","title":"Evision.SparsePyrLKOpticalFlow.setTermCriteria!/2","type":"function"},{"doc":"Positional Arguments crit : TermCriteria Python prototype (for reference): setTermCriteria(crit) -&gt; None","ref":"Evision.SparsePyrLKOpticalFlow.html#setTermCriteria/2","title":"Evision.SparsePyrLKOpticalFlow.setTermCriteria/2","type":"function"},{"doc":"Raising version of setWinSize/2 .","ref":"Evision.SparsePyrLKOpticalFlow.html#setWinSize!/2","title":"Evision.SparsePyrLKOpticalFlow.setWinSize!/2","type":"function"},{"doc":"Positional Arguments winSize : Size Python prototype (for reference): setWinSize(winSize) -&gt; None","ref":"Evision.SparsePyrLKOpticalFlow.html#setWinSize/2","title":"Evision.SparsePyrLKOpticalFlow.setWinSize/2","type":"function"},{"doc":"","ref":"Evision.StereoBM.html","title":"Evision.StereoBM","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.StereoBM.html#compute!/3","title":"Evision.StereoBM.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.StereoBM.html#compute!/4","title":"Evision.StereoBM.compute!/4","type":"function"},{"doc":"Computes disparity map for the specified stereo pair Positional Arguments left : Evision.Mat . Left 8-bit single-channel image. right : Evision.Mat . Right image of the same size and the same type as the left one. Return disparity : Evision.Mat . Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map. Python prototype (for reference): compute(left, right[, disparity]) -&gt; disparity","ref":"Evision.StereoBM.html#compute/3","title":"Evision.StereoBM.compute/3","type":"function"},{"doc":"Computes disparity map for the specified stereo pair Positional Arguments left : Evision.Mat . Left 8-bit single-channel image. right : Evision.Mat . Right image of the same size and the same type as the left one. Return disparity : Evision.Mat . Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map. Python prototype (for reference): compute(left, right[, disparity]) -&gt; disparity","ref":"Evision.StereoBM.html#compute/4","title":"Evision.StereoBM.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.StereoBM.html#create!/0","title":"Evision.StereoBM.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.StereoBM.html#create!/1","title":"Evision.StereoBM.create!/1","type":"function"},{"doc":"Creates StereoBM object Keyword Arguments numDisparities : int . the disparity search range. For each pixel algorithm will find the best disparity from 0 (default minimum disparity) to numDisparities. The search range can then be shifted by changing the minimum disparity. blockSize : int . the linear size of the blocks compared by the algorithm. The size should be odd (as the block is centered at the current pixel). Larger block size implies smoother, though less accurate disparity map. Smaller block size gives more detailed disparity map, but there is higher chance for algorithm to find a wrong correspondence. The function create StereoBM object. You can then call StereoBM::compute() to compute disparity for a specific stereo pair. Python prototype (for reference): create([, numDisparities[, blockSize]]) -&gt; retval","ref":"Evision.StereoBM.html#create/0","title":"Evision.StereoBM.create/0","type":"function"},{"doc":"Creates StereoBM object Keyword Arguments numDisparities : int . the disparity search range. For each pixel algorithm will find the best disparity from 0 (default minimum disparity) to numDisparities. The search range can then be shifted by changing the minimum disparity. blockSize : int . the linear size of the blocks compared by the algorithm. The size should be odd (as the block is centered at the current pixel). Larger block size implies smoother, though less accurate disparity map. Smaller block size gives more detailed disparity map, but there is higher chance for algorithm to find a wrong correspondence. The function create StereoBM object. You can then call StereoBM::compute() to compute disparity for a specific stereo pair. Python prototype (for reference): create([, numDisparities[, blockSize]]) -&gt; retval","ref":"Evision.StereoBM.html#create/1","title":"Evision.StereoBM.create/1","type":"function"},{"doc":"Raising version of getBlockSize/1 .","ref":"Evision.StereoBM.html#getBlockSize!/1","title":"Evision.StereoBM.getBlockSize!/1","type":"function"},{"doc":"Python prototype (for reference): getBlockSize() -&gt; retval","ref":"Evision.StereoBM.html#getBlockSize/1","title":"Evision.StereoBM.getBlockSize/1","type":"function"},{"doc":"Raising version of getDisp12MaxDiff/1 .","ref":"Evision.StereoBM.html#getDisp12MaxDiff!/1","title":"Evision.StereoBM.getDisp12MaxDiff!/1","type":"function"},{"doc":"Python prototype (for reference): getDisp12MaxDiff() -&gt; retval","ref":"Evision.StereoBM.html#getDisp12MaxDiff/1","title":"Evision.StereoBM.getDisp12MaxDiff/1","type":"function"},{"doc":"Raising version of getMinDisparity/1 .","ref":"Evision.StereoBM.html#getMinDisparity!/1","title":"Evision.StereoBM.getMinDisparity!/1","type":"function"},{"doc":"Python prototype (for reference): getMinDisparity() -&gt; retval","ref":"Evision.StereoBM.html#getMinDisparity/1","title":"Evision.StereoBM.getMinDisparity/1","type":"function"},{"doc":"Raising version of getNumDisparities/1 .","ref":"Evision.StereoBM.html#getNumDisparities!/1","title":"Evision.StereoBM.getNumDisparities!/1","type":"function"},{"doc":"Python prototype (for reference): getNumDisparities() -&gt; retval","ref":"Evision.StereoBM.html#getNumDisparities/1","title":"Evision.StereoBM.getNumDisparities/1","type":"function"},{"doc":"Raising version of getPreFilterCap/1 .","ref":"Evision.StereoBM.html#getPreFilterCap!/1","title":"Evision.StereoBM.getPreFilterCap!/1","type":"function"},{"doc":"Python prototype (for reference): getPreFilterCap() -&gt; retval","ref":"Evision.StereoBM.html#getPreFilterCap/1","title":"Evision.StereoBM.getPreFilterCap/1","type":"function"},{"doc":"Raising version of getPreFilterSize/1 .","ref":"Evision.StereoBM.html#getPreFilterSize!/1","title":"Evision.StereoBM.getPreFilterSize!/1","type":"function"},{"doc":"Python prototype (for reference): getPreFilterSize() -&gt; retval","ref":"Evision.StereoBM.html#getPreFilterSize/1","title":"Evision.StereoBM.getPreFilterSize/1","type":"function"},{"doc":"Raising version of getPreFilterType/1 .","ref":"Evision.StereoBM.html#getPreFilterType!/1","title":"Evision.StereoBM.getPreFilterType!/1","type":"function"},{"doc":"Python prototype (for reference): getPreFilterType() -&gt; retval","ref":"Evision.StereoBM.html#getPreFilterType/1","title":"Evision.StereoBM.getPreFilterType/1","type":"function"},{"doc":"Raising version of getROI1/1 .","ref":"Evision.StereoBM.html#getROI1!/1","title":"Evision.StereoBM.getROI1!/1","type":"function"},{"doc":"Python prototype (for reference): getROI1() -&gt; retval","ref":"Evision.StereoBM.html#getROI1/1","title":"Evision.StereoBM.getROI1/1","type":"function"},{"doc":"Raising version of getROI2/1 .","ref":"Evision.StereoBM.html#getROI2!/1","title":"Evision.StereoBM.getROI2!/1","type":"function"},{"doc":"Python prototype (for reference): getROI2() -&gt; retval","ref":"Evision.StereoBM.html#getROI2/1","title":"Evision.StereoBM.getROI2/1","type":"function"},{"doc":"Raising version of getSmallerBlockSize/1 .","ref":"Evision.StereoBM.html#getSmallerBlockSize!/1","title":"Evision.StereoBM.getSmallerBlockSize!/1","type":"function"},{"doc":"Python prototype (for reference): getSmallerBlockSize() -&gt; retval","ref":"Evision.StereoBM.html#getSmallerBlockSize/1","title":"Evision.StereoBM.getSmallerBlockSize/1","type":"function"},{"doc":"Raising version of getSpeckleRange/1 .","ref":"Evision.StereoBM.html#getSpeckleRange!/1","title":"Evision.StereoBM.getSpeckleRange!/1","type":"function"},{"doc":"Python prototype (for reference): getSpeckleRange() -&gt; retval","ref":"Evision.StereoBM.html#getSpeckleRange/1","title":"Evision.StereoBM.getSpeckleRange/1","type":"function"},{"doc":"Raising version of getSpeckleWindowSize/1 .","ref":"Evision.StereoBM.html#getSpeckleWindowSize!/1","title":"Evision.StereoBM.getSpeckleWindowSize!/1","type":"function"},{"doc":"Python prototype (for reference): getSpeckleWindowSize() -&gt; retval","ref":"Evision.StereoBM.html#getSpeckleWindowSize/1","title":"Evision.StereoBM.getSpeckleWindowSize/1","type":"function"},{"doc":"Raising version of getTextureThreshold/1 .","ref":"Evision.StereoBM.html#getTextureThreshold!/1","title":"Evision.StereoBM.getTextureThreshold!/1","type":"function"},{"doc":"Python prototype (for reference): getTextureThreshold() -&gt; retval","ref":"Evision.StereoBM.html#getTextureThreshold/1","title":"Evision.StereoBM.getTextureThreshold/1","type":"function"},{"doc":"Raising version of getUniquenessRatio/1 .","ref":"Evision.StereoBM.html#getUniquenessRatio!/1","title":"Evision.StereoBM.getUniquenessRatio!/1","type":"function"},{"doc":"Python prototype (for reference): getUniquenessRatio() -&gt; retval","ref":"Evision.StereoBM.html#getUniquenessRatio/1","title":"Evision.StereoBM.getUniquenessRatio/1","type":"function"},{"doc":"Raising version of setBlockSize/2 .","ref":"Evision.StereoBM.html#setBlockSize!/2","title":"Evision.StereoBM.setBlockSize!/2","type":"function"},{"doc":"Positional Arguments blockSize : int Python prototype (for reference): setBlockSize(blockSize) -&gt; None","ref":"Evision.StereoBM.html#setBlockSize/2","title":"Evision.StereoBM.setBlockSize/2","type":"function"},{"doc":"Raising version of setDisp12MaxDiff/2 .","ref":"Evision.StereoBM.html#setDisp12MaxDiff!/2","title":"Evision.StereoBM.setDisp12MaxDiff!/2","type":"function"},{"doc":"Positional Arguments disp12MaxDiff : int Python prototype (for reference): setDisp12MaxDiff(disp12MaxDiff) -&gt; None","ref":"Evision.StereoBM.html#setDisp12MaxDiff/2","title":"Evision.StereoBM.setDisp12MaxDiff/2","type":"function"},{"doc":"Raising version of setMinDisparity/2 .","ref":"Evision.StereoBM.html#setMinDisparity!/2","title":"Evision.StereoBM.setMinDisparity!/2","type":"function"},{"doc":"Positional Arguments minDisparity : int Python prototype (for reference): setMinDisparity(minDisparity) -&gt; None","ref":"Evision.StereoBM.html#setMinDisparity/2","title":"Evision.StereoBM.setMinDisparity/2","type":"function"},{"doc":"Raising version of setNumDisparities/2 .","ref":"Evision.StereoBM.html#setNumDisparities!/2","title":"Evision.StereoBM.setNumDisparities!/2","type":"function"},{"doc":"Positional Arguments numDisparities : int Python prototype (for reference): setNumDisparities(numDisparities) -&gt; None","ref":"Evision.StereoBM.html#setNumDisparities/2","title":"Evision.StereoBM.setNumDisparities/2","type":"function"},{"doc":"Raising version of setPreFilterCap/2 .","ref":"Evision.StereoBM.html#setPreFilterCap!/2","title":"Evision.StereoBM.setPreFilterCap!/2","type":"function"},{"doc":"Positional Arguments preFilterCap : int Python prototype (for reference): setPreFilterCap(preFilterCap) -&gt; None","ref":"Evision.StereoBM.html#setPreFilterCap/2","title":"Evision.StereoBM.setPreFilterCap/2","type":"function"},{"doc":"Raising version of setPreFilterSize/2 .","ref":"Evision.StereoBM.html#setPreFilterSize!/2","title":"Evision.StereoBM.setPreFilterSize!/2","type":"function"},{"doc":"Positional Arguments preFilterSize : int Python prototype (for reference): setPreFilterSize(preFilterSize) -&gt; None","ref":"Evision.StereoBM.html#setPreFilterSize/2","title":"Evision.StereoBM.setPreFilterSize/2","type":"function"},{"doc":"Raising version of setPreFilterType/2 .","ref":"Evision.StereoBM.html#setPreFilterType!/2","title":"Evision.StereoBM.setPreFilterType!/2","type":"function"},{"doc":"Positional Arguments preFilterType : int Python prototype (for reference): setPreFilterType(preFilterType) -&gt; None","ref":"Evision.StereoBM.html#setPreFilterType/2","title":"Evision.StereoBM.setPreFilterType/2","type":"function"},{"doc":"Raising version of setROI1/2 .","ref":"Evision.StereoBM.html#setROI1!/2","title":"Evision.StereoBM.setROI1!/2","type":"function"},{"doc":"Positional Arguments roi1 : Rect Python prototype (for reference): setROI1(roi1) -&gt; None","ref":"Evision.StereoBM.html#setROI1/2","title":"Evision.StereoBM.setROI1/2","type":"function"},{"doc":"Raising version of setROI2/2 .","ref":"Evision.StereoBM.html#setROI2!/2","title":"Evision.StereoBM.setROI2!/2","type":"function"},{"doc":"Positional Arguments roi2 : Rect Python prototype (for reference): setROI2(roi2) -&gt; None","ref":"Evision.StereoBM.html#setROI2/2","title":"Evision.StereoBM.setROI2/2","type":"function"},{"doc":"Raising version of setSmallerBlockSize/2 .","ref":"Evision.StereoBM.html#setSmallerBlockSize!/2","title":"Evision.StereoBM.setSmallerBlockSize!/2","type":"function"},{"doc":"Positional Arguments blockSize : int Python prototype (for reference): setSmallerBlockSize(blockSize) -&gt; None","ref":"Evision.StereoBM.html#setSmallerBlockSize/2","title":"Evision.StereoBM.setSmallerBlockSize/2","type":"function"},{"doc":"Raising version of setSpeckleRange/2 .","ref":"Evision.StereoBM.html#setSpeckleRange!/2","title":"Evision.StereoBM.setSpeckleRange!/2","type":"function"},{"doc":"Positional Arguments speckleRange : int Python prototype (for reference): setSpeckleRange(speckleRange) -&gt; None","ref":"Evision.StereoBM.html#setSpeckleRange/2","title":"Evision.StereoBM.setSpeckleRange/2","type":"function"},{"doc":"Raising version of setSpeckleWindowSize/2 .","ref":"Evision.StereoBM.html#setSpeckleWindowSize!/2","title":"Evision.StereoBM.setSpeckleWindowSize!/2","type":"function"},{"doc":"Positional Arguments speckleWindowSize : int Python prototype (for reference): setSpeckleWindowSize(speckleWindowSize) -&gt; None","ref":"Evision.StereoBM.html#setSpeckleWindowSize/2","title":"Evision.StereoBM.setSpeckleWindowSize/2","type":"function"},{"doc":"Raising version of setTextureThreshold/2 .","ref":"Evision.StereoBM.html#setTextureThreshold!/2","title":"Evision.StereoBM.setTextureThreshold!/2","type":"function"},{"doc":"Positional Arguments textureThreshold : int Python prototype (for reference): setTextureThreshold(textureThreshold) -&gt; None","ref":"Evision.StereoBM.html#setTextureThreshold/2","title":"Evision.StereoBM.setTextureThreshold/2","type":"function"},{"doc":"Raising version of setUniquenessRatio/2 .","ref":"Evision.StereoBM.html#setUniquenessRatio!/2","title":"Evision.StereoBM.setUniquenessRatio!/2","type":"function"},{"doc":"Positional Arguments uniquenessRatio : int Python prototype (for reference): setUniquenessRatio(uniquenessRatio) -&gt; None","ref":"Evision.StereoBM.html#setUniquenessRatio/2","title":"Evision.StereoBM.setUniquenessRatio/2","type":"function"},{"doc":"","ref":"Evision.StereoMatcher.html","title":"Evision.StereoMatcher","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.StereoMatcher.html#compute!/3","title":"Evision.StereoMatcher.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.StereoMatcher.html#compute!/4","title":"Evision.StereoMatcher.compute!/4","type":"function"},{"doc":"Computes disparity map for the specified stereo pair Positional Arguments left : Evision.Mat . Left 8-bit single-channel image. right : Evision.Mat . Right image of the same size and the same type as the left one. Return disparity : Evision.Mat . Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map. Python prototype (for reference): compute(left, right[, disparity]) -&gt; disparity","ref":"Evision.StereoMatcher.html#compute/3","title":"Evision.StereoMatcher.compute/3","type":"function"},{"doc":"Computes disparity map for the specified stereo pair Positional Arguments left : Evision.Mat . Left 8-bit single-channel image. right : Evision.Mat . Right image of the same size and the same type as the left one. Return disparity : Evision.Mat . Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map. Python prototype (for reference): compute(left, right[, disparity]) -&gt; disparity","ref":"Evision.StereoMatcher.html#compute/4","title":"Evision.StereoMatcher.compute/4","type":"function"},{"doc":"Raising version of getBlockSize/1 .","ref":"Evision.StereoMatcher.html#getBlockSize!/1","title":"Evision.StereoMatcher.getBlockSize!/1","type":"function"},{"doc":"Python prototype (for reference): getBlockSize() -&gt; retval","ref":"Evision.StereoMatcher.html#getBlockSize/1","title":"Evision.StereoMatcher.getBlockSize/1","type":"function"},{"doc":"Raising version of getDisp12MaxDiff/1 .","ref":"Evision.StereoMatcher.html#getDisp12MaxDiff!/1","title":"Evision.StereoMatcher.getDisp12MaxDiff!/1","type":"function"},{"doc":"Python prototype (for reference): getDisp12MaxDiff() -&gt; retval","ref":"Evision.StereoMatcher.html#getDisp12MaxDiff/1","title":"Evision.StereoMatcher.getDisp12MaxDiff/1","type":"function"},{"doc":"Raising version of getMinDisparity/1 .","ref":"Evision.StereoMatcher.html#getMinDisparity!/1","title":"Evision.StereoMatcher.getMinDisparity!/1","type":"function"},{"doc":"Python prototype (for reference): getMinDisparity() -&gt; retval","ref":"Evision.StereoMatcher.html#getMinDisparity/1","title":"Evision.StereoMatcher.getMinDisparity/1","type":"function"},{"doc":"Raising version of getNumDisparities/1 .","ref":"Evision.StereoMatcher.html#getNumDisparities!/1","title":"Evision.StereoMatcher.getNumDisparities!/1","type":"function"},{"doc":"Python prototype (for reference): getNumDisparities() -&gt; retval","ref":"Evision.StereoMatcher.html#getNumDisparities/1","title":"Evision.StereoMatcher.getNumDisparities/1","type":"function"},{"doc":"Raising version of getSpeckleRange/1 .","ref":"Evision.StereoMatcher.html#getSpeckleRange!/1","title":"Evision.StereoMatcher.getSpeckleRange!/1","type":"function"},{"doc":"Python prototype (for reference): getSpeckleRange() -&gt; retval","ref":"Evision.StereoMatcher.html#getSpeckleRange/1","title":"Evision.StereoMatcher.getSpeckleRange/1","type":"function"},{"doc":"Raising version of getSpeckleWindowSize/1 .","ref":"Evision.StereoMatcher.html#getSpeckleWindowSize!/1","title":"Evision.StereoMatcher.getSpeckleWindowSize!/1","type":"function"},{"doc":"Python prototype (for reference): getSpeckleWindowSize() -&gt; retval","ref":"Evision.StereoMatcher.html#getSpeckleWindowSize/1","title":"Evision.StereoMatcher.getSpeckleWindowSize/1","type":"function"},{"doc":"Raising version of setBlockSize/2 .","ref":"Evision.StereoMatcher.html#setBlockSize!/2","title":"Evision.StereoMatcher.setBlockSize!/2","type":"function"},{"doc":"Positional Arguments blockSize : int Python prototype (for reference): setBlockSize(blockSize) -&gt; None","ref":"Evision.StereoMatcher.html#setBlockSize/2","title":"Evision.StereoMatcher.setBlockSize/2","type":"function"},{"doc":"Raising version of setDisp12MaxDiff/2 .","ref":"Evision.StereoMatcher.html#setDisp12MaxDiff!/2","title":"Evision.StereoMatcher.setDisp12MaxDiff!/2","type":"function"},{"doc":"Positional Arguments disp12MaxDiff : int Python prototype (for reference): setDisp12MaxDiff(disp12MaxDiff) -&gt; None","ref":"Evision.StereoMatcher.html#setDisp12MaxDiff/2","title":"Evision.StereoMatcher.setDisp12MaxDiff/2","type":"function"},{"doc":"Raising version of setMinDisparity/2 .","ref":"Evision.StereoMatcher.html#setMinDisparity!/2","title":"Evision.StereoMatcher.setMinDisparity!/2","type":"function"},{"doc":"Positional Arguments minDisparity : int Python prototype (for reference): setMinDisparity(minDisparity) -&gt; None","ref":"Evision.StereoMatcher.html#setMinDisparity/2","title":"Evision.StereoMatcher.setMinDisparity/2","type":"function"},{"doc":"Raising version of setNumDisparities/2 .","ref":"Evision.StereoMatcher.html#setNumDisparities!/2","title":"Evision.StereoMatcher.setNumDisparities!/2","type":"function"},{"doc":"Positional Arguments numDisparities : int Python prototype (for reference): setNumDisparities(numDisparities) -&gt; None","ref":"Evision.StereoMatcher.html#setNumDisparities/2","title":"Evision.StereoMatcher.setNumDisparities/2","type":"function"},{"doc":"Raising version of setSpeckleRange/2 .","ref":"Evision.StereoMatcher.html#setSpeckleRange!/2","title":"Evision.StereoMatcher.setSpeckleRange!/2","type":"function"},{"doc":"Positional Arguments speckleRange : int Python prototype (for reference): setSpeckleRange(speckleRange) -&gt; None","ref":"Evision.StereoMatcher.html#setSpeckleRange/2","title":"Evision.StereoMatcher.setSpeckleRange/2","type":"function"},{"doc":"Raising version of setSpeckleWindowSize/2 .","ref":"Evision.StereoMatcher.html#setSpeckleWindowSize!/2","title":"Evision.StereoMatcher.setSpeckleWindowSize!/2","type":"function"},{"doc":"Positional Arguments speckleWindowSize : int Python prototype (for reference): setSpeckleWindowSize(speckleWindowSize) -&gt; None","ref":"Evision.StereoMatcher.html#setSpeckleWindowSize/2","title":"Evision.StereoMatcher.setSpeckleWindowSize/2","type":"function"},{"doc":"","ref":"Evision.StereoSGBM.html","title":"Evision.StereoSGBM","type":"module"},{"doc":"Raising version of compute/3 .","ref":"Evision.StereoSGBM.html#compute!/3","title":"Evision.StereoSGBM.compute!/3","type":"function"},{"doc":"Raising version of compute/4 .","ref":"Evision.StereoSGBM.html#compute!/4","title":"Evision.StereoSGBM.compute!/4","type":"function"},{"doc":"Computes disparity map for the specified stereo pair Positional Arguments left : Evision.Mat . Left 8-bit single-channel image. right : Evision.Mat . Right image of the same size and the same type as the left one. Return disparity : Evision.Mat . Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map. Python prototype (for reference): compute(left, right[, disparity]) -&gt; disparity","ref":"Evision.StereoSGBM.html#compute/3","title":"Evision.StereoSGBM.compute/3","type":"function"},{"doc":"Computes disparity map for the specified stereo pair Positional Arguments left : Evision.Mat . Left 8-bit single-channel image. right : Evision.Mat . Right image of the same size and the same type as the left one. Return disparity : Evision.Mat . Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map. Python prototype (for reference): compute(left, right[, disparity]) -&gt; disparity","ref":"Evision.StereoSGBM.html#compute/4","title":"Evision.StereoSGBM.compute/4","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.StereoSGBM.html#create!/0","title":"Evision.StereoSGBM.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.StereoSGBM.html#create!/1","title":"Evision.StereoSGBM.create!/1","type":"function"},{"doc":"Creates StereoSGBM object Keyword Arguments minDisparity : int . Minimum possible disparity value. Normally, it is zero but sometimes rectification algorithms can shift images, so this parameter needs to be adjusted accordingly. numDisparities : int . Maximum disparity minus minimum disparity. The value is always greater than zero. In the current implementation, this parameter must be divisible by 16. blockSize : int . Matched block size. It must be an odd number &gt;=1 . Normally, it should be somewhere in the 3..11 range. p1 : int . The first parameter controlling the disparity smoothness. See below. p2 : int . The second parameter controlling the disparity smoothness. The larger the values are, the smoother the disparity is. P1 is the penalty on the disparity change by plus or minus 1 between neighbor pixels. P2 is the penalty on the disparity change by more than 1 between neighbor pixels. The algorithm requires P2 &gt; P1 . See stereo_match.cpp sample where some reasonably good P1 and P2 values are shown (like 8*number_of_image_channels*blockSize*blockSize and 32*number_of_image_channels*blockSize*blockSize , respectively). disp12MaxDiff : int . Maximum allowed difference (in integer pixel units) in the left-right disparity check. Set it to a non-positive value to disable the check. preFilterCap : int . Truncation value for the prefiltered image pixels. The algorithm first computes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval. The result values are passed to the Birchfield-Tomasi pixel cost function. uniquenessRatio : int . Margin in percentage by which the best (minimum) computed cost function value should &quot;win&quot; the second best value to consider the found match correct. Normally, a value within the 5-15 range is good enough. speckleWindowSize : int . Maximum size of smooth disparity regions to consider their noise speckles and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the 50-200 range. speckleRange : int . Maximum disparity variation within each connected component. If you do speckle filtering, set the parameter to a positive value, it will be implicitly multiplied by 16. Normally, 1 or 2 is good enough. mode : int . Set it to StereoSGBM::MODE_HH to run the full-scale two-pass dynamic programming algorithm. It will consume O(W*H*numDisparities) bytes, which is large for 640x480 stereo and huge for HD-size pictures. By default, it is set to false . The first constructor initializes StereoSGBM with all the default parameters. So, you only have to set StereoSGBM::numDisparities at minimum. The second constructor enables you to set each parameter to a custom value. Python prototype (for reference): create([, minDisparity[, numDisparities[, blockSize[, P1[, P2[, disp12MaxDiff[, preFilterCap[, uniquenessRatio[, speckleWindowSize[, speckleRange[, mode]]]]]]]]]]]) -&gt; retval","ref":"Evision.StereoSGBM.html#create/0","title":"Evision.StereoSGBM.create/0","type":"function"},{"doc":"Creates StereoSGBM object Keyword Arguments minDisparity : int . Minimum possible disparity value. Normally, it is zero but sometimes rectification algorithms can shift images, so this parameter needs to be adjusted accordingly. numDisparities : int . Maximum disparity minus minimum disparity. The value is always greater than zero. In the current implementation, this parameter must be divisible by 16. blockSize : int . Matched block size. It must be an odd number &gt;=1 . Normally, it should be somewhere in the 3..11 range. p1 : int . The first parameter controlling the disparity smoothness. See below. p2 : int . The second parameter controlling the disparity smoothness. The larger the values are, the smoother the disparity is. P1 is the penalty on the disparity change by plus or minus 1 between neighbor pixels. P2 is the penalty on the disparity change by more than 1 between neighbor pixels. The algorithm requires P2 &gt; P1 . See stereo_match.cpp sample where some reasonably good P1 and P2 values are shown (like 8*number_of_image_channels*blockSize*blockSize and 32*number_of_image_channels*blockSize*blockSize , respectively). disp12MaxDiff : int . Maximum allowed difference (in integer pixel units) in the left-right disparity check. Set it to a non-positive value to disable the check. preFilterCap : int . Truncation value for the prefiltered image pixels. The algorithm first computes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval. The result values are passed to the Birchfield-Tomasi pixel cost function. uniquenessRatio : int . Margin in percentage by which the best (minimum) computed cost function value should &quot;win&quot; the second best value to consider the found match correct. Normally, a value within the 5-15 range is good enough. speckleWindowSize : int . Maximum size of smooth disparity regions to consider their noise speckles and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the 50-200 range. speckleRange : int . Maximum disparity variation within each connected component. If you do speckle filtering, set the parameter to a positive value, it will be implicitly multiplied by 16. Normally, 1 or 2 is good enough. mode : int . Set it to StereoSGBM::MODE_HH to run the full-scale two-pass dynamic programming algorithm. It will consume O(W*H*numDisparities) bytes, which is large for 640x480 stereo and huge for HD-size pictures. By default, it is set to false . The first constructor initializes StereoSGBM with all the default parameters. So, you only have to set StereoSGBM::numDisparities at minimum. The second constructor enables you to set each parameter to a custom value. Python prototype (for reference): create([, minDisparity[, numDisparities[, blockSize[, P1[, P2[, disp12MaxDiff[, preFilterCap[, uniquenessRatio[, speckleWindowSize[, speckleRange[, mode]]]]]]]]]]]) -&gt; retval","ref":"Evision.StereoSGBM.html#create/1","title":"Evision.StereoSGBM.create/1","type":"function"},{"doc":"Raising version of getBlockSize/1 .","ref":"Evision.StereoSGBM.html#getBlockSize!/1","title":"Evision.StereoSGBM.getBlockSize!/1","type":"function"},{"doc":"Python prototype (for reference): getBlockSize() -&gt; retval","ref":"Evision.StereoSGBM.html#getBlockSize/1","title":"Evision.StereoSGBM.getBlockSize/1","type":"function"},{"doc":"Raising version of getDisp12MaxDiff/1 .","ref":"Evision.StereoSGBM.html#getDisp12MaxDiff!/1","title":"Evision.StereoSGBM.getDisp12MaxDiff!/1","type":"function"},{"doc":"Python prototype (for reference): getDisp12MaxDiff() -&gt; retval","ref":"Evision.StereoSGBM.html#getDisp12MaxDiff/1","title":"Evision.StereoSGBM.getDisp12MaxDiff/1","type":"function"},{"doc":"Raising version of getMinDisparity/1 .","ref":"Evision.StereoSGBM.html#getMinDisparity!/1","title":"Evision.StereoSGBM.getMinDisparity!/1","type":"function"},{"doc":"Python prototype (for reference): getMinDisparity() -&gt; retval","ref":"Evision.StereoSGBM.html#getMinDisparity/1","title":"Evision.StereoSGBM.getMinDisparity/1","type":"function"},{"doc":"Raising version of getMode/1 .","ref":"Evision.StereoSGBM.html#getMode!/1","title":"Evision.StereoSGBM.getMode!/1","type":"function"},{"doc":"Python prototype (for reference): getMode() -&gt; retval","ref":"Evision.StereoSGBM.html#getMode/1","title":"Evision.StereoSGBM.getMode/1","type":"function"},{"doc":"Raising version of getNumDisparities/1 .","ref":"Evision.StereoSGBM.html#getNumDisparities!/1","title":"Evision.StereoSGBM.getNumDisparities!/1","type":"function"},{"doc":"Python prototype (for reference): getNumDisparities() -&gt; retval","ref":"Evision.StereoSGBM.html#getNumDisparities/1","title":"Evision.StereoSGBM.getNumDisparities/1","type":"function"},{"doc":"Raising version of getP1/1 .","ref":"Evision.StereoSGBM.html#getP1!/1","title":"Evision.StereoSGBM.getP1!/1","type":"function"},{"doc":"Python prototype (for reference): getP1() -&gt; retval","ref":"Evision.StereoSGBM.html#getP1/1","title":"Evision.StereoSGBM.getP1/1","type":"function"},{"doc":"Raising version of getP2/1 .","ref":"Evision.StereoSGBM.html#getP2!/1","title":"Evision.StereoSGBM.getP2!/1","type":"function"},{"doc":"Python prototype (for reference): getP2() -&gt; retval","ref":"Evision.StereoSGBM.html#getP2/1","title":"Evision.StereoSGBM.getP2/1","type":"function"},{"doc":"Raising version of getPreFilterCap/1 .","ref":"Evision.StereoSGBM.html#getPreFilterCap!/1","title":"Evision.StereoSGBM.getPreFilterCap!/1","type":"function"},{"doc":"Python prototype (for reference): getPreFilterCap() -&gt; retval","ref":"Evision.StereoSGBM.html#getPreFilterCap/1","title":"Evision.StereoSGBM.getPreFilterCap/1","type":"function"},{"doc":"Raising version of getSpeckleRange/1 .","ref":"Evision.StereoSGBM.html#getSpeckleRange!/1","title":"Evision.StereoSGBM.getSpeckleRange!/1","type":"function"},{"doc":"Python prototype (for reference): getSpeckleRange() -&gt; retval","ref":"Evision.StereoSGBM.html#getSpeckleRange/1","title":"Evision.StereoSGBM.getSpeckleRange/1","type":"function"},{"doc":"Raising version of getSpeckleWindowSize/1 .","ref":"Evision.StereoSGBM.html#getSpeckleWindowSize!/1","title":"Evision.StereoSGBM.getSpeckleWindowSize!/1","type":"function"},{"doc":"Python prototype (for reference): getSpeckleWindowSize() -&gt; retval","ref":"Evision.StereoSGBM.html#getSpeckleWindowSize/1","title":"Evision.StereoSGBM.getSpeckleWindowSize/1","type":"function"},{"doc":"Raising version of getUniquenessRatio/1 .","ref":"Evision.StereoSGBM.html#getUniquenessRatio!/1","title":"Evision.StereoSGBM.getUniquenessRatio!/1","type":"function"},{"doc":"Python prototype (for reference): getUniquenessRatio() -&gt; retval","ref":"Evision.StereoSGBM.html#getUniquenessRatio/1","title":"Evision.StereoSGBM.getUniquenessRatio/1","type":"function"},{"doc":"Raising version of setBlockSize/2 .","ref":"Evision.StereoSGBM.html#setBlockSize!/2","title":"Evision.StereoSGBM.setBlockSize!/2","type":"function"},{"doc":"Positional Arguments blockSize : int Python prototype (for reference): setBlockSize(blockSize) -&gt; None","ref":"Evision.StereoSGBM.html#setBlockSize/2","title":"Evision.StereoSGBM.setBlockSize/2","type":"function"},{"doc":"Raising version of setDisp12MaxDiff/2 .","ref":"Evision.StereoSGBM.html#setDisp12MaxDiff!/2","title":"Evision.StereoSGBM.setDisp12MaxDiff!/2","type":"function"},{"doc":"Positional Arguments disp12MaxDiff : int Python prototype (for reference): setDisp12MaxDiff(disp12MaxDiff) -&gt; None","ref":"Evision.StereoSGBM.html#setDisp12MaxDiff/2","title":"Evision.StereoSGBM.setDisp12MaxDiff/2","type":"function"},{"doc":"Raising version of setMinDisparity/2 .","ref":"Evision.StereoSGBM.html#setMinDisparity!/2","title":"Evision.StereoSGBM.setMinDisparity!/2","type":"function"},{"doc":"Positional Arguments minDisparity : int Python prototype (for reference): setMinDisparity(minDisparity) -&gt; None","ref":"Evision.StereoSGBM.html#setMinDisparity/2","title":"Evision.StereoSGBM.setMinDisparity/2","type":"function"},{"doc":"Raising version of setMode/2 .","ref":"Evision.StereoSGBM.html#setMode!/2","title":"Evision.StereoSGBM.setMode!/2","type":"function"},{"doc":"Positional Arguments mode : int Python prototype (for reference): setMode(mode) -&gt; None","ref":"Evision.StereoSGBM.html#setMode/2","title":"Evision.StereoSGBM.setMode/2","type":"function"},{"doc":"Raising version of setNumDisparities/2 .","ref":"Evision.StereoSGBM.html#setNumDisparities!/2","title":"Evision.StereoSGBM.setNumDisparities!/2","type":"function"},{"doc":"Positional Arguments numDisparities : int Python prototype (for reference): setNumDisparities(numDisparities) -&gt; None","ref":"Evision.StereoSGBM.html#setNumDisparities/2","title":"Evision.StereoSGBM.setNumDisparities/2","type":"function"},{"doc":"Raising version of setP1/2 .","ref":"Evision.StereoSGBM.html#setP1!/2","title":"Evision.StereoSGBM.setP1!/2","type":"function"},{"doc":"Positional Arguments p1 : int Python prototype (for reference): setP1(P1) -&gt; None","ref":"Evision.StereoSGBM.html#setP1/2","title":"Evision.StereoSGBM.setP1/2","type":"function"},{"doc":"Raising version of setP2/2 .","ref":"Evision.StereoSGBM.html#setP2!/2","title":"Evision.StereoSGBM.setP2!/2","type":"function"},{"doc":"Positional Arguments p2 : int Python prototype (for reference): setP2(P2) -&gt; None","ref":"Evision.StereoSGBM.html#setP2/2","title":"Evision.StereoSGBM.setP2/2","type":"function"},{"doc":"Raising version of setPreFilterCap/2 .","ref":"Evision.StereoSGBM.html#setPreFilterCap!/2","title":"Evision.StereoSGBM.setPreFilterCap!/2","type":"function"},{"doc":"Positional Arguments preFilterCap : int Python prototype (for reference): setPreFilterCap(preFilterCap) -&gt; None","ref":"Evision.StereoSGBM.html#setPreFilterCap/2","title":"Evision.StereoSGBM.setPreFilterCap/2","type":"function"},{"doc":"Raising version of setSpeckleRange/2 .","ref":"Evision.StereoSGBM.html#setSpeckleRange!/2","title":"Evision.StereoSGBM.setSpeckleRange!/2","type":"function"},{"doc":"Positional Arguments speckleRange : int Python prototype (for reference): setSpeckleRange(speckleRange) -&gt; None","ref":"Evision.StereoSGBM.html#setSpeckleRange/2","title":"Evision.StereoSGBM.setSpeckleRange/2","type":"function"},{"doc":"Raising version of setSpeckleWindowSize/2 .","ref":"Evision.StereoSGBM.html#setSpeckleWindowSize!/2","title":"Evision.StereoSGBM.setSpeckleWindowSize!/2","type":"function"},{"doc":"Positional Arguments speckleWindowSize : int Python prototype (for reference): setSpeckleWindowSize(speckleWindowSize) -&gt; None","ref":"Evision.StereoSGBM.html#setSpeckleWindowSize/2","title":"Evision.StereoSGBM.setSpeckleWindowSize/2","type":"function"},{"doc":"Raising version of setUniquenessRatio/2 .","ref":"Evision.StereoSGBM.html#setUniquenessRatio!/2","title":"Evision.StereoSGBM.setUniquenessRatio!/2","type":"function"},{"doc":"Positional Arguments uniquenessRatio : int Python prototype (for reference): setUniquenessRatio(uniquenessRatio) -&gt; None","ref":"Evision.StereoSGBM.html#setUniquenessRatio/2","title":"Evision.StereoSGBM.setUniquenessRatio/2","type":"function"},{"doc":"","ref":"Evision.Stitcher.html","title":"Evision.Stitcher","type":"module"},{"doc":"Raising version of composePanorama/1 .","ref":"Evision.Stitcher.html#composePanorama!/1","title":"Evision.Stitcher.composePanorama!/1","type":"function"},{"doc":"Raising version of composePanorama/2 .","ref":"Evision.Stitcher.html#composePanorama!/2","title":"Evision.Stitcher.composePanorama!/2","type":"function"},{"doc":"Raising version of composePanorama/3 .","ref":"Evision.Stitcher.html#composePanorama!/3","title":"Evision.Stitcher.composePanorama!/3","type":"function"},{"doc":"##### Return pano : Evision.Mat . Has overloading in C++ Python prototype (for reference): composePanorama([, pano]) -&gt; retval, pano","ref":"Evision.Stitcher.html#composePanorama/1","title":"Evision.Stitcher.composePanorama/1","type":"function"},{"doc":"These functions try to compose the given images (or images stored internally from the other function calls) into the final pano under the assumption that the image transformations were estimated before. Positional Arguments images : [Evision.Mat] . Input images. Return pano : Evision.Mat . Final pano. Note : Use the functions only if you're aware of the stitching pipeline, otherwise use Stitcher::stitch. @return Status code. Python prototype (for reference): composePanorama(images[, pano]) -&gt; retval, pano","ref":"Evision.Stitcher.html#composePanorama/2","title":"Evision.Stitcher.composePanorama/2","type":"function"},{"doc":"These functions try to compose the given images (or images stored internally from the other function calls) into the final pano under the assumption that the image transformations were estimated before. Positional Arguments images : [Evision.Mat] . Input images. Return pano : Evision.Mat . Final pano. Note : Use the functions only if you're aware of the stitching pipeline, otherwise use Stitcher::stitch. @return Status code. Python prototype (for reference): composePanorama(images[, pano]) -&gt; retval, pano","ref":"Evision.Stitcher.html#composePanorama/3","title":"Evision.Stitcher.composePanorama/3","type":"function"},{"doc":"Raising version of compositingResol/1 .","ref":"Evision.Stitcher.html#compositingResol!/1","title":"Evision.Stitcher.compositingResol!/1","type":"function"},{"doc":"Python prototype (for reference): compositingResol() -&gt; retval","ref":"Evision.Stitcher.html#compositingResol/1","title":"Evision.Stitcher.compositingResol/1","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.Stitcher.html#create!/0","title":"Evision.Stitcher.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.Stitcher.html#create!/1","title":"Evision.Stitcher.create!/1","type":"function"},{"doc":"Creates a Stitcher configured in one of the stitching modes. Keyword Arguments mode : Mode . Scenario for stitcher operation. This is usually determined by source of images to stitch and their transformation. Default parameters will be chosen for operation in given scenario. @return Stitcher class instance. Python prototype (for reference): create([, mode]) -&gt; retval","ref":"Evision.Stitcher.html#create/0","title":"Evision.Stitcher.create/0","type":"function"},{"doc":"Creates a Stitcher configured in one of the stitching modes. Keyword Arguments mode : Mode . Scenario for stitcher operation. This is usually determined by source of images to stitch and their transformation. Default parameters will be chosen for operation in given scenario. @return Stitcher class instance. Python prototype (for reference): create([, mode]) -&gt; retval","ref":"Evision.Stitcher.html#create/1","title":"Evision.Stitcher.create/1","type":"function"},{"doc":"Raising version of estimateTransform/2 .","ref":"Evision.Stitcher.html#estimateTransform!/2","title":"Evision.Stitcher.estimateTransform!/2","type":"function"},{"doc":"Raising version of estimateTransform/3 .","ref":"Evision.Stitcher.html#estimateTransform!/3","title":"Evision.Stitcher.estimateTransform!/3","type":"function"},{"doc":"These functions try to match the given images and to estimate rotations of each camera. Positional Arguments images : [Evision.Mat] . Input images. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). Note : Use the functions only if you're aware of the stitching pipeline, otherwise use Stitcher::stitch. @return Status code. Python prototype (for reference): estimateTransform(images[, masks]) -&gt; retval","ref":"Evision.Stitcher.html#estimateTransform/2","title":"Evision.Stitcher.estimateTransform/2","type":"function"},{"doc":"These functions try to match the given images and to estimate rotations of each camera. Positional Arguments images : [Evision.Mat] . Input images. Keyword Arguments masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). Note : Use the functions only if you're aware of the stitching pipeline, otherwise use Stitcher::stitch. @return Status code. Python prototype (for reference): estimateTransform(images[, masks]) -&gt; retval","ref":"Evision.Stitcher.html#estimateTransform/3","title":"Evision.Stitcher.estimateTransform/3","type":"function"},{"doc":"Raising version of interpolationFlags/1 .","ref":"Evision.Stitcher.html#interpolationFlags!/1","title":"Evision.Stitcher.interpolationFlags!/1","type":"function"},{"doc":"Python prototype (for reference): interpolationFlags() -&gt; retval","ref":"Evision.Stitcher.html#interpolationFlags/1","title":"Evision.Stitcher.interpolationFlags/1","type":"function"},{"doc":"Raising version of panoConfidenceThresh/1 .","ref":"Evision.Stitcher.html#panoConfidenceThresh!/1","title":"Evision.Stitcher.panoConfidenceThresh!/1","type":"function"},{"doc":"Python prototype (for reference): panoConfidenceThresh() -&gt; retval","ref":"Evision.Stitcher.html#panoConfidenceThresh/1","title":"Evision.Stitcher.panoConfidenceThresh/1","type":"function"},{"doc":"Raising version of registrationResol/1 .","ref":"Evision.Stitcher.html#registrationResol!/1","title":"Evision.Stitcher.registrationResol!/1","type":"function"},{"doc":"Python prototype (for reference): registrationResol() -&gt; retval","ref":"Evision.Stitcher.html#registrationResol/1","title":"Evision.Stitcher.registrationResol/1","type":"function"},{"doc":"Raising version of seamEstimationResol/1 .","ref":"Evision.Stitcher.html#seamEstimationResol!/1","title":"Evision.Stitcher.seamEstimationResol!/1","type":"function"},{"doc":"Python prototype (for reference): seamEstimationResol() -&gt; retval","ref":"Evision.Stitcher.html#seamEstimationResol/1","title":"Evision.Stitcher.seamEstimationResol/1","type":"function"},{"doc":"Raising version of setCompositingResol/2 .","ref":"Evision.Stitcher.html#setCompositingResol!/2","title":"Evision.Stitcher.setCompositingResol!/2","type":"function"},{"doc":"Positional Arguments resol_mpx : double Python prototype (for reference): setCompositingResol(resol_mpx) -&gt; None","ref":"Evision.Stitcher.html#setCompositingResol/2","title":"Evision.Stitcher.setCompositingResol/2","type":"function"},{"doc":"Raising version of setInterpolationFlags/2 .","ref":"Evision.Stitcher.html#setInterpolationFlags!/2","title":"Evision.Stitcher.setInterpolationFlags!/2","type":"function"},{"doc":"Positional Arguments interp_flags : InterpolationFlags Python prototype (for reference): setInterpolationFlags(interp_flags) -&gt; None","ref":"Evision.Stitcher.html#setInterpolationFlags/2","title":"Evision.Stitcher.setInterpolationFlags/2","type":"function"},{"doc":"Raising version of setPanoConfidenceThresh/2 .","ref":"Evision.Stitcher.html#setPanoConfidenceThresh!/2","title":"Evision.Stitcher.setPanoConfidenceThresh!/2","type":"function"},{"doc":"Positional Arguments conf_thresh : double Python prototype (for reference): setPanoConfidenceThresh(conf_thresh) -&gt; None","ref":"Evision.Stitcher.html#setPanoConfidenceThresh/2","title":"Evision.Stitcher.setPanoConfidenceThresh/2","type":"function"},{"doc":"Raising version of setRegistrationResol/2 .","ref":"Evision.Stitcher.html#setRegistrationResol!/2","title":"Evision.Stitcher.setRegistrationResol!/2","type":"function"},{"doc":"Positional Arguments resol_mpx : double Python prototype (for reference): setRegistrationResol(resol_mpx) -&gt; None","ref":"Evision.Stitcher.html#setRegistrationResol/2","title":"Evision.Stitcher.setRegistrationResol/2","type":"function"},{"doc":"Raising version of setSeamEstimationResol/2 .","ref":"Evision.Stitcher.html#setSeamEstimationResol!/2","title":"Evision.Stitcher.setSeamEstimationResol!/2","type":"function"},{"doc":"Positional Arguments resol_mpx : double Python prototype (for reference): setSeamEstimationResol(resol_mpx) -&gt; None","ref":"Evision.Stitcher.html#setSeamEstimationResol/2","title":"Evision.Stitcher.setSeamEstimationResol/2","type":"function"},{"doc":"Raising version of setWaveCorrection/2 .","ref":"Evision.Stitcher.html#setWaveCorrection!/2","title":"Evision.Stitcher.setWaveCorrection!/2","type":"function"},{"doc":"Positional Arguments flag : bool Python prototype (for reference): setWaveCorrection(flag) -&gt; None","ref":"Evision.Stitcher.html#setWaveCorrection/2","title":"Evision.Stitcher.setWaveCorrection/2","type":"function"},{"doc":"Raising version of stitch/2 .","ref":"Evision.Stitcher.html#stitch!/2","title":"Evision.Stitcher.stitch!/2","type":"function"},{"doc":"Raising version of stitch/3 .","ref":"Evision.Stitcher.html#stitch!/3","title":"Evision.Stitcher.stitch!/3","type":"function"},{"doc":"Raising version of stitch/4 .","ref":"Evision.Stitcher.html#stitch!/4","title":"Evision.Stitcher.stitch!/4","type":"function"},{"doc":"Positional Arguments images : [Evision.Mat] Return pano : Evision.Mat . Has overloading in C++ Python prototype (for reference): stitch(images[, pano]) -&gt; retval, pano","ref":"Evision.Stitcher.html#stitch/2","title":"Evision.Stitcher.stitch/2","type":"function"},{"doc":"Variant 1: These functions try to stitch the given images. Positional Arguments images : [Evision.Mat] . Input images. masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). Return pano : Evision.Mat . Final pano. @return Status code. Python prototype (for reference): stitch(images, masks[, pano]) -&gt; retval, pano Variant 2: Positional Arguments images : [Evision.Mat] Return pano : Evision.Mat . Has overloading in C++ Python prototype (for reference): stitch(images[, pano]) -&gt; retval, pano","ref":"Evision.Stitcher.html#stitch/3","title":"Evision.Stitcher.stitch/3","type":"function"},{"doc":"These functions try to stitch the given images. Positional Arguments images : [Evision.Mat] . Input images. masks : [Evision.Mat] . Masks for each input image specifying where to look for keypoints (optional). Return pano : Evision.Mat . Final pano. @return Status code. Python prototype (for reference): stitch(images, masks[, pano]) -&gt; retval, pano","ref":"Evision.Stitcher.html#stitch/4","title":"Evision.Stitcher.stitch/4","type":"function"},{"doc":"Raising version of waveCorrection/1 .","ref":"Evision.Stitcher.html#waveCorrection!/1","title":"Evision.Stitcher.waveCorrection!/1","type":"function"},{"doc":"Python prototype (for reference): waveCorrection() -&gt; retval","ref":"Evision.Stitcher.html#waveCorrection/1","title":"Evision.Stitcher.waveCorrection/1","type":"function"},{"doc":"Raising version of workScale/1 .","ref":"Evision.Stitcher.html#workScale!/1","title":"Evision.Stitcher.workScale!/1","type":"function"},{"doc":"Python prototype (for reference): workScale() -&gt; retval","ref":"Evision.Stitcher.html#workScale/1","title":"Evision.Stitcher.workScale/1","type":"function"},{"doc":"","ref":"Evision.Subdiv2D.html","title":"Evision.Subdiv2D","type":"module"},{"doc":"Raising version of edgeDst/2 .","ref":"Evision.Subdiv2D.html#edgeDst!/2","title":"Evision.Subdiv2D.edgeDst!/2","type":"function"},{"doc":"Returns the edge destination. Positional Arguments edge : int . Subdivision edge ID. Return dstpt : Point2f* . Output vertex location. @returns vertex ID. Python prototype (for reference): edgeDst(edge) -&gt; retval, dstpt","ref":"Evision.Subdiv2D.html#edgeDst/2","title":"Evision.Subdiv2D.edgeDst/2","type":"function"},{"doc":"Raising version of edgeOrg/2 .","ref":"Evision.Subdiv2D.html#edgeOrg!/2","title":"Evision.Subdiv2D.edgeOrg!/2","type":"function"},{"doc":"Returns the edge origin. Positional Arguments edge : int . Subdivision edge ID. Return orgpt : Point2f* . Output vertex location. @returns vertex ID. Python prototype (for reference): edgeOrg(edge) -&gt; retval, orgpt","ref":"Evision.Subdiv2D.html#edgeOrg/2","title":"Evision.Subdiv2D.edgeOrg/2","type":"function"},{"doc":"Raising version of findNearest/2 .","ref":"Evision.Subdiv2D.html#findNearest!/2","title":"Evision.Subdiv2D.findNearest!/2","type":"function"},{"doc":"Finds the subdivision vertex closest to the given point. Positional Arguments pt : Point2f . Input point. Return nearestPt : Point2f* . Output subdivision vertex point. The function is another function that locates the input point within the subdivision. It finds the subdivision vertex that is the closest to the input point. It is not necessarily one of vertices of the facet containing the input point, though the facet (located using locate() ) is used as a starting point. @returns vertex ID. Python prototype (for reference): findNearest(pt) -&gt; retval, nearestPt","ref":"Evision.Subdiv2D.html#findNearest/2","title":"Evision.Subdiv2D.findNearest/2","type":"function"},{"doc":"Raising version of getEdge/3 .","ref":"Evision.Subdiv2D.html#getEdge!/3","title":"Evision.Subdiv2D.getEdge!/3","type":"function"},{"doc":"Returns one of the edges related to the given edge. Positional Arguments edge : int . Subdivision edge ID. nextEdgeType : int . Parameter specifying which of the related edges to return. The following values are possible: NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture below if e is the input edge) NEXT_AROUND_DST next around the edge vertex ( eDnext ) PREV_AROUND_ORG previous around the edge origin (reversed eRnext ) PREV_AROUND_DST previous around the edge destination (reversed eLnext ) NEXT_AROUND_LEFT next around the left facet ( eLnext ) NEXT_AROUND_RIGHT next around the right facet ( eRnext ) PREV_AROUND_LEFT previous around the left facet (reversed eOnext ) PREV_AROUND_RIGHT previous around the right facet (reversed eDnext ) @returns edge ID related to the input edge. Python prototype (for reference): getEdge(edge, nextEdgeType) -&gt; retval","ref":"Evision.Subdiv2D.html#getEdge/3","title":"Evision.Subdiv2D.getEdge/3","type":"function"},{"doc":"Raising version of getEdgeList/1 .","ref":"Evision.Subdiv2D.html#getEdgeList!/1","title":"Evision.Subdiv2D.getEdgeList!/1","type":"function"},{"doc":"Returns a list of all edges. Return edgeList : [Vec4f] . Output vector. The function gives each edge as a 4 numbers vector, where each two are one of the edge vertices. i.e. org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3]. Python prototype (for reference): getEdgeList() -&gt; edgeList","ref":"Evision.Subdiv2D.html#getEdgeList/1","title":"Evision.Subdiv2D.getEdgeList/1","type":"function"},{"doc":"Raising version of getLeadingEdgeList/1 .","ref":"Evision.Subdiv2D.html#getLeadingEdgeList!/1","title":"Evision.Subdiv2D.getLeadingEdgeList!/1","type":"function"},{"doc":"Returns a list of the leading edge ID connected to each triangle. Return leadingEdgeList : [int] . Output vector. The function gives one edge ID for each triangle. Python prototype (for reference): getLeadingEdgeList() -&gt; leadingEdgeList","ref":"Evision.Subdiv2D.html#getLeadingEdgeList/1","title":"Evision.Subdiv2D.getLeadingEdgeList/1","type":"function"},{"doc":"Raising version of getTriangleList/1 .","ref":"Evision.Subdiv2D.html#getTriangleList!/1","title":"Evision.Subdiv2D.getTriangleList!/1","type":"function"},{"doc":"Returns a list of all triangles. Return triangleList : [Vec6f] . Output vector. The function gives each triangle as a 6 numbers vector, where each two are one of the triangle vertices. i.e. p1_x = v[0], p1_y = v[1], p2_x = v[2], p2_y = v[3], p3_x = v[4], p3_y = v[5]. Python prototype (for reference): getTriangleList() -&gt; triangleList","ref":"Evision.Subdiv2D.html#getTriangleList/1","title":"Evision.Subdiv2D.getTriangleList/1","type":"function"},{"doc":"Raising version of getVertex/2 .","ref":"Evision.Subdiv2D.html#getVertex!/2","title":"Evision.Subdiv2D.getVertex!/2","type":"function"},{"doc":"Returns vertex location from vertex ID. Positional Arguments vertex : int . vertex ID. Return firstEdge : int* . Optional. The first edge ID which is connected to the vertex. @returns vertex (x,y) Python prototype (for reference): getVertex(vertex) -&gt; retval, firstEdge","ref":"Evision.Subdiv2D.html#getVertex/2","title":"Evision.Subdiv2D.getVertex/2","type":"function"},{"doc":"Raising version of getVoronoiFacetList/2 .","ref":"Evision.Subdiv2D.html#getVoronoiFacetList!/2","title":"Evision.Subdiv2D.getVoronoiFacetList!/2","type":"function"},{"doc":"Returns a list of all Voronoi facets. Positional Arguments idx : [int] . Vector of vertices IDs to consider. For all vertices you can pass empty vector. Return facetList : [vector_Point2f] . Output vector of the Voronoi facets. facetCenters : [Point2f] . Output vector of the Voronoi facets center points. Python prototype (for reference): getVoronoiFacetList(idx) -&gt; facetList, facetCenters","ref":"Evision.Subdiv2D.html#getVoronoiFacetList/2","title":"Evision.Subdiv2D.getVoronoiFacetList/2","type":"function"},{"doc":"Raising version of initDelaunay/2 .","ref":"Evision.Subdiv2D.html#initDelaunay!/2","title":"Evision.Subdiv2D.initDelaunay!/2","type":"function"},{"doc":"Creates a new empty Delaunay subdivision Positional Arguments rect : Rect . Rectangle that includes all of the 2D points that are to be added to the subdivision. Python prototype (for reference): initDelaunay(rect) -&gt; None","ref":"Evision.Subdiv2D.html#initDelaunay/2","title":"Evision.Subdiv2D.initDelaunay/2","type":"function"},{"doc":"Raising version of insert/2 .","ref":"Evision.Subdiv2D.html#insert!/2","title":"Evision.Subdiv2D.insert!/2","type":"function"},{"doc":"Insert multiple points into a Delaunay triangulation. Positional Arguments ptvec : [Point2f] . Points to insert. The function inserts a vector of points into a subdivision and modifies the subdivision topology appropriately. Python prototype (for reference): insert(ptvec) -&gt; None","ref":"Evision.Subdiv2D.html#insert/2","title":"Evision.Subdiv2D.insert/2","type":"function"},{"doc":"Raising version of locate/2 .","ref":"Evision.Subdiv2D.html#locate!/2","title":"Evision.Subdiv2D.locate!/2","type":"function"},{"doc":"Returns the location of a point within a Delaunay triangulation. Positional Arguments pt : Point2f . Point to locate. Return edge : int . Output edge that the point belongs to or is located to the right of it. vertex : int . Optional output vertex the input point coincides with. The function locates the input point within the subdivision and gives one of the triangle edges or vertices. @returns an integer which specify one of the following five cases for point location: The point falls into some facet. The function returns #PTLOC_INSIDE and edge will contain one of edges of the facet. The point falls onto the edge. The function returns #PTLOC_ON_EDGE and edge will contain this edge. The point coincides with one of the subdivision vertices. The function returns #PTLOC_VERTEX and vertex will contain a pointer to the vertex. The point is outside the subdivision reference rectangle. The function returns #PTLOC_OUTSIDE_RECT and no pointers are filled. One of input arguments is invalid. A runtime error is raised or, if silent or &quot;parent&quot; error processing mode is selected, #PTLOC_ERROR is returned. Python prototype (for reference): locate(pt) -&gt; retval, edge, vertex","ref":"Evision.Subdiv2D.html#locate/2","title":"Evision.Subdiv2D.locate/2","type":"function"},{"doc":"Raising version of nextEdge/2 .","ref":"Evision.Subdiv2D.html#nextEdge!/2","title":"Evision.Subdiv2D.nextEdge!/2","type":"function"},{"doc":"Returns next edge around the edge origin. Positional Arguments edge : int . Subdivision edge ID. @returns an integer which is next edge ID around the edge origin: eOnext on the picture above if e is the input edge). Python prototype (for reference): nextEdge(edge) -&gt; retval","ref":"Evision.Subdiv2D.html#nextEdge/2","title":"Evision.Subdiv2D.nextEdge/2","type":"function"},{"doc":"Raising version of rotateEdge/3 .","ref":"Evision.Subdiv2D.html#rotateEdge!/3","title":"Evision.Subdiv2D.rotateEdge!/3","type":"function"},{"doc":"Returns another edge of the same quad-edge. Positional Arguments edge : int . Subdivision edge ID. rotate : int . Parameter specifying which of the edges of the same quad-edge as the input one to return. The following values are possible: 0 - the input edge ( e on the picture below if e is the input edge) 1 - the rotated edge ( eRot ) 2 - the reversed edge (reversed e (in green)) 3 - the reversed rotated edge (reversed eRot (in green)) @returns one of the edges ID of the same quad-edge as the input edge. Python prototype (for reference): rotateEdge(edge, rotate) -&gt; retval","ref":"Evision.Subdiv2D.html#rotateEdge/3","title":"Evision.Subdiv2D.rotateEdge/3","type":"function"},{"doc":"Raising version of subdiv2D/0 .","ref":"Evision.Subdiv2D.html#subdiv2D!/0","title":"Evision.Subdiv2D.subdiv2D!/0","type":"function"},{"doc":"Raising version of subdiv2D/1 .","ref":"Evision.Subdiv2D.html#subdiv2D!/1","title":"Evision.Subdiv2D.subdiv2D!/1","type":"function"},{"doc":"creates an empty Subdiv2D object. To create a new empty Delaunay subdivision you need to use the #initDelaunay function. Python prototype (for reference): Subdiv2D() -&gt; &lt;Subdiv2D object&gt;","ref":"Evision.Subdiv2D.html#subdiv2D/0","title":"Evision.Subdiv2D.subdiv2D/0","type":"function"},{"doc":"Positional Arguments rect : Rect . Rectangle that includes all of the 2D points that are to be added to the subdivision. Has overloading in C++ The function creates an empty Delaunay subdivision where 2D points can be added using the function insert() . All of the points to be added must be within the specified rectangle, otherwise a runtime error is raised. Python prototype (for reference): Subdiv2D(rect) -&gt; &lt;Subdiv2D object&gt;","ref":"Evision.Subdiv2D.html#subdiv2D/1","title":"Evision.Subdiv2D.subdiv2D/1","type":"function"},{"doc":"Raising version of symEdge/2 .","ref":"Evision.Subdiv2D.html#symEdge!/2","title":"Evision.Subdiv2D.symEdge!/2","type":"function"},{"doc":"Positional Arguments edge : int Python prototype (for reference): symEdge(edge) -&gt; retval","ref":"Evision.Subdiv2D.html#symEdge/2","title":"Evision.Subdiv2D.symEdge/2","type":"function"},{"doc":"","ref":"Evision.TickMeter.html","title":"Evision.TickMeter","type":"module"},{"doc":"Raising version of getAvgTimeMilli/1 .","ref":"Evision.TickMeter.html#getAvgTimeMilli!/1","title":"Evision.TickMeter.getAvgTimeMilli!/1","type":"function"},{"doc":"Python prototype (for reference): getAvgTimeMilli() -&gt; retval","ref":"Evision.TickMeter.html#getAvgTimeMilli/1","title":"Evision.TickMeter.getAvgTimeMilli/1","type":"function"},{"doc":"Raising version of getAvgTimeSec/1 .","ref":"Evision.TickMeter.html#getAvgTimeSec!/1","title":"Evision.TickMeter.getAvgTimeSec!/1","type":"function"},{"doc":"Python prototype (for reference): getAvgTimeSec() -&gt; retval","ref":"Evision.TickMeter.html#getAvgTimeSec/1","title":"Evision.TickMeter.getAvgTimeSec/1","type":"function"},{"doc":"Raising version of getCounter/1 .","ref":"Evision.TickMeter.html#getCounter!/1","title":"Evision.TickMeter.getCounter!/1","type":"function"},{"doc":"Python prototype (for reference): getCounter() -&gt; retval","ref":"Evision.TickMeter.html#getCounter/1","title":"Evision.TickMeter.getCounter/1","type":"function"},{"doc":"Raising version of getFPS/1 .","ref":"Evision.TickMeter.html#getFPS!/1","title":"Evision.TickMeter.getFPS!/1","type":"function"},{"doc":"Python prototype (for reference): getFPS() -&gt; retval","ref":"Evision.TickMeter.html#getFPS/1","title":"Evision.TickMeter.getFPS/1","type":"function"},{"doc":"Raising version of getTimeMicro/1 .","ref":"Evision.TickMeter.html#getTimeMicro!/1","title":"Evision.TickMeter.getTimeMicro!/1","type":"function"},{"doc":"Python prototype (for reference): getTimeMicro() -&gt; retval","ref":"Evision.TickMeter.html#getTimeMicro/1","title":"Evision.TickMeter.getTimeMicro/1","type":"function"},{"doc":"Raising version of getTimeMilli/1 .","ref":"Evision.TickMeter.html#getTimeMilli!/1","title":"Evision.TickMeter.getTimeMilli!/1","type":"function"},{"doc":"Python prototype (for reference): getTimeMilli() -&gt; retval","ref":"Evision.TickMeter.html#getTimeMilli/1","title":"Evision.TickMeter.getTimeMilli/1","type":"function"},{"doc":"Raising version of getTimeSec/1 .","ref":"Evision.TickMeter.html#getTimeSec!/1","title":"Evision.TickMeter.getTimeSec!/1","type":"function"},{"doc":"Python prototype (for reference): getTimeSec() -&gt; retval","ref":"Evision.TickMeter.html#getTimeSec/1","title":"Evision.TickMeter.getTimeSec/1","type":"function"},{"doc":"Raising version of getTimeTicks/1 .","ref":"Evision.TickMeter.html#getTimeTicks!/1","title":"Evision.TickMeter.getTimeTicks!/1","type":"function"},{"doc":"Python prototype (for reference): getTimeTicks() -&gt; retval","ref":"Evision.TickMeter.html#getTimeTicks/1","title":"Evision.TickMeter.getTimeTicks/1","type":"function"},{"doc":"Raising version of reset/1 .","ref":"Evision.TickMeter.html#reset!/1","title":"Evision.TickMeter.reset!/1","type":"function"},{"doc":"Python prototype (for reference): reset() -&gt; None","ref":"Evision.TickMeter.html#reset/1","title":"Evision.TickMeter.reset/1","type":"function"},{"doc":"Raising version of start/1 .","ref":"Evision.TickMeter.html#start!/1","title":"Evision.TickMeter.start!/1","type":"function"},{"doc":"Python prototype (for reference): start() -&gt; None","ref":"Evision.TickMeter.html#start/1","title":"Evision.TickMeter.start/1","type":"function"},{"doc":"Raising version of stop/1 .","ref":"Evision.TickMeter.html#stop!/1","title":"Evision.TickMeter.stop!/1","type":"function"},{"doc":"Python prototype (for reference): stop() -&gt; None","ref":"Evision.TickMeter.html#stop/1","title":"Evision.TickMeter.stop/1","type":"function"},{"doc":"Raising version of tickMeter/0 .","ref":"Evision.TickMeter.html#tickMeter!/0","title":"Evision.TickMeter.tickMeter!/0","type":"function"},{"doc":"Python prototype (for reference): TickMeter() -&gt; &lt;TickMeter object&gt;","ref":"Evision.TickMeter.html#tickMeter/0","title":"Evision.TickMeter.tickMeter/0","type":"function"},{"doc":"","ref":"Evision.Tonemap.html","title":"Evision.Tonemap","type":"module"},{"doc":"Raising version of getGamma/1 .","ref":"Evision.Tonemap.html#getGamma!/1","title":"Evision.Tonemap.getGamma!/1","type":"function"},{"doc":"Python prototype (for reference): getGamma() -&gt; retval","ref":"Evision.Tonemap.html#getGamma/1","title":"Evision.Tonemap.getGamma/1","type":"function"},{"doc":"Raising version of process/2 .","ref":"Evision.Tonemap.html#process!/2","title":"Evision.Tonemap.process!/2","type":"function"},{"doc":"Raising version of process/3 .","ref":"Evision.Tonemap.html#process!/3","title":"Evision.Tonemap.process!/3","type":"function"},{"doc":"Tonemaps image Positional Arguments src : Evision.Mat . source image - CV_32FC3 Mat (float 32 bits 3 channels) Return dst : Evision.Mat . destination image - CV_32FC3 Mat with values in [0, 1] range Python prototype (for reference): process(src[, dst]) -&gt; dst","ref":"Evision.Tonemap.html#process/2","title":"Evision.Tonemap.process/2","type":"function"},{"doc":"Tonemaps image Positional Arguments src : Evision.Mat . source image - CV_32FC3 Mat (float 32 bits 3 channels) Return dst : Evision.Mat . destination image - CV_32FC3 Mat with values in [0, 1] range Python prototype (for reference): process(src[, dst]) -&gt; dst","ref":"Evision.Tonemap.html#process/3","title":"Evision.Tonemap.process/3","type":"function"},{"doc":"Raising version of setGamma/2 .","ref":"Evision.Tonemap.html#setGamma!/2","title":"Evision.Tonemap.setGamma!/2","type":"function"},{"doc":"Positional Arguments gamma : float Python prototype (for reference): setGamma(gamma) -&gt; None","ref":"Evision.Tonemap.html#setGamma/2","title":"Evision.Tonemap.setGamma/2","type":"function"},{"doc":"","ref":"Evision.TonemapDrago.html","title":"Evision.TonemapDrago","type":"module"},{"doc":"Raising version of getBias/1 .","ref":"Evision.TonemapDrago.html#getBias!/1","title":"Evision.TonemapDrago.getBias!/1","type":"function"},{"doc":"Python prototype (for reference): getBias() -&gt; retval","ref":"Evision.TonemapDrago.html#getBias/1","title":"Evision.TonemapDrago.getBias/1","type":"function"},{"doc":"Raising version of getSaturation/1 .","ref":"Evision.TonemapDrago.html#getSaturation!/1","title":"Evision.TonemapDrago.getSaturation!/1","type":"function"},{"doc":"Python prototype (for reference): getSaturation() -&gt; retval","ref":"Evision.TonemapDrago.html#getSaturation/1","title":"Evision.TonemapDrago.getSaturation/1","type":"function"},{"doc":"Raising version of setBias/2 .","ref":"Evision.TonemapDrago.html#setBias!/2","title":"Evision.TonemapDrago.setBias!/2","type":"function"},{"doc":"Positional Arguments bias : float Python prototype (for reference): setBias(bias) -&gt; None","ref":"Evision.TonemapDrago.html#setBias/2","title":"Evision.TonemapDrago.setBias/2","type":"function"},{"doc":"Raising version of setSaturation/2 .","ref":"Evision.TonemapDrago.html#setSaturation!/2","title":"Evision.TonemapDrago.setSaturation!/2","type":"function"},{"doc":"Positional Arguments saturation : float Python prototype (for reference): setSaturation(saturation) -&gt; None","ref":"Evision.TonemapDrago.html#setSaturation/2","title":"Evision.TonemapDrago.setSaturation/2","type":"function"},{"doc":"","ref":"Evision.TonemapMantiuk.html","title":"Evision.TonemapMantiuk","type":"module"},{"doc":"Raising version of getSaturation/1 .","ref":"Evision.TonemapMantiuk.html#getSaturation!/1","title":"Evision.TonemapMantiuk.getSaturation!/1","type":"function"},{"doc":"Python prototype (for reference): getSaturation() -&gt; retval","ref":"Evision.TonemapMantiuk.html#getSaturation/1","title":"Evision.TonemapMantiuk.getSaturation/1","type":"function"},{"doc":"Raising version of getScale/1 .","ref":"Evision.TonemapMantiuk.html#getScale!/1","title":"Evision.TonemapMantiuk.getScale!/1","type":"function"},{"doc":"Python prototype (for reference): getScale() -&gt; retval","ref":"Evision.TonemapMantiuk.html#getScale/1","title":"Evision.TonemapMantiuk.getScale/1","type":"function"},{"doc":"Raising version of setSaturation/2 .","ref":"Evision.TonemapMantiuk.html#setSaturation!/2","title":"Evision.TonemapMantiuk.setSaturation!/2","type":"function"},{"doc":"Positional Arguments saturation : float Python prototype (for reference): setSaturation(saturation) -&gt; None","ref":"Evision.TonemapMantiuk.html#setSaturation/2","title":"Evision.TonemapMantiuk.setSaturation/2","type":"function"},{"doc":"Raising version of setScale/2 .","ref":"Evision.TonemapMantiuk.html#setScale!/2","title":"Evision.TonemapMantiuk.setScale!/2","type":"function"},{"doc":"Positional Arguments scale : float Python prototype (for reference): setScale(scale) -&gt; None","ref":"Evision.TonemapMantiuk.html#setScale/2","title":"Evision.TonemapMantiuk.setScale/2","type":"function"},{"doc":"","ref":"Evision.TonemapReinhard.html","title":"Evision.TonemapReinhard","type":"module"},{"doc":"Raising version of getColorAdaptation/1 .","ref":"Evision.TonemapReinhard.html#getColorAdaptation!/1","title":"Evision.TonemapReinhard.getColorAdaptation!/1","type":"function"},{"doc":"Python prototype (for reference): getColorAdaptation() -&gt; retval","ref":"Evision.TonemapReinhard.html#getColorAdaptation/1","title":"Evision.TonemapReinhard.getColorAdaptation/1","type":"function"},{"doc":"Raising version of getIntensity/1 .","ref":"Evision.TonemapReinhard.html#getIntensity!/1","title":"Evision.TonemapReinhard.getIntensity!/1","type":"function"},{"doc":"Python prototype (for reference): getIntensity() -&gt; retval","ref":"Evision.TonemapReinhard.html#getIntensity/1","title":"Evision.TonemapReinhard.getIntensity/1","type":"function"},{"doc":"Raising version of getLightAdaptation/1 .","ref":"Evision.TonemapReinhard.html#getLightAdaptation!/1","title":"Evision.TonemapReinhard.getLightAdaptation!/1","type":"function"},{"doc":"Python prototype (for reference): getLightAdaptation() -&gt; retval","ref":"Evision.TonemapReinhard.html#getLightAdaptation/1","title":"Evision.TonemapReinhard.getLightAdaptation/1","type":"function"},{"doc":"Raising version of setColorAdaptation/2 .","ref":"Evision.TonemapReinhard.html#setColorAdaptation!/2","title":"Evision.TonemapReinhard.setColorAdaptation!/2","type":"function"},{"doc":"Positional Arguments color_adapt : float Python prototype (for reference): setColorAdaptation(color_adapt) -&gt; None","ref":"Evision.TonemapReinhard.html#setColorAdaptation/2","title":"Evision.TonemapReinhard.setColorAdaptation/2","type":"function"},{"doc":"Raising version of setIntensity/2 .","ref":"Evision.TonemapReinhard.html#setIntensity!/2","title":"Evision.TonemapReinhard.setIntensity!/2","type":"function"},{"doc":"Positional Arguments intensity : float Python prototype (for reference): setIntensity(intensity) -&gt; None","ref":"Evision.TonemapReinhard.html#setIntensity/2","title":"Evision.TonemapReinhard.setIntensity/2","type":"function"},{"doc":"Raising version of setLightAdaptation/2 .","ref":"Evision.TonemapReinhard.html#setLightAdaptation!/2","title":"Evision.TonemapReinhard.setLightAdaptation!/2","type":"function"},{"doc":"Positional Arguments light_adapt : float Python prototype (for reference): setLightAdaptation(light_adapt) -&gt; None","ref":"Evision.TonemapReinhard.html#setLightAdaptation/2","title":"Evision.TonemapReinhard.setLightAdaptation/2","type":"function"},{"doc":"","ref":"Evision.Tracker.html","title":"Evision.Tracker","type":"module"},{"doc":"Raising version of init/3 .","ref":"Evision.Tracker.html#init!/3","title":"Evision.Tracker.init!/3","type":"function"},{"doc":"Initialize the tracker with a known bounding box that surrounded the target Positional Arguments image : Evision.Mat . The initial frame boundingBox : Rect . The initial bounding box Python prototype (for reference): init(image, boundingBox) -&gt; None","ref":"Evision.Tracker.html#init/3","title":"Evision.Tracker.init/3","type":"function"},{"doc":"Raising version of update/2 .","ref":"Evision.Tracker.html#update!/2","title":"Evision.Tracker.update!/2","type":"function"},{"doc":"Update the tracker, find the new most likely bounding box for the target Positional Arguments image : Evision.Mat . The current frame Return boundingBox : Rect . The bounding box that represent the new target location, if true was returned, not modified otherwise @return True means that target was located and false means that tracker cannot locate target in current frame. Note, that latter does not imply that tracker has failed, maybe target is indeed missing from the frame (say, out of sight) Python prototype (for reference): update(image) -&gt; retval, boundingBox","ref":"Evision.Tracker.html#update/2","title":"Evision.Tracker.update/2","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.html","title":"Evision.TrackerDaSiamRPN","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.TrackerDaSiamRPN.html#create!/0","title":"Evision.TrackerDaSiamRPN.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.TrackerDaSiamRPN.html#create!/1","title":"Evision.TrackerDaSiamRPN.create!/1","type":"function"},{"doc":"Constructor Keyword Arguments parameters : TrackerDaSiamRPN_Params . DaSiamRPN parameters TrackerDaSiamRPN::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.TrackerDaSiamRPN.html#create/0","title":"Evision.TrackerDaSiamRPN.create/0","type":"function"},{"doc":"Constructor Keyword Arguments parameters : TrackerDaSiamRPN_Params . DaSiamRPN parameters TrackerDaSiamRPN::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.TrackerDaSiamRPN.html#create/1","title":"Evision.TrackerDaSiamRPN.create/1","type":"function"},{"doc":"Raising version of getTrackingScore/1 .","ref":"Evision.TrackerDaSiamRPN.html#getTrackingScore!/1","title":"Evision.TrackerDaSiamRPN.getTrackingScore!/1","type":"function"},{"doc":"Return tracking score Python prototype (for reference): getTrackingScore() -&gt; retval","ref":"Evision.TrackerDaSiamRPN.html#getTrackingScore/1","title":"Evision.TrackerDaSiamRPN.getTrackingScore/1","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html","title":"Evision.TrackerDaSiamRPN.Params","type":"module"},{"doc":"Raising version of get_backend/1 .","ref":"Evision.TrackerDaSiamRPN.Params.html#get_backend!/1","title":"Evision.TrackerDaSiamRPN.Params.get_backend!/1","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#get_backend/1","title":"Evision.TrackerDaSiamRPN.Params.get_backend/1","type":"function"},{"doc":"Raising version of get_kernel_cls1/1 .","ref":"Evision.TrackerDaSiamRPN.Params.html#get_kernel_cls1!/1","title":"Evision.TrackerDaSiamRPN.Params.get_kernel_cls1!/1","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#get_kernel_cls1/1","title":"Evision.TrackerDaSiamRPN.Params.get_kernel_cls1/1","type":"function"},{"doc":"Raising version of get_kernel_r1/1 .","ref":"Evision.TrackerDaSiamRPN.Params.html#get_kernel_r1!/1","title":"Evision.TrackerDaSiamRPN.Params.get_kernel_r1!/1","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#get_kernel_r1/1","title":"Evision.TrackerDaSiamRPN.Params.get_kernel_r1/1","type":"function"},{"doc":"Raising version of get_model/1 .","ref":"Evision.TrackerDaSiamRPN.Params.html#get_model!/1","title":"Evision.TrackerDaSiamRPN.Params.get_model!/1","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#get_model/1","title":"Evision.TrackerDaSiamRPN.Params.get_model/1","type":"function"},{"doc":"Raising version of get_target/1 .","ref":"Evision.TrackerDaSiamRPN.Params.html#get_target!/1","title":"Evision.TrackerDaSiamRPN.Params.get_target!/1","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#get_target/1","title":"Evision.TrackerDaSiamRPN.Params.get_target/1","type":"function"},{"doc":"Raising version of set_backend/2 .","ref":"Evision.TrackerDaSiamRPN.Params.html#set_backend!/2","title":"Evision.TrackerDaSiamRPN.Params.set_backend!/2","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#set_backend/2","title":"Evision.TrackerDaSiamRPN.Params.set_backend/2","type":"function"},{"doc":"Raising version of set_kernel_cls1/2 .","ref":"Evision.TrackerDaSiamRPN.Params.html#set_kernel_cls1!/2","title":"Evision.TrackerDaSiamRPN.Params.set_kernel_cls1!/2","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#set_kernel_cls1/2","title":"Evision.TrackerDaSiamRPN.Params.set_kernel_cls1/2","type":"function"},{"doc":"Raising version of set_kernel_r1/2 .","ref":"Evision.TrackerDaSiamRPN.Params.html#set_kernel_r1!/2","title":"Evision.TrackerDaSiamRPN.Params.set_kernel_r1!/2","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#set_kernel_r1/2","title":"Evision.TrackerDaSiamRPN.Params.set_kernel_r1/2","type":"function"},{"doc":"Raising version of set_model/2 .","ref":"Evision.TrackerDaSiamRPN.Params.html#set_model!/2","title":"Evision.TrackerDaSiamRPN.Params.set_model!/2","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#set_model/2","title":"Evision.TrackerDaSiamRPN.Params.set_model/2","type":"function"},{"doc":"Raising version of set_target/2 .","ref":"Evision.TrackerDaSiamRPN.Params.html#set_target!/2","title":"Evision.TrackerDaSiamRPN.Params.set_target!/2","type":"function"},{"doc":"","ref":"Evision.TrackerDaSiamRPN.Params.html#set_target/2","title":"Evision.TrackerDaSiamRPN.Params.set_target/2","type":"function"},{"doc":"Raising version of trackerDaSiamRPN_Params/0 .","ref":"Evision.TrackerDaSiamRPN.Params.html#trackerDaSiamRPN_Params!/0","title":"Evision.TrackerDaSiamRPN.Params.trackerDaSiamRPN_Params!/0","type":"function"},{"doc":"Python prototype (for reference): TrackerDaSiamRPN_Params() -&gt; &lt;TrackerDaSiamRPN_Params object&gt;","ref":"Evision.TrackerDaSiamRPN.Params.html#trackerDaSiamRPN_Params/0","title":"Evision.TrackerDaSiamRPN.Params.trackerDaSiamRPN_Params/0","type":"function"},{"doc":"","ref":"Evision.TrackerGOTURN.html","title":"Evision.TrackerGOTURN","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.TrackerGOTURN.html#create!/0","title":"Evision.TrackerGOTURN.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.TrackerGOTURN.html#create!/1","title":"Evision.TrackerGOTURN.create!/1","type":"function"},{"doc":"Constructor Keyword Arguments parameters : TrackerGOTURN_Params . GOTURN parameters TrackerGOTURN::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.TrackerGOTURN.html#create/0","title":"Evision.TrackerGOTURN.create/0","type":"function"},{"doc":"Constructor Keyword Arguments parameters : TrackerGOTURN_Params . GOTURN parameters TrackerGOTURN::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.TrackerGOTURN.html#create/1","title":"Evision.TrackerGOTURN.create/1","type":"function"},{"doc":"","ref":"Evision.TrackerGOTURN.Params.html","title":"Evision.TrackerGOTURN.Params","type":"module"},{"doc":"Raising version of get_modelBin/1 .","ref":"Evision.TrackerGOTURN.Params.html#get_modelBin!/1","title":"Evision.TrackerGOTURN.Params.get_modelBin!/1","type":"function"},{"doc":"","ref":"Evision.TrackerGOTURN.Params.html#get_modelBin/1","title":"Evision.TrackerGOTURN.Params.get_modelBin/1","type":"function"},{"doc":"Raising version of get_modelTxt/1 .","ref":"Evision.TrackerGOTURN.Params.html#get_modelTxt!/1","title":"Evision.TrackerGOTURN.Params.get_modelTxt!/1","type":"function"},{"doc":"","ref":"Evision.TrackerGOTURN.Params.html#get_modelTxt/1","title":"Evision.TrackerGOTURN.Params.get_modelTxt/1","type":"function"},{"doc":"Raising version of set_modelBin/2 .","ref":"Evision.TrackerGOTURN.Params.html#set_modelBin!/2","title":"Evision.TrackerGOTURN.Params.set_modelBin!/2","type":"function"},{"doc":"","ref":"Evision.TrackerGOTURN.Params.html#set_modelBin/2","title":"Evision.TrackerGOTURN.Params.set_modelBin/2","type":"function"},{"doc":"Raising version of set_modelTxt/2 .","ref":"Evision.TrackerGOTURN.Params.html#set_modelTxt!/2","title":"Evision.TrackerGOTURN.Params.set_modelTxt!/2","type":"function"},{"doc":"","ref":"Evision.TrackerGOTURN.Params.html#set_modelTxt/2","title":"Evision.TrackerGOTURN.Params.set_modelTxt/2","type":"function"},{"doc":"Raising version of trackerGOTURN_Params/0 .","ref":"Evision.TrackerGOTURN.Params.html#trackerGOTURN_Params!/0","title":"Evision.TrackerGOTURN.Params.trackerGOTURN_Params!/0","type":"function"},{"doc":"Python prototype (for reference): TrackerGOTURN_Params() -&gt; &lt;TrackerGOTURN_Params object&gt;","ref":"Evision.TrackerGOTURN.Params.html#trackerGOTURN_Params/0","title":"Evision.TrackerGOTURN.Params.trackerGOTURN_Params/0","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.html","title":"Evision.TrackerMIL","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.TrackerMIL.html#create!/0","title":"Evision.TrackerMIL.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.TrackerMIL.html#create!/1","title":"Evision.TrackerMIL.create!/1","type":"function"},{"doc":"Create MIL tracker instance Keyword Arguments parameters : TrackerMIL_Params . MIL parameters TrackerMIL::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.TrackerMIL.html#create/0","title":"Evision.TrackerMIL.create/0","type":"function"},{"doc":"Create MIL tracker instance Keyword Arguments parameters : TrackerMIL_Params . MIL parameters TrackerMIL::Params Python prototype (for reference): create([, parameters]) -&gt; retval","ref":"Evision.TrackerMIL.html#create/1","title":"Evision.TrackerMIL.create/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html","title":"Evision.TrackerMIL.Params","type":"module"},{"doc":"Raising version of get_featureSetNumFeatures/1 .","ref":"Evision.TrackerMIL.Params.html#get_featureSetNumFeatures!/1","title":"Evision.TrackerMIL.Params.get_featureSetNumFeatures!/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#get_featureSetNumFeatures/1","title":"Evision.TrackerMIL.Params.get_featureSetNumFeatures/1","type":"function"},{"doc":"Raising version of get_samplerInitInRadius/1 .","ref":"Evision.TrackerMIL.Params.html#get_samplerInitInRadius!/1","title":"Evision.TrackerMIL.Params.get_samplerInitInRadius!/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#get_samplerInitInRadius/1","title":"Evision.TrackerMIL.Params.get_samplerInitInRadius/1","type":"function"},{"doc":"Raising version of get_samplerInitMaxNegNum/1 .","ref":"Evision.TrackerMIL.Params.html#get_samplerInitMaxNegNum!/1","title":"Evision.TrackerMIL.Params.get_samplerInitMaxNegNum!/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#get_samplerInitMaxNegNum/1","title":"Evision.TrackerMIL.Params.get_samplerInitMaxNegNum/1","type":"function"},{"doc":"Raising version of get_samplerSearchWinSize/1 .","ref":"Evision.TrackerMIL.Params.html#get_samplerSearchWinSize!/1","title":"Evision.TrackerMIL.Params.get_samplerSearchWinSize!/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#get_samplerSearchWinSize/1","title":"Evision.TrackerMIL.Params.get_samplerSearchWinSize/1","type":"function"},{"doc":"Raising version of get_samplerTrackInRadius/1 .","ref":"Evision.TrackerMIL.Params.html#get_samplerTrackInRadius!/1","title":"Evision.TrackerMIL.Params.get_samplerTrackInRadius!/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#get_samplerTrackInRadius/1","title":"Evision.TrackerMIL.Params.get_samplerTrackInRadius/1","type":"function"},{"doc":"Raising version of get_samplerTrackMaxNegNum/1 .","ref":"Evision.TrackerMIL.Params.html#get_samplerTrackMaxNegNum!/1","title":"Evision.TrackerMIL.Params.get_samplerTrackMaxNegNum!/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#get_samplerTrackMaxNegNum/1","title":"Evision.TrackerMIL.Params.get_samplerTrackMaxNegNum/1","type":"function"},{"doc":"Raising version of get_samplerTrackMaxPosNum/1 .","ref":"Evision.TrackerMIL.Params.html#get_samplerTrackMaxPosNum!/1","title":"Evision.TrackerMIL.Params.get_samplerTrackMaxPosNum!/1","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#get_samplerTrackMaxPosNum/1","title":"Evision.TrackerMIL.Params.get_samplerTrackMaxPosNum/1","type":"function"},{"doc":"Raising version of set_featureSetNumFeatures/2 .","ref":"Evision.TrackerMIL.Params.html#set_featureSetNumFeatures!/2","title":"Evision.TrackerMIL.Params.set_featureSetNumFeatures!/2","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#set_featureSetNumFeatures/2","title":"Evision.TrackerMIL.Params.set_featureSetNumFeatures/2","type":"function"},{"doc":"Raising version of set_samplerInitInRadius/2 .","ref":"Evision.TrackerMIL.Params.html#set_samplerInitInRadius!/2","title":"Evision.TrackerMIL.Params.set_samplerInitInRadius!/2","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#set_samplerInitInRadius/2","title":"Evision.TrackerMIL.Params.set_samplerInitInRadius/2","type":"function"},{"doc":"Raising version of set_samplerInitMaxNegNum/2 .","ref":"Evision.TrackerMIL.Params.html#set_samplerInitMaxNegNum!/2","title":"Evision.TrackerMIL.Params.set_samplerInitMaxNegNum!/2","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#set_samplerInitMaxNegNum/2","title":"Evision.TrackerMIL.Params.set_samplerInitMaxNegNum/2","type":"function"},{"doc":"Raising version of set_samplerSearchWinSize/2 .","ref":"Evision.TrackerMIL.Params.html#set_samplerSearchWinSize!/2","title":"Evision.TrackerMIL.Params.set_samplerSearchWinSize!/2","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#set_samplerSearchWinSize/2","title":"Evision.TrackerMIL.Params.set_samplerSearchWinSize/2","type":"function"},{"doc":"Raising version of set_samplerTrackInRadius/2 .","ref":"Evision.TrackerMIL.Params.html#set_samplerTrackInRadius!/2","title":"Evision.TrackerMIL.Params.set_samplerTrackInRadius!/2","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#set_samplerTrackInRadius/2","title":"Evision.TrackerMIL.Params.set_samplerTrackInRadius/2","type":"function"},{"doc":"Raising version of set_samplerTrackMaxNegNum/2 .","ref":"Evision.TrackerMIL.Params.html#set_samplerTrackMaxNegNum!/2","title":"Evision.TrackerMIL.Params.set_samplerTrackMaxNegNum!/2","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#set_samplerTrackMaxNegNum/2","title":"Evision.TrackerMIL.Params.set_samplerTrackMaxNegNum/2","type":"function"},{"doc":"Raising version of set_samplerTrackMaxPosNum/2 .","ref":"Evision.TrackerMIL.Params.html#set_samplerTrackMaxPosNum!/2","title":"Evision.TrackerMIL.Params.set_samplerTrackMaxPosNum!/2","type":"function"},{"doc":"","ref":"Evision.TrackerMIL.Params.html#set_samplerTrackMaxPosNum/2","title":"Evision.TrackerMIL.Params.set_samplerTrackMaxPosNum/2","type":"function"},{"doc":"Raising version of trackerMIL_Params/0 .","ref":"Evision.TrackerMIL.Params.html#trackerMIL_Params!/0","title":"Evision.TrackerMIL.Params.trackerMIL_Params!/0","type":"function"},{"doc":"Python prototype (for reference): TrackerMIL_Params() -&gt; &lt;TrackerMIL_Params object&gt;","ref":"Evision.TrackerMIL.Params.html#trackerMIL_Params/0","title":"Evision.TrackerMIL.Params.trackerMIL_Params/0","type":"function"},{"doc":"","ref":"Evision.UMat.html","title":"Evision.UMat","type":"module"},{"doc":"Raising version of context/0 .","ref":"Evision.UMat.html#context!/0","title":"Evision.UMat.context!/0","type":"function"},{"doc":"Python prototype (for reference): context() -&gt; retval","ref":"Evision.UMat.html#context/0","title":"Evision.UMat.context/0","type":"function"},{"doc":"Raising version of get/1 .","ref":"Evision.UMat.html#get!/1","title":"Evision.UMat.get!/1","type":"function"},{"doc":"Python prototype (for reference): get() -&gt; retval","ref":"Evision.UMat.html#get/1","title":"Evision.UMat.get/1","type":"function"},{"doc":"Raising version of get_offset/1 .","ref":"Evision.UMat.html#get_offset!/1","title":"Evision.UMat.get_offset!/1","type":"function"},{"doc":"","ref":"Evision.UMat.html#get_offset/1","title":"Evision.UMat.get_offset/1","type":"function"},{"doc":"Raising version of handle/2 .","ref":"Evision.UMat.html#handle!/2","title":"Evision.UMat.handle!/2","type":"function"},{"doc":"Positional Arguments accessFlags : AccessFlag Python prototype (for reference): handle(accessFlags) -&gt; retval","ref":"Evision.UMat.html#handle/2","title":"Evision.UMat.handle/2","type":"function"},{"doc":"Raising version of isContinuous/1 .","ref":"Evision.UMat.html#isContinuous!/1","title":"Evision.UMat.isContinuous!/1","type":"function"},{"doc":"Python prototype (for reference): isContinuous() -&gt; retval","ref":"Evision.UMat.html#isContinuous/1","title":"Evision.UMat.isContinuous/1","type":"function"},{"doc":"Raising version of isSubmatrix/1 .","ref":"Evision.UMat.html#isSubmatrix!/1","title":"Evision.UMat.isSubmatrix!/1","type":"function"},{"doc":"Python prototype (for reference): isSubmatrix() -&gt; retval","ref":"Evision.UMat.html#isSubmatrix/1","title":"Evision.UMat.isSubmatrix/1","type":"function"},{"doc":"Raising version of queue/0 .","ref":"Evision.UMat.html#queue!/0","title":"Evision.UMat.queue!/0","type":"function"},{"doc":"Python prototype (for reference): queue() -&gt; retval","ref":"Evision.UMat.html#queue/0","title":"Evision.UMat.queue/0","type":"function"},{"doc":"Raising version of set_offset/2 .","ref":"Evision.UMat.html#set_offset!/2","title":"Evision.UMat.set_offset!/2","type":"function"},{"doc":"","ref":"Evision.UMat.html#set_offset/2","title":"Evision.UMat.set_offset/2","type":"function"},{"doc":"Raising version of uMat/0 .","ref":"Evision.UMat.html#uMat!/0","title":"Evision.UMat.uMat!/0","type":"function"},{"doc":"Raising version of uMat/1 .","ref":"Evision.UMat.html#uMat!/1","title":"Evision.UMat.uMat!/1","type":"function"},{"doc":"Raising version of uMat/2 .","ref":"Evision.UMat.html#uMat!/2","title":"Evision.UMat.uMat!/2","type":"function"},{"doc":"Raising version of uMat/3 .","ref":"Evision.UMat.html#uMat!/3","title":"Evision.UMat.uMat!/3","type":"function"},{"doc":"Raising version of uMat/4 .","ref":"Evision.UMat.html#uMat!/4","title":"Evision.UMat.uMat!/4","type":"function"},{"doc":"Raising version of uMat/5 .","ref":"Evision.UMat.html#uMat!/5","title":"Evision.UMat.uMat!/5","type":"function"},{"doc":"##### Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat([, usageFlags]) -&gt; &lt;UMat object&gt;","ref":"Evision.UMat.html#uMat/0","title":"Evision.UMat.uMat/0","type":"function"},{"doc":"Variant 1: Positional Arguments m : Evision.Mat Python prototype (for reference): UMat(m) -&gt; &lt;UMat object&gt; Variant 2: ##### Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat([, usageFlags]) -&gt; &lt;UMat object&gt;","ref":"Evision.UMat.html#uMat/1","title":"Evision.UMat.uMat/1","type":"function"},{"doc":"Variant 1: Positional Arguments m : Evision.Mat ranges : [Range] Python prototype (for reference): UMat(m, ranges) -&gt; &lt;UMat object&gt; Variant 2: Positional Arguments m : Evision.Mat roi : Rect Python prototype (for reference): UMat(m, roi) -&gt; &lt;UMat object&gt; Variant 3: Positional Arguments size : Size type : int Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(size, type[, usageFlags]) -&gt; &lt;UMat object&gt;","ref":"Evision.UMat.html#uMat/2","title":"Evision.UMat.uMat/2","type":"function"},{"doc":"Variant 1: Positional Arguments size : Size type : int s : Scalar Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(size, type, s[, usageFlags]) -&gt; &lt;UMat object&gt; Variant 2: Positional Arguments rows : int cols : int type : int Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(rows, cols, type[, usageFlags]) -&gt; &lt;UMat object&gt; Variant 3: Positional Arguments size : Size type : int Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(size, type[, usageFlags]) -&gt; &lt;UMat object&gt;","ref":"Evision.UMat.html#uMat/3","title":"Evision.UMat.uMat/3","type":"function"},{"doc":"Variant 1: Positional Arguments rows : int cols : int type : int s : Scalar Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(rows, cols, type, s[, usageFlags]) -&gt; &lt;UMat object&gt; Variant 2: Positional Arguments size : Size type : int s : Scalar Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(size, type, s[, usageFlags]) -&gt; &lt;UMat object&gt; Variant 3: Positional Arguments rows : int cols : int type : int Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(rows, cols, type[, usageFlags]) -&gt; &lt;UMat object&gt;","ref":"Evision.UMat.html#uMat/4","title":"Evision.UMat.uMat/4","type":"function"},{"doc":"Positional Arguments rows : int cols : int type : int s : Scalar Keyword Arguments usageFlags : UMatUsageFlags . Python prototype (for reference): UMat(rows, cols, type, s[, usageFlags]) -&gt; &lt;UMat object&gt;","ref":"Evision.UMat.html#uMat/5","title":"Evision.UMat.uMat/5","type":"function"},{"doc":"","ref":"Evision.UsacParams.html","title":"Evision.UsacParams","type":"module"},{"doc":"Raising version of get_confidence/1 .","ref":"Evision.UsacParams.html#get_confidence!/1","title":"Evision.UsacParams.get_confidence!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_confidence/1","title":"Evision.UsacParams.get_confidence/1","type":"function"},{"doc":"Raising version of get_isParallel/1 .","ref":"Evision.UsacParams.html#get_isParallel!/1","title":"Evision.UsacParams.get_isParallel!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_isParallel/1","title":"Evision.UsacParams.get_isParallel/1","type":"function"},{"doc":"Raising version of get_loIterations/1 .","ref":"Evision.UsacParams.html#get_loIterations!/1","title":"Evision.UsacParams.get_loIterations!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_loIterations/1","title":"Evision.UsacParams.get_loIterations/1","type":"function"},{"doc":"Raising version of get_loMethod/1 .","ref":"Evision.UsacParams.html#get_loMethod!/1","title":"Evision.UsacParams.get_loMethod!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_loMethod/1","title":"Evision.UsacParams.get_loMethod/1","type":"function"},{"doc":"Raising version of get_loSampleSize/1 .","ref":"Evision.UsacParams.html#get_loSampleSize!/1","title":"Evision.UsacParams.get_loSampleSize!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_loSampleSize/1","title":"Evision.UsacParams.get_loSampleSize/1","type":"function"},{"doc":"Raising version of get_maxIterations/1 .","ref":"Evision.UsacParams.html#get_maxIterations!/1","title":"Evision.UsacParams.get_maxIterations!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_maxIterations/1","title":"Evision.UsacParams.get_maxIterations/1","type":"function"},{"doc":"Raising version of get_neighborsSearch/1 .","ref":"Evision.UsacParams.html#get_neighborsSearch!/1","title":"Evision.UsacParams.get_neighborsSearch!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_neighborsSearch/1","title":"Evision.UsacParams.get_neighborsSearch/1","type":"function"},{"doc":"Raising version of get_randomGeneratorState/1 .","ref":"Evision.UsacParams.html#get_randomGeneratorState!/1","title":"Evision.UsacParams.get_randomGeneratorState!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_randomGeneratorState/1","title":"Evision.UsacParams.get_randomGeneratorState/1","type":"function"},{"doc":"Raising version of get_sampler/1 .","ref":"Evision.UsacParams.html#get_sampler!/1","title":"Evision.UsacParams.get_sampler!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_sampler/1","title":"Evision.UsacParams.get_sampler/1","type":"function"},{"doc":"Raising version of get_score/1 .","ref":"Evision.UsacParams.html#get_score!/1","title":"Evision.UsacParams.get_score!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_score/1","title":"Evision.UsacParams.get_score/1","type":"function"},{"doc":"Raising version of get_threshold/1 .","ref":"Evision.UsacParams.html#get_threshold!/1","title":"Evision.UsacParams.get_threshold!/1","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#get_threshold/1","title":"Evision.UsacParams.get_threshold/1","type":"function"},{"doc":"Raising version of set_confidence/2 .","ref":"Evision.UsacParams.html#set_confidence!/2","title":"Evision.UsacParams.set_confidence!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_confidence/2","title":"Evision.UsacParams.set_confidence/2","type":"function"},{"doc":"Raising version of set_isParallel/2 .","ref":"Evision.UsacParams.html#set_isParallel!/2","title":"Evision.UsacParams.set_isParallel!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_isParallel/2","title":"Evision.UsacParams.set_isParallel/2","type":"function"},{"doc":"Raising version of set_loIterations/2 .","ref":"Evision.UsacParams.html#set_loIterations!/2","title":"Evision.UsacParams.set_loIterations!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_loIterations/2","title":"Evision.UsacParams.set_loIterations/2","type":"function"},{"doc":"Raising version of set_loMethod/2 .","ref":"Evision.UsacParams.html#set_loMethod!/2","title":"Evision.UsacParams.set_loMethod!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_loMethod/2","title":"Evision.UsacParams.set_loMethod/2","type":"function"},{"doc":"Raising version of set_loSampleSize/2 .","ref":"Evision.UsacParams.html#set_loSampleSize!/2","title":"Evision.UsacParams.set_loSampleSize!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_loSampleSize/2","title":"Evision.UsacParams.set_loSampleSize/2","type":"function"},{"doc":"Raising version of set_maxIterations/2 .","ref":"Evision.UsacParams.html#set_maxIterations!/2","title":"Evision.UsacParams.set_maxIterations!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_maxIterations/2","title":"Evision.UsacParams.set_maxIterations/2","type":"function"},{"doc":"Raising version of set_neighborsSearch/2 .","ref":"Evision.UsacParams.html#set_neighborsSearch!/2","title":"Evision.UsacParams.set_neighborsSearch!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_neighborsSearch/2","title":"Evision.UsacParams.set_neighborsSearch/2","type":"function"},{"doc":"Raising version of set_randomGeneratorState/2 .","ref":"Evision.UsacParams.html#set_randomGeneratorState!/2","title":"Evision.UsacParams.set_randomGeneratorState!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_randomGeneratorState/2","title":"Evision.UsacParams.set_randomGeneratorState/2","type":"function"},{"doc":"Raising version of set_sampler/2 .","ref":"Evision.UsacParams.html#set_sampler!/2","title":"Evision.UsacParams.set_sampler!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_sampler/2","title":"Evision.UsacParams.set_sampler/2","type":"function"},{"doc":"Raising version of set_score/2 .","ref":"Evision.UsacParams.html#set_score!/2","title":"Evision.UsacParams.set_score!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_score/2","title":"Evision.UsacParams.set_score/2","type":"function"},{"doc":"Raising version of set_threshold/2 .","ref":"Evision.UsacParams.html#set_threshold!/2","title":"Evision.UsacParams.set_threshold!/2","type":"function"},{"doc":"","ref":"Evision.UsacParams.html#set_threshold/2","title":"Evision.UsacParams.set_threshold/2","type":"function"},{"doc":"Raising version of usacParams/0 .","ref":"Evision.UsacParams.html#usacParams!/0","title":"Evision.UsacParams.usacParams!/0","type":"function"},{"doc":"Python prototype (for reference): UsacParams() -&gt; &lt;UsacParams object&gt;","ref":"Evision.UsacParams.html#usacParams/0","title":"Evision.UsacParams.usacParams/0","type":"function"},{"doc":"","ref":"Evision.Utils.html","title":"Evision.Utils","type":"module"},{"doc":"Raising version of dumpBool/1 .","ref":"Evision.Utils.html#dumpBool!/1","title":"Evision.Utils.dumpBool!/1","type":"function"},{"doc":"Positional Arguments argument : bool Python prototype (for reference): dumpBool(argument) -&gt; retval","ref":"Evision.Utils.html#dumpBool/1","title":"Evision.Utils.dumpBool/1","type":"function"},{"doc":"Raising version of dumpCString/1 .","ref":"Evision.Utils.html#dumpCString!/1","title":"Evision.Utils.dumpCString!/1","type":"function"},{"doc":"Positional Arguments argument : c_string Python prototype (for reference): dumpCString(argument) -&gt; retval","ref":"Evision.Utils.html#dumpCString/1","title":"Evision.Utils.dumpCString/1","type":"function"},{"doc":"Raising version of dumpDouble/1 .","ref":"Evision.Utils.html#dumpDouble!/1","title":"Evision.Utils.dumpDouble!/1","type":"function"},{"doc":"Positional Arguments argument : double Python prototype (for reference): dumpDouble(argument) -&gt; retval","ref":"Evision.Utils.html#dumpDouble/1","title":"Evision.Utils.dumpDouble/1","type":"function"},{"doc":"Raising version of dumpFloat/1 .","ref":"Evision.Utils.html#dumpFloat!/1","title":"Evision.Utils.dumpFloat!/1","type":"function"},{"doc":"Positional Arguments argument : float Python prototype (for reference): dumpFloat(argument) -&gt; retval","ref":"Evision.Utils.html#dumpFloat/1","title":"Evision.Utils.dumpFloat/1","type":"function"},{"doc":"Raising version of dumpInputArray/1 .","ref":"Evision.Utils.html#dumpInputArray!/1","title":"Evision.Utils.dumpInputArray!/1","type":"function"},{"doc":"Positional Arguments argument : Evision.Mat Python prototype (for reference): dumpInputArray(argument) -&gt; retval","ref":"Evision.Utils.html#dumpInputArray/1","title":"Evision.Utils.dumpInputArray/1","type":"function"},{"doc":"Raising version of dumpInputArrayOfArrays/1 .","ref":"Evision.Utils.html#dumpInputArrayOfArrays!/1","title":"Evision.Utils.dumpInputArrayOfArrays!/1","type":"function"},{"doc":"Positional Arguments argument : [Evision.Mat] Python prototype (for reference): dumpInputArrayOfArrays(argument) -&gt; retval","ref":"Evision.Utils.html#dumpInputArrayOfArrays/1","title":"Evision.Utils.dumpInputArrayOfArrays/1","type":"function"},{"doc":"Raising version of dumpInputOutputArray/1 .","ref":"Evision.Utils.html#dumpInputOutputArray!/1","title":"Evision.Utils.dumpInputOutputArray!/1","type":"function"},{"doc":"##### Return argument : Evision.Mat Python prototype (for reference): dumpInputOutputArray(argument) -&gt; retval, argument","ref":"Evision.Utils.html#dumpInputOutputArray/1","title":"Evision.Utils.dumpInputOutputArray/1","type":"function"},{"doc":"Raising version of dumpInputOutputArrayOfArrays/1 .","ref":"Evision.Utils.html#dumpInputOutputArrayOfArrays!/1","title":"Evision.Utils.dumpInputOutputArrayOfArrays!/1","type":"function"},{"doc":"##### Return argument : [Evision.Mat] Python prototype (for reference): dumpInputOutputArrayOfArrays(argument) -&gt; retval, argument","ref":"Evision.Utils.html#dumpInputOutputArrayOfArrays/1","title":"Evision.Utils.dumpInputOutputArrayOfArrays/1","type":"function"},{"doc":"Raising version of dumpInt/1 .","ref":"Evision.Utils.html#dumpInt!/1","title":"Evision.Utils.dumpInt!/1","type":"function"},{"doc":"Positional Arguments argument : int Python prototype (for reference): dumpInt(argument) -&gt; retval","ref":"Evision.Utils.html#dumpInt/1","title":"Evision.Utils.dumpInt/1","type":"function"},{"doc":"Raising version of dumpRange/1 .","ref":"Evision.Utils.html#dumpRange!/1","title":"Evision.Utils.dumpRange!/1","type":"function"},{"doc":"Positional Arguments argument : Range Python prototype (for reference): dumpRange(argument) -&gt; retval","ref":"Evision.Utils.html#dumpRange/1","title":"Evision.Utils.dumpRange/1","type":"function"},{"doc":"Raising version of dumpRect/1 .","ref":"Evision.Utils.html#dumpRect!/1","title":"Evision.Utils.dumpRect!/1","type":"function"},{"doc":"Positional Arguments argument : Rect Python prototype (for reference): dumpRect(argument) -&gt; retval","ref":"Evision.Utils.html#dumpRect/1","title":"Evision.Utils.dumpRect/1","type":"function"},{"doc":"Raising version of dumpRotatedRect/1 .","ref":"Evision.Utils.html#dumpRotatedRect!/1","title":"Evision.Utils.dumpRotatedRect!/1","type":"function"},{"doc":"Positional Arguments argument : {centre={x, y}, size={s1, s2}, angle} Python prototype (for reference): dumpRotatedRect(argument) -&gt; retval","ref":"Evision.Utils.html#dumpRotatedRect/1","title":"Evision.Utils.dumpRotatedRect/1","type":"function"},{"doc":"Raising version of dumpSizeT/1 .","ref":"Evision.Utils.html#dumpSizeT!/1","title":"Evision.Utils.dumpSizeT!/1","type":"function"},{"doc":"Positional Arguments argument : size_t Python prototype (for reference): dumpSizeT(argument) -&gt; retval","ref":"Evision.Utils.html#dumpSizeT/1","title":"Evision.Utils.dumpSizeT/1","type":"function"},{"doc":"Raising version of dumpString/1 .","ref":"Evision.Utils.html#dumpString!/1","title":"Evision.Utils.dumpString!/1","type":"function"},{"doc":"Positional Arguments argument : String Python prototype (for reference): dumpString(argument) -&gt; retval","ref":"Evision.Utils.html#dumpString/1","title":"Evision.Utils.dumpString/1","type":"function"},{"doc":"Raising version of dumpTermCriteria/1 .","ref":"Evision.Utils.html#dumpTermCriteria!/1","title":"Evision.Utils.dumpTermCriteria!/1","type":"function"},{"doc":"Positional Arguments argument : TermCriteria Python prototype (for reference): dumpTermCriteria(argument) -&gt; retval","ref":"Evision.Utils.html#dumpTermCriteria/1","title":"Evision.Utils.dumpTermCriteria/1","type":"function"},{"doc":"Raising version of dumpVectorOfDouble/1 .","ref":"Evision.Utils.html#dumpVectorOfDouble!/1","title":"Evision.Utils.dumpVectorOfDouble!/1","type":"function"},{"doc":"Positional Arguments vec : [double] Python prototype (for reference): dumpVectorOfDouble(vec) -&gt; retval","ref":"Evision.Utils.html#dumpVectorOfDouble/1","title":"Evision.Utils.dumpVectorOfDouble/1","type":"function"},{"doc":"Raising version of dumpVectorOfInt/1 .","ref":"Evision.Utils.html#dumpVectorOfInt!/1","title":"Evision.Utils.dumpVectorOfInt!/1","type":"function"},{"doc":"Positional Arguments vec : [int] Python prototype (for reference): dumpVectorOfInt(vec) -&gt; retval","ref":"Evision.Utils.html#dumpVectorOfInt/1","title":"Evision.Utils.dumpVectorOfInt/1","type":"function"},{"doc":"Raising version of dumpVectorOfRect/1 .","ref":"Evision.Utils.html#dumpVectorOfRect!/1","title":"Evision.Utils.dumpVectorOfRect!/1","type":"function"},{"doc":"Positional Arguments vec : [Rect] Python prototype (for reference): dumpVectorOfRect(vec) -&gt; retval","ref":"Evision.Utils.html#dumpVectorOfRect/1","title":"Evision.Utils.dumpVectorOfRect/1","type":"function"},{"doc":"Raising version of generateVectorOfInt/1 .","ref":"Evision.Utils.html#generateVectorOfInt!/1","title":"Evision.Utils.generateVectorOfInt!/1","type":"function"},{"doc":"Positional Arguments len : size_t Return vec : [int] Python prototype (for reference): generateVectorOfInt(len) -&gt; vec","ref":"Evision.Utils.html#generateVectorOfInt/1","title":"Evision.Utils.generateVectorOfInt/1","type":"function"},{"doc":"Raising version of generateVectorOfMat/4 .","ref":"Evision.Utils.html#generateVectorOfMat!/4","title":"Evision.Utils.generateVectorOfMat!/4","type":"function"},{"doc":"Raising version of generateVectorOfMat/5 .","ref":"Evision.Utils.html#generateVectorOfMat!/5","title":"Evision.Utils.generateVectorOfMat!/5","type":"function"},{"doc":"Positional Arguments len : size_t rows : int cols : int dtype : int Return vec : [Evision.Mat] . Python prototype (for reference): generateVectorOfMat(len, rows, cols, dtype[, vec]) -&gt; vec","ref":"Evision.Utils.html#generateVectorOfMat/4","title":"Evision.Utils.generateVectorOfMat/4","type":"function"},{"doc":"Positional Arguments len : size_t rows : int cols : int dtype : int Return vec : [Evision.Mat] . Python prototype (for reference): generateVectorOfMat(len, rows, cols, dtype[, vec]) -&gt; vec","ref":"Evision.Utils.html#generateVectorOfMat/5","title":"Evision.Utils.generateVectorOfMat/5","type":"function"},{"doc":"Raising version of generateVectorOfRect/1 .","ref":"Evision.Utils.html#generateVectorOfRect!/1","title":"Evision.Utils.generateVectorOfRect!/1","type":"function"},{"doc":"Positional Arguments len : size_t Return vec : [Rect] Python prototype (for reference): generateVectorOfRect(len) -&gt; vec","ref":"Evision.Utils.html#generateVectorOfRect/1","title":"Evision.Utils.generateVectorOfRect/1","type":"function"},{"doc":"Raising version of testAsyncArray/1 .","ref":"Evision.Utils.html#testAsyncArray!/1","title":"Evision.Utils.testAsyncArray!/1","type":"function"},{"doc":"Positional Arguments argument : Evision.Mat Python prototype (for reference): testAsyncArray(argument) -&gt; retval","ref":"Evision.Utils.html#testAsyncArray/1","title":"Evision.Utils.testAsyncArray/1","type":"function"},{"doc":"Raising version of testAsyncException/0 .","ref":"Evision.Utils.html#testAsyncException!/0","title":"Evision.Utils.testAsyncException!/0","type":"function"},{"doc":"Python prototype (for reference): testAsyncException() -&gt; retval","ref":"Evision.Utils.html#testAsyncException/0","title":"Evision.Utils.testAsyncException/0","type":"function"},{"doc":"Raising version of testOverloadResolution/1 .","ref":"Evision.Utils.html#testOverloadResolution!/1","title":"Evision.Utils.testOverloadResolution!/1","type":"function"},{"doc":"Raising version of testOverloadResolution/2 .","ref":"Evision.Utils.html#testOverloadResolution!/2","title":"Evision.Utils.testOverloadResolution!/2","type":"function"},{"doc":"Variant 1: Positional Arguments rect : Rect Python prototype (for reference): testOverloadResolution(rect) -&gt; retval Variant 2: Positional Arguments value : int Keyword Arguments point : Point . Python prototype (for reference): testOverloadResolution(value[, point]) -&gt; retval","ref":"Evision.Utils.html#testOverloadResolution/1","title":"Evision.Utils.testOverloadResolution/1","type":"function"},{"doc":"Positional Arguments value : int Keyword Arguments point : Point . Python prototype (for reference): testOverloadResolution(value[, point]) -&gt; retval","ref":"Evision.Utils.html#testOverloadResolution/2","title":"Evision.Utils.testOverloadResolution/2","type":"function"},{"doc":"Raising version of testOverwriteNativeMethod/1 .","ref":"Evision.Utils.html#testOverwriteNativeMethod!/1","title":"Evision.Utils.testOverwriteNativeMethod!/1","type":"function"},{"doc":"Positional Arguments argument : int Python prototype (for reference): testOverwriteNativeMethod(argument) -&gt; retval","ref":"Evision.Utils.html#testOverwriteNativeMethod/1","title":"Evision.Utils.testOverwriteNativeMethod/1","type":"function"},{"doc":"Raising version of testRaiseGeneralException/0 .","ref":"Evision.Utils.html#testRaiseGeneralException!/0","title":"Evision.Utils.testRaiseGeneralException!/0","type":"function"},{"doc":"Python prototype (for reference): testRaiseGeneralException() -&gt; None","ref":"Evision.Utils.html#testRaiseGeneralException/0","title":"Evision.Utils.testRaiseGeneralException/0","type":"function"},{"doc":"Raising version of testReservedKeywordConversion/1 .","ref":"Evision.Utils.html#testReservedKeywordConversion!/1","title":"Evision.Utils.testReservedKeywordConversion!/1","type":"function"},{"doc":"Raising version of testReservedKeywordConversion/2 .","ref":"Evision.Utils.html#testReservedKeywordConversion!/2","title":"Evision.Utils.testReservedKeywordConversion!/2","type":"function"},{"doc":"Positional Arguments positional_argument : int Keyword Arguments lambda : int . from : int . Python prototype (for reference): testReservedKeywordConversion(positional_argument[, lambda[, from]]) -&gt; retval","ref":"Evision.Utils.html#testReservedKeywordConversion/1","title":"Evision.Utils.testReservedKeywordConversion/1","type":"function"},{"doc":"Positional Arguments positional_argument : int Keyword Arguments lambda : int . from : int . Python prototype (for reference): testReservedKeywordConversion(positional_argument[, lambda[, from]]) -&gt; retval","ref":"Evision.Utils.html#testReservedKeywordConversion/2","title":"Evision.Utils.testReservedKeywordConversion/2","type":"function"},{"doc":"Raising version of testRotatedRect/5 .","ref":"Evision.Utils.html#testRotatedRect!/5","title":"Evision.Utils.testRotatedRect!/5","type":"function"},{"doc":"Positional Arguments x : float y : float w : float h : float angle : float Python prototype (for reference): testRotatedRect(x, y, w, h, angle) -&gt; retval","ref":"Evision.Utils.html#testRotatedRect/5","title":"Evision.Utils.testRotatedRect/5","type":"function"},{"doc":"Raising version of testRotatedRectVector/5 .","ref":"Evision.Utils.html#testRotatedRectVector!/5","title":"Evision.Utils.testRotatedRectVector!/5","type":"function"},{"doc":"Positional Arguments x : float y : float w : float h : float angle : float Python prototype (for reference): testRotatedRectVector(x, y, w, h, angle) -&gt; retval","ref":"Evision.Utils.html#testRotatedRectVector/5","title":"Evision.Utils.testRotatedRectVector/5","type":"function"},{"doc":"","ref":"Evision.Utils.Nested.OriginalClassName.html","title":"Evision.Utils.Nested.OriginalClassName","type":"module"},{"doc":"Raising version of create/0 .","ref":"Evision.Utils.Nested.OriginalClassName.html#create!/0","title":"Evision.Utils.Nested.OriginalClassName.create!/0","type":"function"},{"doc":"Raising version of create/1 .","ref":"Evision.Utils.Nested.OriginalClassName.html#create!/1","title":"Evision.Utils.Nested.OriginalClassName.create!/1","type":"function"},{"doc":"##### Keyword Arguments params : OriginalClassName_Params . Python prototype (for reference): create([, params]) -&gt; retval","ref":"Evision.Utils.Nested.OriginalClassName.html#create/0","title":"Evision.Utils.Nested.OriginalClassName.create/0","type":"function"},{"doc":"##### Keyword Arguments params : OriginalClassName_Params . Python prototype (for reference): create([, params]) -&gt; retval","ref":"Evision.Utils.Nested.OriginalClassName.html#create/1","title":"Evision.Utils.Nested.OriginalClassName.create/1","type":"function"},{"doc":"Raising version of getFloatParam/1 .","ref":"Evision.Utils.Nested.OriginalClassName.html#getFloatParam!/1","title":"Evision.Utils.Nested.OriginalClassName.getFloatParam!/1","type":"function"},{"doc":"Python prototype (for reference): getFloatParam() -&gt; retval","ref":"Evision.Utils.Nested.OriginalClassName.html#getFloatParam/1","title":"Evision.Utils.Nested.OriginalClassName.getFloatParam/1","type":"function"},{"doc":"Raising version of getIntParam/1 .","ref":"Evision.Utils.Nested.OriginalClassName.html#getIntParam!/1","title":"Evision.Utils.Nested.OriginalClassName.getIntParam!/1","type":"function"},{"doc":"Python prototype (for reference): getIntParam() -&gt; retval","ref":"Evision.Utils.Nested.OriginalClassName.html#getIntParam/1","title":"Evision.Utils.Nested.OriginalClassName.getIntParam/1","type":"function"},{"doc":"Raising version of originalName/0 .","ref":"Evision.Utils.Nested.OriginalClassName.html#originalName!/0","title":"Evision.Utils.Nested.OriginalClassName.originalName!/0","type":"function"},{"doc":"Python prototype (for reference): originalName() -&gt; retval","ref":"Evision.Utils.Nested.OriginalClassName.html#originalName/0","title":"Evision.Utils.Nested.OriginalClassName.originalName/0","type":"function"},{"doc":"","ref":"Evision.Utils.Nested.OriginalClassName.Params.html","title":"Evision.Utils.Nested.OriginalClassName.Params","type":"module"},{"doc":"Raising version of get_float_value/1 .","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#get_float_value!/1","title":"Evision.Utils.Nested.OriginalClassName.Params.get_float_value!/1","type":"function"},{"doc":"","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#get_float_value/1","title":"Evision.Utils.Nested.OriginalClassName.Params.get_float_value/1","type":"function"},{"doc":"Raising version of get_int_value/1 .","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#get_int_value!/1","title":"Evision.Utils.Nested.OriginalClassName.Params.get_int_value!/1","type":"function"},{"doc":"","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#get_int_value/1","title":"Evision.Utils.Nested.OriginalClassName.Params.get_int_value/1","type":"function"},{"doc":"Raising version of set_float_value/2 .","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#set_float_value!/2","title":"Evision.Utils.Nested.OriginalClassName.Params.set_float_value!/2","type":"function"},{"doc":"","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#set_float_value/2","title":"Evision.Utils.Nested.OriginalClassName.Params.set_float_value/2","type":"function"},{"doc":"Raising version of set_int_value/2 .","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#set_int_value!/2","title":"Evision.Utils.Nested.OriginalClassName.Params.set_int_value!/2","type":"function"},{"doc":"","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#set_int_value/2","title":"Evision.Utils.Nested.OriginalClassName.Params.set_int_value/2","type":"function"},{"doc":"Raising version of utils_nested_OriginalClassName_Params/0 .","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#utils_nested_OriginalClassName_Params!/0","title":"Evision.Utils.Nested.OriginalClassName.Params.utils_nested_OriginalClassName_Params!/0","type":"function"},{"doc":"Raising version of utils_nested_OriginalClassName_Params/1 .","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#utils_nested_OriginalClassName_Params!/1","title":"Evision.Utils.Nested.OriginalClassName.Params.utils_nested_OriginalClassName_Params!/1","type":"function"},{"doc":"##### Keyword Arguments int_param : int . float_param : float . Python prototype (for reference): OriginalClassName_Params([, int_param[, float_param]]) -&gt; &lt;utils_nested_OriginalClassName_Params object&gt;","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#utils_nested_OriginalClassName_Params/0","title":"Evision.Utils.Nested.OriginalClassName.Params.utils_nested_OriginalClassName_Params/0","type":"function"},{"doc":"##### Keyword Arguments int_param : int . float_param : float . Python prototype (for reference): OriginalClassName_Params([, int_param[, float_param]]) -&gt; &lt;utils_nested_OriginalClassName_Params object&gt;","ref":"Evision.Utils.Nested.OriginalClassName.Params.html#utils_nested_OriginalClassName_Params/1","title":"Evision.Utils.Nested.OriginalClassName.Params.utils_nested_OriginalClassName_Params/1","type":"function"},{"doc":"","ref":"Evision.UtilsFS.html","title":"Evision.UtilsFS","type":"module"},{"doc":"Raising version of getCacheDirectoryForDownloads/0 .","ref":"Evision.UtilsFS.html#getCacheDirectoryForDownloads!/0","title":"Evision.UtilsFS.getCacheDirectoryForDownloads!/0","type":"function"},{"doc":"Python prototype (for reference): getCacheDirectoryForDownloads() -&gt; retval","ref":"Evision.UtilsFS.html#getCacheDirectoryForDownloads/0","title":"Evision.UtilsFS.getCacheDirectoryForDownloads/0","type":"function"},{"doc":"","ref":"Evision.Utilsnested.html","title":"Evision.Utilsnested","type":"module"},{"doc":"Raising version of testEchoBooleanFunction/1 .","ref":"Evision.Utilsnested.html#testEchoBooleanFunction!/1","title":"Evision.Utilsnested.testEchoBooleanFunction!/1","type":"function"},{"doc":"Positional Arguments flag : bool Python prototype (for reference): testEchoBooleanFunction(flag) -&gt; retval","ref":"Evision.Utilsnested.html#testEchoBooleanFunction/1","title":"Evision.Utilsnested.testEchoBooleanFunction/1","type":"function"},{"doc":"","ref":"Evision.VariationalRefinement.html","title":"Evision.VariationalRefinement","type":"module"},{"doc":"Raising version of calcUV/5 .","ref":"Evision.VariationalRefinement.html#calcUV!/5","title":"Evision.VariationalRefinement.calcUV!/5","type":"function"},{"doc":"@ref calc function overload to handle separate horizontal (u) and vertical (v) flow components (to avoid extra splits/merges) Positional Arguments i0 : Evision.Mat i1 : Evision.Mat Return flow_u : Evision.Mat flow_v : Evision.Mat Python prototype (for reference): calcUV(I0, I1, flow_u, flow_v) -&gt; flow_u, flow_v","ref":"Evision.VariationalRefinement.html#calcUV/5","title":"Evision.VariationalRefinement.calcUV/5","type":"function"},{"doc":"Raising version of create/0 .","ref":"Evision.VariationalRefinement.html#create!/0","title":"Evision.VariationalRefinement.create!/0","type":"function"},{"doc":"Creates an instance of VariationalRefinement Python prototype (for reference): create() -&gt; retval","ref":"Evision.VariationalRefinement.html#create/0","title":"Evision.VariationalRefinement.create/0","type":"function"},{"doc":"Raising version of getAlpha/1 .","ref":"Evision.VariationalRefinement.html#getAlpha!/1","title":"Evision.VariationalRefinement.getAlpha!/1","type":"function"},{"doc":"Weight of the smoothness term @see setAlpha Python prototype (for reference): getAlpha() -&gt; retval","ref":"Evision.VariationalRefinement.html#getAlpha/1","title":"Evision.VariationalRefinement.getAlpha/1","type":"function"},{"doc":"Raising version of getDelta/1 .","ref":"Evision.VariationalRefinement.html#getDelta!/1","title":"Evision.VariationalRefinement.getDelta!/1","type":"function"},{"doc":"Weight of the color constancy term @see setDelta Python prototype (for reference): getDelta() -&gt; retval","ref":"Evision.VariationalRefinement.html#getDelta/1","title":"Evision.VariationalRefinement.getDelta/1","type":"function"},{"doc":"Raising version of getFixedPointIterations/1 .","ref":"Evision.VariationalRefinement.html#getFixedPointIterations!/1","title":"Evision.VariationalRefinement.getFixedPointIterations!/1","type":"function"},{"doc":"Number of outer (fixed-point) iterations in the minimization procedure. @see setFixedPointIterations Python prototype (for reference): getFixedPointIterations() -&gt; retval","ref":"Evision.VariationalRefinement.html#getFixedPointIterations/1","title":"Evision.VariationalRefinement.getFixedPointIterations/1","type":"function"},{"doc":"Raising version of getGamma/1 .","ref":"Evision.VariationalRefinement.html#getGamma!/1","title":"Evision.VariationalRefinement.getGamma!/1","type":"function"},{"doc":"Weight of the gradient constancy term @see setGamma Python prototype (for reference): getGamma() -&gt; retval","ref":"Evision.VariationalRefinement.html#getGamma/1","title":"Evision.VariationalRefinement.getGamma/1","type":"function"},{"doc":"Raising version of getOmega/1 .","ref":"Evision.VariationalRefinement.html#getOmega!/1","title":"Evision.VariationalRefinement.getOmega!/1","type":"function"},{"doc":"Relaxation factor in SOR @see setOmega Python prototype (for reference): getOmega() -&gt; retval","ref":"Evision.VariationalRefinement.html#getOmega/1","title":"Evision.VariationalRefinement.getOmega/1","type":"function"},{"doc":"Raising version of getSorIterations/1 .","ref":"Evision.VariationalRefinement.html#getSorIterations!/1","title":"Evision.VariationalRefinement.getSorIterations!/1","type":"function"},{"doc":"Number of inner successive over-relaxation (SOR) iterations in the minimization procedure to solve the respective linear system. @see setSorIterations Python prototype (for reference): getSorIterations() -&gt; retval","ref":"Evision.VariationalRefinement.html#getSorIterations/1","title":"Evision.VariationalRefinement.getSorIterations/1","type":"function"},{"doc":"Raising version of setAlpha/2 .","ref":"Evision.VariationalRefinement.html#setAlpha!/2","title":"Evision.VariationalRefinement.setAlpha!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getAlpha @see getAlpha Python prototype (for reference): setAlpha(val) -&gt; None","ref":"Evision.VariationalRefinement.html#setAlpha/2","title":"Evision.VariationalRefinement.setAlpha/2","type":"function"},{"doc":"Raising version of setDelta/2 .","ref":"Evision.VariationalRefinement.html#setDelta!/2","title":"Evision.VariationalRefinement.setDelta!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getDelta @see getDelta Python prototype (for reference): setDelta(val) -&gt; None","ref":"Evision.VariationalRefinement.html#setDelta/2","title":"Evision.VariationalRefinement.setDelta/2","type":"function"},{"doc":"Raising version of setFixedPointIterations/2 .","ref":"Evision.VariationalRefinement.html#setFixedPointIterations!/2","title":"Evision.VariationalRefinement.setFixedPointIterations!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getFixedPointIterations @see getFixedPointIterations Python prototype (for reference): setFixedPointIterations(val) -&gt; None","ref":"Evision.VariationalRefinement.html#setFixedPointIterations/2","title":"Evision.VariationalRefinement.setFixedPointIterations/2","type":"function"},{"doc":"Raising version of setGamma/2 .","ref":"Evision.VariationalRefinement.html#setGamma!/2","title":"Evision.VariationalRefinement.setGamma!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getGamma @see getGamma Python prototype (for reference): setGamma(val) -&gt; None","ref":"Evision.VariationalRefinement.html#setGamma/2","title":"Evision.VariationalRefinement.setGamma/2","type":"function"},{"doc":"Raising version of setOmega/2 .","ref":"Evision.VariationalRefinement.html#setOmega!/2","title":"Evision.VariationalRefinement.setOmega!/2","type":"function"},{"doc":"Positional Arguments val : float @copybrief getOmega @see getOmega Python prototype (for reference): setOmega(val) -&gt; None","ref":"Evision.VariationalRefinement.html#setOmega/2","title":"Evision.VariationalRefinement.setOmega/2","type":"function"},{"doc":"Raising version of setSorIterations/2 .","ref":"Evision.VariationalRefinement.html#setSorIterations!/2","title":"Evision.VariationalRefinement.setSorIterations!/2","type":"function"},{"doc":"Positional Arguments val : int @copybrief getSorIterations @see getSorIterations Python prototype (for reference): setSorIterations(val) -&gt; None","ref":"Evision.VariationalRefinement.html#setSorIterations/2","title":"Evision.VariationalRefinement.setSorIterations/2","type":"function"},{"doc":"","ref":"Evision.VideoCapture.html","title":"Evision.VideoCapture","type":"module"},{"doc":"Raising version of get/2 .","ref":"Evision.VideoCapture.html#get!/2","title":"Evision.VideoCapture.get!/2","type":"function"},{"doc":"Returns the specified VideoCapture property Positional Arguments propId : int . Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...) or one from @ref videoio_flags_others @return Value for the specified property. Value 0 is returned when querying a property that is not supported by the backend used by the VideoCapture instance. Note : Reading / writing properties involves many layers. Some unexpected result might happens along this chain. VideoCapture -&gt; API Backend -&gt; Operating System -&gt; Device Driver -&gt; Device Hardware The returned value might be different from what really used by the device or it could be encoded using device dependent rules (eg. steps or percentage). Effective behaviour depends from device driver and API Backend Python prototype (for reference): get(propId) -&gt; retval","ref":"Evision.VideoCapture.html#get/2","title":"Evision.VideoCapture.get/2","type":"function"},{"doc":"Raising version of getBackendName/1 .","ref":"Evision.VideoCapture.html#getBackendName!/1","title":"Evision.VideoCapture.getBackendName!/1","type":"function"},{"doc":"Returns used backend API name Note : Stream should be opened. Python prototype (for reference): getBackendName() -&gt; retval","ref":"Evision.VideoCapture.html#getBackendName/1","title":"Evision.VideoCapture.getBackendName/1","type":"function"},{"doc":"Raising version of getExceptionMode/1 .","ref":"Evision.VideoCapture.html#getExceptionMode!/1","title":"Evision.VideoCapture.getExceptionMode!/1","type":"function"},{"doc":"Python prototype (for reference): getExceptionMode() -&gt; retval","ref":"Evision.VideoCapture.html#getExceptionMode/1","title":"Evision.VideoCapture.getExceptionMode/1","type":"function"},{"doc":"Raising version of grab/1 .","ref":"Evision.VideoCapture.html#grab!/1","title":"Evision.VideoCapture.grab!/1","type":"function"},{"doc":"Grabs the next frame from video file or capturing device. @return true (non-zero) in the case of success. The method/function grabs the next frame from video file or camera and returns true (non-zero) in the case of success. The primary use of the function is in multi-camera environments, especially when the cameras do not have hardware synchronization. That is, you call VideoCapture::grab() for each camera and after that call the slower method VideoCapture::retrieve() to decode and get frame from each camera. This way the overhead on demosaicing or motion jpeg decompression etc. is eliminated and the retrieved frames from different cameras will be closer in time. Also, when a connected camera is multi-head (for example, a stereo camera or a Kinect device), the correct way of retrieving data from it is to call VideoCapture::grab() first and then call VideoCapture::retrieve() one or more times with different values of the channel parameter. @ref tutorial_kinect_openni Python prototype (for reference): grab() -&gt; retval","ref":"Evision.VideoCapture.html#grab/1","title":"Evision.VideoCapture.grab/1","type":"function"},{"doc":"Raising version of isOpened/1 .","ref":"Evision.VideoCapture.html#isOpened!/1","title":"Evision.VideoCapture.isOpened!/1","type":"function"},{"doc":"Returns true if video capturing has been initialized already. If the previous call to VideoCapture constructor or VideoCapture::open() succeeded, the method returns true. Python prototype (for reference): isOpened() -&gt; retval","ref":"Evision.VideoCapture.html#isOpened/1","title":"Evision.VideoCapture.isOpened/1","type":"function"},{"doc":"Raising version of open/2 .","ref":"Evision.VideoCapture.html#open!/2","title":"Evision.VideoCapture.open!/2","type":"function"},{"doc":"Raising version of open/3 .","ref":"Evision.VideoCapture.html#open!/3","title":"Evision.VideoCapture.open!/3","type":"function"},{"doc":"Raising version of open/4 .","ref":"Evision.VideoCapture.html#open!/4","title":"Evision.VideoCapture.open!/4","type":"function"},{"doc":"Variant 1: Opens a camera for video capturing Positional Arguments index : int Keyword Arguments apiPreference : int . Has overloading in C++ Parameters are same as the constructor VideoCapture(int index, int apiPreference = CAP_ANY) @return true if the camera has been successfully opened. The method first calls VideoCapture::release to close the already opened file or camera. Python prototype (for reference): open(index[, apiPreference]) -&gt; retval Variant 2: Opens a video file or a capturing device or an IP video stream for video capturing. Positional Arguments filename : String Keyword Arguments apiPreference : int . Has overloading in C++ Parameters are same as the constructor VideoCapture(const String&amp; filename, int apiPreference = CAP_ANY) @return true if the file has been successfully opened The method first calls VideoCapture::release to close the already opened file or camera. Python prototype (for reference): open(filename[, apiPreference]) -&gt; retval","ref":"Evision.VideoCapture.html#open/2","title":"Evision.VideoCapture.open/2","type":"function"},{"doc":"Variant 1: Opens a camera for video capturing Positional Arguments index : int Keyword Arguments apiPreference : int . Has overloading in C++ Parameters are same as the constructor VideoCapture(int index, int apiPreference = CAP_ANY) @return true if the camera has been successfully opened. The method first calls VideoCapture::release to close the already opened file or camera. Python prototype (for reference): open(index[, apiPreference]) -&gt; retval Variant 2: Opens a video file or a capturing device or an IP video stream for video capturing. Positional Arguments filename : String Keyword Arguments apiPreference : int . Has overloading in C++ Parameters are same as the constructor VideoCapture(const String&amp; filename, int apiPreference = CAP_ANY) @return true if the file has been successfully opened The method first calls VideoCapture::release to close the already opened file or camera. Python prototype (for reference): open(filename[, apiPreference]) -&gt; retval","ref":"Evision.VideoCapture.html#open/3","title":"Evision.VideoCapture.open/3","type":"function"},{"doc":"Variant 1: Opens a camera for video capturing with API Preference and parameters Positional Arguments index : int apiPreference : int params : [int] Has overloading in C++ The params parameter allows to specify extra parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ...) . See cv::VideoCaptureProperties @return true if the camera has been successfully opened. The method first calls VideoCapture::release to close the already opened file or camera. Python prototype (for reference): open(index, apiPreference, params) -&gt; retval Variant 2: Opens a video file or a capturing device or an IP video stream for video capturing with API Preference and parameters Positional Arguments filename : String apiPreference : int params : [int] Has overloading in C++ The params parameter allows to specify extra parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ...) . See cv::VideoCaptureProperties @return true if the file has been successfully opened The method first calls VideoCapture::release to close the already opened file or camera. Python prototype (for reference): open(filename, apiPreference, params) -&gt; retval","ref":"Evision.VideoCapture.html#open/4","title":"Evision.VideoCapture.open/4","type":"function"},{"doc":"Raising version of read/1 .","ref":"Evision.VideoCapture.html#read!/1","title":"Evision.VideoCapture.read!/1","type":"function"},{"doc":"Grabs, decodes and returns the next video frame. Return image : Evision.Mat . @return false if no frames has been grabbed The method/function combines VideoCapture::grab() and VideoCapture::retrieve() in one call. This is the most convenient method for reading video files or capturing data from decode and returns the just grabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more frames in video file), the method returns false and the function returns empty image (with %cv::Mat, test it with Mat::empty()). Note : In @ref videoio_c &quot;C API&quot;, functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video capturing structure. It is not allowed to modify or release the image! You can copy the frame using cvCloneImage and then do whatever you want with the copy. Python prototype (for reference): read([, image]) -&gt; retval, image","ref":"Evision.VideoCapture.html#read/1","title":"Evision.VideoCapture.read/1","type":"function"},{"doc":"Raising version of release/1 .","ref":"Evision.VideoCapture.html#release!/1","title":"Evision.VideoCapture.release!/1","type":"function"},{"doc":"Closes video file or capturing device. The method is automatically called by subsequent VideoCapture::open and by VideoCapture destructor. The C function also deallocates memory and clears *capture pointer. Python prototype (for reference): release() -&gt; None","ref":"Evision.VideoCapture.html#release/1","title":"Evision.VideoCapture.release/1","type":"function"},{"doc":"Raising version of retrieve/1 .","ref":"Evision.VideoCapture.html#retrieve!/1","title":"Evision.VideoCapture.retrieve!/1","type":"function"},{"doc":"Decodes and returns the grabbed video frame. Keyword Arguments flag : int . it could be a frame index or a driver specific flag Return image : Evision.Mat . @return false if no frames has been grabbed The method decodes and returns the just grabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more frames in video file), the method returns false and the function returns an empty image (with %cv::Mat, test it with Mat::empty()). @sa read() Note : In @ref videoio_c &quot;C API&quot;, functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video capturing structure. It is not allowed to modify or release the image! You can copy the frame using cvCloneImage and then do whatever you want with the copy. Python prototype (for reference): retrieve([, image[, flag]]) -&gt; retval, image","ref":"Evision.VideoCapture.html#retrieve/1","title":"Evision.VideoCapture.retrieve/1","type":"function"},{"doc":"Raising version of set/3 .","ref":"Evision.VideoCapture.html#set!/3","title":"Evision.VideoCapture.set!/3","type":"function"},{"doc":"Sets a property in the VideoCapture. Positional Arguments propId : int . Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...) or one from @ref videoio_flags_others value : double . Value of the property. @return true if the property is supported by backend used by the VideoCapture instance. Note : Even if it returns true this doesn't ensure that the property value has been accepted by the capture device. See note in VideoCapture::get() Python prototype (for reference): set(propId, value) -&gt; retval","ref":"Evision.VideoCapture.html#set/3","title":"Evision.VideoCapture.set/3","type":"function"},{"doc":"Raising version of setExceptionMode/2 .","ref":"Evision.VideoCapture.html#setExceptionMode!/2","title":"Evision.VideoCapture.setExceptionMode!/2","type":"function"},{"doc":"Positional Arguments enable : bool Switches exceptions mode methods raise exceptions if not successful instead of returning an error code Python prototype (for reference): setExceptionMode(enable) -&gt; None","ref":"Evision.VideoCapture.html#setExceptionMode/2","title":"Evision.VideoCapture.setExceptionMode/2","type":"function"},{"doc":"Raising version of videoCapture/0 .","ref":"Evision.VideoCapture.html#videoCapture!/0","title":"Evision.VideoCapture.videoCapture!/0","type":"function"},{"doc":"Raising version of videoCapture/1 .","ref":"Evision.VideoCapture.html#videoCapture!/1","title":"Evision.VideoCapture.videoCapture!/1","type":"function"},{"doc":"Raising version of videoCapture/2 .","ref":"Evision.VideoCapture.html#videoCapture!/2","title":"Evision.VideoCapture.videoCapture!/2","type":"function"},{"doc":"Raising version of videoCapture/3 .","ref":"Evision.VideoCapture.html#videoCapture!/3","title":"Evision.VideoCapture.videoCapture!/3","type":"function"},{"doc":"Default constructor Note : In @ref videoio_c &quot;C API&quot;, when you finished working with video, release CvCapture structure with cvReleaseCapture(), or use Ptr\\&lt;CvCapture&gt; that calls cvReleaseCapture() automatically in the destructor. Python prototype (for reference): VideoCapture() -&gt; &lt;VideoCapture object&gt;","ref":"Evision.VideoCapture.html#videoCapture/0","title":"Evision.VideoCapture.videoCapture/0","type":"function"},{"doc":"Variant 1: Opens a camera for video capturing Positional Arguments index : int . id of the video capturing device to open. To open default camera using default backend just pass 0. (to backward compatibility usage of camera id + domain_offset (CAP *) is valid when apiPreference is CAP_ANY) Keyword Arguments apiPreference : int . preferred Capture API backends to use. Can be used to enforce a specific reader implementation if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L. Has overloading in C++ @sa cv::VideoCaptureAPIs Python prototype (for reference): VideoCapture(index[, apiPreference]) -&gt; &lt;VideoCapture object&gt; Variant 2: Opens a video file or a capturing device or an IP video stream for video capturing with API Preference Positional Arguments filename : String .it can be: name of video file (eg. video.avi ) or image sequence (eg. img_%02d.jpg , which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ... ) or URL of video stream (eg. protocol://host:port/script_name?script_params|auth ) or GStreamer pipeline string in gst-launch tool format in case if GStreamer is used as backend Note that each video stream or IP camera feed has its own URL scheme. Please refer to the documentation of source stream to know the right URL. Keyword Arguments apiPreference : int . preferred Capture API backends to use. Can be used to enforce a specific reader implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW. Has overloading in C++ @sa cv::VideoCaptureAPIs Python prototype (for reference): VideoCapture(filename[, apiPreference]) -&gt; &lt;VideoCapture object&gt;","ref":"Evision.VideoCapture.html#videoCapture/1","title":"Evision.VideoCapture.videoCapture/1","type":"function"},{"doc":"Variant 1: Opens a camera for video capturing Positional Arguments index : int . id of the video capturing device to open. To open default camera using default backend just pass 0. (to backward compatibility usage of camera id + domain_offset (CAP *) is valid when apiPreference is CAP_ANY) Keyword Arguments apiPreference : int . preferred Capture API backends to use. Can be used to enforce a specific reader implementation if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L. Has overloading in C++ @sa cv::VideoCaptureAPIs Python prototype (for reference): VideoCapture(index[, apiPreference]) -&gt; &lt;VideoCapture object&gt; Variant 2: Opens a video file or a capturing device or an IP video stream for video capturing with API Preference Positional Arguments filename : String .it can be: name of video file (eg. video.avi ) or image sequence (eg. img_%02d.jpg , which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ... ) or URL of video stream (eg. protocol://host:port/script_name?script_params|auth ) or GStreamer pipeline string in gst-launch tool format in case if GStreamer is used as backend Note that each video stream or IP camera feed has its own URL scheme. Please refer to the documentation of source stream to know the right URL. Keyword Arguments apiPreference : int . preferred Capture API backends to use. Can be used to enforce a specific reader implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW. Has overloading in C++ @sa cv::VideoCaptureAPIs Python prototype (for reference): VideoCapture(filename[, apiPreference]) -&gt; &lt;VideoCapture object&gt;","ref":"Evision.VideoCapture.html#videoCapture/2","title":"Evision.VideoCapture.videoCapture/2","type":"function"},{"doc":"Variant 1: Opens a camera for video capturing with API Preference and parameters Positional Arguments index : int apiPreference : int params : [int] Has overloading in C++ The params parameter allows to specify extra parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ...) . See cv::VideoCaptureProperties Python prototype (for reference): VideoCapture(index, apiPreference, params) -&gt; &lt;VideoCapture object&gt; Variant 2: Opens a video file or a capturing device or an IP video stream for video capturing with API Preference and parameters Positional Arguments filename : String apiPreference : int params : [int] Has overloading in C++ The params parameter allows to specify extra parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ...) . See cv::VideoCaptureProperties Python prototype (for reference): VideoCapture(filename, apiPreference, params) -&gt; &lt;VideoCapture object&gt;","ref":"Evision.VideoCapture.html#videoCapture/3","title":"Evision.VideoCapture.videoCapture/3","type":"function"},{"doc":"","ref":"Evision.VideoIORegistry.html","title":"Evision.VideoIORegistry","type":"module"},{"doc":"Raising version of getBackendName/1 .","ref":"Evision.VideoIORegistry.html#getBackendName!/1","title":"Evision.VideoIORegistry.getBackendName!/1","type":"function"},{"doc":"Returns backend API name or &quot;UnknownVideoAPI(xxx)&quot; Positional Arguments api : VideoCaptureAPIs . backend ID (#VideoCaptureAPIs) Python prototype (for reference): getBackendName(api) -&gt; retval","ref":"Evision.VideoIORegistry.html#getBackendName/1","title":"Evision.VideoIORegistry.getBackendName/1","type":"function"},{"doc":"Raising version of getBackends/0 .","ref":"Evision.VideoIORegistry.html#getBackends!/0","title":"Evision.VideoIORegistry.getBackends!/0","type":"function"},{"doc":"Returns list of all available backends Python prototype (for reference): getBackends() -&gt; retval","ref":"Evision.VideoIORegistry.html#getBackends/0","title":"Evision.VideoIORegistry.getBackends/0","type":"function"},{"doc":"Raising version of getCameraBackendPluginVersion/1 .","ref":"Evision.VideoIORegistry.html#getCameraBackendPluginVersion!/1","title":"Evision.VideoIORegistry.getCameraBackendPluginVersion!/1","type":"function"},{"doc":"Returns description and ABI/API version of videoio plugin's camera interface Positional Arguments api : VideoCaptureAPIs Return version_ABI : int version_API : int Python prototype (for reference): getCameraBackendPluginVersion(api) -&gt; retval, version_ABI, version_API","ref":"Evision.VideoIORegistry.html#getCameraBackendPluginVersion/1","title":"Evision.VideoIORegistry.getCameraBackendPluginVersion/1","type":"function"},{"doc":"Raising version of getCameraBackends/0 .","ref":"Evision.VideoIORegistry.html#getCameraBackends!/0","title":"Evision.VideoIORegistry.getCameraBackends!/0","type":"function"},{"doc":"Returns list of available backends which works via cv::VideoCapture(int index) Python prototype (for reference): getCameraBackends() -&gt; retval","ref":"Evision.VideoIORegistry.html#getCameraBackends/0","title":"Evision.VideoIORegistry.getCameraBackends/0","type":"function"},{"doc":"Raising version of getStreamBackendPluginVersion/1 .","ref":"Evision.VideoIORegistry.html#getStreamBackendPluginVersion!/1","title":"Evision.VideoIORegistry.getStreamBackendPluginVersion!/1","type":"function"},{"doc":"Returns description and ABI/API version of videoio plugin's stream capture interface Positional Arguments api : VideoCaptureAPIs Return version_ABI : int version_API : int Python prototype (for reference): getStreamBackendPluginVersion(api) -&gt; retval, version_ABI, version_API","ref":"Evision.VideoIORegistry.html#getStreamBackendPluginVersion/1","title":"Evision.VideoIORegistry.getStreamBackendPluginVersion/1","type":"function"},{"doc":"Raising version of getStreamBackends/0 .","ref":"Evision.VideoIORegistry.html#getStreamBackends!/0","title":"Evision.VideoIORegistry.getStreamBackends!/0","type":"function"},{"doc":"Returns list of available backends which works via cv::VideoCapture(filename) Python prototype (for reference): getStreamBackends() -&gt; retval","ref":"Evision.VideoIORegistry.html#getStreamBackends/0","title":"Evision.VideoIORegistry.getStreamBackends/0","type":"function"},{"doc":"Raising version of getWriterBackendPluginVersion/1 .","ref":"Evision.VideoIORegistry.html#getWriterBackendPluginVersion!/1","title":"Evision.VideoIORegistry.getWriterBackendPluginVersion!/1","type":"function"},{"doc":"Returns description and ABI/API version of videoio plugin's writer interface Positional Arguments api : VideoCaptureAPIs Return version_ABI : int version_API : int Python prototype (for reference): getWriterBackendPluginVersion(api) -&gt; retval, version_ABI, version_API","ref":"Evision.VideoIORegistry.html#getWriterBackendPluginVersion/1","title":"Evision.VideoIORegistry.getWriterBackendPluginVersion/1","type":"function"},{"doc":"Raising version of getWriterBackends/0 .","ref":"Evision.VideoIORegistry.html#getWriterBackends!/0","title":"Evision.VideoIORegistry.getWriterBackends!/0","type":"function"},{"doc":"Returns list of available backends which works via cv::VideoWriter() Python prototype (for reference): getWriterBackends() -&gt; retval","ref":"Evision.VideoIORegistry.html#getWriterBackends/0","title":"Evision.VideoIORegistry.getWriterBackends/0","type":"function"},{"doc":"Raising version of hasBackend/1 .","ref":"Evision.VideoIORegistry.html#hasBackend!/1","title":"Evision.VideoIORegistry.hasBackend!/1","type":"function"},{"doc":"Returns true if backend is available Positional Arguments api : VideoCaptureAPIs Python prototype (for reference): hasBackend(api) -&gt; retval","ref":"Evision.VideoIORegistry.html#hasBackend/1","title":"Evision.VideoIORegistry.hasBackend/1","type":"function"},{"doc":"Raising version of isBackendBuiltIn/1 .","ref":"Evision.VideoIORegistry.html#isBackendBuiltIn!/1","title":"Evision.VideoIORegistry.isBackendBuiltIn!/1","type":"function"},{"doc":"Returns true if backend is built in (false if backend is used as plugin) Positional Arguments api : VideoCaptureAPIs Python prototype (for reference): isBackendBuiltIn(api) -&gt; retval","ref":"Evision.VideoIORegistry.html#isBackendBuiltIn/1","title":"Evision.VideoIORegistry.isBackendBuiltIn/1","type":"function"},{"doc":"","ref":"Evision.VideoWriter.html","title":"Evision.VideoWriter","type":"module"},{"doc":"Raising version of fourcc/4 .","ref":"Evision.VideoWriter.html#fourcc!/4","title":"Evision.VideoWriter.fourcc!/4","type":"function"},{"doc":"Concatenates 4 chars to a fourcc code Positional Arguments c1 : char c2 : char c3 : char c4 : char @return a fourcc code This static method constructs the fourcc code of the codec to be used in the constructor VideoWriter::VideoWriter or VideoWriter::open. Python prototype (for reference): fourcc(c1, c2, c3, c4) -&gt; retval","ref":"Evision.VideoWriter.html#fourcc/4","title":"Evision.VideoWriter.fourcc/4","type":"function"},{"doc":"Raising version of get/2 .","ref":"Evision.VideoWriter.html#get!/2","title":"Evision.VideoWriter.get!/2","type":"function"},{"doc":"Returns the specified VideoWriter property Positional Arguments propId : int . Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY) or one of @ref videoio_flags_others @return Value for the specified property. Value 0 is returned when querying a property that is not supported by the backend used by the VideoWriter instance. Python prototype (for reference): get(propId) -&gt; retval","ref":"Evision.VideoWriter.html#get/2","title":"Evision.VideoWriter.get/2","type":"function"},{"doc":"Raising version of getBackendName/1 .","ref":"Evision.VideoWriter.html#getBackendName!/1","title":"Evision.VideoWriter.getBackendName!/1","type":"function"},{"doc":"Returns used backend API name Note : Stream should be opened. Python prototype (for reference): getBackendName() -&gt; retval","ref":"Evision.VideoWriter.html#getBackendName/1","title":"Evision.VideoWriter.getBackendName/1","type":"function"},{"doc":"Raising version of isOpened/1 .","ref":"Evision.VideoWriter.html#isOpened!/1","title":"Evision.VideoWriter.isOpened!/1","type":"function"},{"doc":"Returns true if video writer has been successfully initialized. Python prototype (for reference): isOpened() -&gt; retval","ref":"Evision.VideoWriter.html#isOpened/1","title":"Evision.VideoWriter.isOpened/1","type":"function"},{"doc":"Raising version of open/5 .","ref":"Evision.VideoWriter.html#open!/5","title":"Evision.VideoWriter.open!/5","type":"function"},{"doc":"Raising version of open/6 .","ref":"Evision.VideoWriter.html#open!/6","title":"Evision.VideoWriter.open!/6","type":"function"},{"doc":"Raising version of open/7 .","ref":"Evision.VideoWriter.html#open!/7","title":"Evision.VideoWriter.open!/7","type":"function"},{"doc":"Initializes or reinitializes video writer. Positional Arguments filename : String fourcc : int fps : double frameSize : Size Keyword Arguments isColor : bool . The method opens video writer. Parameters are the same as in the constructor VideoWriter::VideoWriter. @return true if video writer has been successfully initialized The method first calls VideoWriter::release to close the already opened file. Python prototype (for reference): open(filename, fourcc, fps, frameSize[, isColor]) -&gt; retval","ref":"Evision.VideoWriter.html#open/5","title":"Evision.VideoWriter.open/5","type":"function"},{"doc":"Variant 1: Positional Arguments filename : String fourcc : int fps : double frameSize : Size params : [int] Has overloading in C++ Python prototype (for reference): open(filename, fourcc, fps, frameSize, params) -&gt; retval Variant 2: Positional Arguments filename : String apiPreference : int fourcc : int fps : double frameSize : Size Keyword Arguments isColor : bool . Has overloading in C++ Python prototype (for reference): open(filename, apiPreference, fourcc, fps, frameSize[, isColor]) -&gt; retval Variant 3: Initializes or reinitializes video writer. Positional Arguments filename : String fourcc : int fps : double frameSize : Size Keyword Arguments isColor : bool . The method opens video writer. Parameters are the same as in the constructor VideoWriter::VideoWriter. @return true if video writer has been successfully initialized The method first calls VideoWriter::release to close the already opened file. Python prototype (for reference): open(filename, fourcc, fps, frameSize[, isColor]) -&gt; retval","ref":"Evision.VideoWriter.html#open/6","title":"Evision.VideoWriter.open/6","type":"function"},{"doc":"Variant 1: Positional Arguments filename : String apiPreference : int fourcc : int fps : double frameSize : Size params : [int] Has overloading in C++ Python prototype (for reference): open(filename, apiPreference, fourcc, fps, frameSize, params) -&gt; retval Variant 2: Positional Arguments filename : String apiPreference : int fourcc : int fps : double frameSize : Size Keyword Arguments isColor : bool . Has overloading in C++ Python prototype (for reference): open(filename, apiPreference, fourcc, fps, frameSize[, isColor]) -&gt; retval","ref":"Evision.VideoWriter.html#open/7","title":"Evision.VideoWriter.open/7","type":"function"},{"doc":"Raising version of release/1 .","ref":"Evision.VideoWriter.html#release!/1","title":"Evision.VideoWriter.release!/1","type":"function"},{"doc":"Closes the video writer. The method is automatically called by subsequent VideoWriter::open and by the VideoWriter destructor. Python prototype (for reference): release() -&gt; None","ref":"Evision.VideoWriter.html#release/1","title":"Evision.VideoWriter.release/1","type":"function"},{"doc":"Raising version of set/3 .","ref":"Evision.VideoWriter.html#set!/3","title":"Evision.VideoWriter.set!/3","type":"function"},{"doc":"Sets a property in the VideoWriter. Positional Arguments propId : int . Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY) or one of @ref videoio_flags_others value : double . Value of the property. @return true if the property is supported by the backend used by the VideoWriter instance. Python prototype (for reference): set(propId, value) -&gt; retval","ref":"Evision.VideoWriter.html#set/3","title":"Evision.VideoWriter.set/3","type":"function"},{"doc":"Raising version of videoWriter/0 .","ref":"Evision.VideoWriter.html#videoWriter!/0","title":"Evision.VideoWriter.videoWriter!/0","type":"function"},{"doc":"Raising version of videoWriter/4 .","ref":"Evision.VideoWriter.html#videoWriter!/4","title":"Evision.VideoWriter.videoWriter!/4","type":"function"},{"doc":"Raising version of videoWriter/5 .","ref":"Evision.VideoWriter.html#videoWriter!/5","title":"Evision.VideoWriter.videoWriter!/5","type":"function"},{"doc":"Raising version of videoWriter/6 .","ref":"Evision.VideoWriter.html#videoWriter!/6","title":"Evision.VideoWriter.videoWriter!/6","type":"function"},{"doc":"Default constructors The constructors/functions initialize video writers. On Linux FFMPEG is used to write videos; On Windows FFMPEG or MSWF or DSHOW is used; On MacOSX AVFoundation is used. Python prototype (for reference): VideoWriter() -&gt; &lt;VideoWriter object&gt;","ref":"Evision.VideoWriter.html#videoWriter/0","title":"Evision.VideoWriter.videoWriter/0","type":"function"},{"doc":"Positional Arguments filename : String . Name of the output video file. fourcc : int . 4-character code of codec used to compress the frames. For example, VideoWriter::fourcc('P','I','M','1') is a MPEG-1 codec, VideoWriter::fourcc('M','J','P','G') is a motion-jpeg codec etc. List of codes can be obtained at Video Codecs by FOURCC page. FFMPEG backend with MP4 container natively uses other values as fourcc code: see ObjectType , so you may receive a warning message from OpenCV about fourcc code conversion. fps : double . Framerate of the created video stream. frameSize : Size . Size of the video frames. Keyword Arguments isColor : bool . If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames. Has overloading in C++ @b Tips: With some backends fourcc=-1 pops up the codec selection dialog from the system. To save image sequence use a proper filename (eg. img_%02d.jpg ) and fourcc=0 OR fps=0 . Use uncompressed image format (eg. img_%02d.BMP ) to save raw frames. Most codecs are lossy. If you want lossless video file you need to use a lossless codecs (eg. FFMPEG FFV1, Huffman HFYU, Lagarith LAGS, etc...) If FFMPEG is enabled, using codec=0; fps=0; you can create an uncompressed (raw) video file. Python prototype (for reference): VideoWriter(filename, fourcc, fps, frameSize[, isColor]) -&gt; &lt;VideoWriter object&gt;","ref":"Evision.VideoWriter.html#videoWriter/4","title":"Evision.VideoWriter.videoWriter/4","type":"function"},{"doc":"Variant 1: Positional Arguments filename : String fourcc : int fps : double frameSize : Size params : [int] Has overloading in C++ The params parameter allows to specify extra encoder parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see cv::VideoWriterProperties Python prototype (for reference): VideoWriter(filename, fourcc, fps, frameSize, params) -&gt; &lt;VideoWriter object&gt; Variant 2: Positional Arguments filename : String apiPreference : int fourcc : int fps : double frameSize : Size Keyword Arguments isColor : bool . Has overloading in C++ The apiPreference parameter allows to specify API backends to use. Can be used to enforce a specific reader implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_GSTREAMER. Python prototype (for reference): VideoWriter(filename, apiPreference, fourcc, fps, frameSize[, isColor]) -&gt; &lt;VideoWriter object&gt; Variant 3: Positional Arguments filename : String . Name of the output video file. fourcc : int . 4-character code of codec used to compress the frames. For example, VideoWriter::fourcc('P','I','M','1') is a MPEG-1 codec, VideoWriter::fourcc('M','J','P','G') is a motion-jpeg codec etc. List of codes can be obtained at Video Codecs by FOURCC page. FFMPEG backend with MP4 container natively uses other values as fourcc code: see ObjectType , so you may receive a warning message from OpenCV about fourcc code conversion. fps : double . Framerate of the created video stream. frameSize : Size . Size of the video frames. Keyword Arguments isColor : bool . If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames. Has overloading in C++ @b Tips: With some backends fourcc=-1 pops up the codec selection dialog from the system. To save image sequence use a proper filename (eg. img_%02d.jpg ) and fourcc=0 OR fps=0 . Use uncompressed image format (eg. img_%02d.BMP ) to save raw frames. Most codecs are lossy. If you want lossless video file you need to use a lossless codecs (eg. FFMPEG FFV1, Huffman HFYU, Lagarith LAGS, etc...) If FFMPEG is enabled, using codec=0; fps=0; you can create an uncompressed (raw) video file. Python prototype (for reference): VideoWriter(filename, fourcc, fps, frameSize[, isColor]) -&gt; &lt;VideoWriter object&gt;","ref":"Evision.VideoWriter.html#videoWriter/5","title":"Evision.VideoWriter.videoWriter/5","type":"function"},{"doc":"Variant 1: Positional Arguments filename : String apiPreference : int fourcc : int fps : double frameSize : Size params : [int] Has overloading in C++ Python prototype (for reference): VideoWriter(filename, apiPreference, fourcc, fps, frameSize, params) -&gt; &lt;VideoWriter object&gt; Variant 2: Positional Arguments filename : String apiPreference : int fourcc : int fps : double frameSize : Size Keyword Arguments isColor : bool . Has overloading in C++ The apiPreference parameter allows to specify API backends to use. Can be used to enforce a specific reader implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_GSTREAMER. Python prototype (for reference): VideoWriter(filename, apiPreference, fourcc, fps, frameSize[, isColor]) -&gt; &lt;VideoWriter object&gt;","ref":"Evision.VideoWriter.html#videoWriter/6","title":"Evision.VideoWriter.videoWriter/6","type":"function"},{"doc":"Raising version of write/2 .","ref":"Evision.VideoWriter.html#write!/2","title":"Evision.VideoWriter.write!/2","type":"function"},{"doc":"Writes the next video frame Positional Arguments image : Evision.Mat . The written frame. In general, color images are expected in BGR format. The function/method writes the specified image to video file. It must have the same size as has been specified when opening the video writer. Python prototype (for reference): write(image) -&gt; None","ref":"Evision.VideoWriter.html#write/2","title":"Evision.VideoWriter.write/2","type":"function"},{"doc":"A task responsible for downloading the precompiled NIFs for a given module. This task must only be used by package creators who want to ship the precompiled NIFs. The goal is to download the precompiled packages and generate a checksum to check-in alongside the project in the the Hex repository. This is done by passing the --all flag. You can also use the --only-local flag to download only the precompiled package for use during development. You can use the --ignore-unavailable flag to ignore any NIFs that are not available. This is useful when you are developing a new NIF that does not support all platforms. This task also accept the --print flag to print the checksums.","ref":"Mix.Tasks.Evision.Fetch.html","title":"Mix.Tasks.Evision.Fetch","type":"task"},{"doc":"","ref":"changelog.html","title":"Changelog","type":"extras"},{"doc":"Browse the Repository | Released Assets Bug Fixes Mix.Tasks.Compile.EvisionPrecompiled : using File.cp_r/2 instead of calling cp -a via System.cmd/3 . Fixed TLS warnings when downloading precompiled tarball file. Thanks to @kipcole9! Only include evision_custom_headers/evision_ml.hpp if the HAVE_OPENCV_ML macro is defined. Support parsing RefWrapper&lt;T&gt; (&amp;value)[N] from list or tuple. ( #99 ) See the function in c_src/evision.cpp . bool parseSequence(ErlNifEnv *env, ERL_NIF_TERM obj, RefWrapper&lt;T&gt; (&amp;value)[N], const ArgInfo&amp; info) # `RotatedRect` has to be a tuple, {centre, size, angle} Evision . boxPoints! ( { { 224.0 , 262.5 } , { 343.0 , 344.0 } , 90.0 } ) # while `Point`/`Size` can be either a list, `[x, y]`, or a tuple, `{x, y}` Evision . boxPoints! ( { [ 224.0 , 262.5 ] , [ 343.0 , 344.0 ] , 90.0 } ) Fixed the mapping from a type to the corresponding function guard in py_src/helper.py . ( #99 ) Changed Display RotatedRect type as {centre={x, y}, size={s1, s2}, angle} in docs.","ref":"changelog.html#v0-1-9-2022-10-09","title":"Changelog - v0.1.9 (2022-10-09)","type":"extras"},{"doc":"Browse the Repository | Released Assets Changed CMake and make ( nmake if on Windows) will not be used to download and deploy precompiled binaries for Elixir users. This means that evision can be downloaded and deployed once Erlang and Elixir are properly installed on the system.","ref":"changelog.html#v0-1-8-2022-10-08","title":"Changelog - v0.1.8 (2022-10-08)","type":"extras"},{"doc":"Browse the Repository | Released Assets Breaking Changes EVISION_PREFER_PRECOMPILED is set to true by default. :evision will try to use precompiled binaries if available. Otherwise, it will fallback to building from source. Precompiled binary filename changed: arm64 - apple - darwin =&gt; aarch64 - apple - darwin amd64 - windows - msvc =&gt; x86_64 - windows - msvc Changed cv::VideoCapture will be wrapped in struct. For example: iex&gt; cap = Evision.VideoCapture . videoCapture! ( &quot;test/videocapture_test.mp4&quot; ) % Evision.VideoCapture { fps : 43.2 , frame_count : 18.0 , frame_width : 1920.0 , frame_height : 1080.0 , isOpened : true , ref : # Reference &lt; 0.3650318819 . 3952214034.37793 &gt; } iex&gt; frame = Evision.VideoCapture . read! ( cap ) % Evision.Mat { channels : 3 , dims : 2 , type : { :u , 8 } , raw_type : 16 , shape : { 1080 , 1920 , 3 } , ref : # Reference &lt; 0.3650318819 . 3952214042.38343 &gt; } Evision.Mat.empty/0 will also return an Evision.Mat struct (was returning #Reference&lt;some random numbers&gt; ). iex&gt; Evision.Mat . empty! ( ) % Evision.Mat { channels : 1 , dims : 0 , type : { :u , 8 } , raw_type : 0 , shape : { } , ref : # Reference &lt; 0.2351084001 . 2568618002.207930 &gt; } raise RuntimeError for all unimplemented :nx callbacks. raise RuntimeError , &quot;not implemented yet&quot; Elixir functions that have the same name and arity will be grouped together now. This should massively reduce the number of warnings emitted by the elixir compiler. Only generate corresponding binding code. Only generate binding code for Elixir when compiling :evision using mix ; Only generate binding code for erlang when compiling :evision using rebar ; It's possible to generate erlang and Elixir at the same time. However, currently it's only possible to do so when compiling evision using mix . # default value is `elixir` when compiling evision using `mix` # default value is `erlang` when compiling evision using `rebar` # # expected format is a comma-separated string export EVISION_GENERATE_LANG=&quot;erlang,elixir&quot; Better inline docs. Inline docs will have a section for Positional Arguments and a section for Keyword Arguments . For example, @doc &quot;&quot;&quot; ### Positional Arguments - **bboxes**: vector_Rect2d. - **scores**: vector_float. - **score_threshold**: float. - **nms_threshold**: float. ### Keyword Arguments - **eta**: float. - **top_k**: int. Performs non maximum suppression given boxes and corresponding scores. Python prototype (for reference): \\` `` NMSBoxes(bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]) -&gt; indices \\` `` &quot;&quot;&quot; @doc namespace : :&quot;cv.dnn&quot; def nmsBoxes ( bboxes , scores , score_threshold , nms_threshold , opts ) If a function (same name and arity) has multiple variants, the inline docs will show each of them in section ## Variant VAR_INDEX . For example, @doc &quot;&quot;&quot; #### Variant 1: ##### Positional Arguments - **dx**: UMat. - **dy**: UMat. - **threshold1**: double. - **threshold2**: double. ##### Keyword Arguments - **edges**: UMat. - **l2gradient**: bool. \\\\ overload Finds edges in an image using the Canny algorithm with custom image gradient. \\\\ f$= \\\\ sqrt{(dI/dx)^2 + (dI/dy)^2} \\\\ f$ should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default \\\\ f$L \\\\ _1 \\\\ f$ norm \\\\ f$=|dI/dx|+|dI/dy| \\\\ f$ is enough ( L2gradient=false ). Python prototype (for reference): \\` `` Canny(dx, dy, threshold1, threshold2[, edges[, L2gradient]]) -&gt; edges \\` `` #### Variant 2: ##### Positional Arguments - **image**: UMat. - **threshold1**: double. - **threshold2**: double. ##### Keyword Arguments - **edges**: UMat. - **apertureSize**: int. - **l2gradient**: bool. Finds edges in an image using the Canny algorithm @cite Canny86 . The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See &lt;http://en.wikipedia.org/wiki/Canny_edge_detector&gt; \\\\ f$= \\\\ sqrt{(dI/dx)^2 + (dI/dy)^2} \\\\ f$ should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default \\\\ f$L \\\\ _1 \\\\ f$ norm \\\\ f$=|dI/dx|+|dI/dy| \\\\ f$ is enough ( L2gradient=false ). Python prototype (for reference): \\` `` Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]]) -&gt; edges \\` `` &quot;&quot;&quot; @doc namespace : :cv def canny ( image , threshold1 , threshold2 , opts ) when ( is_reference ( image ) or is_struct ( image ) ) and is_number ( threshold1 ) and is_number ( threshold2 ) and is_list ( opts ) and ( opts == [ ] or is_tuple ( hd ( opts ) ) ) , do : # variant 2 def canny ( dx , dy , threshold1 , threshold2 ) when ( is_reference ( dx ) or is_struct ( dx ) ) and ( is_reference ( dy ) or is_struct ( dy ) ) and is_number ( threshold1 ) and is_number ( threshold2 ) , do : # variant 1 Better integration with :nx . iex&gt; t = Nx.tensor([[[0,0,0], [255, 255, 255]]], type: :u8) #Nx.Tensor&lt; u8[1][2][3] [ [ [0, 0, 0], [255, 255, 255] ] ] &gt; iex&gt; mat = Evision.imread!(&quot;test.png&quot;) %Evision.Mat{ channels: 3, dims: 2, type: {:u, 8}, raw_type: 16, shape: {1, 2, 3}, ref: #Reference&lt;0.2067356221.74055707.218654&gt; } iex&gt; mat = Evision.Mat.channel_as_last_dim!(mat) %Evision.Mat{ channels: 1, dims: 3, type: {:u, 8}, raw_type: 0, shape: {1, 2, 3}, ref: #Reference&lt;0.2067356221.74055698.218182&gt; } iex&gt; result = Evision.Mat.add!(t, mat) %Evision.Mat{ channels: 1, dims: 3, type: {:u, 8}, raw_type: 0, shape: {1, 2, 3}, ref: #Reference&lt;0.2067356221.74055698.218184&gt; } iex&gt; Evision.Nx.to_nx!(result) #Nx.Tensor&lt; u8[1][2][3] Evision.Backend [ [ [255, 255, 255], [255, 255, 255] ] ] &gt; - Implemented property setter for ` cv :: Ptr &lt;&gt; ` wrapped types . For example , iex&gt; k = Evision.KalmanFilter.kalmanFilter!(1, 1) #Reference&lt;0.382162378.457572372.189094&gt; iex&gt; Evision.KalmanFilter.get_gain!(k) |&gt; Evision.Nx.to_nx! #Nx.Tensor&lt; f32[1][1] Evision.Backend [ [0.0] ] &gt; iex&gt; Evision.KalmanFilter.set_gain!(k, Evision.Mat.literal!([1.0], :f32)) #Reference&lt;0.382162378.457572372.189094&gt; iex&gt; Evision.KalmanFilter.get_gain!(k) |&gt; Evision.Nx.to_nx! #Nx.Tensor&lt; f32[1][1] Evision.Backend [ [1.0] ] &gt; - More detailed error message for property getter / setter . For example , - When setting a property that is type ` A ` and value passed to the setter is type ` B ` , and there is no known conversion from ` B ` to ` A ` , then it will return an error - tuple iex&gt; k = Evision.KalmanFilter.kalmanFilter!(1, 1) iex&gt; Evision.KalmanFilter.set_gain(k, :p) iex&gt; Evision.KalmanFilter.set_gain(k, :p) ** (RuntimeError) cannot assign new value, mismatched type? ( evision 0.1 . 7 ) lib / generated / evision_kalmanfilter . ex : 175 : Evision.KalmanFilter . set_gain! / 2 iex : 7 : ( file ) - For property getter / setter , if the ` self ` passed in is a different type than what is expected , an error - tuple will be returned iex&gt; mat = Evision.Mat.literal!([1.0], :f32) %Evision.Mat{ channels : 1 , dims : 2 , type : { :f , 32 } , raw_type : 5 , shape : { 1 , 1 } , ref : # Reference &lt; 0.1499445684 . 3682467860.58544 &gt; } iex&gt; Evision.KalmanFilter.set_gain(mat, mat) {:error, &quot;cannot get Ptr&lt;cv::KalmanFilter&gt; from self : mismatched type or invalid resource?&quot;} iex&gt; Evision.KalmanFilter.set_gain!(mat, mat) ** (RuntimeError) cannot get Ptr&lt;cv::KalmanFilter&gt; from self : mismatched type or invalid resource? ( evision 0.1 . 7 ) lib / generated / evision_kalmanfilter . ex : 175 : Evision.KalmanFilter . set_gain! / 2 iex : 2 : ( file ) - ` evision_ ##NAME##_getp` (in `c_src/erlcompat.hpp`) should just return true or false. Returning a ` ERL_NIF_TERM ` ( ` enif_make_badarg ` ) in the macro ( when ` enif_get_resource ` fails ) will prevent the caller from returning an error - tuple with detailed error message . - Improved the quality of generated inline docs . Also displays what variable ( s ) will be returned ( when applicable ) in the ` ##### Return` section. ### Added - Added ` Evision.Mat . literal / { 1 , 2 , 3 } ` to create ` Evision.Mat ` from list literals . Creating ` Evision.Mat ` from empty list literal ( ` [ ] ` ) is the same as calling ` Evision.Mat . empty ( ) ` . iex&gt; Evision.Mat.literal!([]) %Evision.Mat{ channels: 1, dims: 0, type: {:u, 8}, raw_type: 0, shape: {}, ref: #Reference&lt;0.1204050731.2031747092.46781&gt; } By default , the shape of the Mat will stay as is . iex&gt; Evision.Mat.literal!([[[1,1,1],[2,2,2],[3,3,3]]], :u8) %Evision.Mat{ channels: 1, dims: 3, type: {:u, 8}, raw_type: 0, shape: {1, 3, 3}, ref: #Reference&lt;0.512519210.691404819.106300&gt; } ` Evision.Mat . literal / 3 ` will return a vaild 2 D image if the keyword argument , ` as_2d ` , is set to ` true ` and if the list literal can be represented as a 2 D image . iex&gt; Evision.Mat.literal!([[[1,1,1],[2,2,2],[3,3,3]]], :u8, as_2d: true) %Evision.Mat{ channels: 3, dims: 2, type: {:u, 8}, raw_type: 16, shape: {1, 3, 3}, ref: #Reference&lt;0.512519210.691404820.106293&gt; } - Added ` Evision.Mat . channel_as_last_dim / 1 ` . This function does the opposite as to ` Evision.Mat . last_dim_as_channel / 1 ` . If the number of channels of the input Evision.Mat is greater than 1 , then this function would convert the input Evision.Mat with dims ` dims = list ( int ( ) ) ` to a ` 1 ` - channel Evision.Mat with dims ` [ dims | channels ] ` . If the number of channels of the input Evision.Mat is equal to 1 , - if dims == shape , then nothing happens - otherwise , a new Evision.Mat that has dims = ` [ dims | channels ] ` will be returned For example , iex&gt; mat = Evision.imread!(&quot;test.png&quot;) %Evision.Mat{ channels: 3, dims: 2, type: {:u, 8}, raw_type: 16, shape: {1, 2, 3}, ref: #Reference&lt;0.2067356221.74055707.218654&gt; } iex&gt; mat = Evision.Mat.channel_as_last_dim!(mat) %Evision.Mat{ channels: 1, dims: 3, type: {:u, 8}, raw_type: 0, shape: {1, 2, 3}, ref: #Reference&lt;0.2067356221.74055698.218182&gt; } - Automatically displays a tabbed output in Livebook if the type of evaluated result is ` Evision.Mat ` . This is an optional feature . To enable it , ` :kino ` should be added to ` deps ` , e . g . , defp deps do [ # ... {:kino, &quot;~&gt; 0.7&quot;}, # ... ] end Now , with ` :kino ` &gt;= v0 . 7 available , a tabbed output will shown in Livebook if the evaluated result is an ` Evision.Mat ` . A ` Raw ` tab will always be the first one , e . g . , %Evision.Mat{ channels: 1, dims: 3, type: {:u, 8}, raw_type: 0, shape: {1, 2, 3}, ref: #Reference&lt;0.3310236255.1057357843.168932&gt; } For 2 D images ( ` dims == 2 ` ) , the second tab will be ` Image ` , which displays the image . For all ` Evision.Mat ` , the last tab will be ` Numerical ` , which shows the numbers behind the scene . Of course , for large size ` Evision.Mat ` , only part of the data will be shown . A example output in this tab : #Nx.Tensor&lt; u8[1][2][3] Evision.Backend [ [ [1, 2, 3], [1, 2, 3] ] ] &gt; ## v0.1.6 (2022-09-29) [ Browse the Repository ] ( https :// github . com / cocoa - xu / evision / tree / v0 . 1.6 ) | [ Released Assets ] ( https :// github . com / cocoa - xu / evision / releases / tag / v0 . 1.6 ) ### Breaking Changes - ` Evision . imencode / { 2 , 3 } ` will now return encoded image as binary instead of a list . - ` cv :: Mat ` will be wrapped in struct . For example : iex&gt; Evision.imread!(&quot;path/to/image.png&quot;) %Evision.Mat{ channels: 3, dims: 2, type: {:u, 8}, raw_type: 16, shape: {512, 512, 3}, ref: #Reference&lt;0.2992585850.4173463580.172624&gt; } This should close #76. ## v0.1.5 (2022-09-27) [ Browse the Repository ] ( https :// github . com / cocoa - xu / evision / tree / v0 . 1.5 ) | [ Released Assets ] ( https :// github . com / cocoa - xu / evision / releases / tag / v0 . 1.5 ) ### Changed - Always use ` Evision.Mat . from_binary_by_shape / 3 ` for ` Evision.Nx . to_mat ` . - Check ` cv :: Mat :: Mat . type ( ) ` when fetching the shape of a Mat . The number of channels will be included as the last dim of the shape if and only if ` cv :: Mat :: Mat . type ( ) ` did not encode any channel information . ### Bug Fixes - Fixed ` Evision.Mat . transpose ` : should call ` shape! ` instead of ` shape ` . Thanks to @kipcole9 ! #77 ### Added - Added ` Evision.Mat . last_dim_as_channel / 1 ` . This method convert a tensor - like ` Mat ` to a &quot;valid 2D image&quot; with its ` channels ` equals to ` 3 ` or ` 1 ` . - Added ` Evision.Nx . to_mat / 2 ` . This method convert a ` Nx.Tensor ` to a ` Mat ` . The second argument indicates the wanted / actual shape of the tensor . - Added more Mat functions : - ` Evision.Mat . as_shape / 2 ` . - ` Evision.Mat . size / 1 ` . - ` Evision.Mat . channels / 1 ` . - ` Evision.Mat . depth / 1 ` . - ` Evision.Mat . raw_type / 1 ` . - ` Evision.Mat . isSubmatrix / 1 ` . - ` Evision.Mat . isContinuous / 1 ` . - ` Evision.Mat . elemSize / 1 ` . - ` Evision.Mat . elemSize1 / 1 ` . - ` Evision.Mat . total / { 1 , 2 , 3 } ` . - Added OpenCV types : - ` Evision . cv_cn_shift / 0 ` . - ` Evision . cv_depth_max / 0 ` . - ` Evision . cv_mat_depth_mask / 0 ` . - ` Evision . cv_maketype / 2 ` . - ` Evision . cv_8U / 0 ` . - ` Evision . cv_8UC / 1 ` . - ` Evision . cv_8UC1 / 0 ` . - ` Evision . cv_8UC2 / 0 ` . - ` Evision . cv_8UC3 / 0 ` . - ` Evision . cv_8UC4 / 0 ` . - ` Evision . cv_8S / 0 ` . - ` Evision . cv_8SC / 1 ` . - ` Evision . cv_8SC1 / 0 ` . - ` Evision . cv_8SC2 / 0 ` . - ` Evision . cv_8SC3 / 0 ` . - ` Evision . cv_8SC4 / 0 ` . - ` Evision . cv_16U / 0 ` . - ` Evision . cv_16UC / 1 ` . - ` Evision . cv_16UC1 / 0 ` . - ` Evision . cv_16UC2 / 0 ` . - ` Evision . cv_16UC3 / 0 ` . - ` Evision . cv_16UC4 / 0 ` . - ` Evision . cv_16S / 0 ` . - ` Evision . cv_16SC / 1 ` . - ` Evision . cv_16SC1 / 0 ` . - ` Evision . cv_16SC2 / 0 ` . - ` Evision . cv_16SC3 / 0 ` . - ` Evision . cv_16SC4 / 0 ` . - ` Evision . cv_32S / 0 ` . - ` Evision . cv_32SC / 1 ` . - ` Evision . cv_32SC1 / 0 ` . - ` Evision . cv_32SC2 / 0 ` . - ` Evision . cv_32SC3 / 0 ` . - ` Evision . cv_32SC4 / 0 ` . - ` Evision . cv_32F / 0 ` . - ` Evision . cv_32FC / 1 ` . - ` Evision . cv_32FC1 / 0 ` . - ` Evision . cv_32FC2 / 0 ` . - ` Evision . cv_32FC3 / 0 ` . - ` Evision . cv_32FC4 / 0 ` . - ` Evision . cv_64F / 0 ` . - ` Evision . cv_64FC / 1 ` . - ` Evision . cv_64FC1 / 0 ` . - ` Evision . cv_64FC2 / 0 ` . - ` Evision . cv_64FC3 / 0 ` . - ` Evision . cv_64FC4 / 0 ` . - ` Evision . cv_16F / 0 ` . - ` Evision . cv_16FC / 1 ` . - ` Evision . cv_16FC1 / 0 ` . - ` Evision . cv_16FC2 / 0 ` . - ` Evision . cv_16FC3 / 0 ` . - ` Evision . cv_16FC4 / 0 ` . ## v0.1.4 (2022-09-10) [ Browse the Repository ] ( https :// github . com / cocoa - xu / evision / tree / v0 . 1.4 ) | [ Released Assets ] ( https :// github . com / cocoa - xu / evision / releases / tag / v0 . 1.4 ) ### Changed - Default to ` Evision.Backend ` for ` Evision.Nx . to_nx / 2 ` . ### Bug Fixes - Fixed class inheritance issue in ` py_src / class_info . py ` . - Fixed missing comma in example livebooks &#39; `Mix.install`. Thanks to @dbii. ### Added - Added decision tree and random forest example. ## v0.1.3 (2022-09-01) [Browse the Repository](https://github.com/cocoa-xu/evision/tree/v0.1.3) | [Released Assets](https://github.com/cocoa-xu/evision/releases/tag/v0.1.3) ### Bug Fixes - Fixed issues in restoring files from precompiled package for macOS and Linux. - Paths are now quoted. - using `cp -RPf` on macOS while `cp -a` on Linux. - Fixed `destroyAllWindows` in NIF. It was generated as &#39; erlang :destroyAllWindows / 1 &#39; but it should be &#39; erlang :destroyAllWindows / 0 &#39; . ## v0.1.2 (2022-08-26) [ Browse the Repository ] ( https :// github . com / cocoa - xu / evision / tree / v0 . 1.2 ) | [ Released Assets ] ( https :// github . com / cocoa - xu / evision / releases / tag / v0 . 1.2 ) ### Bug Fixes - Fixed transpose . ### Added - Added x86_64 musl compilation CI test . - Added a few precompilation musl targets : - x86_64 - linux - musl - aarch64 - linux - musl - armv7l - linux - musleabihf - riscv64 - linux - musl ## v0.1.1 (2022-08-25) [ Browse the Repository ] ( https :// github . com / cocoa - xu / evision / tree / v0 . 1.1 ) | [ Released Assets ] ( https :// github . com / cocoa - xu / evision / releases / tag / v0 . 1.1 ) ### Changed - Use OpenCV 4.6 . 0 by default . - Deprecated the use of the ` EVISION_PRECOMPILED_VERSION ` environment variable . The version information will be implied by the tag : def deps do [ { :evision , &quot;~&gt; 0.1.1&quot; , github : &quot;cocoa-xu/evision&quot; , tag : &quot;v0.1.1&quot; } ] end The value of the environment variable ` EVISION_PREFER_PRECOMPILED ` decides whether the precompiled artefacts will be used or not . ~ ~ From the next version ( &gt;= 0.1 . 2 ) , ` evision ` will set ` EVISION_PREFER_PRECOMPILED ` to ` true ` by default . ~ ~ ### Added - Implemented a few nx callbacks ( remaining ones will be implemented in the next release ) . ## v0.1.0 (2022-07-23) First release .","ref":"changelog.html#v0-1-7-2022-10-07","title":"Changelog - v0.1.7 (2022-10-07)","type":"extras"},{"doc":"OS Arch ABI Build Status Has Precompiled Library Linux x86_64 gnu Yes Linux x86_64 musl Yes Linux arm64 gnu Yes Linux arm64 musl Yes Linux armv7l (armhf) gnueabihf Yes Linux ppc64le gnu Yes Linux s390x gnu Yes Linux riscv64 gnu Yes Linux riscv64 musl Yes macOS 11 Big Sur x86_64 darwin Yes macOS 11 Big Sur arm64 darwin Yes Windows 2019 x86_64 msvc Yes","ref":"readme.html","title":"evision [WIP]","type":"extras"},{"doc":"Online docs for the latest released version is available on Hex.pm, https://hexdocs.pm/evision/ . Online docs for git HEAD is available here, https://cocoa-xu.github.io/evision/ .","ref":"readme.html#docs","title":"evision [WIP] - Docs","type":"extras"},{"doc":"Prebuilt firmwares are available here . Select the most recent run and scroll down to the Artifacts section, download the firmware file for your board and run fwup /path/to/the/downloaded/firmware.fw In the nerves build, evision is integrated as one of the dependencies of the nerves_livebook project. This means that you can use livebook (as well as other pre-pulled libraries) to explore and evaluate the evision project. The default password of the livebook is nerves (as the time of writing, if it does not work, please check the nerves_livebook project).","ref":"readme.html#nerves-support","title":"evision [WIP] - Nerves Support","type":"extras"},{"doc":"Evision.Nx module converts Evision.Mat to Nx.tensor : iex&gt; { :ok , mat } = Evision . imread ( &quot;/path/to/image.png&quot; ) # Or you can use the !(bang) version, but if the image cannot be read by OpenCV for whatever reason # the bang version will raise a RuntimeError exception iex&gt; mat = Evision . imread! ( &quot;/path/to/image.png&quot; ) % Evision.Mat { channels : 3 , dims : 2 , type : { :u , 8 } , raw_type : 16 , shape : { 512 , 512 , 3 } , ref : # Reference &lt; 0.2992585850 . 4173463580.172624 &gt; } iex&gt; t = Evision.Nx . to_nx ( mat ) # Nx.Tensor &lt; u8 [ 512 ] [ 512 ] [ 3 ] Evision.Backend [ [ [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , 255 ] , [ 255 , 255 , ... ] , ... ] , ... ] &gt; and vice-versa: iex&gt; mat = Evision . imread! ( &quot;/path/to/image.png&quot; ) iex&gt; t = Evision.Nx . to_nx ( mat ) # convert a tensor to a mat iex&gt; mat_from_tensor = Evision.Nx . to_mat! ( t ) % Evision.Mat { channels : 1 , dims : 3 , type : { :u , 8 } , raw_type : 0 , shape : { 512 , 512 , 3 } , ref : # Reference &lt; 0.1086574232 . 1510342676.18186 &gt; } # Note that `Evision.Nx.to_mat` gives a tensor # however, some OpenCV functions expect the mat # to be a &quot;valid 2D image&quot; # therefore, in such cases `Evision.Nx.to_mat_2d` # should be used instead # # Noticing the changes in `channels`, `dims` and `raw_type` iex&gt; mat_from_tensor = Evision.Nx . to_mat_2d! ( t ) % Evision.Mat { channels : 3 , dims : 2 , type : { :u , 8 } , raw_type : 16 , shape : { 512 , 512 , 3 } , ref : # Reference &lt; 0.1086574232 . 1510342676.18187 &gt; } # and it works for tensors with any shapes iex&gt; t = Nx . iota ( { 2 , 3 , 2 , 3 , 2 , 3 } , type : :s32 ) iex&gt; mat = Evision.Nx . to_mat! ( t ) % Evision.Mat { channels : 1 , dims : 6 , type : { :s , 32 } , raw_type : 4 , shape : { 2 , 3 , 2 , 3 , 2 , 3 } , ref : # Reference &lt; 0.1086574232 . 1510342676.18188 &gt; } Unsupported Type Map As OpenCV does not support the following types (yet, as of OpenCV 4.6.0) {:s, 64} {:u, 32} {:u, 64} Although it's possible to store values with those types using custom types, the resulting Mat/tensor will be incompatible with most existing functions in OpenCV. Moreover, it's somewhat inconvinient to explicitly specify the type each time using them. Therefore, Evision allows to set a map for those unsupported types. config :evision , unsupported_type_map : %{ { :s , 64 } =&gt; { :f , 64 } , { :u , 64 } =&gt; { :f , 64 } , { :u , 32 } =&gt; { :f , 32 } } The key of this unsupported_type_map is the unsupported type, and the value is the replacement type for it. See this reply for more details on this.","ref":"readme.html#integration-with-nx","title":"evision [WIP] - Integration with Nx","type":"extras"},{"doc":"Some examples are available in the examples directory.","ref":"readme.html#examples","title":"evision [WIP] - Examples","type":"extras"},{"doc":"evision will pull OpenCV source code from GitHub, then parse and automatically generate corresponding OpenCV-Elixir bindings. This project uses and modifies gen2.py and hdr_parser.py from the python module in the OpenCV repo so that they output header files that can be used in Elixir bindings. We hope this project can largely reduce the work of manually porting OpenCV functions/modules to Elixir. Compatible OpenCV versions: 4.5.3 4.5.4 4.5.5 4.6.0 by compatible, it means these versions can compile successfully, and I tested a small range of functions. Tons of tests should be written, and then we can have a list for tested OpenCV versions.","ref":"readme.html#description","title":"evision [WIP] - Description","type":"extras"},{"doc":"In order to use evision , you will need Elixir installed. Then create an Elixir project via the mix build tool: $ mix new my_app Then you can add evision as dependency in your mix.exs . def deps do [ { :evision , &quot;~&gt; 0.1.9&quot; } ] end Please note that although :evision is available on hex.pm now, it's still in its early versions. And it will remain on v0.1.x for a while, and all v0.1.x versions should be treated as in very active development. Please read the CHANGELOG.md for all breaking changes even it's a &quot;minor&quot; update. Therefore, it's recommended to use a specific version (i.e., include the minor version number in deps , {:evision, &quot;~&gt; 0.1.8&quot;} , instead of {:evision, &quot;~&gt; 0.1&quot;} ) at the moment. Use Precompiled Library (Default) The following environment variables can be set based on your needs. (Note that precompiled binaries do not use FFmpeg. If you'd like to use FFmpeg, please compile from source (please see instructions in the next section) and set corresponding environment variables. We're considering this option at the moment.) Important notes When using :evision from git, version &quot;0.1.1&quot; to &quot;0.1.7&quot; are available. Starting from 0.1.8 (included) and onwards, using :evision from git is no longer supported (unless set EVISION_PREFER_PRECOMPILED to false ) because we started to use checksum file to verify the integrity of the downloaded tarball file, and the checksum file is only tracked in the hex.pm package. def deps do [ { :evision , &quot;~&gt; 0.1.7&quot; , github : &quot;cocoa-xu/evision&quot; , tag : &quot;v0.1.7&quot; } ] end It is recommended to use :evision from hex.pm. Currently &quot;0.1.7&quot; to &quot;0.1.9&quot; are available on hex.pm, def deps do [ { :evision , &quot;~&gt; 0.1.9&quot; } ] end TARGET_ABI # required if and only if the build target is using musl libc. # # (for nerves project, this environment variable is set by nerves) export TARGET_ABI=musl ## (for armv7l which uses hard-float ABI (armhf)) export TARGET_ABI=musleabihf The default value for the TARGET_ABI env var is obtained using the following elixir code target_abi = List . last ( String . split ( to_string ( :erlang . system_info ( :system_architecture ) ) , &quot;-&quot; ) ) target_abi = case target_abi do &quot;darwin&quot; &lt;&gt; _ -&gt; &quot;darwin&quot; &quot;win32&quot; -&gt; { compiler_id , _ } = :erlang . system_info ( :c_compiler_used ) case compiler_id do :msc -&gt; &quot;msvc&quot; _ -&gt; to_string ( compiler_id ) end _ -&gt; target_abi end EVISION_PREFER_PRECOMPILED # optional. # set this to &quot;false&quot; if you prefer :evision to be compiled from source # # default value is &quot;true&quot;, and :evision will prefer to use precompiled binaries (if available) export EVISION_PREFER_PRECOMPILED=false If you found the precompiled binaries does not suit your needs (e.g., perhaps you need OpenCV to be compiled with FFmpeg to handle more video formats.), it's possible to override the behaviour by setting the environment variable EVISION_PREFER_PRECOMPILED to false export EVISION_PREFER_PRECOMPILED=false For livebook users, Mix . install ( [ { :evision , &quot;~&gt; 0.1.9&quot; } ] , system_env : [ { &quot;EVISION_PREFER_PRECOMPILED&quot; , &quot;false&quot; } ] ) EVISION_PRECOMPILED_CACHE_DIR # optional. ## set the cache directory for the precompiled archive file export EVISION_PRECOMPILED_CACHE_DIR=&quot;$(pwd)/.cache&quot; Compile evision from source Dependencies Python3 (Only during the compilation, to generate binding files) Tested Python verisons (on ubuntu:20.04 , see workflow file ): 3.6.15 3.7.12 3.8.12 3.9.9 3.10.1 CMake &gt;= 3.3 (for this project) The minimal version required by OpenCV can vary between versions. OpenCV 4.5.5 requires at least CMake 3.5.1. Erlang development library/headers. Tested on OTP/25. Build from source To obtain and compile OpenCV's source code from official releases, the following environment variables can affect the build # optional ## set OpenCV version ## the corresponding license file should be available at https://github.com/opencv/opencv/blob/${OPENCV_VER}/LICENSE export OPENCV_VER=&quot;4.6.0&quot; # optional ## Use Debug build export CMAKE_BUILD_TYPE=Debug # optional ## enable FFmpeg ## this will allow cmake to auto-detect FFmpeg libraries installed on the host ## on Windows, OpenCV will download prebuilt FFmpeg libraries ## for more information, please visit https://github.com/opencv/opencv/tree/4.x/3rdparty/ffmpeg export CMAKE_OPENCV_OPTIONS=&quot;-D WITH_FFMPEG=ON&quot; ## or disable FFmpeg export CMAKE_OPENCV_OPTIONS=&quot;-D WITH_FFMPEG=OFF&quot; Note 1: OpenCV can encode and decode some video formats (varies depending on your system). FFmpeg can be used to encode/decode more video formats. However, you should be aware of the license of the FFmpeg components you selected as they could be licensed by LGPL/GPL or other licenses. Note 2: FFmpeg 5 is not supported by OpenCV yet (as of OpenCV 4.6.0). sudo apt install -y libavcodec-dev libavformat-dev libavutil-dev libswscale-dev libavresample-dev ffmpeg on macOS brew install ffmpeg@4 brew link ffmpeg@4 Extra notes for building from source on Windows Evision on Windows uses nmake to handle the Makefile.win at the moment. And we also need powershell for now. nmake should be included in Microsoft Visual Studio, and powershell should be included in almost all recent versions (it was first released in 2007) of Windows. If ninja can be found in %PATH% , then we will prefer using ninja to build everything as it allows parallel building. Evision is NOT tested in MSYS2, Cygwin, or WSL/WSL2. Using source from a git repo (Optional) It's also possible to obtain and compile OpenCV's source code from a custom git repo by setting the following environment variables (in addition to the ones above) # required if and only if you prefer to compile OpenCV from a git repo # set OPENCV_USE_GIT_HEAD to true to compile OpenCV from a git repo # default value is false export OPENCV_USE_GIT_HEAD=true # required if and only if you prefer to compile OpenCV from a git repo # this env var indicates which branch you prefer to use # no default value export OPENCV_USE_GIT_BRANCH=4.x # optional. # set this env var to specify which git repo to use # default value is https://github.com/opencv/opencv.git, which is the offical git repo of OpenCV export OPENCV_GIT_REPO=&quot;https://github.com/opencv/opencv.git&quot; When OPENCV_USE_GIT_HEAD is set to true , the following command will be used to fetch OpenCV's source code in Makefile : git clone --branch=${OPENCV_USE_GIT_BRANCH} --depth=1 ${OPENCV_GIT_REPO} &quot;${OPENCV_DIR}&quot; More Configuration (Optional) evision will compile a subset of OpenCV functionality. You can configure the enabled modules in your config files: config :evision , enabled_modules : [ :calib3d , :core , :features2d , :flann , :highgui , :imgcodecs , :imgproc , :ml , :photo , :stitching , :ts , :video , :videoio , :dnn ] If a module is not specified in :enabled_modules , it may still be compiled if all requirements are present in your machine. You can enforce only the :enabled_modules to be compiled by changing the compilation mode: config :evision , :compile_mode , :only_enabled_modules You can also configure the list of image codecs used: config :evision , enabled_img_codecs : [ :png , :jpeg , :tiff , :webp , :openjpeg , :jasper , :openexr ] Notes How do I use my own OpenCV source code on my local disk? # To skip the download process, you can put the source zip file at `3rd_party/cache/opencv-${OPENCV_VER}.zip`. # Or you could supply OpenCV source code at `3rd_party/opencv/opencv-${OPENCV_VER}`. # # `3rd_party/opencv/opencv-${OPENCV_VER}` is the default value for `OPENCV_DIR` export OPENCV_DIR=/path/to/your/opencv/source/root How do I use my own OpenCV source code on my git repo? # use branch export OPENCV_USE_GIT_BRANCH=&quot;branch_name&quot; export OPENCV_GIT_REPO=&quot;https://github.com/username/opencv.git&quot; # use HEAD export OPENCV_USE_GIT_HEAD=true export OPENCV_GIT_REPO=&quot;https://github.com/username/opencv.git&quot; How do I set the number of jobs for compiling? # use all logical cores, by default # `&quot;-j\#{System.schedulers_online()}&quot;`. In `mix.exs`. export MAKE_BUILD_FLAGS=&quot;-j$(nproc)&quot; # use 2 cores export MAKE_BUILD_FLAGS=&quot;-j2&quot; How do I set up for cross-compile or specify the toolchain? export CMAKE_TOOLCHAIN_FILE=&quot;/path/to/toolchain.cmake&quot; How do I make my own adjustments to the OpenCV CMake options? export CMAKE_OPENCV_OPTIONS=&quot;YOUR CMAKE OPTIONS FOR OPENCV&quot; How do I generate binding code for erlang and Elixir at the same time? Yes, but currently it's only possible to do so when compiling evision using mix . # default value is `elixir` when compiling evision using `mix` # default value is `erlang` when compiling evision using `rebar` # # expected format is a comma-separated string export EVISION_GENERATE_LANG=&quot;erlang,elixir&quot; Which ones of OpenCV options are supposed to be specified in config/config.exs ? Enabled and disabled OpenCV modules Image codecs (if you enabled related OpenCV modules). Debug related Say you have the following MIX environment variables: # set by MIX MIX_ENV=dev # set by evision or you OPENCV_VER=4.6.0 # set by yourself if you&#39;re compiling evision to a nerves firmware MIX_TARGET=rpi4 How do I delete OpenCV related CMake build caches? # delete OpenCV related CMake build caches. rm -rf &quot;_build/${MIX_ENV}/lib/evision/cmake_opencv_${OPENCV_VER}&quot; ## for nerves rm -rf &quot;_build/${MIX_TARGET}_${MIX_ENV}/lib/evision/cmake_opencv_${OPENCV_VER}&quot; How do I remove downloaded OpenCV source zip file. rm -f &quot;3rd_party/cache/opencv-${OPENCV_VER}&quot; Can I manually edit the generated files and compile them? First, delete evision.so (so that cmake can rebuild it) # rm -f &quot;_build/${MIX_ENV}/lib/evision/priv/evision.so&quot; ## if you&#39;re building with nerves, ## use this path instead rm -rf &quot;_build/${MIX_TARGET}_${MIX_ENV}/lib/evision/priv/evision.so&quot; Secondly, comment out the following lines in the CMakeLists.txt otherwise, your editing will be overwritten by the py_src/gen2.py (executing from the CMakeLists.txt ) if(WIN32) execute_process(COMMAND &quot;rmdir ${GENERATED_ELIXIR_SRC_DIR} /s /q &amp;&amp; rmdir ${GENERATED_ERLANG_SRC_DIR} /s /q &amp;&amp; mkdir ${GENERATED_ELIXIR_SRC_DIR} &amp;&amp; mkdir ${GENERATED_ERLANG_SRC_DIR}&quot;) message(&quot;enabled modules: ${ENABLED_CV_MODULES}&quot;) execute_process(COMMAND python3.exe &quot;${PY_SRC}\\\\gen2.py&quot; &quot;${C_SRC}&quot; &quot;${GENERATED_ELIXIR_SRC_DIR}&quot; &quot;${GENERATED_ERLANG_SRC_DIR}&quot; &quot;${C_SRC}\\\\headers.txt&quot; &quot;${EVISION_GENERATE_LANG}&quot; &quot;${ENABLED_CV_MODULES}&quot; RESULT_VARIABLE STATUS) else() execute_process(COMMAND bash -c &quot;rm -rf ${GENERATED_ELIXIR_SRC_DIR} &amp;&amp; rm -rf ${GENERATED_ERLANG_SRC_DIR} &amp;&amp; mkdir -p ${GENERATED_ELIXIR_SRC_DIR} &amp;&amp; mkdir -p ${GENERATED_ERLANG_SRC_DIR}&quot;) message(&quot;enabled modules: ${ENABLED_CV_MODULES}&quot;) execute_process(COMMAND bash -c &quot;python3 ${PY_SRC}/gen2.py ${C_SRC} ${GENERATED_ELIXIR_SRC_DIR} ${GENERATED_ERLANG_SRC_DIR} ${C_SRC}/headers.txt ${EVISION_GENERATE_LANG} ${ENABLED_CV_MODULES}&quot; RESULT_VARIABLE STATUS) endif() if(STATUS STREQUAL &quot;0&quot;) message(STATUS &quot;Successfully generated binding code for: ${EVISION_GENERATE_LANG}&quot;) else() message(FATAL_ERROR &quot;Failed to generate binding code for: ${EVISION_GENERATE_LANG}&quot;) endif() Then you can edit the source files and recompile evision.so . mix compile Runtime related How do I enable debug logging for OpenCV (prints to stderr). export OPENCV_EVISION_DEBUG=1 Acknowledgements gen2.py , hdr_parser.py and c_src/erlcompat.hpp were directly copied from the python module in the OpenCV repo . Changes applied. Makefile , CMakeLists.txt and c_src/nif_utils.hpp were also copied from the torchx module in the elixir-nx repo . Minor changes applied.","ref":"readme.html#installation","title":"evision [WIP] - Installation","type":"extras"}]